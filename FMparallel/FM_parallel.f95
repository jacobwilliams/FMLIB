
   MODULE FMVALS_PARALLEL
      PRIVATE AINT, CEILING, DIGITS, EPSILON, HUGE, LOG, MAX, MIN, SQRT


!     Version 1.4                        David M. Smith                            9-01-2021

!  This is the thread-safe version of FM.  It can be used with a program that uses coarrays,
!  which is the Fortran-standard way of parallel programming.  It should also be ok to use
!  with other, non-standard, ways of parallel programming (openMP, MPI, etc.).

!  Because of restrictions imposed by the need to be thread-safe, this version of FM has
!  several limitations compared to the regular version of FM.

!  1.  Global variables defined in modules are not thread-safe if they can be changed
!      while the program runs.  This means the user sets the FM precision level by
!      defining variable FM_SIGNIFICANT_DIGITS here in module FMVALS_PARALLEL, then
!      compiles this file and links it to their program.  Calling FM_SET to set the
!      precision is not available.

!  2.  TYPE(IM) integer multi-precision numbers have varying numbers of digits that are
!      indirectly limited by FM_SIGNIFICANT_DIGITS.  Make sure that all TYPE(IM) values,
!      intermediate as well as final results, have fewer than 20*FM_SIGNIFICANT_DIGITS
!      decimal digits.

!  3.  It is less common, but if a user program wants different values for other FM
!      options like rounding mode, screen width for FM output, etc., they must be
!      initialized here in this module and not changed while the program runs.

!  4.  Similarly, FM precision level cannot be changed by the user's program while
!      it runs.

!  5.  The FM_RANDOM_NUMBER random number generator cannot be used, since it depends
!      on a global saved state to get the next number.

!  6.  Because multi-precision variables are no longer stored in a global module
!      database, the FM_DEALLOCATE function is not needed and has been removed.
!      Similarly, the FM_(ENTER or EXIT)_USER_(FUNCTION or ROUTINE) calls are not
!      needed and those routines have been removed.

!  7.  Saved values like pi, e, euler gamma, etc., are global variables in the standard
!      version of FM.  They have been removed from this thread-safe version, so they are
!      re-computed each time they are needed.  That makes some functions like trig and
!      log/exponential functions slightly slower.

!  8.  The global allocatable database from version 1.3 has been replaced with local fixed-size
!      arrays for the multiple precision numbers.  A few routines like fm_fprime and zm_fprime
!      that relied on raising precision a lot to overcome unstable formulas may now return unknown.
!      Up to 4th or 5th derivatives should usually be ok, but higher derivatives may fail.


      INTEGER, PARAMETER :: FM_SIGNIFICANT_DIGITS = 50

!  Default settings for other FM options:
!  MBASE is set to a power of 10, 10**7 for machines with 64-bit double precision.
!  The trace option is set off.
!  The mode for angles in trig functions is set to radians.
!  The rounding mode is set to symmetric rounding (to nearest).
!  Warning error message level is set to 1.
!  Screen width for output is set to 100 columns.
!  The exponent character for FM output is set to 'M'.
!  Debug error checking is set off.
!  KW, the unit number for all FM output, is set to 6.



      REAL (KIND(1.0D0)), PARAMETER :: M_TWO = 2
      DOUBLE PRECISION, PARAMETER :: DP_TWO = 2
      INTEGER, PARAMETER :: I_TWO = 2
      REAL, PARAMETER :: R_TWO = 2

!             KW is the unit number for standard output from the FM package.
!                This includes trace output and error messages.

      INTEGER, PARAMETER :: KW = 6

      REAL (KIND(1.0D0)), PARAMETER :: MAX_REPRESENTABLE_M_VAR =  &
                            ( (M_TWO ** (MIN(DIGITS(M_TWO),DIGITS(DP_TWO))-1)) - 1 ) * 2 + 1

      REAL (KIND(1.0D0)), PARAMETER :: MAXINT = MAX_REPRESENTABLE_M_VAR

      INTEGER, PARAMETER :: INTMAX = HUGE(I_TWO)

      DOUBLE PRECISION, PARAMETER :: DPMAX = HUGE(DP_TWO)/5

      REAL, PARAMETER :: SPMAX = HUGE(R_TWO)/5

      REAL (KIND(1.0D0)), PARAMETER :: MAX_BASE = AINT(SQRT(MAX_REPRESENTABLE_M_VAR + 1.0D-9))

      REAL (KIND(1.0D0)), PARAMETER :: MXBASE = MAX_BASE

      REAL (KIND(1.0D0)), PARAMETER :: M_TEN = 10

      REAL (KIND(1.0D0)), PARAMETER :: MAX_EXPONENT = AINT( MIN(                                  &
                                       MAX(HUGE(INTMAX) / LOG(MAX_BASE+1.0D-9) , 117496405.0D0),  &
                                       MAX_REPRESENTABLE_M_VAR / 20.0D0) )

      INTEGER, PARAMETER :: LHASH1 =   0
      INTEGER, PARAMETER :: LHASH2 = 256

      INTEGER, PARAMETER :: LJSUMS = 100

      INTEGER, PARAMETER :: LMBERN = 600

      INTEGER, PARAMETER :: NDIG_USER = CEILING( (FM_SIGNIFICANT_DIGITS+2) /  &
                                                  AINT(LOG(MAX_BASE/4.0D0)/LOG(10.0D0)) ) + 1

      INTEGER, PARAMETER :: NDIG_MAX = 25*NDIG_USER

      INTEGER, PARAMETER :: LMBUFF = MAX(25*FM_SIGNIFICANT_DIGITS+50,550)
      INTEGER, PARAMETER :: LMBUFZ = MAX(50*FM_SIGNIFICANT_DIGITS+50,1000)

      TYPE MULTI
         REAL (KIND(1.0D0)) :: MP(NDIG_MAX+2)
      END TYPE

      TYPE WORK_AREA
         REAL (KIND(1.0D0)) :: MP(2*NDIG_MAX+20)
      END TYPE

      TYPE FM
         TYPE(MULTI) :: MFM
      END TYPE

      TYPE IM
         TYPE(MULTI) :: MIM
      END TYPE

      TYPE ZM
         TYPE(MULTI) :: MZM(2)
      END TYPE

      TYPE FM_SETTINGS
         INTEGER :: NDIG = NDIG_USER
         INTEGER :: KFLAG = 0
         INTEGER :: NTRACE = 0
         INTEGER :: LVLTRC = 1
         INTEGER :: NCALL = 0
         REAL (KIND(1.0D0)) :: MBASE = M_TEN ** AINT(LOG(MAX_BASE/4.0D0) / LOG(10.0D0))
         INTEGER :: RAISE_NDIG = 0
         CHARACTER(9) :: NAMEST(0:50)
         INTEGER :: NDIGPI = 0
         REAL (KIND(1.0D0)) :: MBSPI = 0
         INTEGER :: NDIGE = 0
         REAL (KIND(1.0D0)) :: MBSE = 0
         INTEGER :: NDIGLB = 0
         REAL (KIND(1.0D0)) :: MBSLB = 0
         INTEGER :: NDIGLI = 0
         REAL (KIND(1.0D0)) :: MBSLI = 0
         REAL (KIND(1.0D0)) :: MXEXP = AINT( MAX_EXPONENT / 2.01D0 + 0.5D0 )
         REAL (KIND(1.0D0)) :: MXEXP2 = MAX_EXPONENT
         REAL (KIND(1.0D0)) :: MEXPUN = AINT( -MAX_EXPONENT * 1.01D0 )
         REAL (KIND(1.0D0)) :: MEXPOV = AINT( MAX_EXPONENT * 1.01D0 )
         REAL (KIND(1.0D0)) :: MUNKNO = AINT( MAX_EXPONENT * 1.0201D0 )
         REAL :: RUNKNO = -1.01*(HUGE(R_TWO)/3.0)
         INTEGER :: IUNKNO = -HUGE(I_TWO)/18
         INTEGER :: JFORM1 = 1
         INTEGER :: JFORM2 = FM_SIGNIFICANT_DIGITS
         INTEGER :: KRAD = 1
         INTEGER :: KWARN = 1
         INTEGER :: KROUND = 1
         INTEGER :: KSWIDE = 100
         INTEGER :: KESWCH = 1
         CHARACTER :: CMCHAR = 'M'
         INTEGER :: KDEBUG = 0
         INTEGER :: KROUND_RETRY = 0
         INTEGER :: KSUB = 0
         INTEGER :: KSQR = 0
         INTEGER :: KREM = 1
         INTEGER :: JRSIGN = 0
         INTEGER :: LHASH = 0
         INTEGER :: KHASHT(LHASH1:LHASH2)
         INTEGER :: KHASHV(LHASH1:LHASH2)
         DOUBLE PRECISION :: DPEPS = EPSILON(DP_TWO)
         REAL (KIND(1.0D0)) :: MBLOGS = 0
         REAL :: ALOGMB = 1.611810E+1
         REAL :: ALOGM2 = 2.325350E+1
         REAL :: ALOGMX = 3.673680E+1
         REAL :: ALOGMT = 7.0E0
         INTEGER :: NGRD21 = 1
         INTEGER :: NGRD52 = 2
         INTEGER :: NGRD22 = 2
         REAL (KIND(1.0D0)) :: MEXPAB = AINT(MAX_EXPONENT / 5.0D0)
         DOUBLE PRECISION :: DLOGMB = 1.611809565095832D+1
         DOUBLE PRECISION :: DLOGTN = 2.302585092994046D+0
         DOUBLE PRECISION :: DLOGTW = 6.931471805599453D-1
         DOUBLE PRECISION :: DPPI   = 3.141592653589793D+0
         DOUBLE PRECISION :: DLOGTP = 1.837877066409345D+0
         DOUBLE PRECISION :: DLOGPI = 1.144729885849400D+0
         DOUBLE PRECISION :: DLOGEB = 2.236222824932432D+0
         REAL (KIND(1.0D0)) :: MBASEL = 0
         REAL (KIND(1.0D0)) :: MBASEN = 0
         INTEGER :: NDIGL = 0
         INTEGER :: NDIGN = 0
         INTEGER :: NGUARL = 0
         INTEGER :: N21
         INTEGER :: NGRDN
         INTEGER :: JFORMZ = 1
         INTEGER :: JPRNTZ = 1
         REAL (KIND(1.0D0)) :: MBS2PI = 0
         INTEGER :: NDG2PI = 0
      END TYPE

   END MODULE FMVALS_PARALLEL


      SUBROUTINE FMSET(NPREC,QX)

!  The user cannot change FM settings in the thread-safe version.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NPREC
      TYPE(FM_SETTINGS) :: QX

      WRITE (*,"(//A)")  ' The user cannot change FM settings in the thread-safe version.'
      IF (NPREC >= -31 .OR. QX%MBASE > -31) THEN
          WRITE (*,"(/A//)") ' See the comments at the top of file FM_parallel.f95'
      ENDIF
      STOP

      END SUBROUTINE FMSET

      SUBROUTINE FMABS(MA,MB,QX)

!  MB = ABS(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KWRNSV


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMABS'
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)

      QX%KFLAG = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMEQ(MA,MB,QX)
      MB%MP(1) = 1
      QX%KWARN = KWRNSV
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMABS

      SUBROUTINE FMACOS(MA,MB,QX)

!  MB = ACOS(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(6)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG .AND. QX%KRAD == 0) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMACOS'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMI2M(180,MXY(1),QX)
          CALL FMPI(MXY(2),QX)
          CALL FMDIV(MXY(1),MXY(2),MXY(3),QX)
          IF (MA%MP(2) > QX%MEXPUN) THEN
              CALL FMMPY(MXY(3),MA,MXY(2),QX)
          ELSE
              CALL FMEQ(MA,MXY(2),QX)
          ENDIF
          CALL FMI2M(90,MXY(1),QX)
          CALL FMSUB(MXY(1),MXY(2),MB,QX)
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMACOS'
              QX%KFLAG = -4
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMACOS'
              IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
              IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMACOS'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(2) > 0 .OR. MA%MP(3) == 0) THEN
          CALL FMENTR('FMACOS   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMACOS'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      MAS = MA%MP(1)
      CALL FMEQU(MA,MXY(6),NDSAVE,QX%NDIG,QX)
      IF (QX%KROUND /= 1 .AND. QX%KRAD /= 1) THEN
          CALL FMST2M('0.5',MXY(1),QX)
          CALL FMSUB(MXY(6),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0) THEN
              CALL FMST2M('60',MXY(6),QX)
              GO TO 120
          ENDIF
          CALL FMADD(MXY(6),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0) THEN
              CALL FMST2M('120',MXY(6),QX)
              GO TO 120
          ENDIF
      ENDIF

!             Use ACOS(X) = ATAN(SQRT(1-X*X)/X)

      MXY(6)%MP(1) = 1
      CALL FMI2M(1,MXY(4),QX)
      CALL FMSUB(MXY(4),MXY(6),MXY(2),QX)
      CALL FMADD(MXY(4),MXY(6),MXY(3),QX)
      CALL FMMPY_R2(MXY(2),MXY(3),QX)
      CALL FMSQRT_R1(MXY(3),QX)
      CALL FMDIV(MXY(3),MXY(6),MXY(5),QX)
      CALL FMATAN(MXY(5),MXY(6),QX)

      IF (MAS < 0) THEN
          IF (QX%KRAD == 1) THEN
              CALL FMPI(MXY(4),QX)
          ELSE
              CALL FMI2M(180,MXY(4),QX)
          ENDIF
          CALL FMSUB_R2(MXY(4),MXY(6),QX)
      ENDIF

!             Round the result and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(6)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMACOS

      SUBROUTINE FMACOSH(MA,MB,QX)

!  MB = ARCCOSH(MA)      Inverse hyperbolic cosine.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MLN2,MLN3,MLN5,MLN7
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX


      CALL FMENTR('FMACOSH  ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

      IF (MXY(1)%MP(2) == QX%MEXPOV .OR. MXY(1)%MP(2) <= 0 .OR.  &
          MXY(1)%MP(1) < 0) THEN
          QX%KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(2),QX)
      ELSE IF (4.0*(MXY(1)%MP(2)-1) > QX%NDIG) THEN
          CALL FMMPYI(MXY(1),2,MXY(2),QX)
          IF (MXY(2)%MP(2) == QX%MEXPOV) THEN
              CALL FMLN(MXY(1),MXY(2),QX)
              CALL FMLNI(2,MXY(3),MLN2,MLN3,MLN5,MLN7,QX)
              CALL FMADD_R1(MXY(2),MXY(3),QX)
          ELSE
              CALL FMI2M(1,MXY(3),QX)
              CALL FMSQR(MXY(2),MXY(4),QX)
              CALL FMDIV_R2(MXY(3),MXY(4),QX)
              CALL FMLN(MXY(2),MXY(3),QX)
              CALL FMSUB(MXY(3),MXY(4),MXY(2),QX)
          ENDIF
      ELSE
          IEXTRA = MXY(1)%MP(2)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
              QX%NDIG = QX%NDIG + IEXTRA
          ENDIF
          CALL FMI2M(1,MXY(2),QX)
          CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
          CALL FMADD(MXY(1),MXY(2),MXY(4),QX)
          CALL FMMPY_R1(MXY(3),MXY(4),QX)
          CALL FMSQRT_R1(MXY(3),QX)
          CALL FMDIV_R1(MXY(3),MXY(1),QX)
          CALL FMATANH(MXY(3),MXY(2),QX)
      ENDIF
      QX%NAMEST(QX%NCALL) = 'FMACOSH'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMACOSH

      SUBROUTINE FMADD(MA,MB,MC,QX)

!  MC = MA + MB

!  This routine performs the trace printing for addition.  FMADD2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMADD'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMADD2(MA,MB,MC,QX)

          CALL FMNTR(1,MC,MC,1,1,QX)
      ELSE
          CALL FMADD2(MA,MB,MC,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMADD

      SUBROUTINE FMADD2(MA,MB,MC,QX)

!  Internal addition routine.  MC = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      TYPE(WORK_AREA) :: MWA
      REAL (KIND(1.0D0)) :: MAS,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          IF (QX%KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT,QX)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT,QX)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MA%MP(3) == 0 .OR.  &
                  MB%MP(3) == 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  IF (QX%KSUB == 1) THEN
                      QX%NAMEST(QX%NCALL) = 'FMSUB'
                  ELSE
                      QX%NAMEST(QX%NCALL) = 'FMADD'
                  ENDIF
                  CALL FMRSLT(MA,MB,MC,KRESLT,QX)
                  QX%JRSIGN = JRSSAV
                  QX%NCALL = QX%NCALL - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MA%MP(3) == 0) THEN
              CALL FMEQ(MB,MC,QX)
              QX%KFLAG = 1
              IF (QX%KSUB == 1) THEN
                  IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0)  &
                      MC%MP(1) = -MC%MP(1)
                  QX%KFLAG = 0
              ENDIF
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
          IF (MB%MP(3) == 0) THEN
              CALL FMEQ(MA,MC,QX)
              QX%KFLAG = 1
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (QX%KROUND_RETRY >= 1) THEN
              NGUARD = QX%NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MA%MP(1)
      MBS = MB%MP(1)
      IF (QX%KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MA%MP(2) > MB%MP(2)) THEN
          JCOMP = 1
      ELSE IF (MB%MP(2) > MA%MP(2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MA%MP(J+1) > MB%MP(J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MB%MP(J+1) > MA%MP(J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          QX%JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,MWA,NGUARD,NMWA,QX)
          ELSE
              CALL FMADDN(MA,MB,MWA,NGUARD,NMWA,QX)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          QX%JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,MWA,NGUARD,NMWA,QX)
          ELSE
              CALL FMADDN(MB,MA,MWA,NGUARD,NMWA,QX)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%KROUND_RETRY == 1 .AND. NGUARD < QX%NDIG) THEN
          QX%KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MC and fix the sign of the result.

      CALL FMMOVE(MWA,MC,QX)
      MC%MP(1) = 1
      IF (JSIGN < 0 .AND. MC%MP(3) /= 0) MC%MP(1) = -1

      IF (QX%KFLAG < 0) THEN
          IF (QX%KSUB == 1) THEN
              QX%NAMEST(QX%NCALL) = 'FMSUB'
          ELSE
              QX%NAMEST(QX%NCALL) = 'FMADD'
          ENDIF
          CALL FMWARN(QX)
      ENDIF

      QX%JRSIGN = JRSSAV
      QX%KROUND_RETRY = 0
      RETURN
      END SUBROUTINE FMADD2

      SUBROUTINE FMADD_R1(MA,MB,QX)

!  MA = MA + MB

!  This routine performs the trace printing for addition.  FMADD2_R1 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMADD_R1'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMADD2_R1(MA,MB,QX)

          QX%NAMEST(QX%NCALL) = 'FMADD_R1'
          CALL FMNTR(1,MA,MA,1,1,QX)
      ELSE
          CALL FMADD2_R1(MA,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMADD_R1

      SUBROUTINE FMADD2_R1(MA,MB,QX)

!  Internal addition routine.  MA = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MXY(2)


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          IF (QX%KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT,QX)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT,QX)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MA%MP(3) == 0 .OR.  &
                  MB%MP(3) == 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  IF (QX%KSUB == 1) THEN
                      QX%NAMEST(QX%NCALL) = 'FMSUB_R1'
                  ELSE
                      QX%NAMEST(QX%NCALL) = 'FMADD_R1'
                  ENDIF
                  CALL FMRSLT(MA,MB,MXY(1),KRESLT,QX)
                  CALL FMEQ(MXY(1),MA,QX)
                  QX%JRSIGN = JRSSAV
                  QX%NCALL = QX%NCALL - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MA%MP(3) == 0) THEN
              CALL FMEQ(MB,MA,QX)
              QX%KFLAG = 1
              IF (QX%KSUB == 1) THEN
                  IF (MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0)  &
                      MA%MP(1) = -MA%MP(1)
                  QX%KFLAG = 0
              ENDIF
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
          IF (MB%MP(3) == 0) THEN
              QX%KFLAG = 1
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (QX%KROUND_RETRY >= 1) THEN
              NGUARD = QX%NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MA%MP(1)
      MBS = MB%MP(1)
      IF (QX%KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MA%MP(2) > MB%MP(2)) THEN
          JCOMP = 1
      ELSE IF (MB%MP(2) > MA%MP(2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MA%MP(J+1) > MB%MP(J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MB%MP(J+1) > MA%MP(J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          QX%JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,MWA,NGUARD,NMWA,QX)
          ELSE
              CALL FMADDN(MA,MB,MWA,NGUARD,NMWA,QX)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          QX%JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,MWA,NGUARD,NMWA,QX)
          ELSE
              CALL FMADDN(MB,MA,MWA,NGUARD,NMWA,QX)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%KROUND_RETRY == 1 .AND. NGUARD < QX%NDIG) THEN
          QX%KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MA and fix the sign of the result.

      CALL FMMOVE(MWA,MA,QX)
      MA%MP(1) = 1
      IF (JSIGN < 0 .AND. MA%MP(3) /= 0) MA%MP(1) = -1

      IF (QX%KFLAG < 0) THEN
          IF (QX%KSUB == 1) THEN
              QX%NAMEST(QX%NCALL) = 'FMSUB_R1'
          ELSE
              QX%NAMEST(QX%NCALL) = 'FMADD_R1'
          ENDIF
          CALL FMWARN(QX)
      ENDIF

      QX%JRSIGN = JRSSAV
      QX%KROUND_RETRY = 0
      RETURN
      END SUBROUTINE FMADD2_R1

      SUBROUTINE FMADD_R2(MA,MB,QX)

!  MB = MA + MB

!  This routine performs the trace printing for addition.  FMADD2_R2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMADD_R2'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMADD2_R2(MA,MB,QX)

          QX%NAMEST(QX%NCALL) = 'FMADD_R2'
          CALL FMNTR(1,MB,MB,1,1,QX)
      ELSE
          CALL FMADD2_R2(MA,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMADD_R2

      SUBROUTINE FMADD2_R2(MA,MB,QX)

!  Internal addition routine.  MB = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          IF (QX%KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT,QX)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT,QX)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MA%MP(3) == 0 .OR.  &
                  MB%MP(3) == 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  IF (QX%KSUB == 1) THEN
                      QX%NAMEST(QX%NCALL) = 'FMSUB_R2'
                  ELSE
                      QX%NAMEST(QX%NCALL) = 'FMADD_R2'
                  ENDIF
                  CALL FMRSLT(MA,MB,MXY(1),KRESLT,QX)
                  CALL FMEQ(MXY(1),MB,QX)
                  QX%JRSIGN = JRSSAV
                  QX%NCALL = QX%NCALL - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MA%MP(3) == 0) THEN
              QX%KFLAG = 1
              IF (QX%KSUB == 1) THEN
                  IF (MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0)  &
                      MB%MP(1) = -MB%MP(1)
                  QX%KFLAG = 0
              ENDIF
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
          IF (MB%MP(3) == 0) THEN
              CALL FMEQ(MA,MB,QX)
              QX%KFLAG = 1
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (QX%KROUND_RETRY >= 1) THEN
              NGUARD = QX%NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MA%MP(1)
      MBS = MB%MP(1)
      IF (QX%KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MA%MP(2) > MB%MP(2)) THEN
          JCOMP = 1
      ELSE IF (MB%MP(2) > MA%MP(2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MA%MP(J+1) > MB%MP(J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MB%MP(J+1) > MA%MP(J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          QX%JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,MWA,NGUARD,NMWA,QX)
          ELSE
              CALL FMADDN(MA,MB,MWA,NGUARD,NMWA,QX)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          QX%JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,MWA,NGUARD,NMWA,QX)
          ELSE
              CALL FMADDN(MB,MA,MWA,NGUARD,NMWA,QX)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%KROUND_RETRY == 1 .AND. NGUARD < QX%NDIG) THEN
          QX%KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MB and fix the sign of the result.

      CALL FMMOVE(MWA,MB,QX)
      MB%MP(1) = 1
      IF (JSIGN < 0 .AND. MB%MP(3) /= 0) MB%MP(1) = -1

      IF (QX%KFLAG < 0) THEN
          IF (QX%KSUB == 1) THEN
              QX%NAMEST(QX%NCALL) = 'FMSUB_R2'
          ELSE
              QX%NAMEST(QX%NCALL) = 'FMADD_R2'
          ENDIF
          CALL FMWARN(QX)
      ENDIF

      QX%JRSIGN = JRSSAV
      QX%KROUND_RETRY = 0
      RETURN
      END SUBROUTINE FMADD2_R2

      SUBROUTINE FMADDI(MA,IVAL,QX)

!  MA = MA + IVAL

!  Increment MA by one word integer IVAL.

!  This routine is faster than FMADD when IVAL is small enough so that it can be added to a single
!  word of MA without often causing a carry.  Otherwise FMI2M and FMADD are used.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAEXP,MKSUM
      INTEGER :: KPTMA
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX


      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMADDI'
          CALL FMNTR(2,MA,MA,1,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)
      ENDIF
      QX%KFLAG = 0

      MAEXP = MA%MP(2)
      IF (MAEXP <= 0 .OR. MAEXP > QX%NDIG) GO TO 110
      KPTMA = INT(MAEXP) + 1
      IF (MA%MP(1) < 0) THEN
          MKSUM = MA%MP(KPTMA+1) - IVAL
      ELSE
          MKSUM = MA%MP(KPTMA+1) + IVAL
      ENDIF

      IF (MKSUM >= QX%MBASE .OR. MKSUM < 0) GO TO 110
      IF (KPTMA == 2 .AND. MKSUM == 0) GO TO 110
      MA%MP(KPTMA+1) = MKSUM
      GO TO 120

  110 CALL FMI2M(IVAL,MXY(1),QX)
      CALL FMADD2_R1(MA,MXY(1),QX)

  120 IF (QX%NTRACE /= 0) THEN
          CALL FMNTR(1,MA,MA,1,1,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMADDI

      SUBROUTINE FMADDN(MA,MB,MWA,NGUARD,NMWA,QX)

!  Internal addition routine.  MWA = MA - MB
!  The arguments are such that MA >= MB >= 0.

!  NGUARD is the number of guard digits being carried.
!  NMWA is the number of words in MWA that will be used.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: NGUARD,NMWA
      TYPE(WORK_AREA) :: MWA
      REAL (KIND(1.0D0)) :: MK,MR
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KP1,KP2,KPT,KSH,N1,N2,NK,NK1
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      N1 = QX%NDIG + 1

!             Check for an insignificant operand.

      MK = MA%MP(2) - MB%MP(2)
      IF (MK >= QX%NDIG+2) THEN
          DO J = 1, N1
             MWA%MP(J+1) = MA%MP(J+1)
          ENDDO
          MWA%MP(N1+2) = 0
          IF (QX%KROUND == 0 .OR. (QX%KROUND == 2 .AND. QX%JRSIGN == -1) .OR.  &
             (QX%KROUND == -1 .AND. QX%JRSIGN == 1)) THEN
              MWA%MP(N1+1) = MWA%MP(N1+1) - 1
              GO TO 120
          ENDIF
          QX%KFLAG = 1
          RETURN
      ENDIF
      K = INT(MK)
      IF (NGUARD <= 1) NMWA = N1 + 2

!             Subtract MB from MA.

      KP1 = MIN(N1,K+1)
      MWA%MP(K+2) = 0
      DO J = 1, KP1
         MWA%MP(J+1) = MA%MP(J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      DO J = KP2+1, N1+1
         MWA%MP(J) = MA%MP(J) - MB%MP(J-K)
      ENDDO

      N2 = QX%NDIG + 2
      IF (N2-K <= 1) N2 = 2 + K
      NK = MIN(NMWA,N1+K)
      DO J = N2, NK
         MWA%MP(J+1) = -MB%MP(J-K+1)
      ENDDO
      NK1 = NK + 1
      DO J = NK1, NMWA
         MWA%MP(J+1) = 0
      ENDDO

!             Normalize.  Fix the sign of any negative digit.

      IF (K > 0) THEN
          DO J = NMWA, KP2, -1
             IF (MWA%MP(J+1) < 0) THEN
                 MWA%MP(J+1) = MWA%MP(J+1) + QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - 1
             ENDIF
          ENDDO

          KPT = KP2 - 1
  110     IF (MWA%MP(KPT+1) < 0 .AND. KPT >= 3) THEN
              MWA%MP(KPT+1) = MWA%MP(KPT+1) + QX%MBASE
              MWA%MP(KPT) = MWA%MP(KPT) - 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
          GO TO 130
      ENDIF

  120 DO J = N1, 3, -1
         IF (MWA%MP(J+1) < 0) THEN
             MWA%MP(J+1) = MWA%MP(J+1) + QX%MBASE
             MWA%MP(J) = MWA%MP(J) - 1
         ENDIF
      ENDDO

!             Shift left if there are any leading zeros in the mantissa.

  130 DO J = 2, NMWA
         IF (MWA%MP(J+1) > 0) THEN
             KSH = J - 2
             GO TO 140
         ENDIF
      ENDDO
      MWA%MP(2) = 0
      RETURN

  140 IF (KSH > 0) THEN
          KL = NMWA - KSH
          DO J = 2, KL
             MWA%MP(J+1) = MWA%MP(J+KSH+1)
          ENDDO
          DO J = KL+1, NMWA
             MWA%MP(J+1) = 0
          ENDDO
          MWA%MP(2) = MWA%MP(2) - KSH
          IF (MK >= QX%NDIG+2) THEN
              MWA%MP(N1+1) = QX%MBASE - 1
          ENDIF
      ENDIF

!             Round the result.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) QX%KROUND_RETRY = QX%KROUND_RETRY + 1
      ENDIF
      MR = 2*MWA%MP(QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                  MWA%MP(N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
          ENDIF
      ENDIF

!             See if the result is equal to one of the input arguments.

      IF (ABS(MA%MP(2)-MB%MP(2)) < QX%NDIG) GO TO 150
      IF (ABS(MA%MP(2)-MB%MP(2)) > QX%NDIG+1) THEN
          QX%KFLAG = 1
          GO TO 150
      ENDIF

      N2 = QX%NDIG + 4
      DO J = 3, N1
         IF (MWA%MP(N2-J+1) /= MA%MP(N2-J+1)) GO TO 150
      ENDDO
      IF (MWA%MP(2) /= MA%MP(2)) GO TO 150
      IF (MWA%MP(3) /= ABS(MA%MP(3))) GO TO 150
      QX%KFLAG = 1

  150 RETURN
      END SUBROUTINE FMADDN

      SUBROUTINE FMADDP(MA,MB,MWA,NGUARD,NMWA,QX)

!  Internal addition routine.  MWA = MA + MB
!  The arguments are such that MA >= MB >= 0.

!  NMWA is the number of words in MWA that will be used.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      INTEGER :: NGUARD,NMWA
      REAL (KIND(1.0D0)) :: MK,MKT,MR
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KP,KP2,KPT,KSHIFT,N1,N2,NK
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      N1 = QX%NDIG + 1

!             Check for an insignificant operand.

      MK = MA%MP(2) - MB%MP(2)
      IF (MK >= QX%NDIG+1) THEN
          MWA%MP(2) = MA%MP(2) + 1
          MWA%MP(3) = 0
          DO J = 2, N1
             MWA%MP(J+2) = MA%MP(J+1)
          ENDDO
          MWA%MP(N1+3) = 0
          IF ((QX%KROUND ==  2 .AND. QX%JRSIGN ==  1) .OR.  &
              (QX%KROUND == -1 .AND. QX%JRSIGN == -1)) THEN
              MWA%MP(N1+3) = 1
              GO TO 120
          ENDIF
          QX%KFLAG = 1
          RETURN
      ENDIF
      K = INT(MK)

!             Add MA and MB.

      MWA%MP(2) = MA%MP(2) + 1
      MWA%MP(3) = 0
      DO J = 2, K+1
         MWA%MP(J+2) = MA%MP(J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      DO J = KP2+1, N1+1
         MWA%MP(J+1) = MA%MP(J) + MB%MP(J-K)
      ENDDO
      N2 = QX%NDIG + 2
      NK = MIN(NMWA,N1+K)
      DO J = N2, NK
         MWA%MP(J+2) = MB%MP(J-K+1)
      ENDDO
      DO J = NK+1, NMWA
         MWA%MP(J+2) = 0
      ENDDO

!             Normalize.  Fix any digit not less than MBASE.

      IF (K == QX%NDIG) GO TO 140

      IF (K > 0) THEN
          DO J = N1+1, KP2, -1
             IF (MWA%MP(J+1) >= QX%MBASE) THEN
                 MWA%MP(J+1) = MWA%MP(J+1) - QX%MBASE
                 MWA%MP(J) = MWA%MP(J) + 1
             ENDIF
          ENDDO

          KPT = KP2 - 1
  110     IF (MWA%MP(KPT+1) >= QX%MBASE .AND. KPT >= 3) THEN
              MWA%MP(KPT+1) = MWA%MP(KPT+1) - QX%MBASE
              MWA%MP(KPT) = MWA%MP(KPT) + 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
          GO TO 120
      ENDIF

      DO J = N1+1, 3, -1
         IF (MWA%MP(J+1) >= QX%MBASE) THEN
             MWA%MP(J+1) = MWA%MP(J+1) - QX%MBASE
             MWA%MP(J) = MWA%MP(J) + 1
         ENDIF
      ENDDO

!             Shift right if the leading digit is not less than MBASE.

  120 IF (MWA%MP(3) >= QX%MBASE) THEN
  130     KP = NMWA + 4
          DO J = 4, NMWA
             MWA%MP(KP-J+1) = MWA%MP(KP-J)
          ENDDO
          MKT = AINT (MWA%MP(3)/QX%MBASE)
          MWA%MP(4) = MWA%MP(3) - MKT*QX%MBASE
          MWA%MP(3) = MKT
          MWA%MP(2) = MWA%MP(2) + 1
          IF (MWA%MP(3) >= QX%MBASE) GO TO 130
      ENDIF

!             Round the result.

  140 KSHIFT = 0
      IF (MWA%MP(3) == 0) KSHIFT = 1
      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) QX%KROUND_RETRY = QX%KROUND_RETRY + 1
      ENDIF
      MR = 2*MWA%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(KSHIFT+N1+1) = MWA%MP(KSHIFT+N1+1) + 1
                  MWA%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF

!             See if the result is equal to one of the input arguments.

      IF (ABS(MA%MP(2)-MB%MP(2)) < QX%NDIG) GO TO 150
      IF (KSHIFT == 0) GO TO 150
      IF (ABS(MA%MP(2)-MB%MP(2)) > QX%NDIG+1) THEN
          QX%KFLAG = 1
          GO TO 150
      ENDIF

      N2 = QX%NDIG + 4
      DO J = 3, N1
         IF (MWA%MP(N2-J+2) /= MA%MP(N2-J+1)) GO TO 150
      ENDDO
      IF (MWA%MP(2) /= MA%MP(2)+1) GO TO 150
      IF (MWA%MP(4) /= ABS(MA%MP(3))) GO TO 150
      QX%KFLAG = 1

  150 RETURN
      END SUBROUTINE FMADDP

      SUBROUTINE FMARGS(KROUTN,NARGS,MA,MB,KRESLT,QX)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)
!  KRESLT - Result code returned to the calling routine.

!  Result codes:

!   0 - Perform the normal operation
!   1 - The result is the first input argument
!   2 - The result is the second input argument
!   3 - The result is -OVERFLOW
!   4 - The result is +OVERFLOW
!   5 - The result is -UNDERFLOW
!   6 - The result is +UNDERFLOW
!   7 - The result is -1.0
!   8 - The result is +1.0
!   9 - The result is -pi/2
!  10 - The result is +pi/2
!  11 - The result is 0.0
!  12 - The result is UNKNOWN
!  13 - The result is +pi
!  14 - The result is -pi/4
!  15 - The result is +pi/4

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(9) :: KROUTN
      TYPE(MULTI) :: MA,MB
      INTEGER :: NARGS,KRESLT
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,KWRNSV,NCATMA,NCATMB

!             These tables define the result codes to be returned for given values of the input
!             argument(s).

!             For example, row 7 column 2 of this array initialization KADD(2,7) = 2 means that if
!             the first argument in a call to FMADD is in category 7 ( -UNDERFLOW ) and the second
!             argument is in category 2 ( near -OVERFLOW but representable ) then the result code
!             is 2 ( the value of the sum is equal to the second input argument ).
!             See routine FMCAT for descriptions of the categories.

      INTEGER :: KADD(15,15) = RESHAPE(  (/                        &
                 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,12,12,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,12,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0,12, 1,12, 0, 0, 0, 0, 0, 4,      &
                 3, 2, 2, 2, 2,12,12, 5,12,12, 2, 2, 2, 2, 4,      &
                 3, 2, 2, 2, 2, 2, 5, 2, 6, 2, 2, 2, 2, 2, 4,      &
                 3, 2, 2, 2, 2,12,12, 6,12,12, 2, 2, 2, 2, 4,      &
                 3, 0, 0, 0, 0, 0,12, 1,12, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                12, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,      &
                12,12, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KMPY(15,15) = RESHAPE(  (/                        &
                 4, 4, 4, 4,12,12,12,11,12,12,12, 3, 3, 3, 3,      &
                 4, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 3,      &
                 4, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 3,      &
                 4, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0, 3,      &
                12, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0,12,      &
                12, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0,12,      &
                12,12,12, 6, 6, 6, 6,11, 5, 5, 5, 5,12,12,12,      &
                11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,      &
                12,12,12, 5, 5, 5, 5,11, 6, 6, 6, 6,12,12,12,      &
                12, 0, 0, 0, 0, 0, 5,11, 6, 0, 0, 1, 0, 0,12,      &
                12, 0, 0, 0, 0, 0, 5,11, 6, 0, 0, 1, 0, 0,12,      &
                 3, 2, 2, 2, 2, 2, 5,11, 6, 2, 2, 2, 2, 2, 4,      &
                 3, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 4,      &
                 3, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 4,      &
                 3, 3, 3, 3,12,12,12,11,12,12,12, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KDIV(15,15) = RESHAPE(  (/                        &
                12,12,12, 4, 4, 4, 4,12, 3, 3, 3, 3,12,12,12,      &
                12, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0,12,      &
                12, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0,12,      &
                 6, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0, 5,      &
                 6, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 5,      &
                 6, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 5,      &
                 6, 6, 6, 6,12,12,12,12,12,12,12, 5, 5, 5, 5,      &
                11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,      &
                 5, 5, 5, 5,12,12,12,12,12,12,12, 6, 6, 6, 6,      &
                 5, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 6,      &
                 5, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 6,      &
                 5, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0, 6,      &
                12, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0,12,      &
                12, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0,12,      &
                12,12,12, 3, 3, 3, 3,12, 4, 4, 4, 4,12,12,12   /)  &
        , (/ 15,15 /) )

      INTEGER :: KPWR(15,15) = RESHAPE(  (/                        &
                12,12, 0, 5,12,12,12, 8,12,12,12, 3, 0,12,12,      &
                12, 0, 0, 0,12,12,12, 8,12,12,12, 1, 0, 0,12,      &
                12, 0, 0, 0,12,12,12, 8,12,12,12, 1, 0, 0,12,      &
                12, 0, 0, 0,12,12,12, 8,12,12,12, 1, 0, 0,12,      &
                12, 0, 0, 0,12,12,12, 8,12,12,12, 1, 0, 0,12,      &
                12, 0, 0, 0,12,12,12, 8,12,12,12, 1, 0, 0,12,      &
                12,12, 0, 3,12,12,12, 8,12,12,12, 5, 0,12,12,      &
                12,12,12,12,12,12,12,12,11,11,11,11,11,11,11,      &
                 4, 4, 4, 4,12,12,12, 8,12,12,12, 6, 6, 6, 6,      &
                 4, 4, 0, 0, 0, 8, 8, 8, 8, 0, 0, 1, 0, 6, 6,      &
                 4, 4, 0, 0, 0, 8, 8, 8, 8, 0, 0, 1, 0, 6, 6,      &
                 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,      &
                 6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 1, 0, 4, 4,      &
                 6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 1, 0, 4, 4,      &
                 6, 6, 6, 6,12,12,12, 8,12,12,12, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KSQRT(15) = (/ 12,12,12,12,12,12,12,11,12, 0, 0, 8, 0, 0,12 /)
      INTEGER :: KEXP(15)  = (/  6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 4, 4 /)
      INTEGER :: KLN(15)   = (/ 12,12,12,12,12,12,12,12,12, 0, 0,11, 0, 0,12 /)
      INTEGER :: KSIN(15)  = (/ 12,12, 0, 0, 0, 0, 5,11, 6, 0, 0, 0, 0,12,12 /)
      INTEGER :: KCOS(15)  = (/ 12,12, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0,12,12 /)
      INTEGER :: KTAN(15)  = (/ 12,12, 0, 0, 0, 0, 5,11, 6, 0, 0, 0, 0,12,12 /)
      INTEGER :: KASIN(15) = (/ 12,12,12, 9, 0, 0, 5,11, 6, 0, 0,10,12,12,12 /)
      INTEGER :: KACOS(15) = (/ 12,12,12,13, 0,10,10,10,10,10, 0,11,12,12,12 /)
      INTEGER :: KATAN(15) = (/  9, 9, 0,14, 0, 0, 5,11, 6, 0, 0,15, 0,10,10 /)
      INTEGER :: KSINH(15) = (/  3, 3, 0, 0, 0, 1, 5,11, 6, 1, 0, 0, 0, 4, 4 /)
      INTEGER :: KCOSH(15) = (/  4, 4, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 4, 4 /)
      INTEGER :: KTANH(15) = (/  7, 7, 0, 0, 0, 1, 5,11, 6, 1, 0, 0, 0, 8, 8 /)
      INTEGER :: KLG10(15) = (/ 12,12,12,12,12,12,12,12,12, 0, 0,11, 0, 0,12 /)
      INTENT (IN) :: MA,MB

      KRESLT = 12
      QX%KFLAG = -4
      IF (MA%MP(2) == QX%MUNKNO) RETURN
      IF (NARGS == 2) THEN
          IF (MB%MP(2) == QX%MUNKNO) RETURN
      ENDIF
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      QX%NAMEST(QX%NCALL) = KROUTN

!             Check the validity of parameters if this is a user call.

      IF (QX%NCALL > 1 .AND. QX%KDEBUG == 0) GO TO 130

!             Check exponent range.

      IF (MA%MP(2) > QX%MXEXP+1 .OR. MA%MP(2) < -QX%MXEXP) THEN
          IF (ABS(MA%MP(2)) /= QX%MEXPOV .OR. ABS(MA%MP(3)) /= 1) THEN
              QX%KFLAG = -3
              CALL FMWARN(QX)
              RETURN
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MB%MP(2) > QX%MXEXP+1 .OR. MB%MP(2) < -QX%MXEXP) THEN
              IF (ABS(MB%MP(2)) /= QX%MEXPOV .OR. ABS(MB%MP(3)) /= 1) THEN
                  QX%KFLAG = -3
                  CALL FMWARN(QX)
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MA%MP(2)-INT(MA%MP(2))) /= 0) QX%KFLAG = 1
      IF (MA%MP(3) <= (-1) .OR. MA%MP(3) >= QX%MBASE .OR.  &
          ABS(MA%MP(3)-INT(MA%MP(3))) /= 0) QX%KFLAG = 2
      IF (QX%KDEBUG == 0) GO TO 110
      DO J = 3, QX%NDIG+1
         IF (MA%MP(J+1) < 0 .OR. MA%MP(J+1) >= QX%MBASE .OR.  &
             ABS(MA%MP(J+1)-INT(MA%MP(J+1))) /= 0) THEN
             QX%KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
  110 IF (QX%KFLAG /= 0) THEN
          J = QX%KFLAG
          QX%KFLAG = -4
          KWRNSV = QX%KWARN
          IF (QX%KWARN >= 2) QX%KWARN = 1
          CALL FMWARN(QX)
          QX%KWARN = KWRNSV
          IF (QX%KWARN >= 1) THEN
              WRITE (KW,*) ' First invalid array element:  MA(', J,') = ',MA%MP(J+1)
          ENDIF
          QX%KFLAG = -4
          IF (QX%KWARN >= 2) THEN
              STOP
          ENDIF
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MB%MP(2)-INT(MB%MP(2))) /= 0) QX%KFLAG = 1
          IF (MB%MP(3) <= (-1) .OR. MB%MP(3) >= QX%MBASE .OR.  &
              ABS(MB%MP(3)-INT(MB%MP(3))) /= 0) QX%KFLAG = 2
          IF (QX%KDEBUG == 0) GO TO 120
          DO J = 3, QX%NDIG+1
             IF (MB%MP(J+1) < 0 .OR. MB%MP(J+1) >= QX%MBASE .OR.  &
                 ABS(MB%MP(J+1)-INT(MB%MP(J+1))) /= 0) THEN
                 QX%KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (QX%KFLAG /= 0) THEN
              J = QX%KFLAG
              QX%KFLAG = -4
              KWRNSV = QX%KWARN
              IF (QX%KWARN >= 2) QX%KWARN = 1
              CALL FMWARN(QX)
              QX%KWARN = KWRNSV
              IF (QX%KWARN >= 1) THEN
                  WRITE (KW,*) ' First invalid array element:  MB(', J,') = ',MB%MP(J+1)
              ENDIF
              QX%KFLAG = -4
              IF (QX%KWARN >= 2) THEN
                  STOP
              ENDIF
              RETURN
          ENDIF
      ENDIF

!             Check for special cases.

  130 CALL FMCAT(MA,NCATMA,QX)
      IF (NCATMA > 15) THEN
          KRESLT = 12
          RETURN
      ENDIF
      NCATMB = 0
      IF (NARGS == 2) THEN
          CALL FMCAT(MB,NCATMB,QX)
          IF (NCATMB > 15) THEN
              KRESLT = 12
              RETURN
          ENDIF
      ENDIF

      IF (KROUTN == 'FMADD') THEN
          KRESLT = KADD(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSUB') THEN
          IF (NCATMB < 16) NCATMB = 16 - NCATMB
          KRESLT = KADD(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMMPY') THEN
          KRESLT = KMPY(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMDIV') THEN
          KRESLT = KDIV(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMPWR') THEN
          KRESLT = KPWR(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSQRT' .OR. KROUTN == 'FMSQRT_R1') THEN
          KRESLT = KSQRT(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMEXP') THEN
          KRESLT = KEXP(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMLN') THEN
          KRESLT = KLN(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSIN') THEN
          KRESLT = KSIN(NCATMA)
          IF (QX%KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMCOS') THEN
          KRESLT = KCOS(NCATMA)
          IF (QX%KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMTAN') THEN
          KRESLT = KTAN(NCATMA)
          IF (QX%KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMASIN') THEN
          KRESLT = KASIN(NCATMA)
          IF ((NCATMA == 7.OR.NCATMA == 9) .AND. QX%KRAD == 0) KRESLT = 12
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMACOS') THEN
          KRESLT = KACOS(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMATAN') THEN
          KRESLT = KATAN(NCATMA)
          IF ((NCATMA == 7.OR.NCATMA == 9) .AND. QX%KRAD == 0) KRESLT = 12
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSINH') THEN
          KRESLT = KSINH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMCOSH') THEN
          KRESLT = KCOSH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMTANH') THEN
          KRESLT = KTANH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMLG10') THEN
          KRESLT = KLG10(NCATMA)
          GO TO 140
      ENDIF

      KRESLT = 0
      RETURN

  140 IF (KRESLT == 12) THEN
          QX%KFLAG = -4
          CALL FMWARN(QX)
      ENDIF
      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              QX%KFLAG = -5
          ELSE
              QX%KFLAG = -5
              CALL FMWARN(QX)
          ENDIF
      ENDIF
      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              QX%KFLAG = -6
          ELSE
              QX%KFLAG = -6
              CALL FMWARN(QX)
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMARGS

      SUBROUTINE FMASIN(MA,MB,QX)

!  MB = ARCSIN(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG .AND. QX%KRAD == 1) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMASIN'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMMPY(MXY(1),MA,MXY(2),QX)
          CALL FMDIVI(MXY(2),6,MXY(3),QX)
          IF (MXY(3)%MP(2) > QX%MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB,QX)
          ELSE IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MA,MB,QX)
          ELSE IF (MA%MP(1) < 0 .AND. QX%KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
              MB%MP(2) = MA%MP(2) + MB%MP(2)
          ELSE IF (MA%MP(1) >= 0 .AND. QX%KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
              MB%MP(2) = MA%MP(2) + MB%MP(2)
          ELSE
              CALL FMEQ(MA,MB,QX)
          ENDIF
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMASIN'
              QX%KFLAG = -4
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMASIN'
              IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
              IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMASIN'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(2) > 0 .OR. MA%MP(3) == 0) THEN
          CALL FMENTR('FMASIN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMASIN'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(5),NDSAVE,QX%NDIG,QX)
      IF (QX%KROUND /= 1 .AND. QX%KRAD /= 1) THEN
          CALL FMST2M('0.5',MXY(1),QX)
          CALL FMSUB(MXY(5),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0) THEN
              CALL FMST2M('30',MXY(5),QX)
              GO TO 120
          ENDIF
          CALL FMADD(MXY(5),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0) THEN
              CALL FMST2M('-30',MXY(5),QX)
              GO TO 120
          ENDIF
      ENDIF

!             Use ASIN(X) = ATAN(X/SQRT(1-X*X))

      CALL FMI2M(1,MXY(3),QX)
      CALL FMSUB(MXY(3),MXY(5),MXY(1),QX)
      CALL FMADD(MXY(3),MXY(5),MXY(2),QX)
      CALL FMMPY_R2(MXY(1),MXY(2),QX)
      CALL FMSQRT_R1(MXY(2),QX)
      CALL FMDIV(MXY(5),MXY(2),MXY(4),QX)
      CALL FMATAN(MXY(4),MXY(5),QX)

!             Round the result and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMASIN

      SUBROUTINE FMASINH(MA,MB,QX)

!  MB = ARCSINH(MA)      Inverse hyperbolic sine.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MLN2,MLN3,MLN5,MLN7
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX


      CALL FMENTR('FMASINH  ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(2),QX)
      ELSE IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(2),QX)
      ELSE IF (MXY(1)%MP(2) <= -QX%MEXPAB) THEN
          CALL FMSIN(MXY(1),MXY(2),QX)
          IF (QX%KROUND /= 1) KR_RETRY = 2
      ELSE IF (MXY(1)%MP(2) < -QX%NDIG) THEN
          CALL FMSQR(MXY(1),MXY(2),QX)
          CALL FMMPY_R2(MXY(1),MXY(2),QX)
          CALL FMDIVI_R1(MXY(2),6,QX)
          CALL FMSUB_R2(MXY(1),MXY(2),QX)
          IF (QX%KROUND /= 1) KR_RETRY = 2
      ELSE IF (4.0*(MXY(1)%MP(2)-1) > QX%NDIG) THEN
          CALL FMMPYI(MXY(1),2,MXY(2),QX)
          IF (MXY(2)%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1) < 0) THEN
                  CALL FMABS(MXY(1),MXY(3),QX)
                  CALL FMLN(MXY(3),MXY(2),QX)
                  CALL FMLNI(2,MXY(3),MLN2,MLN3,MLN5,MLN7,QX)
                  CALL FMADD_R1(MXY(2),MXY(3),QX)
                  IF (MXY(2)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(3) /= 0)  &
                      MXY(2)%MP(1) = -MXY(2)%MP(1)
              ELSE
                  CALL FMLN(MXY(1),MXY(2),QX)
                  CALL FMLNI(2,MXY(3),MLN2,MLN3,MLN5,MLN7,QX)
                  CALL FMADD_R1(MXY(2),MXY(3),QX)
              ENDIF
          ELSE
              IF (MA%MP(1) < 0) THEN
                  CALL FMI2M(1,MXY(3),QX)
                  CALL FMSQR(MXY(2),MXY(4),QX)
                  CALL FMDIV_R2(MXY(3),MXY(4),QX)
                  CALL FMABS(MXY(2),MXY(3),QX)
                  CALL FMLN(MXY(3),MXY(2),QX)
                  CALL FMADD_R1(MXY(2),MXY(4),QX)
                  IF (MXY(2)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(3) /= 0)  &
                      MXY(2)%MP(1) = -MXY(2)%MP(1)
              ELSE
                  CALL FMI2M(1,MXY(3),QX)
                  CALL FMSQR(MXY(2),MXY(4),QX)
                  CALL FMDIV_R2(MXY(3),MXY(4),QX)
                  CALL FMLN(MXY(2),MXY(3),QX)
                  CALL FMADD(MXY(3),MXY(4),MXY(2),QX)
              ENDIF
          ENDIF
      ELSE IF (MXY(1)%MP(2) > 0) THEN
          IF (MA%MP(1) < 0) THEN
              CALL FMSQR(MXY(1),MXY(3),QX)
              CALL FMI2M(1,MXY(2),QX)
              CALL FMADD_R1(MXY(3),MXY(2),QX)
              CALL FMSQRT_R1(MXY(3),QX)
              CALL FMSUB_R1(MXY(3),MXY(1),QX)
              CALL FMLN(MXY(3),MXY(2),QX)
              IF (MXY(2)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(3) /= 0)  &
                  MXY(2)%MP(1) = -MXY(2)%MP(1)
          ELSE
              CALL FMSQR(MXY(1),MXY(3),QX)
              CALL FMI2M(1,MXY(2),QX)
              CALL FMADD_R1(MXY(3),MXY(2),QX)
              CALL FMSQRT_R1(MXY(3),QX)
              CALL FMADD_R2(MXY(1),MXY(3),QX)
              CALL FMLN(MXY(3),MXY(2),QX)
          ENDIF
      ELSE
          CALL FMSQR(MXY(1),MXY(3),QX)
          CALL FMI2M(1,MXY(2),QX)
          CALL FMADD_R1(MXY(3),MXY(2),QX)
          CALL FMSQRT_R1(MXY(3),QX)
          CALL FMDIV_R2(MXY(1),MXY(3),QX)
          CALL FMATANH(MXY(3),MXY(2),QX)
      ENDIF

      QX%NAMEST(QX%NCALL) = 'FMASINH'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMASINH

      SUBROUTINE FMATAN(MA,MB,QX)

!  MB = ARCTAN(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MPISAV
      INTEGER :: NSTACK(49)
      REAL (KIND(1.0D0)) :: MA1,MAS,MAXV,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,J2,K,K2,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,KST,KTWO,KWRNSV,  &
                 NDSAV1,NDSAVE,NDSV,NMETHD,NTERM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGPI = 0
      KWRNSV = QX%KWARN

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG .AND. QX%KRAD == 1) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMATAN'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMMPY(MXY(1),MA,MXY(2),QX)
          CALL FMDIVI(MXY(2),-3,MXY(3),QX)
          IF (MXY(3)%MP(2) > QX%MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB,QX)
          ELSE IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MA,MB,QX)
          ELSE IF (MA%MP(1) < 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              MXY(3)%MP(2) = MA%MP(2) + MXY(3)%MP(2)
              CALL FMEQ(MXY(3),MB,QX)
          ELSE IF (MA%MP(1) >= 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              MXY(3)%MP(2) = MA%MP(2) + MXY(3)%MP(2)
              CALL FMEQ(MXY(3),MB,QX)
          ELSE
              CALL FMEQ(MA,MB,QX)
          ENDIF
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = KWRNSV
          IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMATAN'
              QX%KFLAG = -4
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMATAN'
              IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
              IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMATAN'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (QX%KROUND /= 1 .AND. MA%MP(2) > QX%NDIG .AND. MA%MP(2) /= QX%MUNKNO .AND.  &
          QX%KRAD /= 1) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMATAN'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          QX%KWARN = 0
          IF (MA%MP(1) < 0) THEN
              IF (MA%MP(2) /= QX%MEXPOV) THEN
                  CALL FMI2M(180,MXY(1),QX)
                  CALL FMPI(MXY(2),QX)
                  CALL FMDIV(MXY(1),MXY(2),MXY(3),QX)
                  CALL FMDIV(MXY(3),MA,MXY(2),QX)
                  CALL FMI2M(-90,MXY(1),QX)
                  CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              ELSE
                  CALL FMI2M(-90,MXY(1),QX)
                  CALL FMTINY(MXY(2),QX)
                  CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
              ENDIF
          ELSE
              IF (MA%MP(2) /= QX%MEXPOV) THEN
                  CALL FMI2M(180,MXY(1),QX)
                  CALL FMPI(MXY(2),QX)
                  CALL FMDIV(MXY(1),MXY(2),MXY(3),QX)
                  CALL FMDIV(MXY(3),MA,MXY(2),QX)
                  CALL FMI2M(90,MXY(1),QX)
                  CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              ELSE
                  CALL FMI2M(90,MXY(1),QX)
                  CALL FMTINY(MXY(2),QX)
                  CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              ENDIF
          ENDIF
          CALL FMEQ(MXY(3),MB,QX)
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = KWRNSV
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMATAN'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0) THEN
          CALL FMENTR('FMATAN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMATAN'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      QX%NDIG = QX%NDIG + QX%NDIG/100
      CALL FMEQU(MA,MXY(3),NDSAVE,QX%NDIG,QX)
      IF (QX%KROUND /= 1 .AND. QX%KRAD /= 1) THEN
          CALL FMI2M(1,MXY(1),QX)
          CALL FMSUB(MXY(3),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0) THEN
              CALL FMST2M('45',MXY(5),QX)
              GO TO 160
          ENDIF
          CALL FMADD(MXY(3),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0) THEN
              CALL FMST2M('-45',MXY(5),QX)
              GO TO 160
          ENDIF
      ENDIF

!             If MA >= 1 work with 1/MA.

      MA1 = MA%MP(2)
      MAS = MA%MP(1)
      MXY(3)%MP(1) = 1
      IF (MA1 >= 1) THEN
          CALL FMI2M(1,MXY(5),QX)
          CALL FMDIV_R2(MXY(5),MXY(3),QX)
      ENDIF

      KRSAVE = QX%KRAD
      QX%KRAD = 1
      X = MXY(3)%MP(2)

!             In case pi has not been computed at the current precision and will be needed here,
!             get it to full precision first to avoid repeated calls at increasing precision during
!             Newton iteration.

      IF (MA1 >= 1 .OR. KRSAVE == 0) THEN
          IF (QX%MBSPI /= QX%MBASE .OR. QX%NDIGPI < QX%NDIG)  THEN
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(5),QX)
              QX%NDIG = NDSV
          ENDIF
      ENDIF

      NMETHD = 1
      IF (QX%NDIG*QX%ALOGMT > 2000) NMETHD = 2
      IF (MXY(3)%MP(2) < -QX%NDIG) NMETHD = 1
      IF (NMETHD == 2) GO TO 140

!             Method 1.  Reduce the argument and use the Taylor series.
!                        Atan(x) = x - x^3 / 3 + x^5 / 5 - ...

      K2 = MAX(2,INT(0.67*(QX%NDIG*QX%ALOGMT)**0.3333 + 0.4))
      K2 = MAX(K2,3)
      IF (MXY(3)%MP(2) <= -QX%NDIG/3) THEN
          K2 = 0
      ELSE
          IF (MXY(3)%MP(2)*QX%DLOGMB < LOG(2.0D0**(-K2))) THEN
              K2 = 0
          ELSE
              CALL FMM2DP(MXY(3),X,QX)
              K = K2 + 1
              DO J = 0, K
                 IF (X < 0.375D0/2.0D0**(J)) THEN
                     K2 = K2 - 1
                     IF (K2 <= 0) EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      CALL FMEQ(MXY(3),MXY(1),QX)
      CALL FMI2M(1,MXY(4),QX)
      DO J = 1, K2
         CALL FMSQR(MXY(1),MXY(2),QX)
         CALL FMADD_R2(MXY(4),MXY(2),QX)
         CALL FMSQRT_R1(MXY(2),QX)
         CALL FMSUB_R1(MXY(2),MXY(4),QX)
         CALL FMDIV_R2(MXY(2),MXY(1),QX)
      ENDDO

      J2 = INT(0.96*(QX%NDIG*QX%ALOGMT)**0.3333 - 1.7)
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      NTERM = 1
      DO J = 1, J2
         IF (NTERM > 1) THEN
             CALL FMCSDIVI(MXY(1),NTERM,MJSUMS(J),QX)
         ELSE
             CALL FMEQ(MXY(1),MJSUMS(J),QX)
         ENDIF
         NTERM = NTERM + 2
      ENDDO
      NDSAV1 = QX%NDIG
      CALL FMEQ(MXY(1),MXY(4),QX)
      CALL FMSQR_R1(MXY(1),QX)
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 130
      CALL FMIPWR(MXY(1),J2,MXY(2),QX)

  120 CALL FMCSMPY_R1(MXY(4),MXY(2),QX)
      DO J = 1, J2
         CALL FMCSDIVI(MXY(4),NTERM,MXY(5),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(5),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(5)%MP(2))
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(5),QX)
      IF (MXY(1)%MP(2) /= QX%MUNKNO .AND. MXY(1)%MP(3) /= 0)  &
          MXY(1)%MP(1) = -MXY(1)%MP(1)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(1),QX)
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1),QX)
      ENDDO

!             Reverse the argument reduction.

      KTWO = 1
      MAXV = MXBASE/2
      DO J = 1, K2
         KTWO = 2*KTWO
         IF (KTWO > MAXV) THEN
             CALL FMCSMPYI_R1(MXY(5),KTWO,QX)
             KTWO = 1
         ENDIF
      ENDDO
      IF (KTWO > 1) CALL FMCSMPYI_R1(MXY(5),KTWO,QX)

      GO TO 150

!             Method 2.  Newton iteration.

  140 CALL FMI2M(0,MXY(1),QX)
      CALL FMI2M(0,MXY(2),QX)
      CALL FMI2M(0,MXY(4),QX)

      IF (MXY(3)%MP(2)*QX%DLOGMB < -46) THEN
          CALL FMEQ(MXY(3),MXY(5),QX)
      ELSE
          CALL FMM2DP(MXY(3),X,QX)
          X = ATAN(X)
          CALL FMDPM(X,MXY(5),QX)
      ENDIF
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration.

      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         CALL FMSIN(MXY(5),MXY(4),QX)
         IF (2*MXY(5)%MP(2) <= -QX%NDIG) THEN
             CALL FMI2M(1,MXY(2),QX)
             CALL FMSUB(MXY(2),MXY(4),MXY(1),QX)
             CALL FMADD_R1(MXY(2),MXY(4),QX)
             CALL FMMPY_R1(MXY(1),MXY(2),QX)
             CALL FMSQRT(MXY(1),MXY(2),QX)
             CALL FMDIV_R2(MXY(4),MXY(2),QX)
             CALL FMSUB_R1(MXY(2),MXY(3),QX)
             CALL FMMPY_R2(MXY(1),MXY(2),QX)
             CALL FMSUB_R1(MXY(5),MXY(2),QX)
         ELSE
             CALL FMSQR(MXY(4),MXY(1),QX)
             CALL FMI2M(1,MXY(2),QX)
             CALL FMSUB_R2(MXY(2),MXY(1),QX)
             CALL FMSQRT(MXY(1),MXY(2),QX)
             CALL FMDIV_R2(MXY(4),MXY(2),QX)
             CALL FMSUB_R1(MXY(2),MXY(3),QX)
             CALL FMMPY_R2(MXY(1),MXY(2),QX)
             CALL FMSUB_R1(MXY(5),MXY(2),QX)
         ENDIF
      ENDDO

!             If MA >= 1 use pi/2 - ATAN(1/MA)

  150 IF (MA1 >= 1) THEN
          CALL FMPI(MPISAV,QX)
          CALL FMDIVI(MPISAV,2,MXY(4),QX)
          CALL FMSUB_R2(MXY(4),MXY(5),QX)
      ENDIF

!             Convert to degrees if necessary, round and return.

      QX%KRAD = KRSAVE
      IF (QX%KRAD == 0) THEN
          CALL FMMPYI_R1(MXY(5),180,QX)
          CALL FMPI(MPISAV,QX)
          CALL FMDIV_R1(MXY(5),MPISAV,QX)
      ENDIF
      IF (MXY(5)%MP(2) /= QX%MUNKNO .AND. MXY(5)%MP(3) /= 0 .AND. MAS < 0)  &
          MXY(5)%MP(1) = -MXY(5)%MP(1)

  160 IF (QX%KFLAG == 1) QX%KFLAG = 0
      QX%KWARN = KWRNSV

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KOVUN,QX)
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      RETURN
      END SUBROUTINE FMATAN

      SUBROUTINE FMATANH(MA,MB,QX)

!  MB = ARCTANH(MA)      Inverse hyperbolic tangent.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MAS,MAXV,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,J2,K,K2,KL,KOVUN,KR_RETRY,KRESLT,K_RETURN_CODE,KRSAVE,KTWO,  &
                 KWRNSV,NDSAV1,NDSAVE,NMETHD,NTERM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(10),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX

      KWRNSV = QX%KWARN

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      MAS = MA%MP(1)
      K = 0
      K_RETURN_CODE = 0
      QX%NCALL = QX%NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          KL = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMDIVI(MXY(1),3,MXY(2),QX)
          IF (MXY(2)%MP(2) < -QX%NDIG) K = 1
          QX%NTRACE = J
          QX%KWARN = KL
      ENDIF
      IF (QX%KROUND /= 1 .AND. K == 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMSQR(MXY(1),MXY(2),QX)
          CALL FMMPY(MXY(1),MXY(2),MXY(3),QX)
          CALL FMDIVI(MXY(3),3,MXY(5),QX)
          CALL FMEQ(MXY(1),MXY(4),QX)
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG .AND.  &
              MXY(4)%MP(2) > QX%MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(4),MXY(8),MXY(6),QX)
              IF (MXY(6)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MXY(9),QX)
                  IF (MXY(9)%MP(2) >= QX%MEXPOV) THEN
                      IF (MXY(6)%MP(1) > 0) THEN
                          IF (MXY(7)%MP(1) < 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MXY(9),QX)
                          ELSE IF (MXY(7)%MP(1) > 0 .AND. QX%KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MXY(9),QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9),QX)
                          ENDIF
                      ELSE
                          IF (MXY(7)%MP(1) < 0 .AND. QX%KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MXY(9),QX)
                          ELSE IF (MXY(7)%MP(1) > 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MXY(9),QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9),QX)
                          ENDIF
                      ENDIF
                  ENDIF
                  CALL FMEQU(MXY(9),MB,QX%NDIG,NDSAVE,QX)
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ELSE IF (MXY(4)%MP(2) == QX%MEXPUN) THEN
              IF (KRSAVE == 2 .AND. MA%MP(1) == 1) THEN
                  CALL FMTINY(MXY(9),QX)
                  CALL FMEQU(MXY(9),MB,QX%NDIG,NDSAVE,QX)
                  K_RETURN_CODE = 1
              ENDIF
              IF (KRSAVE == -1 .AND. MA%MP(1) == -1) THEN
                  CALL FMTINY(MXY(9),QX)
                  MXY(9)%MP(1) = -1
                  CALL FMEQU(MXY(9),MB,QX%NDIG,NDSAVE,QX)
                  K_RETURN_CODE = 1
              ENDIF
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NAMEST(QX%NCALL) = 'FMATANH'
                  CALL FMNTR(2,MA,MA,1,1,QX)
                  CALL FMNTR(1,MB,MB,1,1,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMENTR('FMATANH  ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMATANH'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      QX%NDIG = QX%NDIG + QX%NDIG/100
      CALL FMEQU(MA,MXY(3),NDSAVE,QX%NDIG,QX)
      MXY(3)%MP(1) = 1

!             Check for special cases.

      IF (MXY(3)%MP(2) >= 1) THEN
          CALL FMST2M('UNKNOWN',MXY(5),QX)
          QX%KFLAG = -4
          GO TO 160
      ELSE IF (MXY(3)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(5),QX)
          GO TO 160
      ELSE IF (MXY(3)%MP(2) == QX%MEXPUN) THEN
          CALL FMEQ(MXY(3),MXY(5),QX)
          IF (MA%MP(1) < 0) MXY(5)%MP(1) = -1
          QX%KFLAG = -6
          GO TO 160
      ENDIF

      NMETHD = 1
      CALL FMM2DP(MXY(3),X,QX)
      IF (MXY(3)%MP(2) >= -QX%NDIG) THEN
          IF (ABS(X) >= 1234.0/(QX%NDIG*QX%ALOGMT)**2) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 140

!             Method 1.  Reduce the argument and use the Taylor series.
!                        Atanh(x) = x + x^3 / 3 + x^5 / 5 + ...

      K2 = MAX(2,INT(0.67*(QX%NDIG*QX%ALOGMT)**0.3333 + 0.4))
      K2 = MAX(K2,3)
      IF (MXY(3)%MP(2) <= -QX%NDIG/3) THEN
          K2 = 0
      ELSE
          IF (MXY(3)%MP(2)*QX%DLOGMB < LOG(2.0D0**(-K2))) THEN
              K2 = 0
          ELSE
              K = K2 + 1
              DO J = 0, K
                 IF (X < 0.375D0/2.0D0**(J)) THEN
                     K2 = K2 - 1
                     IF (K2 <= 0) EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      CALL FMEQ(MXY(3),MXY(1),QX)
      CALL FMI2M(1,MXY(4),QX)
      DO J = 1, K2
         CALL FMSQR(MXY(1),MXY(2),QX)
         CALL FMSUB_R2(MXY(4),MXY(2),QX)
         CALL FMSQRT_R1(MXY(2),QX)
         CALL FMSUB_R2(MXY(4),MXY(2),QX)
         CALL FMDIV_R2(MXY(2),MXY(1),QX)
      ENDDO

      J2 = INT(0.96*(QX%NDIG*QX%ALOGMT)**0.3333 - 1.7)
      J2 = MAX(1,MIN(J2,LJSUMS))

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      NTERM = 1
      DO J = 1, J2
         IF (NTERM > 1) THEN
             CALL FMCSDIVI(MXY(1),NTERM,MJSUMS(J),QX)
         ELSE
             CALL FMEQ(MXY(1),MJSUMS(J),QX)
         ENDIF
         NTERM = NTERM + 2
      ENDDO
      NDSAV1 = QX%NDIG
      CALL FMEQ(MXY(1),MXY(4),QX)
      CALL FMSQR_R1(MXY(1),QX)
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 130
      CALL FMIPWR(MXY(1),J2,MXY(2),QX)

  120 CALL FMCSMPY_R1(MXY(4),MXY(2),QX)
      DO J = 1, J2
         CALL FMCSDIVI(MXY(4),NTERM,MXY(5),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(5),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(5)%MP(2))
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(5),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(1),QX)
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1),QX)
      ENDDO

!             Reverse the argument reduction.

      KTWO = 1
      MAXV = MXBASE/2
      DO J = 1, K2
         KTWO = 2*KTWO
         IF (KTWO > MAXV) THEN
             CALL FMCSMPYI_R1(MXY(5),KTWO,QX)
             KTWO = 1
         ENDIF
      ENDDO
      IF (KTWO > 1) CALL FMCSMPYI_R1(MXY(5),KTWO,QX)

      GO TO 150

!             Method 2.  Atanh(x) =  ln( (1+x) / (1-x) ) / 2

  140 IEXTRA = -MXY(3)%MP(2)
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(3),QX%NDIG,QX%NDIG+IEXTRA,QX)
          QX%NDIG = QX%NDIG + IEXTRA
      ENDIF
      CALL FMI2M(1,MXY(1),QX)
      CALL FMADD(MXY(1),MXY(3),MXY(4),QX)
      CALL FMSUB(MXY(1),MXY(3),MXY(5),QX)
      CALL FMDIV(MXY(4),MXY(5),MXY(2),QX)
      CALL FMLN(MXY(2),MXY(5),QX)
      CALL FMDIVI_R1(MXY(5),2,QX)

  150 IF (MXY(5)%MP(2) /= QX%MUNKNO .AND. MXY(5)%MP(3) /= 0 .AND. MAS < 0)  &
          MXY(5)%MP(1) = -MXY(5)%MP(1)

      IF (QX%KFLAG == 1) QX%KFLAG = 0
      QX%KWARN = KWRNSV

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
  160 CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KOVUN,QX)
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      RETURN
      END SUBROUTINE FMATANH

      SUBROUTINE FMATN2(MA,MB,MC,QX)

!  MC = ATAN2(MA,MB)

!  MC is returned as the angle between -pi and pi (or -180 and 180 if degree mode is selected) for
!  which TAN(MC) = MA/MB.  MC is an angle for the point (MB,MA) in polar coordinates.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JQUAD,K,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(5)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MB%MP(1) >= 0 .AND. QX%KRAD == 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KL = QX%KROUND
          QX%KROUND = 1
          QX%NCALL = QX%NCALL + 1
          CALL FMDIV(MA,MB,MXY(1),QX)
          QX%NCALL = QX%NCALL - 1
          QX%KROUND = KL
          IF (MXY(1)%MP(2) < -QX%NDIG) THEN
              QX%NTRACE = J
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMATN2'
                  CALL FMNTR(2,MA,MB,2,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              QX%NTRACE = 0
              IF (MXY(1)%MP(2) == QX%MEXPUN) THEN
                  CALL FMEQ(MXY(1),MXY(3),QX)
              ELSE
                  CALL FMSQR(MXY(1),MXY(2),QX)
                  CALL FMMPY_R1(MXY(2),MXY(1),QX)
                  CALL FMDIVI_R1(MXY(2),3,QX)
                  IF (MXY(2)%MP(2) /= QX%MEXPUN) THEN
                      CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                  ELSE IF (MXY(1)%MP(1) < 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
                      KL = MXY(1)%MP(2)
                      MXY(1)%MP(2) = 0
                      CALL FMULP(MXY(1),MXY(2),QX)
                      CALL FMSUB(MXY(1),MXY(2),MXY(4),QX)
                      MXY(4)%MP(2) = KL + MXY(4)%MP(2)
                      CALL FMEQ(MXY(4),MXY(3),QX)
                  ELSE IF (MXY(1)%MP(1) >= 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
                      KL = MXY(1)%MP(2)
                      MXY(1)%MP(2) = 0
                      CALL FMULP(MXY(1),MXY(2),QX)
                      CALL FMSUB(MXY(1),MXY(2),MXY(4),QX)
                      MXY(4)%MP(2) = KL + MXY(4)%MP(2)
                      CALL FMEQ(MXY(4),MXY(3),QX)
                  ELSE
                      CALL FMEQ(MXY(1),MXY(3),QX)
                  ENDIF
              ENDIF
              QX%KFLAG = 0
              QX%NTRACE = J
              QX%KWARN = K
              CALL FMEQ(MXY(3),MC,QX)
              IF (MC%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO .AND.  &
                  MB%MP(2) /= QX%MUNKNO) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMATN2'
                  QX%KFLAG = -4
                  CALL FMWARN(QX)
                  QX%NCALL = QX%NCALL - 1
              ELSE IF (ABS(MC%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV .AND.  &
                       ABS(MB%MP(2))  < QX%MEXPOV) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMATN2'
                  IF (MC%MP(2) == QX%MEXPOV) QX%KFLAG = -5
                  IF (MC%MP(2) == QX%MEXPUN) QX%KFLAG = -6
                  CALL FMWARN(QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMATN2'
                  CALL FMNTR(1,MC,MC,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              RETURN
          ENDIF
          QX%NTRACE = J
          QX%KWARN = K
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB) THEN
          CALL FMENTR('FMATN2   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMATN2'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

      KWRNSV = QX%KWARN
      QX%KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO .OR.  &
         (MA%MP(3) == 0 .AND. MB%MP(3) == 0)) THEN
          CALL FMST2M('UNKNOWN',MXY(5),QX)
          QX%KFLAG = -4
          GO TO 120
      ENDIF
      IF (QX%KROUND /= 1 .AND. QX%KRAD /= 1) THEN
          IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMTINY(MXY(3),QX)
          ELSE IF (MA%MP(2) == QX%MEXPOV) THEN
              CALL FMBIG(MXY(3),QX)
          ELSE
              CALL FMEQ(MXY(1),MXY(3),QX)
          ENDIF
          MXY(3)%MP(1) = MA%MP(1)
          IF (MB%MP(2) == QX%MEXPUN) THEN
              CALL FMTINY(MXY(4),QX)
          ELSE IF (MB%MP(2) == QX%MEXPOV) THEN
              CALL FMBIG(MXY(4),QX)
          ELSE
              CALL FMEQ(MXY(2),MXY(4),QX)
          ENDIF
          MXY(4)%MP(1) = MB%MP(1)
          IF (MXY(3)%MP(2) > MXY(4)%MP(2)+QX%NDIG) THEN
              IF (MA%MP(1) > 0) THEN
                  CALL FMDIV(MXY(4),MXY(3),MXY(5),QX)
                  CALL FMMPYI_R1(MXY(5),180,QX)
                  CALL FMPI(MXY(3),QX)
                  CALL FMDIV(MXY(5),MXY(3),MXY(4),QX)
                  CALL FMI2M(90,MXY(3),QX)
                  CALL FMSUB(MXY(3),MXY(4),MXY(5),QX)
                  GO TO 120
              ENDIF
              IF (MA%MP(1) < 0) THEN
                  CALL FMDIV(MXY(4),MXY(3),MXY(5),QX)
                  CALL FMMPYI_R1(MXY(5),180,QX)
                  CALL FMPI(MXY(3),QX)
                  CALL FMDIV(MXY(5),MXY(3),MXY(4),QX)
                  CALL FMI2M(-90,MXY(3),QX)
                  CALL FMSUB(MXY(3),MXY(4),MXY(5),QX)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MXY(4)%MP(2) > MXY(3)%MP(2)+QX%NDIG .AND. MB%MP(1) < 0) THEN
              IF (MA%MP(1) > 0) THEN
                  CALL FMDIV(MXY(3),MXY(4),MXY(5),QX)
                  CALL FMMPYI_R1(MXY(5),180,QX)
                  CALL FMPI(MXY(3),QX)
                  CALL FMDIV(MXY(5),MXY(3),MXY(4),QX)
                  CALL FMI2M(180,MXY(3),QX)
                  CALL FMADD(MXY(3),MXY(4),MXY(5),QX)
                  GO TO 120
              ENDIF
              IF (MA%MP(1) < 0) THEN
                  CALL FMDIV(MXY(3),MXY(4),MXY(5),QX)
                  CALL FMMPYI_R1(MXY(5),180,QX)
                  CALL FMPI(MXY(3),QX)
                  CALL FMDIV(MXY(5),MXY(3),MXY(4),QX)
                  CALL FMI2M(-180,MXY(3),QX)
                  CALL FMADD(MXY(3),MXY(4),MXY(5),QX)
                  GO TO 120
              ENDIF
          ENDIF
      ENDIF

      IF (MB%MP(3) == 0 .AND. MA%MP(1) > 0) THEN
          IF (QX%KRAD == 0) THEN
              CALL FMI2M(90,MXY(5),QX)
          ELSE
              CALL FMPI(MXY(5),QX)
              CALL FMDIVI_R1(MXY(5),2,QX)
          ENDIF
          GO TO 120
      ENDIF

      IF (MB%MP(3) == 0 .AND. MA%MP(1) < 0) THEN
          IF (QX%KRAD == 0) THEN
              CALL FMI2M(-90,MXY(5),QX)
          ELSE
              CALL FMPI(MXY(5),QX)
              CALL FMDIVI_R1(MXY(5),-2,QX)
          ENDIF
          GO TO 120
      ENDIF

      MXEXP1 = INT(QX%MXEXP2/2.01D0)
      IF (MA%MP(2) == QX%MEXPOV .AND. MB%MP(2) < MXEXP1-QX%NDIG-2) THEN
          IF (QX%KRAD == 0) THEN
              CALL FMI2M(90,MXY(5),QX)
          ELSE
              CALL FMPI(MXY(5),QX)
              CALL FMDIVI_R1(MXY(5),2,QX)
          ENDIF
          IF (MXY(1)%MP(1) < 0) MXY(5)%MP(1) = -1
          GO TO 120
      ENDIF

      IF (MA%MP(2) == QX%MEXPUN .AND. (-MB%MP(2)) < MXEXP1-QX%NDIG-2 .AND.  &
                                 MB%MP(1) < 0) THEN
          IF (QX%KRAD == 0) THEN
              CALL FMI2M(180,MXY(5),QX)
          ELSE
              CALL FMPI(MXY(5),QX)
          ENDIF
          IF (MXY(1)%MP(1) < 0) MXY(5)%MP(1) = -1
          GO TO 120
      ENDIF

      IF (MB%MP(2) == QX%MEXPOV .AND. MA%MP(2) < MXEXP1-QX%NDIG-2 .AND.  &
                                MB%MP(1) < 0) THEN
          IF (QX%KRAD == 0) THEN
              CALL FMI2M(180,MXY(5),QX)
          ELSE
              CALL FMPI(MXY(5),QX)
          ENDIF
          IF (MXY(1)%MP(1) < 0) MXY(5)%MP(1) = -1
          GO TO 120
      ENDIF

      IF (MB%MP(2) == QX%MEXPUN .AND. MA%MP(3) == 0) THEN
          IF (MB%MP(1) < 0) THEN
              IF (QX%KRAD == 0) THEN
                  CALL FMI2M(180,MXY(5),QX)
              ELSE
                  CALL FMPI(MXY(5),QX)
              ENDIF
          ELSE
              CALL FMI2M(0,MXY(5),QX)
          ENDIF
          GO TO 120
      ENDIF

      IF (MB%MP(2) == QX%MEXPUN .AND. (-MA%MP(2)) < MXEXP1-QX%NDIG-2) THEN
          IF (QX%KRAD == 0) THEN
              CALL FMI2M(90,MXY(5),QX)
          ELSE
              CALL FMPI(MXY(5),QX)
              CALL FMDIVI_R1(MXY(5),2,QX)
          ENDIF
          IF (MXY(1)%MP(1) < 0) MXY(5)%MP(1) = -1
          GO TO 120
      ENDIF

!             Determine the quadrant for the result, then use FMATAN.

      IF (MA%MP(1) >= 0 .AND. MB%MP(1) > 0) JQUAD = 1
      IF (MA%MP(1) >= 0 .AND. MB%MP(1) < 0) JQUAD = 2
      IF (MA%MP(1)  < 0 .AND. MB%MP(1) < 0) JQUAD = 3
      IF (MA%MP(1)  < 0 .AND. MB%MP(1) > 0) JQUAD = 4

      CALL FMDIV(MXY(1),MXY(2),MXY(4),QX)
      MXY(4)%MP(1) = 1
      CALL FMATAN(MXY(4),MXY(5),QX)

      IF (JQUAD == 2 .OR. JQUAD == 3) THEN
          IF (QX%KRAD == 0) THEN
              CALL FMI2M(180,MXY(3),QX)
              CALL FMSUB_R2(MXY(3),MXY(5),QX)
          ELSE
              CALL FMPI(MXY(3),QX)
              CALL FMSUB_R2(MXY(3),MXY(5),QX)
          ENDIF
      ENDIF

      IF ((JQUAD == 3 .OR. JQUAD == 4) .AND. MXY(5)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(5)%MP(3) /= 0) MXY(5)%MP(1) = -MXY(5)%MP(1)

!             Round the result and return.

  120 IF (QX%KFLAG == 1) QX%KFLAG = 0
      QX%KWARN = KWRNSV

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMATN2

      SUBROUTINE FMBIG(MA,QX)

!     MA = The biggest representable FM number using the current base and precision.
!          The smallest positive number is then 1.0/MA.
!          In some rounding modes, 1.0/(1.0/MA) may then overflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: J,N1
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMBIG'

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      DO J = 2, N1
         MA%MP(J+1) = QX%MBASE - 1
      ENDDO
      MA%MP(2) = QX%MXEXP + 1
      MA%MP(1) = 1

      IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMBIG

      SUBROUTINE FMCAT(MA,NCAT,QX)

!  NCAT is returned as the category of MA.  This is used by the various arithmetic routines to
!  handle special cases such as: 'number greater than 1' + 'underflowed result' is the first
!  argument, 'overflowed result' / 'overflowed result' is 'unknown'.

!  NCAT       range

!   1.         -OV                OV stands for overflowed results.
!   2.   (-OV   , -OVTH)             ( MA%MP(2) >= MAXEXP+2 )
!   3.   (-OVTH ,    -1)
!   4.         -1                 OVTH stands for a representable
!   5.   (-1    , -UNTH)               number near the overflow
!   6.   (-UNTH ,   -UN)               threshold.
!   7.         -UN                     ( MA%MP(2) >= MAXEXP-NDIG+1 )
!   8.          0
!   9.         +UN                UN stands for underflowed results.
!  10.   (+UN   , +UNTH)             ( MA%MP(2) <= -MAXEXP-1 )
!  11.   (+UNTH ,    +1)
!  12.         +1                 UNTH stands for a representable
!  13.   (+1    , +OVTH)               number near the underflow
!  14.   (+OVTH ,   +OV)               threshold.
!  15.         +OV                     ( MA%MP(2) <= -MAXEXP+NDIG-1 )
!  16.       UNKNOWN

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: NCAT
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MA2,MXEXP1
      INTEGER :: J,NLAST
      INTENT (IN) :: MA
      INTENT (INOUT) :: NCAT

!             Check for special symbols.

      NCAT = 16
      IF (MA%MP(2) == QX%MUNKNO) RETURN

      IF (MA%MP(2) == QX%MEXPOV) THEN
          NCAT = 15
          IF (MA%MP(1) < 0) NCAT = 1
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPUN) THEN
          NCAT = 9
          IF (MA%MP(1) < 0) NCAT = 7
          RETURN
      ENDIF

      IF (MA%MP(3) == 0) THEN
          NCAT = 8
          RETURN
      ENDIF

!             Check for +1 or -1.

      MA2 = ABS(MA%MP(3))
      IF (MA%MP(2) == 1 .AND. MA2 == 1) THEN
          NLAST = QX%NDIG + 1
          IF (NLAST >= 3) THEN
              DO J = 3, NLAST
                 IF (MA%MP(J+1) /= 0) GO TO 110
              ENDDO
          ENDIF
          NCAT = 12
          IF (MA%MP(1) < 0) NCAT = 4
          RETURN
      ENDIF

  110 MXEXP1 = INT(QX%MXEXP)
      IF (MA%MP(2) >= MXEXP1-QX%NDIG+2) THEN
          NCAT = 14
          IF (MA%MP(1) < 0) NCAT = 2
          RETURN
      ENDIF

      IF (MA%MP(2) >= 1) THEN
          NCAT = 13
          IF (MA%MP(1) < 0) NCAT = 3
          RETURN
      ENDIF

      IF (MA%MP(2) >= -MXEXP1+QX%NDIG) THEN
          NCAT = 11
          IF (MA%MP(1) < 0) NCAT = 5
          RETURN
      ENDIF

      IF (MA%MP(2) >= -MXEXP1) THEN
          NCAT = 10
          IF (MA%MP(1) < 0) NCAT = 6
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE FMCAT

      SUBROUTINE FMCHANGEBASE(MA,MB,NEW_MBASE,NEW_NDIG,QX)

!  Change the internal representation of a number from one base to another.
!  MA is given with NDIG digits in base MBASE (the current precision and base).
!  MB is returned as the same number, approximated with NEW_NDIG digits in base NEW_MBASE.

!  Note NDIG and MBASE are unchanged after calling FMCHANGEBASE, but if MB is to be used
!  in further operations, NDIG and MBASE should be changed to the new values in the calling program.
!
!  This routine is primarily meant to be used by the input and output conversion routines when the
!  base being used is not a power of ten.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: NEW_MBASE,NEW_NDIG
      INTENT (IN) :: MA,NEW_MBASE,NEW_NDIG
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4),MBPOWERS(9)
      INTEGER :: IEXTRA,J,K,KL,KRSAVE,KR_RETRY,NDSAVE
      REAL (KIND(1.0D0)) :: MBSAVE
      DOUBLE PRECISION :: ERR
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMCHANGEB'

!             The change of base is done by summing this series in the new base:
!                 d(1)/b + d(2)/b**2 + ... + d(k)/b**k
!             where d(i) is the i-th digit in the old base, b.

      NDSAVE = QX%NDIG
      MBSAVE = QX%MBASE
      QX%MBASE = NEW_MBASE
      CALL FMCONS(QX)
      QX%NDIG = NEW_NDIG + QX%NGRD52

!             If the exponent is large, raise the precision.

      IEXTRA = MAX(0,ABS(INT(LOG(MAX(1.0D0,DBLE(ABS(MA%MP(2)))))/LOG(DBLE(MBSAVE))))+1)
      QX%NDIG = QX%NDIG + IEXTRA


      KRSAVE = QX%KROUND
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF

!             Initialize the array of powers of the base.

      CALL IMI2M2(1,MXY(3),QX)
      DO K = 1, 9
         CALL IMMPYI2(MXY(3),INT(MBSAVE),MBPOWERS(K),QX)
         CALL IMEQ(MBPOWERS(K),MXY(3),QX)
      ENDDO

      CALL FMCHANGEBASE_TQ(MA,MBSAVE,0,NDSAVE-1,MXY(1),MXY(2),MBPOWERS,QX)

      QX%KROUND = 1
      CALL IMI2FM(MXY(1),MXY(3),QX)
      CALL IMI2FM(MXY(2),MXY(4),QX)
      CALL FMDIV2(MXY(3),MXY(4),MXY(2),QX)

!             Put the exponent and sign on MB.

      K = MBSAVE
      CALL FMIM(K,MXY(3),QX)
      K = MA%MP(2)
      IF (K /= 0) THEN
          CALL FMIPWR2(MXY(3),K,MXY(4),QX)
          CALL FMMPY2(MXY(2),MXY(4),MXY(1),QX)
          CALL FMEQ(MXY(1),MXY(2),QX)
      ENDIF
      MXY(2)%MP(1) = MA%MP(1)
      IF (KRSAVE /= 1) THEN
          K = (QX%NDIG + NEW_NDIG) / 2
          QX%KROUND = 1
          CALL FMEQU(MXY(2),MB,QX%NDIG,K,QX)
          QX%KROUND = KRSAVE
          CALL FMEQU_R1(MB,K,NEW_NDIG,QX)
      ELSE
          QX%KROUND = KRSAVE
          CALL FMEQU(MXY(2),MB,QX%NDIG,NEW_NDIG,QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NEW_NDIG,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NEW_NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NEW_NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      QX%MBASE = MBSAVE
      CALL FMCONS(QX)
      QX%NDIG = NDSAVE

      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMCHANGEBASE

      RECURSIVE SUBROUTINE FMCHANGEBASE_TQ(MA,MBSAVE,A,B,MT,MQ,MBPOWERS,QX)

!  This routine does the binary splitting for computing a change of base.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MT,MQ
      INTEGER :: A,B
      REAL (KIND(1.0D0)) :: MBSAVE
      INTENT (IN) :: MA,A,B,MBSAVE
      INTENT (INOUT) :: MT,MQ
      TYPE(MULTI) :: MXY(4),MBPOWERS(9)
      INTEGER :: DIGIT,J,K,M,OLD_BASE,RESULT_SIZE
      REAL (KIND(0.0D0)) :: DA,DB,DM
      TYPE(FM_SETTINGS) :: QX

      DA = A
      DB = B
      DM = MBSAVE
      OLD_BASE = MBSAVE
      RESULT_SIZE = ( (DB-DA+1)*LOG(DM) + 5 ) / QX%DLOGMB + 8
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      IF (B-A < 9) THEN
          DIGIT = MA%MP(A+3)
          CALL IMI2M2(DIGIT,MT,QX)
          DO J = A+1, B
             CALL IMMPYI2(MT,OLD_BASE,MXY(2),QX)
             DIGIT = MA%MP(J+3)
             CALL IMI2M2(DIGIT,MXY(1),QX)
             CALL IMADD2(MXY(2),MXY(1),MT,QX)
          ENDDO

!             There may be thousands of calls, all with K = 5,6,7,8,9.
!             These powers are saved instead of re-computing them each time.

          K = B - A + 1
          CALL IMEQ(MBPOWERS(K),MQ,QX)
          RETURN
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMCHANGEBASE_TQ(MA,MBSAVE,A,M-1,MXY(1),MXY(2),MBPOWERS,QX)
      CALL FMCHANGEBASE_TQ(MA,MBSAVE,M,B,MXY(3),MXY(4),MBPOWERS,QX)
      CALL IMMPY2(MXY(1),MXY(4),MQ,QX)
      CALL IMADD2(MXY(3),MQ,MT,QX)

      CALL IMMPY2(MXY(2),MXY(4),MQ,QX)

      RETURN
      END SUBROUTINE FMCHANGEBASE_TQ

      SUBROUTINE FMCHSH(MA,MB,MC,QX)

!  MB = COSH(MA),    MC = SINH(MA)

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  FMCOSH and FMSINH.

!  MB and MC must be distinct arrays.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(MULTI) :: MXY(5)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      MAS = MA%MP(1)
      KR_RETRY = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCHSH'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMCOSH(MA,MB,QX)
          CALL FMSINH(MA,MC,QX)
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCHSH'
              CALL FMNTR(1,MB,MB,1,1,QX)
              IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
                  IF (QX%NTRACE < 0) THEN
                      CALL FMNTRJ(MC,QX%NDIG,QX)
                  ELSE
                      CALL FMPRNT(MC,QX)
                  ENDIF
              ENDIF
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          NCSAVE = QX%NCALL
          CALL FMENTR('FMCHSH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (MA%MP(2) == QX%MUNKNO) KOVUN = 2
          QX%NCALL = NCSAVE + 1
          CALL FMEQU(MA,MXY(3),NDSAVE,QX%NDIG,QX)
          MXY(3)%MP(1) = 1
          CALL FMCOSH(MXY(3),MXY(4),QX)
          CALL FMSINH(MXY(3),MXY(5),QX)
          GO TO 120
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMCHSH'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(3),NDSAVE,QX%NDIG,QX)
      MXY(3)%MP(1) = 1

      K = 1
      IF (MXY(3)%MP(2) == 0 .AND. MXY(3)%MP(3) /= 0) THEN
          IF (QX%MBASE/MXY(3)%MP(3) >= 100) K = 2
      ENDIF
      IF (MXY(3)%MP(2) >= 0 .AND. MXY(3)%MP(3) /= 0 .AND. K == 1) THEN
          CALL FMCOSH(MXY(3),MXY(4),QX)
          IF (MXY(4)%MP(2) > QX%NDIG) THEN
              CALL FMEQ(MXY(4),MXY(5),QX)
              GO TO 120
          ENDIF
          CALL FMSQR(MXY(4),MXY(2),QX)
          CALL FMI2M(-1,MXY(1),QX)
          CALL FMADD_R1(MXY(2),MXY(1),QX)
          CALL FMSQRT(MXY(2),MXY(5),QX)
      ELSE
          CALL FMSINH(MXY(3),MXY(5),QX)
          CALL FMSQR(MXY(5),MXY(2),QX)
          CALL FMI2M(1,MXY(1),QX)
          CALL FMADD_R1(MXY(2),MXY(1),QX)
          CALL FMSQRT(MXY(2),MXY(4),QX)
      ENDIF

!             Round and return.

  120 IF (MAS < 0 .AND. MXY(5)%MP(2) /= QX%MUNKNO .AND. MXY(5)%MP(3) /= 0)  &
          MXY(5)%MP(1) = -MXY(5)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(4)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEQU(MXY(5),MC,QX%NDIG,NDSAVE,QX)
      IF (KOVUN == 2) THEN
          KWRNSV = QX%KWARN
          QX%KWARN = 0
      ENDIF
      CALL FMEXIT(MXY(4),MB,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KOVUN == 2) THEN
          QX%KWARN = KWRNSV
      ENDIF
      IF (QX%NTRACE /= 0) THEN
          IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL+1 <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL FMNTRJ(MC,QX%NDIG,QX)
              ELSE
                  CALL FMPRNT(MC,QX)
              ENDIF
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMCHSH

      FUNCTION FMCOMP(MA,LREL,MB,QX)

!  Logical comparison of FM numbers MA and MB.

!  LREL is a CHARACTER description of the comparison to be done:
!  LREL = 'EQ' returns FMCOMP = .TRUE. if MA == MB
!       = 'NE', 'GE', 'GT', 'LE', 'LT' also work like a logical IF.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

!  For comparisons involving 'UNKNOWN' or two identical special symbols such as
!  +OVERFLOW,'EQ',+OVERFLOW, FMCOMP is returned FALSE and a KFLAG = -4 error condition is returned.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      LOGICAL :: FMCOMP
      CHARACTER(*) :: LREL
      CHARACTER(2) :: JREL
      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,JCOMP,NLAST
      INTENT (IN) :: MA,LREL,MB

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMCOMP'

      IF (QX%NCALL <= QX%LVLTRC .AND. ABS(QX%NTRACE) >= 2) THEN
          WRITE (KW,"(' Input to FMCOMP')")

          IF (QX%NTRACE > 0) THEN
              CALL FMPRNT(MA,QX)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL FMPRNT(MB,QX)
          ELSE
              CALL FMNTRJ(MA,QX%NDIG,QX)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL FMNTRJ(MB,QX%NDIG,QX)
          ENDIF
      ENDIF

!             JCOMP will be 1 if MA > MB
!                           2 if MA == MB
!                           3 if MA < MB

!             Check for special cases.

      JREL = LREL
      IF (LREL /= 'EQ' .AND. LREL /= 'NE' .AND. LREL /= 'LT' .AND.  &
          LREL /= 'GT' .AND. LREL /= 'LE' .AND. LREL /= 'GE') THEN
          IF (LREL == 'eq' .OR. LREL == '==') THEN
              JREL = 'EQ'
          ELSE IF (LREL == 'ne' .OR. LREL == '/=') THEN
              JREL = 'NE'
          ELSE IF (LREL == 'lt' .OR. LREL == '<') THEN
              JREL = 'LT'
          ELSE IF (LREL == 'gt' .OR. LREL == '>') THEN
              JREL = 'GT'
          ELSE IF (LREL == 'le' .OR. LREL == '<=') THEN
              JREL = 'LE'
          ELSE IF (LREL == 'ge' .OR. LREL == '>=') THEN
              JREL = 'GE'
          ELSE
              FMCOMP = .FALSE.
              QX%KFLAG = -4
              IF (QX%NCALL /= 1 .OR. QX%KWARN <= 0) GO TO 120
              IF (QX%KWARN <= 0) GO TO 120
              WRITE (KW,                                                     &
                     "(/' Error of type KFLAG = -4 in FM package in',"   //  &
                     "' routine FMCOMP'//1X,A,' is not one of the six'," //  &
                     "' recognized comparisons.'//' .FALSE. has been',"  //  &
                     "' returned.'/)"                                        &
                    ) LREL
              IF (QX%KWARN >= 2) THEN
                  STOP
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          FMCOMP = .FALSE.
          QX%KFLAG = -4
          GO TO 120
      ENDIF

      IF (ABS(MA%MP(2)) == QX%MEXPOV .AND. MA%MP(2) == MB%MP(2) .AND.  &
          MA%MP(3) == MB%MP(3) .AND. MA%MP(1) == MB%MP(1)) THEN
          FMCOMP = .FALSE.
          QX%KFLAG = -4
          IF (QX%NCALL /= 1 .OR. QX%KWARN <= 0) GO TO 120
          IF (QX%KWARN <= 0) GO TO 120
          WRITE (KW,                                                           &
                 "(/' Error of type KFLAG = -4 in FM package in routine'," //  &
                 "' FMCOMP'//' Two numbers in the same overflow or',"      //  &
                 "' underflow category cannot be compared.'//"             //  &
                 "' .FALSE. has been returned.'/)"                             &
                 )
          IF (QX%KWARN >= 2) THEN
              STOP
          ENDIF
          GO TO 120
      ENDIF

!             Check for zero.

      QX%KFLAG = 0
      IF (MA%MP(3) == 0) THEN
          JCOMP = 2
          IF (MB%MP(3) == 0) GO TO 110
          IF (MB%MP(1) < 0) JCOMP = 1
          IF (MB%MP(1) > 0) JCOMP = 3
          GO TO 110
      ENDIF
      IF (MB%MP(3) == 0) THEN
          JCOMP = 1
          IF (MA%MP(1) < 0) JCOMP = 3
          GO TO 110
      ENDIF

!             Check for opposite signs.

      IF (MA%MP(1) > 0 .AND. MB%MP(1) < 0) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MB%MP(1) > 0 .AND. MA%MP(1) < 0) THEN
          JCOMP = 3
          GO TO 110
      ENDIF

!             See which one is larger in absolute value.

      IF (MA%MP(2) > MB%MP(2)) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MB%MP(2) > MA%MP(2)) THEN
          JCOMP = 3
          GO TO 110
      ENDIF
      NLAST = QX%NDIG + 1

      DO J = 2, NLAST
         IF (ABS(MA%MP(J+1)) > ABS(MB%MP(J+1))) THEN
             JCOMP = 1
             GO TO 110
         ENDIF
         IF (ABS(MB%MP(J+1)) > ABS(MA%MP(J+1))) THEN
             JCOMP = 3
             GO TO 110
         ENDIF
      ENDDO

      JCOMP = 2

!             Now match the JCOMP value to the requested comparison.

  110 IF (JCOMP == 1 .AND. MA%MP(1) < 0) THEN
          JCOMP = 3
      ELSE IF (JCOMP == 3 .AND. MB%MP(1) < 0) THEN
          JCOMP = 1
      ENDIF

      FMCOMP = .FALSE.
      IF (JCOMP == 1 .AND. (JREL == 'GT' .OR. JREL == 'GE' .OR. JREL == 'NE')) FMCOMP = .TRUE.
      IF (JCOMP == 2 .AND. (JREL == 'EQ' .OR. JREL == 'GE' .OR. JREL == 'LE')) FMCOMP = .TRUE.
      IF (JCOMP == 3 .AND. (JREL == 'NE' .OR. JREL == 'LT' .OR. JREL == 'LE')) FMCOMP = .TRUE.

  120 CONTINUE
      IF (QX%NTRACE /= 0) THEN
          IF (QX%NCALL <= QX%LVLTRC .AND. ABS(QX%NTRACE) >= 1) THEN
              IF (QX%KFLAG == 0) THEN
                  WRITE (KW,                                                   &
                         "(' FMCOMP',15X,'Call level =',I2,5X,'MBASE =',"  //  &
                         "I10,5X,'NDIG =',I10)"                                &
                        ) QX%NCALL,INT(QX%MBASE),QX%NDIG
              ELSE
                  WRITE (KW,                                                  &
                         "(' FMCOMP',6X,'Call level =',I2,4X,'MBASE =',"  //  &
                         "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"               &
                        ) QX%NCALL,INT(QX%MBASE),QX%NDIG,QX%KFLAG
              ENDIF
              IF (FMCOMP) THEN
                  WRITE (KW,"(7X,'.TRUE.')")
              ELSE
                  WRITE (KW,"(7X,'.FALSE.')")
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END FUNCTION FMCOMP

      SUBROUTINE FMCONS(QX)

!  Set several saved machine precision constants.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      REAL :: T = 2.0
      TYPE(FM_SETTINGS) :: QX

      QX%MBLOGS = QX%MBASE
      QX%ALOGMB = LOG(REAL(QX%MBASE))
      QX%ALOGM2 = QX%ALOGMB/LOG(T)
      QX%ALOGMX = LOG(REAL(MAXINT))
      QX%ALOGMT = QX%ALOGMB/LOG(10.0)
      QX%NGRD21 = INT(2.0/QX%ALOGMT + 1.0)
      QX%NGRD52 = INT(5.0/QX%ALOGMT + 2.0)
      QX%NGRD22 = INT(2.0/QX%ALOGMT + 2.0)
      IF (QX%MBASE < 1000) THEN
          QX%NGRD21 = 2*QX%NGRD21
          QX%NGRD52 = 4*QX%NGRD52
          QX%NGRD22 = 2*QX%NGRD22
      ELSE
          QX%NGRD21 = QX%NGRD21 + 1
          QX%NGRD52 = QX%NGRD52 + 1
          QX%NGRD22 = QX%NGRD22 + 1
      ENDIF
      QX%MEXPAB = AINT (QX%MXEXP2/5)
      QX%DLOGMB = LOG(DBLE(QX%MBASE))
      QX%DLOGTN = LOG(10.0D0)
      QX%DLOGTW = LOG(2.0D0)
      QX%DPPI = 4.0D0*ATAN(1.0D0)
      QX%DLOGTP = LOG(2.0D0*QX%DPPI)
      QX%DLOGPI = LOG(QX%DPPI)
      QX%DLOGEB = -LOG(QX%DPEPS)/QX%DLOGMB

      RETURN
      END SUBROUTINE FMCONS

      SUBROUTINE FMCOS(MA,MB,QX)

!  MB = COS(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MPISAV
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(6)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGPI = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCOS'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          IF (QX%KRAD == 0) THEN
              CALL FMPI(MXY(2),QX)
              CALL FMSQR(MXY(2),MXY(3),QX)
              CALL FMDIVI_R1(MXY(3),32400,QX)
              CALL FMMPY_R1(MXY(1),MXY(3),QX)
          ENDIF
          CALL FMDIVI(MXY(1),-2,MXY(3),QX)
          IF (MXY(3)%MP(2) > QX%MEXPUN) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMADD(MXY(1),MXY(3),MB,QX)
          ELSE IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMADD(MXY(1),MXY(3),MB,QX)
          ELSE IF (QX%KROUND == -1 .OR. QX%KROUND == 0) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMDP2M(0.9D0,MXY(2),QX)
              CALL FMULP(MXY(2),MXY(3),QX)
              CALL FMSUB(MXY(1),MXY(3),MB,QX)
          ELSE
              CALL FMI2M(1,MB,QX)
          ENDIF
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCOS'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0) THEN
          CALL FMENTR('FMCOS    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMCOS'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(6),NDSAVE,QX%NDIG,QX)
      MXY(6)%MP(1) = 1
      IF (MA%MP(2) > 3*10**5 .AND. QX%KRAD == 1) THEN
          QX%KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(6),QX)
          GO TO 120
      ENDIF
      CALL FMEQ(MXY(6),MXY(5),QX)
      KWRNSV = QX%KWARN
      QX%KWARN = 0

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP,QX)
      IF (QX%KROUND /= 1 .AND. QX%KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1),QX)
          CALL FMSUB(MXY(6),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0 .AND. JSWAP == 1) THEN
              CALL FMST2M('0.5',MXY(1),QX)
              CALL FMMPYI(MXY(1),JCOS,MXY(6),QX)
              GO TO 120
          ENDIF
      ENDIF
      QX%KWARN = KWRNSV
      IF (MXY(6)%MP(2) == QX%MUNKNO) THEN
          IF (QX%KRAD /= 1 .OR. JSWAP == 1) THEN
              CALL FMEQ(MXY(5),MXY(6),QX)
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP,QX)
              GO TO 120
          ENDIF
          IF (QX%MBSPI /= QX%MBASE .OR. QX%NDIGPI < QX%NDIG)  THEN
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(3),QX)
              QX%NDIG = NDSV
          ENDIF
          CALL FMPI(MPISAV,QX)
          CALL FMDIV(MXY(5),MPISAV,MXY(3),QX)
          CALL FMNINT(MXY(3),MXY(2),QX)
          CALL FMMPY(MXY(2),MPISAV,MXY(1),QX)
          CALL FMSUB_R2(MXY(5),MXY(1),QX)
          IF (MXY(1)%MP(3) == 0) CALL FMULP(MXY(5),MXY(1),QX)
          CALL FMI2M(1,MXY(3),QX)
          CALL FMSQR_R1(MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMSUB_R2(MXY(3),MXY(1),QX)
          CALL FMSUB_R1(MXY(1),MXY(3),QX)
          IF (MXY(1)%MP(3) == 0) THEN
              CALL FMI2M(JCOS,MXY(6),QX)
          ELSE
              CALL FMEQ(MXY(5),MXY(6),QX)
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP,QX)
          ENDIF
          GO TO 120
      ENDIF
      IF (QX%KRAD == 0) THEN
          IF (QX%MBSPI /= QX%MBASE .OR. QX%NDIGPI < QX%NDIG)  THEN
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(4),QX)
              QX%NDIG = NDSV
          ENDIF
          CALL FMPI(MPISAV,QX)
          CALL FMMPY_R1(MXY(6),MPISAV,QX)
          CALL FMDIVI_R1(MXY(6),180,QX)
      ENDIF
      IF (MXY(6)%MP(2) /= QX%MUNKNO) THEN
          IF (JSWAP == 0) THEN
              CALL FMCOS2(MXY(6),MXY(4),QX)
              CALL FMEQ(MXY(4),MXY(6),QX)
          ELSE
              IF (MXY(6)%MP(2) < 0 .OR. QX%NDIG <= 50) THEN
                  CALL FMSIN2(MXY(6),MXY(4),QX)
                  CALL FMEQ(MXY(4),MXY(6),QX)
              ELSE
                  CALL FMCOS2(MXY(6),MXY(4),QX)
                  CALL FMI2M(1,MXY(2),QX)
                  CALL FMSQR(MXY(4),MXY(6),QX)
                  CALL FMSUB_R2(MXY(2),MXY(6),QX)
                  CALL FMSQRT_R1(MXY(6),QX)
              ENDIF
          ENDIF
      ENDIF

!             Append the sign, round, and return.

      IF (MXY(6)%MP(2) /= QX%MUNKNO .AND. MXY(6)%MP(3) /= 0 .AND. JCOS == -1)  &
          MXY(6)%MP(1) = -MXY(6)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(6)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMCOS

      SUBROUTINE FMCOS2(MA,MB,QX)

!  Internal subroutine for MB = COS(MA) where 0 <= MA <= 1.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAXV
      INTEGER :: J,J2,K2,KTWO,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG2,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3),MJSUMS(LJSUMS)


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (MA%MP(3) == 0) THEN
          CALL FMI2M(1,MB,QX)
          RETURN
      ENDIF
      NDSAVE = QX%NDIG
      KWRNSV = QX%KWARN
      QX%KWARN = 0

!             Use the direct series:  COS(X) = 1 - X**2/2! + X**4/4! - ...

!             The argument will be divided by 2**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.

!             Since X is small when the series is summed, COS(X) - 1 is computed.  Then a version of
!             the recovery formula can be used that does not suffer from severe cancellation.

      B = REAL(QX%MBASE)
      T = MAX(QX%NDIG-QX%NGRD52,2)
      ALOG2 = LOG(2.0)
      ALOGT = LOG(T)
      TJ = 0.69*(QX%NDIG*QX%ALOGMT)**0.3333
      J2 = INT(TJ)
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      IF (QX%NDIG > 2000) THEN
          J2 = -4.0 + 3.0*ALOGT
      ENDIF
      K2 = MAX(2,INT(1.25*(QX%NDIG*QX%ALOGMT)**0.3333 - 3.4))


      TJ = -(REAL(MA%MP(2))*QX%ALOGMB+LOG(REAL(MA%MP(3))/B +  &
             REAL(MA%MP(4))/(B*B)))/ALOG2 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (QX%NDIG > 2000) THEN
          K2 = 5.8*QX%ALOGMB - 263 + (35 - 0.58*QX%ALOGMB)*ALOGT
      ENDIF
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
          J2 = MAX(1,MIN(J2,LJSUMS))
      ENDIF

      N2 = INT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/QX%ALOGMB)
      QX%NDIG = QX%NDIG + MAX(L2,0)
      NDSAV1 = QX%NDIG
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))

!             Divide the argument by 2**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      KTWO = 1
      MAXV = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTWO,QX)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMCSDIVI_R1(MXY(1),KTWO,QX)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      NTERM = 2
      CALL FMI2M(1,MXY(2),QX)
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         CALL FMEQ(MXY(2),MJSUMS(J),QX)
         NTERM = NTERM + 2
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 120
      CALL FMSQR_R1(MXY(1),QX)
      CALL FMIPWR(MXY(1),J2,MXY(3),QX)
      IF (MXY(3)%MP(2) < -QX%NDIG) GO TO 120

  110 CALL FMCSMPY_R1(MXY(2),MXY(3),QX)
      DO J = 1, J2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(2),NTERM,QX)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         ENDIF
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2),QX)
         IF (QX%KFLAG /= 0) GO TO 120
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(2)%MP(2))
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(3),QX)
      IF (MXY(1)%MP(2) /= QX%MUNKNO .AND. MXY(1)%MP(3) /= 0)  &
          MXY(1)%MP(1) = -MXY(1)%MP(1)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(1),QX)
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1),QX)
      ENDDO
      CALL FMCSMPY_R1(MXY(3),MXY(1),QX)

!             Reverse the effect of reducing the argument to compute COS(MA).

      QX%NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1),QX)
              DO J = 1, K2
                 CALL FMADD(MXY(3),MXY(1),MXY(2),QX)
                 CALL FMCSMPY_R1(MXY(2),MXY(3),QX)
                 CALL FMADD(MXY(2),MXY(2),MXY(3),QX)
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2),QX)
                 CALL FMADD(MXY(3),MXY(3),MXY(1),QX)
                 CALL FMADD_R1(MXY(2),MXY(1),QX)
                 CALL FMADD(MXY(2),MXY(2),MXY(3),QX)
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(2),QX)
      CALL FMADD_R2(MXY(2),MXY(3),QX)

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV

      RETURN
      END SUBROUTINE FMCOS2

      SUBROUTINE FMCOSH(MA,MB,QX)

!  MB = COSH(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCOSH'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMDIVI(MXY(1),2,MXY(2),QX)
          IF (MXY(2)%MP(2) > QX%MEXPUN) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
          ELSE IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
          ELSE IF (QX%KROUND == 2) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
          ELSE
              CALL FMI2M(1,MB,QX)
          ENDIF
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCOSH'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMENTR('FMCOSH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMCOSH'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
      MXY(2)%MP(1) = 1
      IF (MA%MP(3) == 0) THEN
          CALL FMI2M(1,MXY(2),QX)
          GO TO 120
      ENDIF

!             Use a series for small arguments, FMEXP for large ones.

      IF (MXY(2)%MP(2) == QX%MUNKNO) GO TO 120
      IF (QX%MBASE > 99) THEN
          IF (MXY(2)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE IF (MXY(2)%MP(2) >= 2) THEN
              NMETHD = 2
          ELSE IF (ABS(MXY(2)%MP(3)) < 10) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MXY(2)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 1) THEN
          CALL FMCSH2(MXY(2),MXY(1),QX)
          CALL FMEQ(MXY(1),MXY(2),QX)
      ELSE
          CALL FMEXP(MXY(2),MXY(1),QX)
          CALL FMEQ(MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(2) == QX%MEXPOV) THEN
              GO TO 120
          ENDIF
          IF (INT(MXY(2)%MP(2)) <= (QX%NDIG+1)/2) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMDIV_R1(MXY(1),MXY(2),QX)
              CALL FMADD_R1(MXY(2),MXY(1),QX)
          ENDIF
          CALL FMDIVI_R1(MXY(2),2,QX)
      ENDIF

!             Round and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMCOSH

      SUBROUTINE FMCSADD_R1(MA,MB,QX)

!  Internal addition routine.  MA = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: J,K,KP2,N1
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      IF (QX%NTRACE /= 0 .OR. ABS(MA%MP(2)) >= QX%MEXPAB .OR.       &
          ABS(MB%MP(2)) >= QX%MEXPAB .OR. MA%MP(2) < MB%MP(2) .OR.  &
          MA%MP(1) < 0 .OR. MB%MP(1) < 0 .OR. MA%MP(3) == 0 .OR.    &
          MB%MP(3) == 0) THEN
          CALL FMADD_R1(MA,MB,QX)
          RETURN
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      K = MA%MP(2) - MB%MP(2)

!             Add MA and MB.

      KP2 = K + 2
      DO J = KP2+1, N1+1
         MA%MP(J) = MA%MP(J) + MB%MP(J-K)
      ENDDO

!             Normalize.  Fix any digit not less than MBASE.

      IF (MA%MP(3) >= QX%MBASE) THEN
          MA%MP(2) = MA%MP(2) + 1
          IF (MA%MP(N1+1) >= QX%MBASE) MA%MP(QX%NDIG+1) = MA%MP(QX%NDIG+1) + 1
          DO J = QX%NDIG+1, 4, -1
             IF (MA%MP(J) >= QX%MBASE) THEN
                 MA%MP(J+1) = MA%MP(J) - QX%MBASE
                 MA%MP(J-1) = MA%MP(J-1) + 1
             ELSE
                 MA%MP(J+1) = MA%MP(J)
             ENDIF
          ENDDO
          MA%MP(4) = MA%MP(3) - QX%MBASE
          MA%MP(3) = 1
      ELSE
          DO J = N1+1, 4, -1
             IF (MA%MP(J) >= QX%MBASE) THEN
                 MA%MP(J) = MA%MP(J) - QX%MBASE
                 MA%MP(J-1) = MA%MP(J-1) + 1
             ENDIF
          ENDDO
          IF (MA%MP(3) >= QX%MBASE) THEN
              DO J = N1+1, 5, -1
                 MA%MP(J) = MA%MP(J-1)
              ENDDO
              MA%MP(4) = MA%MP(3) - QX%MBASE
              MA%MP(3) = 1
              MA%MP(2) = MA%MP(2) + 1
          ENDIF
      ENDIF

      IF (ABS(MA%MP(2)-MB%MP(2)) >= QX%NDIG) QX%KFLAG = 1

      RETURN
      END SUBROUTINE FMCSADD_R1

      SUBROUTINE FMCSADDNN_R1(MA,MB,QX)

!  Internal addition routine.  MA = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: J,K,KP2,N1
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      IF (QX%NTRACE /= 0 .OR. ABS(MA%MP(2)) >= QX%MEXPAB .OR. ABS(MB%MP(2)) >= QX%MEXPAB  &
          .OR. MA%MP(2) < MB%MP(2) .OR. MA%MP(3) == 0                                     &
          .OR. MB%MP(3) == 0) THEN
          CALL FMCSNORM(MA,QX)
          CALL FMADD_R1(MA,MB,QX)
          RETURN
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      K = MA%MP(2) - MB%MP(2)

!             Add MA and MB.

      KP2 = K + 2
      DO J = KP2+1, N1+1
         MA%MP(J) = MA%MP(J) + MB%MP(J-K)
      ENDDO

!             See if the result is equal to one of the input arguments.

      IF (ABS(MA%MP(2)-MB%MP(2)) >= QX%NDIG) QX%KFLAG = 1

      RETURN
      END SUBROUTINE FMCSADDNN_R1

      SUBROUTINE FMCSDIV(MA,MB,MC,QX)

!  Internal division routine.  MC = MA/MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: XB,XBR,XBASE,XMWA
      REAL (KIND(1.0D0)) :: MAXMWA,MBP1,MCARRY,MKT,MLMAX,MQD
      REAL :: C
      INTEGER :: J,JB,JL,KA,KB,KL,KPTMWA,N1,NG,NL,NMBWDS,NZDMB
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      C = 3100
      IF (QX%NTRACE /= 0 .OR. ABS(MA%MP(2)) >= QX%MEXPAB  .OR. ABS(MB%MP(2)) >= QX%MEXPAB  &
          .OR. MA%MP(3) == 0 .OR. MB%MP(3) == 0 .OR. QX%MBASE < 1000                       &
          .OR. QX%NDIG >= C) THEN
          CALL FMDIV(MA,MB,MC,QX)
          RETURN
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      NG = QX%NDIG + QX%NGRD21
      NL = NG + 4
      MWA%MP(2) = MA%MP(2) - MB%MP(2) + 1
      MWA%MP(3) = 0
      DO J = 2, N1
         MWA%MP(J+2) = MA%MP(J+1)
      ENDDO
      NL = N1 + QX%NGRD21 + 3
      DO J = QX%NDIG+3, NL
         MWA%MP(J+1) = 0
      ENDDO

!             NMBWDS is the number of words of MB used to compute the estimated quotient digit MQD.

      NMBWDS = 4
      IF (QX%MBASE < 100) NMBWDS = 7

!             XB is an approximation of MB used in estimating the quotient digits.

      XBASE = DBLE(QX%MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= N1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MB%MP(J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= N1) THEN
                 XB = XB*XBASE + DBLE(MB%MP(J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= N1) THEN
          XB = XB + DBLE(MB%MP(JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = QX%MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - QX%MBASE
      MLMAX = MIN(MLMAX,MKT)

!             Count the trailing zero digits of MB.

      DO J = N1, 2, -1
         IF (MB%MP(J+1) /= 0) THEN
             NZDMB = N1 - J
             GO TO 110
         ENDIF
      ENDDO

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.  It is used
!             to determine whether normalization can be postponed.

  110 MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  120 KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWA%MP(KPTMWA+1))*XBASE + DBLE(MWA%MP(KPTMWA+2)))*XBASE  &
                 + DBLE(MWA%MP(KPTMWA+3)))*XBASE + DBLE(MWA%MP(KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWA%MP(KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = MIN(KA+QX%NDIG-1-NZDMB,NL)
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWA%MP(J+1) < 0) THEN
                 MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
                 MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MB from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          DO J = KA+1, KB+1
             MWA%MP(J) = MWA%MP(J) - MQD*MB%MP(J-JB)
          ENDDO
      ENDIF

      MWA%MP(KA+1) = MWA%MP(KA+1) + MWA%MP(KA)*QX%MBASE
      MWA%MP(KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA <= NG) GO TO 120
      IF (MWA%MP(3) == 0 .AND. KPTMWA <= NG+1) GO TO 120

      KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWA%MP(KPTMWA+1))*XBASE + DBLE(MWA%MP(KPTMWA+2)))*XBASE  &
                 + DBLE(MWA%MP(KPTMWA+3)))*XBASE + DBLE(MWA%MP(KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWA%MP(KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF
      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1
      MWA%MP(KPTMWA+1) = MQD
      MWA%MP(KPTMWA+2) = 0
      MWA%MP(KPTMWA+3) = 0

!             Final normalization.

      IF (KPTMWA > 2*QX%NDIG) THEN
          DO J = 2*QX%NDIG+1, KPTMWA
             IF (MWA%MP(J+1) /= QX%MBASE-1) EXIT
             IF (J == KPTMWA) MWA%MP(J+1) = QX%MBASE
          ENDDO
      ENDIF
      DO J = KPTMWA, 3, -1
         IF (MWA%MP(J+1) < 0) THEN
             MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
             MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ENDIF
      ENDDO
      CALL FMMOVE(MWA,MC,QX)
      MC%MP(1) = MA%MP(1) * MB%MP(1)

      RETURN
      END SUBROUTINE FMCSDIV

      SUBROUTINE FMCSDIVI(MA,IVAL,MB,QX)

!  Internal divide by integer routine.  MA = MA / IVAL

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MKT,MODINT,MVALP
      INTEGER :: J,KA,KB,KL,KPT,KPTWA,N1,NMVAL,NV2
      TYPE(FM_SETTINGS) :: QX
      INTENT (INOUT) :: MB
      INTENT (IN) :: MA,IVAL

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (QX%NTRACE /= 0 .OR. ABS(MA%MP(2)) >= QX%MEXPAB .OR. MA%MP(3) == 0 .OR.  &
          IVAL == 0 .OR. ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMDIVI(MA,IVAL,MB,QX)
          RETURN
      ENDIF
      IF (ABS(IVAL) == 1) THEN
          CALL FMEQ(MA,MB,QX)
          MB%MP(1) = MA%MP(1)*IVAL
          RETURN
      ENDIF

!             Find the first significant digit of the quotient.

      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      MVALP = ABS(IVAL)
      MKT = MA%MP(3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 120
      ENDIF
      DO J = 3, N1
         MKT = MKT*QX%MBASE + MA%MP(J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 120
         ENDIF
      ENDDO
      KPT = N1

  110 KPT = KPT + 1
      MKT = MKT*QX%MBASE
      IF (MKT < MVALP) GO TO 110

!             Do the rest of the division.

  120 KA = KPT + 1
      MB%MP(1) = MA%MP(1)*IVAL/ABS(IVAL)
      MB%MP(2) = MA%MP(2) + 2 - KPT
      MB%MP(3) = INT (MKT/MVALP)
      MODINT = MKT - MB%MP(3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          DO J = KA+1, N1+1
             MKT = MODINT*QX%MBASE + MA%MP(J)
             MB%MP(J+KL) = INT (MKT/MVALP)
             MODINT = MKT - MB%MP(J+KL)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1
      DO J = KA, KB
         MKT = MODINT*QX%MBASE
         MB%MP(J+1) = INT (MKT/MVALP)
         MODINT = MKT - MB%MP(J+1)*MVALP
      ENDDO

      RETURN
      END SUBROUTINE FMCSDIVI

      SUBROUTINE FMCSDIVI_R1(MA,IVAL,QX)

!  Internal divide by integer routine.  MA = MA / IVAL

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MKT,MODINT,MVALP
      INTEGER :: J,KA,KB,KL,KPT,KPTWA,N1,NMVAL,NV2
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (QX%NTRACE /= 0 .OR. ABS(MA%MP(2)) >= QX%MEXPAB .OR. MA%MP(3) == 0 .OR.  &
          IVAL == 0 .OR. ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMDIVI_R1(MA,IVAL,QX)
          RETURN
      ENDIF
      IF (ABS(IVAL) == 1) THEN
          MA%MP(1) = MA%MP(1)*IVAL
          RETURN
      ENDIF

!             Find the first significant digit of the quotient.

      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      MVALP = ABS(IVAL)
      MKT = MA%MP(3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 120
      ENDIF
      DO J = 3, N1
         MKT = MKT*QX%MBASE + MA%MP(J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 120
         ENDIF
      ENDDO
      KPT = N1

  110 KPT = KPT + 1
      MKT = MKT*QX%MBASE
      IF (MKT < MVALP) GO TO 110

!             Do the rest of the division.

  120 KA = KPT + 1
      MA%MP(2) = MA%MP(2) + 2 - KPT
      MA%MP(3) = INT (MKT/MVALP)
      MODINT = MKT - MA%MP(3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          DO J = KA+1, N1+1
             MKT = MODINT*QX%MBASE + MA%MP(J)
             MA%MP(J+KL) = INT (MKT/MVALP)
             MODINT = MKT - MA%MP(J+KL)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1
      DO J = KA, KB
         MKT = MODINT*QX%MBASE
         MA%MP(J+1) = INT (MKT/MVALP)
         MODINT = MKT - MA%MP(J+1)*MVALP
      ENDDO
      IF (IVAL < 0) MA%MP(1) = -MA%MP(1)

      RETURN
      END SUBROUTINE FMCSDIVI_R1

      SUBROUTINE FMCSH2(MA,MB,QX)

!  Internal subroutine for MB = COSH(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MAXV
      INTEGER :: J,J2,K,K2,KEXP,KTWO,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG2,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (MA%MP(3) == 0) THEN
          CALL FMI2M(1,MB,QX)
          RETURN
      ENDIF
      NDSAVE = QX%NDIG
      KWRNSV = QX%KWARN
      QX%KWARN = 0

!             Use the direct series:  COSH(X) = 1 + X**2/2! + X**4/4! - ...

!             The argument will be divided by 2**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.

!             Since X is small when the series is summed, COSH(X) - 1 is computed.  Then a version
!             of the recovery formula can be used that does not suffer from severe cancellation.

      B = REAL(QX%MBASE)
      K = QX%NGRD52
      T = MAX(QX%NDIG-K,2)
      ALOG2 = LOG(2.0)
      ALOGT = LOG(T)
      TJ = 0.65*(QX%NDIG*QX%ALOGMT)**0.3333 - 2.0
      J2 = INT(TJ)
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      K2 = INT(1.38*(QX%NDIG*QX%ALOGMT)**0.3333 - 1.8)

      TJ = -(REAL(MA%MP(2))*QX%ALOGMB+LOG(REAL(MA%MP(3))/B +  &
             REAL(MA%MP(4))/(B*B)))/ALOG2 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
          J2 = MAX(1,MIN(J2,LJSUMS))
      ENDIF
      IF (J2 <= 1) J2 = 1

      N2 = INT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/QX%ALOGMB)
      QX%NDIG = QX%NDIG + L2
      NDSAV1 = QX%NDIG
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

!             Divide the argument by 2**K2.

      KTWO = 1
      MAXV = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTWO,QX)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMCSDIVI_R1(MXY(1),KTWO,QX)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMSQR_R1(MXY(1),QX)
      CALL FMEQ(MXY(1),MXY(2),QX)
      NTERM = 2
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         NTERM = NTERM + 2
         CALL FMEQ(MXY(2),MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 120
      CALL FMIPWR(MXY(1),J2,MXY(3),QX)

  110 CALL FMCSMPY_R1(MXY(2),MXY(3),QX)
      DO J = 1, J2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(2),NTERM,QX)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         ENDIF
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2),QX)
         IF (QX%KFLAG /= 0) GO TO 120
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(2)%MP(2))
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(3),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(1),QX)
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1),QX)
      ENDDO

!             Reverse the effect of reducing the argument to compute COSH(MA).

      QX%NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1),QX)
              DO J = 1, K2
                 KEXP = MXY(3)%MP(2)
                 IF (QX%MBASE == 2 .OR. KEXP > 0) THEN
                     CALL FMADD(MXY(3),MXY(1),MXY(2),QX)
                 ELSE
                     DO K = 1, 3-KEXP
                        MXY(2)%MP(K) = MXY(1)%MP(K)
                     ENDDO
                     DO K = 4-KEXP, QX%NDIG+2
                        MXY(2)%MP(K) = MXY(3)%MP(K-1+KEXP)
                     ENDDO
                 ENDIF
                 CALL FMCSMPY_R1(MXY(2),MXY(3),QX)
                 CALL FMCSMPYI(MXY(2),2,MXY(3),QX)
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2),QX)
                 CALL FMADD(MXY(3),MXY(3),MXY(1),QX)
                 CALL FMADD_R1(MXY(2),MXY(1),QX)
                 CALL FMADD(MXY(2),MXY(2),MXY(3),QX)
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(2),QX)
      CALL FMADD_R2(MXY(2),MXY(3),QX)

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV

      RETURN
      END SUBROUTINE FMCSH2

      SUBROUTINE FMCSMPY_R1(MA,MB,QX)

!  Internal multiplication of MA*MB.  The result is returned in MA.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      REAL (KIND(1.0D0)) :: MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MK,MKT,MMAX,MT
      REAL :: C
      INTEGER :: J,JM1,K,KB,KI,KJ,KL,KNZ,KWA,L,N1,NGUARD
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      C = 900
      IF (QX%NTRACE /= 0 .OR. ABS(MA%MP(2)) >= QX%MEXPAB  .OR. ABS(MB%MP(2)) >= QX%MEXPAB  &
          .OR. MA%MP(3) == 0 .OR. MB%MP(3) == 0 .OR. QX%MBASE < 1000                       &
          .OR. QX%NDIG >= C) THEN
          CALL FMMPY_R1(MA,MB,QX)
          RETURN
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      NGUARD = QX%NGRD22
      MWA%MP(2) = MA%MP(2) + MB%MP(2)
      L = N1 + NGUARD
      MWA%MP(L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = QX%MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - QX%MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MB%MP(3)

!             Count the trailing zeros in MA.

          IF (MA%MP(N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = QX%NDIG, 2, -1
                 IF (MA%MP(J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWA%MP(3) = 0
          DO K = QX%NDIG+2, L
             MWA%MP(K+1) = 0
          ENDDO

!             (Inner Loop)

          DO K = 3, N1+1
             MWA%MP(K+1) = MA%MP(K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, N1
             MBJ = MB%MP(J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)
                 DO K = J+2, J+KL
                    MWA%MP(K) = MWA%MP(K) + MA%MP(K-JM1)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWA%MP(KB+1)/QX%MBASE)
                    MWA%MP(KB) = MWA%MP(KB) + MKT
                    MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          DO KB = L+1, 4, -1
             MKT = INT (MWA%MP(KB)/QX%MBASE)
             MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
             MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWA%MP(J+1) = 0
          ENDDO
          KJ = QX%NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MB%MP(KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MA%MP(KI-K+1)*MBKJ + MWA%MP(KWA-K+1) + MK
                MK = INT (MT/QX%MBASE)
                MWA%MP(KWA-K+1) = MT - QX%MBASE*MK
             ENDDO
             MWA%MP(KWA-KL) = MK
          ENDDO
      ENDIF

      IF (MA%MP(1)*MB%MP(1) < 0) THEN
          MA%MP(1) = -1
      ELSE
          MA%MP(1) = 1
      ENDIF
      MA%MP(2) = MWA%MP(2)
      IF (MWA%MP(3) == 0) THEN
          MA%MP(2) = MA%MP(2) - 1
          DO J = 3, N1+1
             MA%MP(J) = MWA%MP(J+1)
          ENDDO
      ELSE
          DO J = 3, N1+1
             MA%MP(J) = MWA%MP(J)
          ENDDO
      ENDIF

      RETURN
      END SUBROUTINE FMCSMPY_R1

      SUBROUTINE FMCSMPYI(MA,IVAL,MB,QX)

!  Internal multiply by integer routine.  MB = MA * IVAL

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MKT,MVAL
      INTEGER :: J,KSHIFT,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      IF (QX%NTRACE /= 0 .OR. ABS(MA%MP(2)) >= QX%MEXPAB .OR. MA%MP(3) == 0 .OR.  &
          ABS(IVAL) <= 1 .OR. ABS(IVAL) > MXBASE) THEN
          CALL FMMPYI(MA,IVAL,MB,QX)
          RETURN
      ENDIF

!             Work with positive numbers.

      QX%KFLAG = 0
      MAS = MA%MP(1)
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MB.

      KSHIFT = 0
      MKT = MA%MP(3) * MVAL
      DO J = 1, 100
         IF (MKT < QX%MBASE) EXIT
         KSHIFT = KSHIFT + 1
         MKT = INT(MKT/QX%MBASE)
      ENDDO

      IF (KSHIFT > QX%NDIG .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMMPYI(MA,IVAL,MB,QX)
          RETURN
      ENDIF
      MB%MP(2) = MA%MP(2) + KSHIFT

      MCARRY = 0
      DO J = QX%NDIG, QX%NDIG-KSHIFT+1, -1
         MKT = MA%MP(J+2)*MVAL + MCARRY
         MCARRY = INT(MKT/QX%MBASE)
      ENDDO
      DO J = QX%NDIG-KSHIFT, 1, -1
         MKT = MA%MP(J+2)*MVAL + MCARRY
         MCARRY = INT(MKT/QX%MBASE)
         MB%MP(J+2+KSHIFT) = MKT - MCARRY*QX%MBASE
      ENDDO
      DO J = KSHIFT, 1, -1
         MKT = MCARRY
         MCARRY = INT(MKT/QX%MBASE)
         MB%MP(J+2) = MKT - MCARRY*QX%MBASE
      ENDDO
      IF (MCARRY > 0) THEN
          MB%MP(2) = MB%MP(2) + 1
          DO J = QX%NDIG, 2, -1
             MB%MP(J+2) = MB%MP(J+1)
          ENDDO
          MB%MP(3) = MCARRY
      ENDIF

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      MB%MP(1) = QX%JRSIGN

      RETURN
      END SUBROUTINE FMCSMPYI

      SUBROUTINE FMCSMPYI_R1(MA,IVAL,QX)

!  Internal multiply by integer routine.  MA = MA * IVAL

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MKT,MVAL
      INTEGER :: J,KSHIFT,NMVAL,NV2
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      IF (QX%NTRACE /= 0 .OR. ABS(MA%MP(2)) >= QX%MEXPAB .OR. MA%MP(3) == 0 .OR.  &
          ABS(IVAL) <= 1 .OR. ABS(IVAL) > MXBASE) THEN
          CALL FMMPYI_R1(MA,IVAL,QX)
          RETURN
      ENDIF

!             Work with positive numbers.

      QX%KFLAG = 0
      MAS = MA%MP(1)
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places.

      KSHIFT = 0
      MKT = MA%MP(3) * MVAL
      DO J = 1, 100
         IF (MKT < QX%MBASE) EXIT
         KSHIFT = KSHIFT + 1
         MKT = INT(MKT/QX%MBASE)
      ENDDO

      IF (KSHIFT > QX%NDIG .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMMPYI_R1(MA,IVAL,QX)
          RETURN
      ENDIF
      MA%MP(2) = MA%MP(2) + KSHIFT

      MCARRY = 0
      DO J = QX%NDIG, QX%NDIG-KSHIFT+1, -1
         MKT = MA%MP(J+2)*MVAL + MCARRY
         MCARRY = INT(MKT/QX%MBASE)
      ENDDO
      DO J = QX%NDIG-KSHIFT, 1, -1
         MKT = MA%MP(J+2)*MVAL + MCARRY
         MCARRY = INT(MKT/QX%MBASE)
         MA%MP(J+2+KSHIFT) = MKT - MCARRY*QX%MBASE
      ENDDO
      DO J = KSHIFT, 1, -1
         MKT = MCARRY
         MCARRY = INT(MKT/QX%MBASE)
         MA%MP(J+2) = MKT - MCARRY*QX%MBASE
      ENDDO
      IF (MCARRY > 0) THEN
          MA%MP(2) = MA%MP(2) + 1
          DO J = QX%NDIG, 2, -1
             MA%MP(J+2) = MA%MP(J+1)
          ENDDO
          MA%MP(3) = MCARRY
      ENDIF

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      MA%MP(1) = QX%JRSIGN

      RETURN
      END SUBROUTINE FMCSMPYI_R1

      SUBROUTINE FMCSMPYIN_R1(MA,JB,JE,QX)

!  Internal routine for  MA = MA * JB**JE

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: JB,JE,J,KJ
      REAL (KIND(1.0D0)) :: MAXV
      INTENT (IN) :: JB,JE
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      KJ = 1
      MAXV = MXBASE/JB
      IF (JE > 0) THEN
          DO J = 1, JE
             KJ = JB*KJ
             IF (KJ > MAXV) THEN
                 CALL FMCSMPYI_R1(MA,KJ,QX)
                 KJ = 1
             ENDIF
          ENDDO
          IF (KJ > 1) CALL FMCSMPYI_R1(MA,KJ,QX)
      ENDIF

      END SUBROUTINE FMCSMPYIN_R1

      SUBROUTINE FMCSNORM(MA,QX)

!  Internal routine to normalize the digits of ma.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: K,KSHIFT
      REAL (KIND(1.0D0)) :: MKT
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      DO K = QX%NDIG+2, 4, -1
         MKT = INT (MA%MP(K)/QX%MBASE)
         MA%MP(K-1) = MA%MP(K-1) + MKT
         MA%MP(K) = MA%MP(K) - MKT*QX%MBASE
      ENDDO
      IF (MA%MP(3) >= QX%MBASE) THEN
          MKT = MA%MP(3)
          KSHIFT = 1
          DO
             MKT = INT (MKT/QX%MBASE)
             IF (MKT < QX%MBASE) EXIT
             KSHIFT = KSHIFT + 1
          ENDDO
          DO K = QX%NDIG+2, 3+KSHIFT, -1
             MA%MP(K) = MA%MP(K-KSHIFT)
          ENDDO
          DO K = 3+KSHIFT, 4, -1
             MKT = INT (MA%MP(K)/QX%MBASE)
             MA%MP(K-1) = MKT
             MA%MP(K) = MA%MP(K) - MKT*QX%MBASE
          ENDDO
          MA%MP(2) = MA%MP(2) + KSHIFT
      ENDIF

      END SUBROUTINE FMCSNORM

      SUBROUTINE FMCSNSUMS(J2,MJSUMS,QX)

!  Internal routine to normalize mjsums.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: J2
      TYPE(MULTI) :: MJSUMS(J2)
      INTEGER :: J
      INTENT (IN) :: J2
      INTENT (INOUT) :: MJSUMS
      TYPE(FM_SETTINGS) :: QX

      DO J = 1, J2
         CALL FMCSNORM(MJSUMS(J),QX)
      ENDDO

      RETURN
      END SUBROUTINE FMCSNSUMS

      SUBROUTINE FMCSSN(MA,MB,MC,QX)

!  MB = COS(MA),    MC = SIN(MA)

!  If both the sine and cosine are needed, this routine is faster than calling both FMCOS and FMSIN.

!  MB and MC must be distinct arrays.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(MULTI) :: MPISAV
      REAL (KIND(1.0D0)) :: MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NCSAVE,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(MULTI) :: MXY(7)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGPI = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      MAS = MA%MP(1)
      KR_RETRY = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCSSN'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMCOS(MA,MB,QX)
          CALL FMSIN(MA,MC,QX)
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCSSN'
              CALL FMNTR(1,MB,MB,1,1,QX)
              IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
                  IF (QX%NTRACE < 0) THEN
                      CALL FMNTRJ(MC,QX%NDIG,QX)
                  ELSE
                      CALL FMPRNT(MC,QX)
                  ENDIF
              ENDIF
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0) THEN
          NCSAVE = QX%NCALL
          CALL FMENTR('FMCSSN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (MA%MP(2) == QX%MUNKNO) KOVUN = 2
          QX%NCALL = NCSAVE + 1
          CALL FMEQU(MA,MXY(3),NDSAVE,QX%NDIG,QX)
          MXY(3)%MP(1) = 1
          IF (MA%MP(2) == QX%MEXPOV) THEN
              QX%KFLAG = -4
              CALL FMST2M('UNKNOWN',MXY(5),QX)
              CALL FMST2M('UNKNOWN',MXY(6),QX)
          ELSE
              CALL FMCOS(MXY(3),MXY(5),QX)
              CALL FMSIN(MXY(3),MXY(6),QX)
          ENDIF
          GO TO 120
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMCSSN'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      IF (MA%MP(2) > 3*10**5 .AND. QX%KRAD == 1) THEN
          QX%KFLAG = -4
          CALL FMWARN(QX)
          CALL FMST2M('UNKNOWN',MXY(5),QX)
          CALL FMST2M('UNKNOWN',MXY(6),QX)
          GO TO 120
      ENDIF

      CALL FMEQU(MA,MXY(5),NDSAVE,QX%NDIG,QX)
      MXY(5)%MP(1) = 1
      CALL FMEQ(MXY(5),MXY(7),QX)

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the functions.

      CALL FMRDC(MXY(5),JSIN,JCOS,JSWAP,QX)
      IF (QX%KROUND /= 1 .AND. QX%KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1),QX)
          CALL FMSUB(MXY(5),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0) THEN
              CALL FMCOS(MXY(7),MXY(5),QX)
              CALL FMSIN(MXY(7),MXY(6),QX)
              GO TO 120
          ENDIF
      ENDIF
      IF (MXY(5)%MP(2) == QX%MUNKNO) THEN
          CALL FMCOS(MXY(7),MXY(5),QX)
          CALL FMSIN(MXY(7),MXY(6),QX)
          GO TO 120
      ENDIF
      IF (QX%KRAD == 0) THEN
          IF (QX%MBSPI /= QX%MBASE .OR. QX%NDIGPI < QX%NDIG)  THEN
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(6),QX)
              QX%NDIG = NDSV
          ENDIF
          CALL FMPI(MPISAV,QX)
          CALL FMMPY_R1(MXY(5),MPISAV,QX)
          CALL FMDIVI_R1(MXY(5),180,QX)
      ENDIF
      IF (MXY(5)%MP(2) /= QX%MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MXY(5)%MP(2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(6),QX)
                  MXY(6)%MP(1) = JSIN*MXY(6)%MP(1)
                  CALL FMSQR(MXY(6),MXY(2),QX)
                  CALL FMI2M(1,MXY(1),QX)
                  CALL FMSUB_R2(MXY(1),MXY(2),QX)
                  CALL FMSQRT(MXY(2),MXY(5),QX)
                  MXY(5)%MP(1) = JCOS*MXY(5)%MP(1)
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4),QX)
                  CALL FMEQ(MXY(4),MXY(5),QX)
                  MXY(5)%MP(1) = JCOS*MXY(5)%MP(1)
                  CALL FMSQR(MXY(5),MXY(2),QX)
                  CALL FMI2M(1,MXY(1),QX)
                  CALL FMSUB_R2(MXY(1),MXY(2),QX)
                  CALL FMSQRT(MXY(2),MXY(6),QX)
                  MXY(6)%MP(1) = JSIN*MXY(6)%MP(1)
              ENDIF
          ELSE
              IF (MXY(5)%MP(2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4),QX)
                  CALL FMEQ(MXY(4),MXY(5),QX)
                  MXY(5)%MP(1) = JCOS*MXY(5)%MP(1)
                  CALL FMSQR(MXY(5),MXY(2),QX)
                  CALL FMI2M(1,MXY(1),QX)
                  CALL FMSUB_R2(MXY(1),MXY(2),QX)
                  CALL FMSQRT(MXY(2),MXY(6),QX)
                  MXY(6)%MP(1) = JSIN*MXY(6)%MP(1)
              ELSE
                  CALL FMCOS2(MXY(5),MXY(6),QX)
                  MXY(6)%MP(1) = JSIN*MXY(6)%MP(1)
                  CALL FMSQR(MXY(6),MXY(2),QX)
                  CALL FMI2M(1,MXY(1),QX)
                  CALL FMSUB_R2(MXY(1),MXY(2),QX)
                  CALL FMSQRT(MXY(2),MXY(5),QX)
                  MXY(5)%MP(1) = JCOS*MXY(5)%MP(1)
              ENDIF
          ENDIF
      ELSE
          CALL FMEQ(MXY(5),MXY(6),QX)
      ENDIF

!             Round and return.

  120 IF (MAS < 0 .AND. MXY(6)%MP(2) /= QX%MUNKNO .AND. MXY(6)%MP(3) /= 0)  &
          MXY(6)%MP(1) = -MXY(6)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1 .AND. MA%MP(2) /= QX%MEXPOV .AND. MXY(5)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(6)%MP(2) /= QX%MUNKNO) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(6)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1 .AND. MA%MP(2) /= QX%MEXPOV .AND. MXY(5)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(6)%MP(2) /= QX%MUNKNO) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (KOVUN == 2) THEN
          KWRNSV = QX%KWARN
          QX%KWARN = 0
      ENDIF
      NDSV = QX%NDIG
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KOVUN,QX)
      CALL FMEQU(MXY(6),MC,NDSV,NDSAVE,QX)
      IF (KOVUN == 2) THEN
          QX%KWARN = KWRNSV
      ENDIF
      IF (QX%NTRACE /= 0) THEN
          IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL+1 <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL FMNTRJ(MC,QX%NDIG,QX)
              ELSE
                  CALL FMPRNT(MC,QX)
              ENDIF
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMCSSN

      SUBROUTINE FMDBL(A,B,C)

!  C = A + B.  All are double precision.  This routine tries to force the compiler to round C to
!  double precision accuracy. Some compilers allow double precision loops like the one in FMDM to
!  be done in extended precision, which defeats the routine's attempt to determine double precision
!  accuracy.  This can lead to doing too few Newton steps and failing to get sufficient accuracy in
!  several FM routines.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      DOUBLE PRECISION :: A,B,C
      INTENT (IN) :: A,B
      INTENT (INOUT) :: C
      C = A + B
      RETURN
      END SUBROUTINE FMDBL

      SUBROUTINE FMDEFINE_ERROR

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      WRITE (KW,*) ' '
      WRITE (KW,*) ' Error in FM.  Out of memory for multiple precision numbers'
      WRITE (KW,*) '               or character strings to format FM output.'
      WRITE (KW,*) '               Allocation of more memory failed.'
      WRITE (KW,*) ' '

      STOP
      END SUBROUTINE FMDEFINE_ERROR

      SUBROUTINE FMDIG(NSTACK,KST,QX)

!  Compute the number of intermediate digits to be used in Newton iteration.  This assumes that a
!  starting approximation that is accurate to double precision is used, and the root is simple.

!  KST is the number of iterations needed for final accuracy NDIG.
!  NSTACK(J) holds the value of NDIG to be used for the Jth iteration.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NSTACK(49),KST
      INTENT (INOUT) :: NSTACK,KST
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: Y
      INTEGER :: J,JT,L,ND,NDT,NE

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             NE is the maximum number of base MBASE digits that can be used in the first
!                Newton iteration.

      NE = INT(1.9D0*QX%DLOGEB)

!             Fill the intermediate digit stack (backwards).

      KST = 1
      ND = QX%NDIG
      NSTACK(1) = ND
      IF (ND < NE .OR. ND <= 2) RETURN

  110 Y = ND

!             The 1.9 accounts for the fact that the number of correct digits approximately doubles
!             at each iteration.

      NDT = INT(Y/1.9D0)
      IF (2*NDT <= ND) NDT = NDT + 1
      ND = NDT
      KST = KST + 1
      NSTACK(KST) = ND
      IF (ND > NE .AND. ND > 2) GO TO 110

!             Reverse the stack.

      L = KST/2
      DO J = 1, L
         JT = NSTACK(J)
         NSTACK(J) = NSTACK(KST+1-J)
         NSTACK(KST+1-J) = JT
      ENDDO

      RETURN
      END SUBROUTINE FMDIG

      SUBROUTINE FMDIM(MA,MB,MC,QX)

!  MC = DIM(MA,MB)

!  Positive difference.  MC = MA - MB  if MA >= MB,
!                           = 0        otherwise.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KOVUN,KRESLT,KWRNSV,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(3)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB) THEN
          CALL FMENTR('FMDIM    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
          QX%NDIG = NDSAVE
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMDIM'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      QX%MXEXP = MXSAVE

      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)

      IF (FMCOMP(MXY(1),'<',MXY(2),QX)) THEN
          CALL FMI2M(0,MXY(3),QX)
      ELSE
          QX%NCALL = QX%NCALL - 1
          CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMDIM'
      ENDIF

      IF (QX%KFLAG == 1) QX%KFLAG = 0
      QX%KWARN = KWRNSV
      CALL FMEXIT(MXY(3),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMDIM

      SUBROUTINE FMDIV(MA,MB,MC,QX)

!  MC = MA / MB

!  This routine performs the trace printing for division.  FMDIV2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIV'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMDIV2(MA,MB,MC,QX)

          CALL FMNTR(1,MC,MC,1,1,QX)
      ELSE
          CALL FMDIV2(MA,MB,MC,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMDIV

      SUBROUTINE FMDIV2(MA,MB,MC,QX)

!  Internal division routine.  MC = MA / MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(WORK_AREA) :: MWA
      TYPE(MULTI) :: MPMA,MPMB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      QX%NDIGL = 0
      QX%NDIGN = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      KR_RETRY = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT,QX)
          IF (KRESLT /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMDIV'
              CALL FMRSLT(MA,MB,MC,KRESLT,QX)
              QX%JRSIGN = JRSSAV
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
      ELSE
          IF (MB%MP(3) == 0) THEN
              QX%NAMEST(QX%NCALL) = 'FMDIV'
              CALL FMIM(0,MC,QX)
              QX%KFLAG = -4
              CALL FMWARN(QX)
              MC%MP(2) = QX%MUNKNO
              MC%MP(3) = 1
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
          IF (MA%MP(3) == 0) THEN
              CALL FMIM(0,MC,QX)
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
      ENDIF
      QX%KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > QX%NDIG+10) NGUARD = QX%NDIG + 10
      N1 = QX%NDIG + 1
      NG = QX%NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      MWA%MP(2) = MA%MP(2) - MB%MP(2) + 1

      IF (QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (QX%NDIGL /= QX%NDIG .OR. QX%MBASEL /= QX%MBASE .OR. QX%NGUARL /= NGUARD) THEN
              QX%MBASEL = QX%MBASE
              QX%NDIGL = QX%NDIG
              QX%NGUARL = NGUARD
              DO J = 2, 1000
                 MR = QX%MBASE*QX%MBASEL
                 IF (4*MR > MXBASE) THEN
                     QX%N21 = J - 1
                     QX%NDIG = (QX%NDIGL-1)/QX%N21 + 1
                     IF (QX%NDIG < 2) QX%NDIG = 2
                     QX%NGRDN = (QX%NDIGL+NGUARD-1)/QX%N21 + 2 - QX%NDIG
                     IF (QX%NGRDN < 1) QX%NGRDN = 1
                     EXIT
                 ENDIF
                 QX%MBASE = MR
              ENDDO
              QX%MBASEN = QX%MBASE
              QX%NDIGN = QX%NDIG
          ELSE
              QX%MBASE = QX%MBASEN
              QX%NDIG = QX%NDIGN
          ENDIF
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
          J = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRDN + 5
          QX%NDIG = J
          MPMA%MP(1) = MA%MP(1)
          MPMB%MP(1) = MB%MP(1)
          MPMA%MP(2) = 0
          MPMB%MP(2) = 0
          L = 2 - QX%N21
          DO J = 2, QX%NDIGL+2-QX%N21, QX%N21
             MT1 = MA%MP(J+1)
             MT2 = MB%MP(J+1)
             DO K = J+1, J+QX%N21-1
                MT1 = MT1*QX%MBASEL + MA%MP(K+1)
                MT2 = MT2*QX%MBASEL + MB%MP(K+1)
             ENDDO
             MPMA%MP(3+J/QX%N21) = MT1
             MPMB%MP(3+J/QX%N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/QX%N21, QX%NDIG+QX%NGRDN+2
             MPMA%MP(J+1) = 0
             MPMB%MP(J+1) = 0
          ENDDO
          IF (L+QX%N21 <= QX%NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+QX%N21, L+2*QX%N21-1
                 IF (J <= QX%NDIGL+1) THEN
                     MT1 = MT1*QX%MBASEL + MA%MP(J+1)
                     MT2 = MT2*QX%MBASEL + MB%MP(J+1)
                 ELSE
                     MT1 = MT1*QX%MBASEL
                     MT2 = MT2*QX%MBASEL
                 ENDIF
              ENDDO
              MPMA%MP(3+(L+QX%N21)/QX%N21) = MT1
              MPMB%MP(3+(L+QX%N21)/QX%N21) = MT2
          ENDIF
          NG = QX%NDIG + QX%NGRDN + 1
          IF (MPMA%MP(3) >= MPMB%MP(3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, QX%NDIG+1
             MWA%MP(J+2) = MPMA%MP(J+1)
          ENDDO
          MWA%MP(3) = 0
          DO J = QX%NDIG+3, NG+4
             MWA%MP(J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG,MWA,QX)
          IF (MWA%MP(3) >= QX%MBASEL) THEN
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 MWA%MP(J+1) = MWA%MP(J)
              ENDDO
              MWA%MP(3) = 0
              MWA%MP(2) = MWA%MP(2) + 1
          ENDIF
          KT3 = QX%N21 - 1
          IF (QX%MBASEL == 2 .AND. QX%MBASE < INTMAX) THEN
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 KT1 = MWA%MP(J+1)
                 KT = 2 + (J-2)*QX%N21
                 KT2 = QX%N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2+KT3)
                    MWA%MP(K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = QX%MBASEL**(QX%N21-1)
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 MR = MS
                 MT1 = MWA%MP(J+1)
                 DO K = 2+(J-2)*QX%N21, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2+KT3)
                    MWA%MP(K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWA%MP(K-KT3+1)*MR
                    MR = AINT (MR/QX%MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          QX%NDIG = QX%NDIGL
          QX%MBASE = QX%MBASEL
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWA%MP(J+2) = MA%MP(J+1)
          ENDDO
          MWA%MP(3) = 0
          NL = N1 + NGUARD + 3
          DO J = QX%NDIG+3, NL
             MWA%MP(J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG,MWA,QX)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWA%MP(3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (QX%NCALL >= 1 .AND. NGUARD < QX%NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWA%MP(J+QX%NDIG+3)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWA%MP(QX%NDIG+4) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+2) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+2) = MWA%MP(N1+2) + 1
                      MWA%MP(N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
              ENDIF
          ENDIF
      ELSE
          IF (QX%NCALL >= 1 .AND. NGUARD < QX%NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWA%MP(J+QX%NDIG+2)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWA%MP(QX%NDIG+3) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                      MWA%MP(N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MC,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIV'
          CALL FMWARN(QX)
      ENDIF

      MC%MP(1) = 1
      IF (MAS*MBS < 0 .AND. MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0)  &
          MC%MP(1) = -1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMDIV2

      SUBROUTINE FMDIV_R1(MA,MB,QX)

!  MA = MA / MB

!  This routine performs the trace printing for division.  FMDIV2_R1 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIV_R1'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMDIV2_R1(MA,MB,QX)

          QX%NAMEST(QX%NCALL) = 'FMDIV_R1'
          CALL FMNTR(1,MA,MA,1,1,QX)
      ELSE
          CALL FMDIV2_R1(MA,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMDIV_R1

      SUBROUTINE FMDIV2_R1(MA,MB,QX)

!  Internal division routine.  MA = MA / MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(MULTI) :: MPMA,MPMB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MXY(2)

      QX%NDIGL = 0
      QX%NDIGN = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      KR_RETRY = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT,QX)
          IF (KRESLT /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMDIV_R1'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT,QX)
              CALL FMEQ(MXY(1),MA,QX)
              QX%JRSIGN = JRSSAV
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
      ELSE
          IF (MB%MP(3) == 0) THEN
              QX%NAMEST(QX%NCALL) = 'FMDIV_R1'
              CALL FMIM(0,MA,QX)
              QX%KFLAG = -4
              CALL FMWARN(QX)
              MA%MP(2) = QX%MUNKNO
              MA%MP(3) = 1
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
          IF (MA%MP(3) == 0) THEN
              CALL FMIM(0,MA,QX)
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
      ENDIF
      QX%KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > QX%NDIG+10) NGUARD = QX%NDIG + 10
      N1 = QX%NDIG + 1
      NG = QX%NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      MWA%MP(2) = MA%MP(2) - MB%MP(2) + 1

      IF (QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (QX%NDIGL /= QX%NDIG .OR. QX%MBASEL /= QX%MBASE .OR. QX%NGUARL /= NGUARD) THEN
              QX%MBASEL = QX%MBASE
              QX%NDIGL = QX%NDIG
              QX%NGUARL = NGUARD
              DO J = 2, 1000
                 MR = QX%MBASE*QX%MBASEL
                 IF (4*MR > MXBASE) THEN
                     QX%N21 = J - 1
                     QX%NDIG = (QX%NDIGL-1)/QX%N21 + 1
                     IF (QX%NDIG < 2) QX%NDIG = 2
                     QX%NGRDN = (QX%NDIGL+NGUARD-1)/QX%N21 + 2 - QX%NDIG
                     IF (QX%NGRDN < 1) QX%NGRDN = 1
                     EXIT
                 ENDIF
                 QX%MBASE = MR
              ENDDO
              QX%MBASEN = QX%MBASE
              QX%NDIGN = QX%NDIG
          ELSE
              QX%MBASE = QX%MBASEN
              QX%NDIG = QX%NDIGN
          ENDIF
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
          J = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRDN + 5
          QX%NDIG = J
          MPMA%MP(1) = MA%MP(1)
          MPMB%MP(1) = MB%MP(1)
          MPMA%MP(2) = 0
          MPMB%MP(2) = 0
          L = 2 - QX%N21
          DO J = 2, QX%NDIGL+2-QX%N21, QX%N21
             MT1 = MA%MP(J+1)
             MT2 = MB%MP(J+1)
             DO K = J+1, J+QX%N21-1
                MT1 = MT1*QX%MBASEL + MA%MP(K+1)
                MT2 = MT2*QX%MBASEL + MB%MP(K+1)
             ENDDO
             MPMA%MP(3+J/QX%N21) = MT1
             MPMB%MP(3+J/QX%N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/QX%N21, QX%NDIG+QX%NGRDN+2
             MPMA%MP(J+1) = 0
             MPMB%MP(J+1) = 0
          ENDDO
          IF (L+QX%N21 <= QX%NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+QX%N21, L+2*QX%N21-1
                 IF (J <= QX%NDIGL+1) THEN
                     MT1 = MT1*QX%MBASEL + MA%MP(J+1)
                     MT2 = MT2*QX%MBASEL + MB%MP(J+1)
                 ELSE
                     MT1 = MT1*QX%MBASEL
                     MT2 = MT2*QX%MBASEL
                 ENDIF
              ENDDO
              MPMA%MP(3+(L+QX%N21)/QX%N21) = MT1
              MPMB%MP(3+(L+QX%N21)/QX%N21) = MT2
          ENDIF
          NG = QX%NDIG + QX%NGRDN + 1
          IF (MPMA%MP(3) >= MPMB%MP(3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, QX%NDIG+1
             MWA%MP(J+2) = MPMA%MP(J+1)
          ENDDO
          MWA%MP(3) = 0
          DO J = QX%NDIG+3, NG+4
             MWA%MP(J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG,MWA,QX)
          IF (MWA%MP(3) >= QX%MBASEL) THEN
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 MWA%MP(J+1) = MWA%MP(J)
              ENDDO
              MWA%MP(3) = 0
              MWA%MP(2) = MWA%MP(2) + 1
          ENDIF
          KT3 = QX%N21 - 1
          IF (QX%MBASEL == 2 .AND. QX%MBASE < INTMAX) THEN
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 KT1 = MWA%MP(J+1)
                 KT = 2 + (J-2)*QX%N21
                 KT2 = QX%N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2+KT3)
                    MWA%MP(K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = QX%MBASEL**(QX%N21-1)
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 MR = MS
                 MT1 = MWA%MP(J+1)
                 DO K = 2+(J-2)*QX%N21, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2+KT3)
                    MWA%MP(K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWA%MP(K-KT3+1)*MR
                    MR = AINT (MR/QX%MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          QX%NDIG = QX%NDIGL
          QX%MBASE = QX%MBASEL
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWA%MP(J+2) = MA%MP(J+1)
          ENDDO
          MWA%MP(3) = 0
          NL = N1 + NGUARD + 3
          DO J = QX%NDIG+3, NL
             MWA%MP(J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG,MWA,QX)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWA%MP(3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (QX%NCALL >= 1 .AND. NGUARD < QX%NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWA%MP(J+QX%NDIG+3)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWA%MP(QX%NDIG+4) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+2) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+2) = MWA%MP(N1+2) + 1
                      MWA%MP(N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
              ENDIF
          ENDIF
      ELSE
          IF (QX%NCALL >= 1 .AND. NGUARD < QX%NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWA%MP(J+QX%NDIG+2)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWA%MP(QX%NDIG+3) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                      MWA%MP(N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIV_R1'
          CALL FMWARN(QX)
      ENDIF

      MA%MP(1) = 1
      IF (MAS*MBS < 0 .AND. MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0)  &
          MA%MP(1) = -1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMDIV2_R1

      SUBROUTINE FMDIV_R2(MA,MB,QX)

!  MB = MA / MB

!  This routine performs the trace printing for division.  FMDIV2_R2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIV_R2'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMDIV2_R2(MA,MB,QX)

          QX%NAMEST(QX%NCALL) = 'FMDIV_R2'
          CALL FMNTR(1,MB,MB,1,1,QX)
      ELSE
          CALL FMDIV2_R2(MA,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMDIV_R2

      SUBROUTINE FMDIV2_R2(MA,MB,QX)

!  Internal division routine.  MB = MA / MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(MULTI) :: MPMA,MPMB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TYPE(MULTI) :: MXY(2)

      QX%NDIGL = 0
      QX%NDIGN = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      KR_RETRY = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT,QX)
          IF (KRESLT /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMDIV_R2'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT,QX)
              CALL FMEQ(MXY(1),MB,QX)
              QX%JRSIGN = JRSSAV
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
      ELSE
          IF (MB%MP(3) == 0) THEN
              QX%NAMEST(QX%NCALL) = 'FMDIV_R2'
              CALL FMIM(0,MB,QX)
              QX%KFLAG = -4
              CALL FMWARN(QX)
              MB%MP(2) = QX%MUNKNO
              MB%MP(3) = 1
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
          IF (MA%MP(3) == 0) THEN
              CALL FMIM(0,MB,QX)
              QX%JRSIGN = JRSSAV
              RETURN
          ENDIF
      ENDIF
      QX%KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > QX%NDIG+10) NGUARD = QX%NDIG + 10
      N1 = QX%NDIG + 1
      NG = QX%NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      MWA%MP(2) = MA%MP(2) - MB%MP(2) + 1

      IF (QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (QX%NDIGL /= QX%NDIG .OR. QX%MBASEL /= QX%MBASE .OR. QX%NGUARL /= NGUARD) THEN
              QX%MBASEL = QX%MBASE
              QX%NDIGL = QX%NDIG
              QX%NGUARL = NGUARD
              DO J = 2, 1000
                 MR = QX%MBASE*QX%MBASEL
                 IF (4*MR > MXBASE) THEN
                     QX%N21 = J - 1
                     QX%NDIG = (QX%NDIGL-1)/QX%N21 + 1
                     IF (QX%NDIG < 2) QX%NDIG = 2
                     QX%NGRDN = (QX%NDIGL+NGUARD-1)/QX%N21 + 2 - QX%NDIG
                     IF (QX%NGRDN < 1) QX%NGRDN = 1
                     EXIT
                 ENDIF
                 QX%MBASE = MR
              ENDDO
              QX%MBASEN = QX%MBASE
              QX%NDIGN = QX%NDIG
          ELSE
              QX%MBASE = QX%MBASEN
              QX%NDIG = QX%NDIGN
          ENDIF
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
          J = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRDN + 5
          QX%NDIG = J
          MPMA%MP(1) = MA%MP(1)
          MPMB%MP(1) = MB%MP(1)
          MPMA%MP(2) = 0
          MPMB%MP(2) = 0
          L = 2 - QX%N21
          DO J = 2, QX%NDIGL+2-QX%N21, QX%N21
             MT1 = MA%MP(J+1)
             MT2 = MB%MP(J+1)
             DO K = J+1, J+QX%N21-1
                MT1 = MT1*QX%MBASEL + MA%MP(K+1)
                MT2 = MT2*QX%MBASEL + MB%MP(K+1)
             ENDDO
             MPMA%MP(3+J/QX%N21) = MT1
             MPMB%MP(3+J/QX%N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/QX%N21, QX%NDIG+QX%NGRDN+2
             MPMA%MP(J+1) = 0
             MPMB%MP(J+1) = 0
          ENDDO
          IF (L+QX%N21 <= QX%NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+QX%N21, L+2*QX%N21-1
                 IF (J <= QX%NDIGL+1) THEN
                     MT1 = MT1*QX%MBASEL + MA%MP(J+1)
                     MT2 = MT2*QX%MBASEL + MB%MP(J+1)
                 ELSE
                     MT1 = MT1*QX%MBASEL
                     MT2 = MT2*QX%MBASEL
                 ENDIF
              ENDDO
              MPMA%MP(3+(L+QX%N21)/QX%N21) = MT1
              MPMB%MP(3+(L+QX%N21)/QX%N21) = MT2
          ENDIF
          NG = QX%NDIG + QX%NGRDN + 1
          IF (MPMA%MP(3) >= MPMB%MP(3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, QX%NDIG+1
             MWA%MP(J+2) = MPMA%MP(J+1)
          ENDDO
          MWA%MP(3) = 0
          DO J = QX%NDIG+3, NG+4
             MWA%MP(J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG,MWA,QX)
          IF (MWA%MP(3) >= QX%MBASEL) THEN
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 MWA%MP(J+1) = MWA%MP(J)
              ENDDO
              MWA%MP(3) = 0
              MWA%MP(2) = MWA%MP(2) + 1
          ENDIF
          KT3 = QX%N21 - 1
          IF (QX%MBASEL == 2 .AND. QX%MBASE < INTMAX) THEN
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 KT1 = MWA%MP(J+1)
                 KT = 2 + (J-2)*QX%N21
                 KT2 = QX%N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2+KT3)
                    MWA%MP(K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = QX%MBASEL**(QX%N21-1)
              DO J = 2+QX%NDIG+QX%NGRDN, 3, -1
                 MR = MS
                 MT1 = MWA%MP(J+1)
                 DO K = 2+(J-2)*QX%N21, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2+KT3)
                    MWA%MP(K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWA%MP(K-KT3+1)*MR
                    MR = AINT (MR/QX%MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          QX%NDIG = QX%NDIGL
          QX%MBASE = QX%MBASEL
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWA%MP(J+2) = MA%MP(J+1)
          ENDDO
          MWA%MP(3) = 0
          NL = N1 + NGUARD + 3
          DO J = QX%NDIG+3, NL
             MWA%MP(J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG,MWA,QX)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWA%MP(3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (QX%NCALL >= 1 .AND. NGUARD < QX%NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWA%MP(J+QX%NDIG+3)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWA%MP(QX%NDIG+4) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+2) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+2) = MWA%MP(N1+2) + 1
                      MWA%MP(N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
              ENDIF
          ENDIF
      ELSE
          IF (QX%NCALL >= 1 .AND. NGUARD < QX%NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWA%MP(J+QX%NDIG+2)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWA%MP(QX%NDIG+3) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                      MWA%MP(N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIV_R2'
          CALL FMWARN(QX)
      ENDIF

      MB%MP(1) = 1
      IF (MAS*MBS < 0 .AND. MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0)  &
          MB%MP(1) = -1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMDIV2_R2

      SUBROUTINE FMDIV3(MB,NG,MWA,QX)

!  Internal division routine.  Divide MA/MB and return the quotient in MWA.
!  MA has already been copied into MWA.
!  NG is the number of guard digits used.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: XB,XBR,XBASE,XMWA
      REAL (KIND(1.0D0)) :: MAXMWA,MBP1,MCARRY,MKT,MLMAX,MQD
      INTEGER :: J,JB,JL,KA,KB,KL,KPTMWA,N1,NG,NL,NMBWDS,NMETHD,NZDMB
      REAL :: C
      INTENT (IN) :: MB

      N1 = QX%NDIG + 1
      NL = NG + 4

!             Check for using an FFT-based method if precision is very high.

      C = 3100
      IF (QX%NDIG >= C) THEN
          NZDMB = 0
          DO J = 2, QX%NDIG
             IF (MB%MP(J+2) == 0) NZDMB = NZDMB + 1
          ENDDO
          IF (QX%NDIG-NZDMB < 50 .OR. REAL(NZDMB)/QX%NDIG > 0.8 ) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMDIVFFT(MB,MWA,QX)
          RETURN
      ENDIF

!             NMBWDS is the number of words of MB used to compute the estimated quotient digit MQD.

      NMBWDS = 4
      IF (QX%MBASE < 100) NMBWDS = 7

!             XB is an approximation of MB used in estimating the quotient digits.

      XBASE = DBLE(QX%MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= N1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MB%MP(J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= N1) THEN
                 XB = XB*XBASE + DBLE(MB%MP(J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= N1) THEN
          XB = XB + DBLE(MB%MP(JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = QX%MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - QX%MBASE
      MLMAX = MIN(MLMAX,MKT)

!             Count the trailing zero digits of MB.

      DO J = N1, 2, -1
         IF (MB%MP(J+1) /= 0) THEN
             NZDMB = N1 - J
             GO TO 110
         ENDIF
      ENDDO

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.  It is used
!             to determine whether normalization can be postponed.

  110 MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  120 KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWA%MP(KPTMWA+1))*XBASE + DBLE(MWA%MP(KPTMWA+2)))*XBASE  &
                 + DBLE(MWA%MP(KPTMWA+3)))*XBASE + DBLE(MWA%MP(KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWA%MP(KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = MIN(KA+QX%NDIG-1-NZDMB,NL)
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWA%MP(J+1) < 0) THEN
                 MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
                 MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MB from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          DO J = KA+1, KB+1
             MWA%MP(J) = MWA%MP(J) - MQD*MB%MP(J-JB)
          ENDDO
      ENDIF

      MWA%MP(KA+1) = MWA%MP(KA+1) + MWA%MP(KA)*QX%MBASE
      MWA%MP(KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA <= NG) GO TO 120
      IF (MWA%MP(3) == 0 .AND. KPTMWA <= NG+1) GO TO 120

      KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWA%MP(KPTMWA+1))*XBASE + DBLE(MWA%MP(KPTMWA+2)))*XBASE  &
                 + DBLE(MWA%MP(KPTMWA+3)))*XBASE + DBLE(MWA%MP(KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWA%MP(KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF
      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1
      MWA%MP(KPTMWA+1) = MQD
      MWA%MP(KPTMWA+2) = 0
      MWA%MP(KPTMWA+3) = 0

!             Final normalization.

      IF (KPTMWA > 2*QX%NDIG) THEN
          DO J = 2*QX%NDIG+1, KPTMWA
             IF (MWA%MP(J+1) /= QX%MBASE-1) EXIT
             IF (J == KPTMWA) MWA%MP(J+1) = QX%MBASE
          ENDDO
      ENDIF
      DO J = KPTMWA, 3, -1
         IF (MWA%MP(J+1) < 0) THEN
             MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
             MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ENDIF
      ENDDO

      RETURN
      END SUBROUTINE FMDIV3

      SUBROUTINE FMDIVD(MA,MB,MC,MD,ME,QX)

!  Double division routine.  MD = MA / MC,   ME = MB / MC

!  It is usually slightly faster to do two divisions that have a common denominator with one call.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC,MD,ME
      TYPE(WORK_AREA) :: MWA,MWD
      TYPE(MULTI) :: MTD
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MA2P,MAS,MAXMWA,MB2P,MBP1,MBS,MC2P,MCARRY,MCS,  &
                            MKT,MLMAX,MLR,MQDMWA,MQDMWD,MTEMP
      DOUBLE PRECISION :: ERR,XB,XBR,XBASE,XMWA,XMWD
      REAL :: C
      INTEGER :: J,JB,JL,JRSSAV,KA,KB,KL,KOVUN,KPTMW,N1,NG,NGUARD,NL,NMBWDS,NZDMB
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD,ME


      QX%NCALL = QX%NCALL + 1
      JRSSAV = QX%JRSIGN
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVD'
          CALL FMNTR(2,MA,MB,2,1,QX)
          IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL FMNTRJ(MC,QX%NDIG,QX)
              ELSE
                  CALL FMPRNT(MC,QX)
              ENDIF
          ENDIF
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      C = 3100
      IF (QX%NDIG >= C .OR.                                              &
          ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR.  &
          ABS(MC%MP(2)) > QX%MEXPAB .OR. QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN .OR.  &
              MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN .OR.  &
              MC%MP(2) == QX%MEXPOV .OR. MC%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO .OR.  &
              MC%MP(2) == QX%MUNKNO) KOVUN = 2
          QX%NCALL = QX%NCALL + 1
          CALL FMDIV2(MA,MC,MTD,QX)
          KB = QX%KFLAG
          CALL FMDIV2(MB,MC,ME,QX)
          QX%NCALL = QX%NCALL - 1
          IF (((QX%KFLAG < 0 .OR. KB < 0) .AND. KOVUN == 0) .OR.  &
              ((QX%KFLAG == -4 .OR. KB == -4) .AND. KOVUN == 1)) THEN
              IF (QX%KFLAG == -4 .OR. KB == -4) THEN
                  QX%KFLAG = -4
              ELSE IF (QX%KFLAG == -5 .OR. KB == -5) THEN
                  QX%KFLAG = -5
              ELSE
                  QX%KFLAG = MIN(QX%KFLAG,KB)
              ENDIF
              QX%NAMEST(QX%NCALL) = 'FMDIVD'
              CALL FMWARN(QX)
          ENDIF
          CALL FMEQ(MTD,MD,QX)
          GO TO 150
      ENDIF
      IF (MC%MP(3) == 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVD'
          QX%KFLAG = -4
          CALL FMWARN(QX)
          CALL FMST2M('UNKNOWN',MD,QX)
          CALL FMST2M('UNKNOWN',ME,QX)
          GO TO 150
      ENDIF
      IF (MA%MP(3) == 0 .OR. MB%MP(3) == 0) THEN
          CALL FMDIV2(MA,MC,MTD,QX)
          CALL FMDIV2(MB,MC,ME,QX)
          CALL FMEQ(MTD,MD,QX)
          GO TO 150
      ENDIF
      QX%KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52 - 1
      ENDIF
      IF (NGUARD > QX%NDIG+10) NGUARD = QX%NDIG + 10
      MA2P = ABS(MA%MP(3))
      MB2P = ABS(MB%MP(3))
      MC2P = ABS(MC%MP(3))
      IF ((MC2P >= MA2P .OR. MC2P >= MB2P) .AND. NGUARD < 2) NGUARD = 2
      N1 = QX%NDIG + 1
      NG = QX%NDIG + NGUARD

!             Copy MA and MB into the working arrays.

      DO J = 3, N1
         MWA%MP(J+2) = MA%MP(J+1)
         MWD%MP(J+2) = MB%MP(J+1)
      ENDDO
      MWA%MP(2) = MA%MP(2) - MC%MP(2) + 1
      MWD%MP(2) = MB%MP(2) - MC%MP(2) + 1
      MWA%MP(3) = 0
      MWD%MP(3) = 0
      NL = N1 + NGUARD + 3
      DO J = QX%NDIG+3, NL
         MWA%MP(J+1) = 0
         MWD%MP(J+1) = 0
      ENDDO

!             Save the signs and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)
      MCS = MC%MP(1)
      MWA%MP(4) = MA%MP(3)
      MWD%MP(4) = MB%MP(3)

!             NMBWDS is the number of words used to compute the estimated quotient digits.

      NMBWDS = 4
      IF (QX%MBASE < 100) NMBWDS = 7

!             XB is an approximation of MC used in selecting estimated quotients.

      XBASE = DBLE(QX%MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= N1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MC%MP(J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= N1) THEN
                 XB = XB*XBASE + DBLE(MC%MP(J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= N1) XB = XB + DBLE(MC%MP(JL+2))/XBASE
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = QX%MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - QX%MBASE
      MLMAX = MIN(MLMAX,MKT)

!             Count the trailing zero digits of MC.

      DO J = N1, 2, -1
         IF (MC%MP(J+1) /= 0) THEN
             NZDMB = N1 - J
             GO TO 110
         ENDIF
      ENDDO

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.  It is used
!             to determine whether normalization can be postponed.

  110 MAXMWA = 0

!             KPTMW points to the next digit in the quotient.

      KPTMW = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in selecting estimated
!             quotients.

  120 KL = KPTMW + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWA%MP(KPTMW+1))*XBASE + DBLE(MWA%MP(KPTMW+2)))*XBASE  &
                 + DBLE(MWA%MP(KPTMW+3)))*XBASE + DBLE(MWA%MP(KPTMW+4))
          XMWD = ((DBLE(MWD%MP(KPTMW+1))*XBASE + DBLE(MWD%MP(KPTMW+2)))*XBASE  &
                 + DBLE(MWD%MP(KPTMW+3)))*XBASE + DBLE(MWD%MP(KPTMW+4))
          DO J = KPTMW+4, KL
             XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
             XMWD = XMWD*XBASE + DBLE(MWD%MP(J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWA%MP(KPTMW+1))
          XMWD = DBLE(MWD%MP(KPTMW+1))
          DO J = KPTMW+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
                 XMWD = XMWD*XBASE + DBLE(MWD%MP(J+1))
             ELSE
                 XMWA = XMWA*XBASE
                 XMWD = XMWD*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQDMWA and MQDMWD are the estimated quotient digits.

      MQDMWA = AINT(XMWA*XBR)
      IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
      MQDMWD = AINT(XMWD*XBR)
      IF (MQDMWD < 0) MQDMWD = MQDMWD - 1

      MAXMWA = MAXMWA + MAX(ABS(MQDMWA),ABS(MQDMWD))

!             See if MWA and MWD must be normalized.

      KA = KPTMW + 1
      KB = MIN(KA+QX%NDIG-1-NZDMB,NL)
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWA%MP(J+1) < 0) THEN
                 MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
                 MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ENDIF
             IF (MWD%MP(J+1) < 0) THEN
                 MCARRY = INT((-MWD%MP(J+1)-1)/QX%MBASE) + 1
                 MWD%MP(J+1) = MWD%MP(J+1) + MCARRY*QX%MBASE
                 MWD%MP(J) = MWD%MP(J) - MCARRY
             ELSE IF (MWD%MP(J+1) >= QX%MBASE) THEN
                 MCARRY = -INT(MWD%MP(J+1)/QX%MBASE)
                 MWD%MP(J+1) = MWD%MP(J+1) + MCARRY*QX%MBASE
                 MWD%MP(J) = MWD%MP(J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          XMWD = 0
          IF (KL <= NL) THEN
              DO J = KPTMW, KL
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
                 XMWD = XMWD*XBASE + DBLE(MWD%MP(J+1))
              ENDDO
          ELSE
              DO J = KPTMW, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
                     XMWD = XMWD*XBASE + DBLE(MWD%MP(J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                     XMWD = XMWD*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQDMWA = AINT(XMWA*XBR)
          IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
          MQDMWD = AINT(XMWD*XBR)
          IF (MQDMWD < 0) MQDMWD = MQDMWD - 1
          MAXMWA = MAX(ABS(MQDMWA),ABS(MQDMWD))
      ENDIF

!             Subtract MQDMWA*MC from MWA and MQDMWD*MC from MWD.

      JB = KA - 2

!             Major (Inner Loop)

      DO J = KA+1, KB+1
         MTEMP = MC%MP(J-JB)
         MWA%MP(J) = MWA%MP(J) - MQDMWA*MTEMP
         MWD%MP(J) = MWD%MP(J) - MQDMWD*MTEMP
      ENDDO

      MWA%MP(KA+1) = MWA%MP(KA+1) + MWA%MP(KA)*QX%MBASE
      MWD%MP(KA+1) = MWD%MP(KA+1) + MWD%MP(KA)*QX%MBASE
      MWA%MP(KPTMW+1) = MQDMWA
      MWD%MP(KPTMW+1) = MQDMWD

      KPTMW = KPTMW + 1
      IF (KPTMW <= NG) GO TO 120

      KL = KPTMW + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWA%MP(KPTMW+1))*XBASE + DBLE(MWA%MP(KPTMW+2)))*XBASE  &
                 + DBLE(MWA%MP(KPTMW+3)))*XBASE + DBLE(MWA%MP(KPTMW+4))
          XMWD = ((DBLE(MWD%MP(KPTMW+1))*XBASE + DBLE(MWD%MP(KPTMW+2)))*XBASE  &
                 + DBLE(MWD%MP(KPTMW+3)))*XBASE + DBLE(MWD%MP(KPTMW+4))
          DO J = KPTMW+4, KL
             XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
             XMWD = XMWD*XBASE + DBLE(MWD%MP(J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWA%MP(KPTMW+1))
          XMWD = DBLE(MWD%MP(KPTMW+1))
          DO J = KPTMW+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
                 XMWD = XMWD*XBASE + DBLE(MWD%MP(J+1))
             ELSE
                 XMWA = XMWA*XBASE
                 XMWD = XMWD*XBASE
             ENDIF
          ENDDO
      ENDIF
      MQDMWA = AINT(XMWA*XBR)
      IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
      MQDMWD = AINT(XMWD*XBR)
      IF (MQDMWD < 0) MQDMWD = MQDMWD - 1
      MWA%MP(KPTMW+1) = MQDMWA
      MWA%MP(KPTMW+2) = 0
      MWA%MP(KPTMW+3) = 0
      MWD%MP(KPTMW+1) = MQDMWD
      MWD%MP(KPTMW+2) = 0
      MWD%MP(KPTMW+3) = 0

!             Final normalization.

      DO J = KPTMW-1, 3, -1
         IF (MWA%MP(J+1) < 0) THEN
             MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
             MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ENDIF
         IF (MWD%MP(J+1) < 0) THEN
             MCARRY = INT((-MWD%MP(J+1)-1)/QX%MBASE) + 1
             MWD%MP(J+1) = MWD%MP(J+1) + MCARRY*QX%MBASE
             MWD%MP(J) = MWD%MP(J) - MCARRY
         ELSE IF (MWD%MP(J+1) >= QX%MBASE) THEN
             MCARRY = -INT(MWD%MP(J+1)/QX%MBASE)
             MWD%MP(J+1) = MWD%MP(J+1) + MCARRY*QX%MBASE
             MWD%MP(J) = MWD%MP(J) - MCARRY
         ENDIF
      ENDDO

!             Round, affix the sign, and return.

      IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (MWA%MP(3) == 0) THEN
          IF (QX%NCALL >= 1) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWA%MP(J+QX%NDIG+3)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MA,MC,MD,QX)
                  GO TO 130
              ENDIF
          ENDIF
          MLR = 2*MWA%MP(QX%NDIG+4) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+2) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+2) = MWA%MP(N1+2) + 1
                      MWA%MP(N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
              ENDIF
          ENDIF
      ELSE
          IF (QX%NCALL >= 1) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWA%MP(J+QX%NDIG+2)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MA,MC,MD,QX)
                  GO TO 130
              ENDIF
          ENDIF
          MLR = 2*MWA%MP(QX%NDIG+3) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                      MWA%MP(N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MD,QX)

  130 IF ((MBS > 0 .AND. MCS > 0) .OR. (MBS < 0 .AND. MCS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (MWD%MP(3) == 0) THEN
          IF (QX%NCALL >= 1) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWD%MP(J+QX%NDIG+3)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MB,MC,ME,QX)
                  GO TO 140
              ENDIF
          ENDIF
          MLR = 2*MWD%MP(QX%NDIG+4) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWD,QX%NDIG,NGUARD,1,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWD%MP(N1+2) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWD%MP(N1+2) = MWD%MP(N1+2) + 1
                      MWD%MP(N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWD,QX%NDIG,NGUARD,1,QX)
              ENDIF
          ENDIF
      ELSE
          IF (QX%NCALL >= 1) THEN
              KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWD%MP(J+QX%NDIG+2)) / QX%MBASE
              ENDDO
              IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MB,MC,ME,QX)
                  GO TO 140
              ENDIF
          ENDIF
          MLR = 2*MWD%MP(QX%NDIG+3) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWD,QX%NDIG,NGUARD,0,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWD%MP(N1+1) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWD%MP(N1+1) = MWD%MP(N1+1) + 1
                      MWD%MP(N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWD,QX%NDIG,NGUARD,0,QX)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,ME,QX)

  140 IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVD'
          CALL FMWARN(QX)
      ENDIF

      MD%MP(1) = 1
      IF (MAS*MCS < 0 .AND. MD%MP(2) /= QX%MUNKNO .AND. MD%MP(3) /= 0)  &
          MD%MP(1) = -1
      ME%MP(1) = 1
      IF (MBS*MCS < 0 .AND. ME%MP(2) /= QX%MUNKNO .AND. ME%MP(3) /= 0)  &
          ME%MP(1) = -1

  150 IF (QX%NTRACE /= 0) THEN
          CALL FMNTR(1,MD,MD,1,1,QX)
          IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL FMNTRJ(ME,QX%NDIG,QX)
              ELSE
                  CALL FMPRNT(ME,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMDIVD

      SUBROUTINE FMDIVFFT(MB,MWA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

!  Internal division routine MA/MB for very high precision.
!  MA has already been moved to MWA before this routine is called.
!  Fast Fourier transforms are used, and the number of digits carried is usually
!  raised slightly, because the FFT is faster when N has only small prime factors.

      TYPE(MULTI) :: MB
      TYPE(WORK_AREA) :: MWA
      INTENT (IN) :: MB
      DOUBLE PRECISION :: XB
      REAL (KIND(1.0D0)) :: MWA1
      INTEGER :: J,K,KST,ND2,NDSAVE,NSTACK(49)
      TYPE(MULTI) :: MXY(10)
      TYPE(FM_SETTINGS) :: QX

      NDSAVE = QX%NDIG

!             Save low precision copies of the numerator and denominator.

      QX%NDIG = 20
      CALL FMIM(1,MXY(7),QX)
      DO J = 1, SIZE(MXY(7)%MP)-3
         MXY(7)%MP(J+2) = MWA%MP(J+3)
      ENDDO
      MXY(7)%MP(2) = MWA%MP(2) + MB%MP(2) - 1
      CALL FMEQU(MB,MXY(8),NDSAVE,20,QX)
      QX%NDIG = NDSAVE

!             Use Newton iteration and the routine FMMPYFFT, with the formula
!                 x = x + x*(1 - b*x)
!             to converge to 1/b.

      K = MAX(QX%NGRD52-1,2)
      QX%NDIG = MAX(QX%NDIG+K,2)

!             Generate the first approximation.

      CALL FMIM(1,MXY(1),QX)
      DO J = 1, NDSAVE
         MXY(1)%MP(J+2) = MWA%MP(J+3)
      ENDDO
      CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
      MXY(1)%MP(2) = 0
      MXY(2)%MP(1) = 1
      MXY(2)%MP(2) = 0
      KST = MWA%MP(2)

!             FMADD2 will negate MXY(2) and add.

      QX%KSUB = 1
      CALL FMADD2(MXY(1),MXY(2),MXY(3),QX)
      QX%KSUB = 0
      IF (MXY(3)%MP(1) >= 0) THEN
          MWA1 = KST
      ELSE
          MWA1 = KST - 1
      ENDIF
      CALL FMMD(MXY(2),XB,QX)
      XB = 1.0D0/XB
      CALL FMDM(XB,MXY(3),QX)

!             Initialize.

      CALL FMIM(0,MXY(4),QX)
      CALL FMIM(0,MXY(5),QX)
      CALL FMIM(1,MXY(6),QX)
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration.

      DO J = 1, KST-1
         QX%NDIG = NSTACK(J)
         CALL FMMPY2(MXY(2),MXY(3),MXY(4),QX)
         QX%KSUB = 1
         CALL FMADD2_R2(MXY(6),MXY(4),QX)
         QX%KSUB = 0
         QX%NDIG = NSTACK(MAX(1,J-1))
         CALL FMMPY2(MXY(3),MXY(4),MXY(5),QX)
         QX%NDIG = NSTACK(J)
         CALL FMADD2_R1(MXY(3),MXY(5),QX)
      ENDDO

!             Karp's trick:
!             The standard last step would give 1/b and then a final full precision
!             multiply by a would be done.  That does 2 full mpy's at the final precision,
!             and one at next-to-last (1/2 of final) precision.

!             Instead combine the a* step into the last iteration and get
!             y = a*x   at 1/2 precision, then
!             y = y + x*(a - b*y)
!             where the x* mpy is at 1/2 precision and only b*y is at final precision.

      QX%NDIG = NSTACK(MAX(1,KST-1))
      CALL FMMPY2(MXY(1),MXY(3),MXY(4),QX)
      QX%NDIG = NSTACK(KST)
      CALL FMMPY2(MXY(2),MXY(4),MXY(5),QX)
      QX%KSUB = 1
      CALL FMADD2(MXY(1),MXY(5),MXY(6),QX)
      QX%KSUB = 0
      QX%NDIG = NSTACK(MAX(1,KST-1))
      CALL FMMPY2(MXY(3),MXY(6),MXY(5),QX)
      QX%NDIG = NSTACK(KST)
      CALL FMADD2(MXY(4),MXY(5),MXY(6),QX)

      MXY(6)%MP(2) = MWA1

!             Because of rounding errors in the Newton iteration, if the quotient is very close
!             to a power of MBASE the exponent of the result might be off by one.
!             Check by doing low precision multiplications.

      ND2 = QX%NDIG
      MXY(7)%MP(1) = -1
      MXY(8)%MP(1) = 1
      CALL FMEQU(MXY(6),MXY(4),NDSAVE,20,QX)
      MXY(4)%MP(1) = 1
      QX%NDIG = 20
      CALL FMMPY2(MXY(8),MXY(4),MXY(5),QX)
      CALL FMADD2(MXY(5),MXY(7),MXY(9),QX)
      MXY(9)%MP(1) = 1
      MXY(4)%MP(2) = MXY(4)%MP(2) + 1
      CALL FMMPY2(MXY(8),MXY(4),MXY(5),QX)
      CALL FMADD2(MXY(5),MXY(7),MXY(10),QX)
      IF (MXY(10)%MP(3) /= 0) MXY(10)%MP(1) = -1
      CALL FMADD2(MXY(10),MXY(9),MXY(5),QX)
      IF (MXY(5)%MP(1) == 1) THEN
          CALL FMEQ(MXY(10),MXY(9),QX)
          MXY(6)%MP(2) = MXY(6)%MP(2) + 1
      ENDIF
      MXY(4)%MP(2) = MXY(4)%MP(2) - 2
      CALL FMMPY2(MXY(8),MXY(4),MXY(5),QX)
      CALL FMADD2(MXY(5),MXY(7),MXY(10),QX)
      IF (MXY(10)%MP(3) /= 0) MXY(10)%MP(1) = -1
      CALL FMADD2(MXY(10),MXY(9),MXY(5),QX)
      IF (MXY(5)%MP(1) == 1) THEN
          MXY(6)%MP(2) = MXY(6)%MP(2) - 1
      ENDIF
      QX%NDIG = ND2

      DO J = 1, QX%NDIG+2
         MWA%MP(J) = MXY(6)%MP(J)
      ENDDO
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE FMDIVFFT

      SUBROUTINE FMDIVI(MA,IVAL,MB,QX)

!  MB = MA / IVAL

!  Divide FM number MA by one word integer IVAL.

!  This routine is faster than FMDIV when the divisor is less than MXBASE (the square root of the
!  largest integer).
!  When IVAL is not less than MXBASE, FMDIV2 is used.  In this case, if IVAL is known to be a
!  product of two integers less than MXBASE, it is usually faster to make two calls to FMDIVI
!  with half-word factors than one call with their product.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVI'
          CALL FMNTR(2,MA,MA,1,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)
          CALL FMDIVN(MA,IVAL,MB,QX)
          CALL FMNTR(1,MB,MB,1,1,QX)
      ELSE
          CALL FMDIVN(MA,IVAL,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMDIVI

      SUBROUTINE FMDIVI_R1(MA,IVAL,QX)

!  MA = MA / IVAL

!  Divide FM number MA by one word integer IVAL.

!  This routine is faster than FMDIV when the divisor is less than MXBASE (the square root of the
!  largest integer).
!  When IVAL is not less than MXBASE, FMDIV2 is used.  In this case, if IVAL is known to be a
!  product of two integers less than MXBASE, it is usually faster to make two calls to FMDIVI
!  with half-word factors than one call with their product.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVI_R1'
          CALL FMNTR(2,MA,MA,1,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)
          CALL FMDIVN_R1(MA,IVAL,QX)
          CALL FMNTR(1,MA,MA,1,1,QX)
      ELSE
          CALL FMDIVN_R1(MA,IVAL,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMDIVI_R1

      SUBROUTINE FMDIVN(MA,IVAL,MB,QX)

!  Internal divide by integer routine.  MB = MA / IVAL

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MA1,MAS,MKT,MLR,MODINT,MVALP
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,KA,KB,KL,KPT,KPTWA,KR_RETRY,N1,NGUARD,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      KR_RETRY = 0

!             Check for special cases.

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      N1 = QX%NDIG + 1
      IF (MA%MP(2) == QX%MUNKNO .OR. IVAL == 0) THEN
          MA1 = MA%MP(2)
          CALL FMIM(0,MB,QX)
          MB%MP(2) = QX%MUNKNO
          MB%MP(3) = 1
          QX%KFLAG = -4
          IF (MA1 /= QX%MUNKNO) THEN
              QX%NAMEST(QX%NCALL) = 'FMDIVI'
              CALL FMWARN(QX)
          ENDIF
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(3) == 0) THEN
          CALL FMEQ(MA,MB,QX)
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (ABS(MA%MP(2)) < QX%MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (ABS(IVAL) == 1) THEN
          DO J = 0, N1
             MB%MP(J+1) = MA%MP(J+1)
          ENDDO
          MB%MP(1) = MA%MP(1)*IVAL
          IF (MA%MP(2) == QX%MEXPOV) QX%KFLAG = -5
          IF (MA%MP(2) == QX%MEXPUN) QX%KFLAG = -6
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPUN) THEN
          MAS = MA%MP(1)
          CALL FMIM(0,MB,QX)
          MB%MP(2) = QX%MEXPUN
          MB%MP(3) = 1
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MB%MP(1) = -1
          QX%KFLAG = -6
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPOV) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVI'
          CALL FMIM(0,MB,QX)
          MB%MP(2) = QX%MUNKNO
          MB%MP(3) = 1
          QX%KFLAG = -4
          CALL FMWARN(QX)
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
      ELSE
          NGUARD = QX%NGRD52
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > QX%NDIG+10) NGUARD = QX%NDIG + 10

!             If ABS(IVAL) >= MXBASE use FMDIV.

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1),QX)
          CALL FMDIV2(MA,MXY(1),MB,QX)
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

!             Work with positive numbers.

      MAS = MA%MP(1)

!             Find the first significant digit of the quotient.

      MKT = MA%MP(3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*QX%MBASE + MA%MP(J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO
      KPT = N1

  120 KPT = KPT + 1
      MKT = MKT*QX%MBASE
      IF (MKT < MVALP) GO TO 120

!             Do the rest of the division.

  130 KA = KPT + 1
      MWA%MP(2) = MA%MP(2) + 2 - KPT
      MWA%MP(3) = INT (MKT/MVALP)
      MODINT = MKT - MWA%MP(3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          DO J = KA+1, N1+1
             MKT = MODINT*QX%MBASE + MA%MP(J)
             MWA%MP(J+KL) = INT (MKT/MVALP)
             MODINT = MKT - MWA%MP(J+KL)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1 + NGUARD
      DO J = KA, KB
         MKT = MODINT*QX%MBASE
         MWA%MP(J+1) = INT (MKT/MVALP)
         MODINT = MKT - MWA%MP(J+1)*MVALP
      ENDDO

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result, put the sign on MB and return.

      MLR = 2*MWA%MP(QX%NDIG+3) + 1
      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
      ELSE IF (MLR >= QX%MBASE) THEN
          IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                  MWA%MP(N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVI'
          CALL FMWARN(QX)
      ENDIF
      MB%MP(1) = QX%JRSIGN
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMDIVN

      SUBROUTINE FMDIVN_R1(MA,IVAL,QX)

!  Internal divide by integer routine.  MA = MA / IVAL

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(WORK_AREA) :: MWA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MA1,MAS,MKT,MLR,MODINT,MVALP
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,KA,KB,KL,KPT,KPTWA,KR_RETRY,N1,NGUARD,NMVAL,NV2
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      KR_RETRY = 0

!             Check for special cases.

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      N1 = QX%NDIG + 1
      IF (MA%MP(2) == QX%MUNKNO .OR. IVAL == 0) THEN
          MA1 = MA%MP(2)
          CALL FMIM(0,MA,QX)
          MA%MP(2) = QX%MUNKNO
          MA%MP(3) = 1
          QX%KFLAG = -4
          IF (MA1 /= QX%MUNKNO) THEN
              QX%NAMEST(QX%NCALL) = 'FMDIVI_R1'
              CALL FMWARN(QX)
          ENDIF
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(3) == 0) THEN
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (ABS(MA%MP(2)) < QX%MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (ABS(IVAL) == 1) THEN
          MA%MP(1) = MA%MP(1)*IVAL
          IF (MA%MP(2) == QX%MEXPOV) QX%KFLAG = -5
          IF (MA%MP(2) == QX%MEXPUN) QX%KFLAG = -6
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPUN) THEN
          MAS = MA%MP(1)
          CALL FMIM(0,MA,QX)
          MA%MP(2) = QX%MEXPUN
          MA%MP(3) = 1
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MA%MP(1) = -1
          QX%KFLAG = -6
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPOV) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVI_R1'
          CALL FMIM(0,MA,QX)
          MA%MP(2) = QX%MUNKNO
          MA%MP(3) = 1
          QX%KFLAG = -4
          CALL FMWARN(QX)
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD21
      ELSE
          NGUARD = QX%NGRD52
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > QX%NDIG+10) NGUARD = QX%NDIG + 10

!             If ABS(IVAL) >= MXBASE use FMDIV.

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1),QX)
          CALL FMDIV2_R1(MA,MXY(1),QX)
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

!             Work with positive numbers.

      MAS = MA%MP(1)

!             Find the first significant digit of the quotient.

      MKT = MA%MP(3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*QX%MBASE + MA%MP(J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO
      KPT = N1

  120 KPT = KPT + 1
      MKT = MKT*QX%MBASE
      IF (MKT < MVALP) GO TO 120

!             Do the rest of the division.

  130 KA = KPT + 1
      MWA%MP(2) = MA%MP(2) + 2 - KPT
      MWA%MP(3) = INT (MKT/MVALP)
      MODINT = MKT - MWA%MP(3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          DO J = KA+1, N1+1
             MKT = MODINT*QX%MBASE + MA%MP(J)
             MWA%MP(J+KL) = INT (MKT/MVALP)
             MODINT = MKT - MWA%MP(J+KL)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1 + NGUARD
      DO J = KA, KB
         MKT = MODINT*QX%MBASE
         MWA%MP(J+1) = INT (MKT/MVALP)
         MODINT = MKT - MWA%MP(J+1)*MVALP
      ENDDO

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result, put the sign on MA and return.

      MLR = 2*MWA%MP(QX%NDIG+3) + 1
      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
      ELSE IF (MLR >= QX%MBASE) THEN
          IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                  MWA%MP(N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,0,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMDIVI_R1'
          CALL FMWARN(QX)
      ENDIF
      MA%MP(1) = QX%JRSIGN
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMDIVN_R1

      SUBROUTINE FMDM(X,MA,QX)

!  Internal routine for converting double precision to multiple precision.  Called by FMDPM.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: ONE,XBASE,Y,Y2,YT
      REAL (KIND(1.0D0)) :: MK,MN
      INTEGER :: J,K,N1,NE
      INTENT (IN) :: X
      INTENT (INOUT) :: MA


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (X > HUGE(X) .OR. X < -HUGE(X) .OR. (.NOT.(X == X))) THEN
          DO J = 2, QX%NDIG
             MA%MP(J+2) = 0
          ENDDO
          QX%KFLAG = -4
          MA%MP(2) = QX%MUNKNO
          MA%MP(3) = 1
          MA%MP(1) = 1
          CALL FMWARN(QX)
          RETURN
      ENDIF

      ONE = 1.0D0
      XBASE = QX%MBASE
      K = 0

!             NE-1 is the number of words at the current precision and base roughly equal to
!             machine precision.

      NE = INT(QX%DLOGEB) + 3
      Y = X
      IF (X < 0.0) Y = -X

      IF (X == 0.0) THEN
          DO J = 1, N1
             MA%MP(J+1) = 0
          ENDDO
          GO TO 160
      ENDIF

!             Get the exponent.

      IF (Y > ONE) THEN
          IF (Y/XBASE < Y) THEN
  110         K = K + 1
              Y = Y/XBASE
              IF (Y > ONE) GO TO 110
              IF (Y < ONE) THEN
                  MA%MP(2) = K
                  GO TO 140
              ENDIF
              GO TO 130
          ELSE
              QX%KFLAG = -4
              CALL FMWARN(QX)
              DO J = 1, N1
                 MA%MP(J+1) = 0
              ENDDO
              MA%MP(2) = QX%MUNKNO
              MA%MP(3) = 1
              MA%MP(1) = 1
              RETURN
          ENDIF
      ENDIF

      IF (Y < ONE) THEN
          IF (Y*XBASE > Y) THEN
  120         K = K - 1
              Y = Y*XBASE
              IF (Y < ONE) GO TO 120
              IF (Y > ONE) THEN
                  K = K + 1
                  Y = Y/XBASE
                  MA%MP(2) = K
                  GO TO 140
              ENDIF
          ELSE
              QX%KFLAG = -4
              CALL FMWARN(QX)
              DO J = 1, N1
                 MA%MP(J+1) = 0
              ENDDO
              MA%MP(2) = QX%MUNKNO
              MA%MP(3) = 1
              MA%MP(1) = 1
              RETURN
          ENDIF
      ENDIF

  130 MA%MP(2) = K + 1
      MA%MP(3) = 1
      DO J = 3, N1
         MA%MP(J+1) = 0
      ENDDO
      GO TO 160

!             Build the rest of the number.

  140 DO J = 2, NE
         Y = Y*XBASE
         MK = AINT(Y)
         YT = -MK
         CALL FMDBL(Y,YT,Y2)
         Y = Y2
         MA%MP(J+1) = MK
         IF (J >= N1) GO TO 150
      ENDDO
      K = NE + 1
      DO J = K, N1
         MA%MP(J+1) = 0
      ENDDO

!             Normalize.

  150 IF (ABS(MA%MP(3)) >= QX%MBASE) THEN
          K = N1 + 1
          DO J = 3, N1
             K = K - 1
             MA%MP(K+1) = MA%MP(K)
          ENDDO
          MN = AINT (MA%MP(3)/QX%MBASE)
          MA%MP(4) = MA%MP(3) - MN*QX%MBASE
          MA%MP(3) = MN
          MA%MP(2) = MA%MP(2) + 1
          GO TO 160
      ENDIF

      IF (MA%MP(3) == 0) THEN
          DO J = 2, QX%NDIG
             MA%MP(J+1) = MA%MP(J+2)
          ENDDO
          MA%MP(2) = MA%MP(2) - 1
          MA%MP(N1+1) = 0
      ENDIF

  160 MA%MP(1) = 1
      IF (X < 0.0 .AND. MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0) MA%MP(1) = -1
      RETURN
      END SUBROUTINE FMDM

      SUBROUTINE FMDM2(X,MA,QX)

!  Internal routine for converting double precision to multiple precision.  Called by FMDP2M.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      TYPE(MULTI) :: MA
      DOUBLE PRECISION :: F1,F2,Y,Y1,Y2,TWO20
      INTEGER :: J,J1,J2,JD,JEXP,K,KEXP,L,NDSAVE
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX


!             Increase the working precision.

      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = MAX(QX%NGRD21,1)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0

!             Special case for X = 0.

      IF (X == 0.0D0) THEN
          DO J = 1, NDSAVE+1
             MA%MP(J+1) = 0
          ENDDO
          GO TO 140
      ENDIF

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (X > HUGE(X) .OR. X < -HUGE(X) .OR. (.NOT.(X == X))) THEN
          DO J = 2, NDSAVE
             MA%MP(J+2) = 0
          ENDDO
          QX%KFLAG = -4
          MA%MP(2) = QX%MUNKNO
          MA%MP(3) = 1
          MA%MP(1) = 1
          CALL FMWARN(QX)
          QX%NDIG = NDSAVE
          RETURN
      ENDIF

!             Special case for MBASE = 2.

      IF (QX%MBASE == 2 .AND. RADIX(X) == 2) THEN
          QX%NDIG = MAX(QX%NDIG,DIGITS(X))
          Y = FRACTION(ABS(X))
          CALL FMI2M(0,MXY(4),QX)
          DO J = 1, MIN(DIGITS(X),QX%NDIG)
             Y = Y + Y
             MXY(4)%MP(J+2) = INT(Y)
             Y = Y - INT(Y)
          ENDDO
          MXY(4)%MP(2) = EXPONENT(X)
          CALL FMEQU(MXY(4),MA,QX%NDIG,NDSAVE,QX)
          GO TO 140
      ENDIF

!             Special case for MBASE = 10**L.

      K = QX%MBASE
      L = 0
      DO
         IF (MOD(K,10) == 0) THEN
             L = L + 1
             K = K/10
             IF (K == 1) EXIT
         ELSE
             L = 0
             EXIT
         ENDIF
      ENDDO
      IF (L > 0) THEN
          QX%NDIG = MAX(QX%NDIG,INT(DIGITS(X)*0.30103/L)+1)
          Y = FRACTION(ABS(X))
          CALL FMI2M(0,MXY(4),QX)
          DO J = 1, QX%NDIG

!             Multiply by 10**L to get the next digit in base MBASE.
!             To avoid any rounding errors in double precision, do each multiply by 10 as
!             one multiply by 8 and one by 2, and keep two integer and two fraction results.
!             So 10*y is broken into 8*y + 2*y, since there will be no rounding with either
!             term in double precision on a binary machine.

             JD = 0
             DO K = 1, L
                Y1 = 8*Y
                Y2 = 2*Y
                J1 = Y1
                J2 = Y2
                F1 = Y1 - J1
                F2 = Y2 - J2
                JD = 10*JD + J1 + J2
                Y = F1 + F2
                IF (Y >= 1.0D0) THEN
                    JD = JD + 1
                    Y = Y - 1
                ENDIF
             ENDDO
             MXY(4)%MP(J+2) = JD
             IF (Y == 0) EXIT
          ENDDO
          K = INTMAX
          IF (MAXINT/QX%MBASE < K) K = MAXINT/QX%MBASE
          K = K/2
          J2 = 1
          JEXP = EXPONENT(X)
          DO J = 1, ABS(JEXP)
             J2 = 2*J2
             IF (J2 >= K .OR. J == ABS(JEXP)) THEN
                 IF (JEXP > 0) THEN
                     CALL FMMPYI_R1(MXY(4),J2,QX)
                 ELSE
                     CALL FMDIVI_R1(MXY(4),J2,QX)
                 ENDIF
                 J2 = 1
             ENDIF
          ENDDO
          CALL FMEQU(MXY(4),MA,QX%NDIG,NDSAVE,QX)
          GO TO 140
      ENDIF

      Y = ABS(X)
      TWO20 = 1048576.0D0

!             If this power of two is not representable at the current base and precision, use a
!             smaller one.

      IF (INT(QX%NDIG*QX%ALOGM2) < 20) THEN
          K = INT(QX%NDIG*QX%ALOGM2)
          TWO20 = 1.0D0
          DO J = 1, K
             TWO20 = TWO20*2.0D0
          ENDDO
      ENDIF

      KEXP = 0
      IF (Y > TWO20) THEN
  110     Y = Y/TWO20
          KEXP = KEXP + 1
          IF (Y > TWO20) GO TO 110
      ELSE IF (Y < 1.0D0) THEN
  120     Y = Y*TWO20
          KEXP = KEXP - 1
          IF (Y < 1.0D0) GO TO 120
      ENDIF

      K = INT(TWO20)
      CALL FMI2M(K,MXY(3),QX)
      K = INT(Y)
      CALL FMI2M(K,MXY(1),QX)
      Y = (Y-DBLE(K))*TWO20
      JEXP = 0

  130 K = INT(Y)
      CALL FMI2M(K,MXY(2),QX)
      CALL FMMPY_R1(MXY(1),MXY(3),QX)
      JEXP = JEXP + 1
      CALL FMADD_R1(MXY(1),MXY(2),QX)
      Y = (Y-DBLE(K))*TWO20
      IF (JEXP <= 1000 .AND. Y /= 0.0D0) GO TO 130

      K = KEXP - JEXP
      IF (K >= 0) THEN
          IF (K == 0) THEN
              CALL FMEQ(MXY(1),MXY(4),QX)
          ELSE IF (K == 1) THEN
              CALL FMMPY(MXY(1),MXY(3),MXY(4),QX)
          ELSE IF (K == 2) THEN
              CALL FMSQR(MXY(3),MXY(2),QX)
              CALL FMMPY(MXY(1),MXY(2),MXY(4),QX)
          ELSE
              CALL FMIPWR(MXY(3),K,MXY(2),QX)
              CALL FMMPY(MXY(1),MXY(2),MXY(4),QX)
          ENDIF
      ELSE
          IF (K == -1) THEN
              CALL FMDIV(MXY(1),MXY(3),MXY(4),QX)
          ELSE IF (K == -2) THEN
              CALL FMSQR(MXY(3),MXY(2),QX)
              CALL FMDIV(MXY(1),MXY(2),MXY(4),QX)
          ELSE
              CALL FMIPWR(MXY(3),-K,MXY(2),QX)
              CALL FMDIV(MXY(1),MXY(2),MXY(4),QX)
          ENDIF
      ENDIF
      CALL FMEQU(MXY(4),MA,QX%NDIG,NDSAVE,QX)

  140 MA%MP(1) = 1
      IF (X < 0.0 .AND. MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0) MA%MP(1) = -1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE FMDM2

      SUBROUTINE FMDP2M(X,MA,QX)

!  MA = X

!  Convert a double precision floating point number to FM format.

!  This version tries to convert the double precision machine number to FM with accuracy of nearly
!  full FM precision. If conversion to FM with approximately double precision accuracy is good
!  enough, FMDPM is faster and uses less scratch space.

!  This routine assumes the machine's base for double precision is a power of two.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      TYPE(MULTI) :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMDP2M'
      IF (QX%NTRACE /= 0) CALL FMNTRR(2,X,1,QX)

      CALL FMDM2(X,MA,QX)

      IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMDP2M

      SUBROUTINE FMDPM(X,MA,QX)

!  MA = X

!  Convert a double precision floating point number to FM format.

!  In general, the relative accuracy of the FM number returned is only the relative accuracy of a
!  machine precision number.  This may be true even if X can be represented exactly in the machine
!  floating point number system.

!  This version is faster than FMDP2M, but often less accurate.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: Y,YT
      INTEGER :: J,K
      INTENT (IN) :: X
      INTENT (INOUT) :: MA

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMDPM'
      IF (QX%NTRACE /= 0) CALL FMNTRR(2,X,1,QX)

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (X > HUGE(X) .OR. X < -HUGE(X) .OR. (.NOT.(X == X))) THEN
          DO J = 2, QX%NDIG
             MA%MP(J+2) = 0
          ENDDO
          QX%KFLAG = -4
          MA%MP(2) = QX%MUNKNO
          MA%MP(3) = 1
          MA%MP(1) = 1
          CALL FMWARN(QX)
          GO TO 110
      ENDIF

!             Check to see if X is exactly a small integer.  If so, converting as an integer is
!             better.  Also see if X is exactly a small integer divided by a small power of two.

      Y = 1048576.0D0
      IF (ABS(X) < Y) THEN
          K = INT(X)
          Y = K
          IF (Y == X) THEN
              CALL FMIM(K,MA,QX)
              GO TO 110
          ENDIF
      ENDIF
      IF (ABS(X) < 1.0D0) THEN
          Y = 4096.0D0*X
          K = INT(Y)
          YT = K
          IF (Y == YT) THEN
              CALL FMIM(K,MA,QX)
              CALL FMDIVI_R1(MA,4096,QX)
              GO TO 110
          ENDIF
      ENDIF

      CALL FMDM(X,MA,QX)

  110 IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMDPM

      SUBROUTINE FMENTR(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)

!  Do the argument checking and increasing of precision and overflow threshold upon entry to an
!  FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result
!           immediately (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow
!           or underflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KOVUN
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: K
      INTENT (IN) :: NROUTN,MA,MB,NARGS,KNAM
      INTENT (INOUT) :: MC,KRESLT,NDSAVE,MXSAVE,KOVUN
      TYPE(MULTI) :: MXY(2)


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = NROUTN
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM,QX)
      CALL FMARGS(NROUTN,NARGS,MA,MB,KRESLT,QX)

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      KOVUN = 0
      IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = MAX(QX%NGRD52-1,2)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          IF (KRESLT == 9 .OR. KRESLT == 10 .OR. KRESLT >= 13) THEN
              IF (QX%KRAD == 1) THEN
                  CALL FMPI(MXY(1),QX)
              ELSE
                  CALL FMI2M(180,MXY(1),QX)
              ENDIF
              IF (KRESLT <= 10) CALL FMDIVI_R1(MXY(1),2,QX)
              IF (KRESLT >= 14) CALL FMDIVI_R1(MXY(1),4,QX)
              IF ((KRESLT == 9 .OR. KRESLT == 14) .AND. MXY(1)%MP(2) /= QX%MUNKNO .AND.  &
                  MXY(1)%MP(3) /= 0) MXY(1)%MP(1) = -MXY(1)%MP(1)
              CALL FMEQU(MXY(1),MC,QX%NDIG,NDSAVE,QX)
              QX%NDIG = NDSAVE
              IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
              MXSAVE = QX%MXEXP
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF

          QX%NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT,QX)
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
          MXSAVE = QX%MXEXP
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF


!             Extend the overflow/underflow threshold.

      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      RETURN
      END SUBROUTINE FMENTR

      SUBROUTINE FMENTR2(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)

!  Do the argument checking and increasing of precision and overflow threshold upon entry to a
!  low-level FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result
!           immediately (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow
!           or underflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KOVUN
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: K
      INTENT (IN) :: NROUTN,MA,MB,NARGS,KNAM
      INTENT (INOUT) :: MC,KRESLT,NDSAVE,MXSAVE,KOVUN

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = NROUTN
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM,QX)
      CALL FMARGS(NROUTN,NARGS,MA,MB,KRESLT,QX)

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      KOVUN = 0
      IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = MAX(QX%NGRD52-1,2)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          QX%NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT,QX)
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
          MXSAVE = QX%MXEXP
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF


!             Extend the overflow/underflow threshold.

      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      RETURN
      END SUBROUTINE FMENTR2

      SUBROUTINE FMEQ(MA,MB,QX)

!  MB = MA

!  This is the standard form of equality, where MA and MB both have precision NDIG.
!  Use FMEQU for assignments that also change precision.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB


!             Copy MA to MB.

      DO J = 1, QX%NDIG+2
         MB%MP(J) = MA%MP(J)
      ENDDO

!             Check for overflow or underflow.

      IF (ABS(MB%MP(2)) > QX%MXEXP) THEN
          IF (MB%MP(2) /= QX%MUNKNO .OR. MB%MP(3) /= 1) THEN
              QX%NCALL = QX%NCALL + 1
              CALL FMTRAP(MB,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (MB%MP(2) == QX%MUNKNO) QX%KFLAG = -4
      ENDIF

      RETURN
      END SUBROUTINE FMEQ

      SUBROUTINE FMEQU(MA,MB,NDA,NDB,QX)

!  Set MB (having NDB digits) equal to MA (having NDA digits).

!  If MB has less precision than MA the result is rounded to NDB digits.

!  If MB has more precision the result has zero digits padded on the right.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NDA,NDB
      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: M2,MBS,MKT
      INTEGER :: J,K,KB,L,N1
      INTENT (IN) :: MA,NDA,NDB
      INTENT (INOUT) :: MB

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Check for precision in range.

      IF (NDA < 1 .OR. NDB < 1) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMEQU'
          QX%KFLAG = -1
          CALL FMWARN(QX)
          WRITE (KW,                                                     &
                 "(/' The two precisions in FMEQU were NDA =',I19,"  //  &
                  "' NDB =',I19/)"                                       &
                ) NDA,NDB
          DO J = 2, NDB
             MB%MP(J+2) = 0
          ENDDO
          QX%KFLAG = -1
          MB%MP(2) = QX%MUNKNO
          MB%MP(3) = 1
          MB%MP(1) = 1
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      MBS = MA%MP(1)
      MB%MP(1) = MBS

!             Check for special symbols.

      QX%KFLAG = 0
      IF (ABS(MA%MP(2)) >= QX%MEXPOV) THEN
          DO J = 2, NDB
             MB%MP(J+2) = 0
          ENDDO
          MB%MP(2) = MA%MP(2)
          MB%MP(3) = MA%MP(3)
          GO TO 150
      ENDIF

      IF (NDB == NDA) GO TO 130

      IF (NDB > NDA) GO TO 140

!             Round to NDB digits.

      N1 = NDB + 1
      DO J = 1, N1
         MB%MP(J+1) = MA%MP(J+1)
      ENDDO
      IF (QX%KROUND == -1 .AND. QX%NCALL <= 1) THEN
          IF (MA%MP(1) > 0) GO TO 150
          DO J = NDB+2, NDA+1
             IF (MA%MP(J+1) > 0) GO TO 110
          ENDDO
          GO TO 150
      ENDIF
      IF (QX%KROUND == 2 .AND. QX%NCALL <= 1) THEN
          IF (MA%MP(1) < 0) GO TO 150
          DO J = NDB+2, NDA+1
             IF (MA%MP(J+1) > 0) GO TO 110
          ENDDO
          GO TO 150
      ENDIF
      IF (QX%KROUND == 0 .AND. QX%NCALL <= 1) GO TO 150

      IF (INT(QX%MBASE-AINT (QX%MBASE/2)*2) /= 0) THEN
          M2 = AINT (QX%MBASE/2)
          DO J = NDB+2, NDA+1
             IF (MA%MP(J+1) /= M2) EXIT
             IF (J == NDA+1) GO TO 110
          ENDDO
      ENDIF
      L = NDB + 2
      IF (2*(MA%MP(L+1)+1) < QX%MBASE) GO TO 150
      M2 = 2
      IF (INT(QX%MBASE-AINT (QX%MBASE/M2)*M2) == 0) THEN
          IF (2*MA%MP(L+1) < QX%MBASE) GO TO 150
          IF (2*MA%MP(L+1) == QX%MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (MA%MP(J+2) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MB%MP(N1+1)-AINT (MB%MP(N1+1)/M2)*M2) == 0) GO TO 150
          ENDIF
      ELSE
          IF (2*MA%MP(L+1)+1 == QX%MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (2*(MA%MP(J+2)+1) < QX%MBASE) GO TO 150
                     IF (2*MA%MP(J+2) > QX%MBASE) GO TO 110
                  ENDDO
                  GO TO 150
              ENDIF
          ENDIF
      ENDIF

  110 MB%MP(NDB+2) = MB%MP(NDB+2) + 1

!             Check whether there was a carry in the rounded digit.

      KB = NDB + 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MB%MP(K+1) < QX%MBASE) GO TO 120
             MKT = AINT (MB%MP(K+1)/QX%MBASE)
             MB%MP(K) = MB%MP(K) + MKT
             MB%MP(K+1) = MB%MP(K+1) - MKT*QX%MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MB%MP(3) < QX%MBASE) GO TO 120
      IF (KB >= 4) THEN
          K = KB + 1
          DO J = 4, KB
             K = K - 1
             MB%MP(K+1) = MB%MP(K)
          ENDDO
      ENDIF

      MKT = AINT (MB%MP(3)/QX%MBASE)
      IF (KB >= 3) MB%MP(4) = MB%MP(3) - MKT*QX%MBASE
      MB%MP(3) = MKT
      MB%MP(2) = MB%MP(2) + 1

  120 IF (MBS < 0 .AND. MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0) MB%MP(1) = -1
      GO TO 150

!             MA and MB have the same precision.

  130 DO J = 1, NDA+1
         MB%MP(J+1) = MA%MP(J+1)
      ENDDO
      GO TO 150

!             Extend to NDB digits by padding with zeros.

  140 DO J = 1, NDA+1
         MB%MP(J+1) = MA%MP(J+1)
      ENDDO
      DO J = NDA+2, NDB+1
         MB%MP(J+1) = 0
      ENDDO

!             Check for overflow or underflow.

  150 IF (ABS(MB%MP(2)) > QX%MXEXP) THEN
          IF (MB%MP(2) /= QX%MUNKNO .OR. MB%MP(3) /= 1) THEN
              IF (MB%MP(2) > QX%MXEXP+1) THEN
                  IF (MB%MP(1) > 0) THEN
                      DO J = 2, NDB
                         MB%MP(J+2) = 0
                      ENDDO
                      MB%MP(2) = QX%MEXPOV
                      MB%MP(3) = 1
                      MB%MP(1) = 1
                  ELSE
                      DO J = 2, NDB
                         MB%MP(J+2) = 0
                      ENDDO
                      MB%MP(2) = QX%MEXPOV
                      MB%MP(3) = 1
                      MB%MP(1) = -1
                  ENDIF
                  QX%KFLAG = -5
              ENDIF
              IF (MB%MP(2) < -QX%MXEXP) THEN
                  IF (MB%MP(1) > 0) THEN
                      DO J = 2, NDB
                         MB%MP(J+2) = 0
                      ENDDO
                      MB%MP(2) = QX%MEXPUN
                      MB%MP(3) = 1
                      MB%MP(1) = 1
                  ELSE
                      DO J = 2, NDB
                         MB%MP(J+2) = 0
                      ENDDO
                      MB%MP(2) = QX%MEXPUN
                      MB%MP(3) = 1
                      MB%MP(1) = -1
                  ENDIF
                  QX%KFLAG = -6
              ENDIF
          ENDIF
          IF (MB%MP(2) == QX%MUNKNO) QX%KFLAG = -4
      ENDIF

      RETURN
      END SUBROUTINE FMEQU

      SUBROUTINE FMEQU_R1(MA,NDA,NDB,QX)

!  Change precision of MA from NDA digits on input to NDB digits on output.

!  If NDB is less than NDA the result is rounded to NDB digits.

!  If NDB is greater than NDA the result has zero digits padded on the right.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: NDA,NDB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: M2,MBS,MKT
      REAL (KIND(1.0D0)), DIMENSION(:), ALLOCATABLE :: MA_COPY
      INTEGER :: J,K,KB,L,N1
      INTENT (INOUT) :: MA
      INTENT (IN) :: NDA,NDB

      IF (SIZE(MA%MP) < NDB+2) THEN
          ALLOCATE(MA_COPY(NDA+2),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR
          ENDIF
          DO J = 1, NDA+2
             MA_COPY(J) = MA%MP(J)
          ENDDO
          DO J = 1, NDA+2
             MA%MP(J) = MA_COPY(J)
          ENDDO
          DEALLOCATE(MA_COPY)
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Check for precision in range.

      IF (NDA < 1 .OR. NDB < 1) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMEQU'
          QX%KFLAG = -1
          CALL FMWARN(QX)
          WRITE (KW,                                                     &
                 "(/' The two precisions in FMEQU were NDA =',I19,"  //  &
                  "' NDB =',I19/)"                                       &
                ) NDA,NDB
          DO J = 2, NDB
             MA%MP(J+2) = 0
          ENDDO
          QX%KFLAG = -1
          MA%MP(2) = QX%MUNKNO
          MA%MP(3) = 1
          MA%MP(1) = 1
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      MBS = MA%MP(1)

!             Check for special symbols.

      QX%KFLAG = 0
      IF (ABS(MA%MP(2)) >= QX%MEXPOV) THEN
          DO J = 2, NDB
             MA%MP(J+2) = 0
          ENDDO
          GO TO 140
      ENDIF

      IF (NDB == NDA) GO TO 140

      IF (NDB > NDA) GO TO 130

!             Round to NDB digits.

      N1 = NDB + 1
      IF (QX%KROUND == -1 .AND. QX%NCALL <= 1) THEN
          IF (MA%MP(1) > 0) GO TO 140
          DO J = NDB+2, NDA+1
             IF (MA%MP(J+1) > 0) GO TO 110
          ENDDO
          GO TO 140
      ENDIF
      IF (QX%KROUND == 2 .AND. QX%NCALL <= 1) THEN
          IF (MA%MP(1) < 0) GO TO 140
          DO J = NDB+2, NDA+1
             IF (MA%MP(J+1) > 0) GO TO 110
          ENDDO
          GO TO 140
      ENDIF
      IF (QX%KROUND == 0 .AND. QX%NCALL <= 1) GO TO 140

      IF (INT(QX%MBASE-AINT (QX%MBASE/2)*2) /= 0) THEN
          M2 = AINT (QX%MBASE/2)
          DO J = NDB+2, NDA+1
             IF (MA%MP(J+1) /= M2) EXIT
             IF (J == NDA+1) GO TO 110
          ENDDO
      ENDIF
      L = NDB + 2
      IF (2*(MA%MP(L+1)+1) < QX%MBASE) GO TO 140
      M2 = 2
      IF (INT(QX%MBASE-AINT (QX%MBASE/M2)*M2) == 0) THEN
          IF (2*MA%MP(L+1) < QX%MBASE) GO TO 140
          IF (2*MA%MP(L+1) == QX%MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (MA%MP(J+2) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MA%MP(N1+1)-AINT (MA%MP(N1+1)/M2)*M2) == 0) GO TO 140
          ENDIF
      ELSE
          IF (2*MA%MP(L+1)+1 == QX%MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (2*(MA%MP(J+2)+1) < QX%MBASE) GO TO 140
                     IF (2*MA%MP(J+2) > QX%MBASE) GO TO 110
                  ENDDO
                  GO TO 140
              ENDIF
          ENDIF
      ENDIF

  110 MA%MP(NDB+2) = MA%MP(NDB+2) + 1
      MA%MP(NDB+3) = 0

!             Check whether there was a carry in the rounded digit.

      KB = NDB + 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MA%MP(K+1) < QX%MBASE) GO TO 120
             MKT = AINT (MA%MP(K+1)/QX%MBASE)
             MA%MP(K) = MA%MP(K) + MKT
             MA%MP(K+1) = MA%MP(K+1) - MKT*QX%MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MA%MP(3) < QX%MBASE) GO TO 120
      IF (KB >= 4) THEN
          K = KB + 1
          DO J = 4, KB
             K = K - 1
             MA%MP(K+1) = MA%MP(K)
          ENDDO
      ENDIF

      MKT = AINT (MA%MP(3)/QX%MBASE)
      IF (KB >= 3) MA%MP(4) = MA%MP(3) - MKT*QX%MBASE
      MA%MP(3) = MKT
      MA%MP(2) = MA%MP(2) + 1

  120 IF (MBS < 0 .AND. MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0) MA%MP(1) = -1
      GO TO 140

!             Extend to NDB digits by padding with zeros.

  130 DO J = NDA+2, NDB+1
         MA%MP(J+1) = 0
      ENDDO

!             Check for overflow or underflow.

  140 IF (ABS(MA%MP(2)) > QX%MXEXP) THEN
          IF (MA%MP(2) /= QX%MUNKNO .OR. MA%MP(3) /= 1) THEN
              IF (MA%MP(2) > QX%MXEXP+1) THEN
                  IF (MA%MP(1) > 0) THEN
                      DO J = 2, NDB
                         MA%MP(J+2) = 0
                      ENDDO
                      MA%MP(2) = QX%MEXPOV
                      MA%MP(3) = 1
                      MA%MP(1) = 1
                  ELSE
                      DO J = 2, NDB
                         MA%MP(J+2) = 0
                      ENDDO
                      MA%MP(2) = QX%MEXPOV
                      MA%MP(3) = 1
                      MA%MP(1) = -1
                  ENDIF
                  QX%KFLAG = -5
              ENDIF
              IF (MA%MP(2) < -QX%MXEXP) THEN
                  IF (MA%MP(1) > 0) THEN
                      DO J = 2, NDB
                         MA%MP(J+2) = 0
                      ENDDO
                      MA%MP(2) = QX%MEXPUN
                      MA%MP(3) = 1
                      MA%MP(1) = 1
                  ELSE
                      DO J = 2, NDB
                         MA%MP(J+2) = 0
                      ENDDO
                      MA%MP(2) = QX%MEXPUN
                      MA%MP(3) = 1
                      MA%MP(1) = -1
                  ENDIF
                  QX%KFLAG = -6
              ENDIF
          ENDIF
          IF (MA%MP(2) == QX%MUNKNO) QX%KFLAG = -4
      ENDIF

      RETURN
      END SUBROUTINE FMEQU_R1

      SUBROUTINE FMEXIT(MT,MC,NDSAVE,MXSAVE,KOVUN,QX)

!  Upon exit from an FM routine the result MT (having precision NDIG) is rounded and returned in MC
!  (having precision NDSAVE).  The values of NDIG, MXEXP, and KACCSW are restored.  KOVUN is nonzero
!  if one of the routine's input arguments was overflow or underflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MT,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KOVUN
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT,NDSAVE,MXSAVE,KOVUN
      INTENT (INOUT) :: MC

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      QX%MXEXP = MXSAVE
      KFSAVE = QX%KFLAG
      CALL FMEQU(MT,MC,QX%NDIG,NDSAVE,QX)
      IF (QX%KFLAG /= -5 .AND. QX%KFLAG /= -6) QX%KFLAG = KFSAVE
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      IF ((MC%MP(2) == QX%MUNKNO .AND. QX%KFLAG /= -9)  &
         .OR. (MC%MP(2) == QX%MEXPUN .AND. KOVUN == 0)  &
         .OR. (MC%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) CALL FMWARN(QX)
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMEXIT

      SUBROUTINE FMEXP(MA,MB,QX)

!  MB = EXP(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MESAV
      CHARACTER(155) :: STRING
      REAL (KIND(1.0D0)) :: M1,MA1,MA2,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,K,KL,KOVUN,KR_RETRY,KRESLT,KT,KWRNSV,NDMB,NDSAVE,NDSV,NMETHD
      REAL :: XMA,XOV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGE = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMEXP'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMI2M(1,MXY(1),QX)
          CALL FMADD(MXY(1),MA,MB,QX)
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMEXP'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0) THEN
          CALL FMENTR('FMEXP    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMEXP'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      MA1 = MA%MP(2)
      MA2 = MA%MP(3)
      MAS = MA%MP(1)

      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)

!             Check for obvious underflow or overflow.
!             XOV is LN(LN(slightly above overflow))
!             XMA is LN(LN(EXP(MA))) approximately.

      XOV = LOG(1.01*REAL(QX%MXEXP)) + LOG(QX%ALOGMB)
      M1 = 1
      XMA = LOG(REAL(MAX(ABS(MA2),M1))) - QX%ALOGMB + REAL(MA1)*QX%ALOGMB

  120 IF (XMA >= XOV) THEN
          CALL FMIM(0,MXY(2),QX)
          IF (MAS > 0) THEN
              QX%KFLAG = -5
              CALL FMST2M('OVERFLOW',MXY(2),QX)
          ELSE
              QX%KFLAG = -6
              CALL FMST2M('UNDERFLOW',MXY(2),QX)
          ENDIF
          CALL FMEQU(MXY(2),MB,QX%NDIG,NDSAVE,QX)
          QX%NDIG = NDSAVE
          QX%MXEXP = MXSAVE
          CALL FMWARN(QX)
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

!             Split MA into integer and fraction parts.  Work with a positive argument.
!             MXY(1) = integer part of ABS(MA)
!             MXY(2) = fraction part of ABS(MA)

      MXY(2)%MP(1) = 1
      CALL FMINT(MXY(2),MXY(1),QX)
      CALL FMSUB_R1(MXY(2),MXY(1),QX)

!             If the integer part is not zero, use FMIPWR to compute E**(MXY(1)).  If MXY(1) is too
!             large to represent as a one word integer, the definition of MXEXP insures that
!             E**(MXY(1)) overflows or underflows.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(1),KT,QX)
      QX%KWARN = KWRNSV
      IF (QX%KFLAG /= 0) THEN
          XMA = XOV
          GO TO 120
      ENDIF
      IF (KT > 0) THEN

!             Compute IEXTRA, the number of extra digits required to get EXP(KT) correct to the
!             current precision.

          IEXTRA = INT(LOG(REAL(KT))/QX%ALOGMB + 0.5)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
          QX%NDIG = QX%NDIG + IEXTRA

          NDMB = INT(150.0*2.302585/QX%ALOGMB)
          IF (NDMB >= QX%NDIG) THEN
              STRING = '2.718281828459045235360287471352662497757247'//  &
              '09369995957496696762772407663035354759457138217852516'//  &
              '6427427466391932003059921817413596629043572900334295261'
              CALL FMST2M(STRING,MESAV,QX)
              QX%MBSE = QX%MBASE
              QX%NDIGE = QX%NDIG
              IF (ABS(MESAV%MP(2)) > 10) QX%NDIGE = 0
          ELSE
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2 + QX%NDIG/100
              CALL FMI2M(1,MESAV,QX)
              CALL FMEXP2(MESAV,MXY(4),QX)
              CALL FMEQ(MXY(4),MESAV,QX)
              QX%MBSE = QX%MBASE
              QX%NDIGE = QX%NDIG
              IF (ABS(MESAV%MP(2)) > 10) QX%NDIGE = 0
              QX%NDIG = NDSV
          ENDIF
      ENDIF

!             Now do the fraction part of MA and combine the results.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      NMETHD = 1
      IF (QX%NDIG > 50) NMETHD = 2
      IF (MXY(2)%MP(3) /= 0 .AND. KT > 0 .AND. NMETHD == 1) THEN
          CALL FMEXP2(MXY(2),MXY(4),QX)
          CALL FMIPWR(MESAV,KT,MXY(3),QX)
          CALL FMMPY(MXY(4),MXY(3),MXY(2),QX)
      ELSE IF (MXY(2)%MP(3) /= 0 .AND. KT == 0 .AND. NMETHD == 1) THEN
          CALL FMEXP2(MXY(2),MXY(4),QX)
          CALL FMEQ(MXY(4),MXY(2),QX)
      ELSE IF (MXY(2)%MP(3) /= 0 .AND. KT > 0 .AND. NMETHD == 2) THEN
          NDSV = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD21
          CALL FMEQU_R1(MXY(2),NDSV,QX%NDIG,QX)
          IF (MXY(2)%MP(2) >= 0) THEN
              CALL FMCSH2(MXY(2),MXY(4),QX)
              CALL FMSQR(MXY(4),MXY(3),QX)
              CALL FMI2M(-1,MXY(1),QX)
              CALL FMADD_R1(MXY(3),MXY(1),QX)
              CALL FMSQRT_R1(MXY(3),QX)
              CALL FMADD(MXY(4),MXY(3),MXY(2),QX)
          ELSE
              CALL FMSNH2(MXY(2),MXY(4),QX)
              CALL FMSQR(MXY(4),MXY(3),QX)
              CALL FMI2M(1,MXY(1),QX)
              CALL FMADD_R1(MXY(3),MXY(1),QX)
              CALL FMSQRT_R1(MXY(3),QX)
              CALL FMADD(MXY(4),MXY(3),MXY(2),QX)
          ENDIF
          QX%NDIG = NDSV
          CALL FMIPWR(MESAV,KT,MXY(3),QX)
          CALL FMMPY_R1(MXY(2),MXY(3),QX)
      ELSE IF (MXY(2)%MP(3) /= 0 .AND. KT == 0 .AND. NMETHD == 2) THEN
          NDSV = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD21
          CALL FMEQU_R1(MXY(2),NDSV,QX%NDIG,QX)
          IF (MXY(2)%MP(2) >= 0) THEN
              CALL FMCSH2(MXY(2),MXY(4),QX)
              CALL FMSQR(MXY(4),MXY(3),QX)
              CALL FMI2M(-1,MXY(1),QX)
              CALL FMADD_R1(MXY(3),MXY(1),QX)
              CALL FMSQRT_R1(MXY(3),QX)
              CALL FMADD(MXY(4),MXY(3),MXY(2),QX)
          ELSE
              CALL FMSNH2(MXY(2),MXY(4),QX)
              CALL FMSQR(MXY(4),MXY(3),QX)
              CALL FMI2M(1,MXY(1),QX)
              CALL FMADD_R1(MXY(3),MXY(1),QX)
              CALL FMSQRT_R1(MXY(3),QX)
              CALL FMADD(MXY(4),MXY(3),MXY(2),QX)
          ENDIF
          QX%NDIG = NDSV
      ELSE IF (MXY(2)%MP(3) == 0 .AND. KT > 0) THEN
          CALL FMIPWR(MESAV,KT,MXY(2),QX)
      ELSE
          CALL FMI2M(1,MXY(2),QX)
      ENDIF

!             Invert if MA was negative.

      IF (MAS < 0) THEN
          CALL FMI2M(1,MXY(1),QX)
          CALL FMDIV_R2(MXY(1),MXY(2),QX)
      ENDIF
      QX%KWARN = KWRNSV

!             Round the result and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMEXP

      SUBROUTINE FMEXP2(MA,MB,QX)

!  MB = EXP(MA)

!  Internal exponential routine (called with 0 < MA <= 1).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MAXV
      REAL (KIND(0.0D0)) :: X1,X2,X3,F1,F2,F3,PI
      INTEGER :: J,J2,K,K2,KEXP,KTWO,L,L2,N2,NBIG,NBOT,NDSAV1,NDSAVE,NTERM,NTOP
      REAL :: ALOG2,ALOGT,B,T,TJ,XN
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      NDSAVE = QX%NDIG
      IF (MA%MP(2) == 1) THEN

!             Here the special case EXP(1.0) is computed.

          T = QX%NDIG
          XN = T*QX%ALOGMB/LOG(T)
          K = INT(LOG(XN)/QX%ALOGMB)
          QX%NDIG = MAX(QX%NDIG+K,2)
          NDSAV1 = QX%NDIG

          IF (NDSAVE < 100) THEN

!             If precision is not very high, use the direct series  e = 1/0! + 1/1! + 1/2! + ...
!             Do as much of the work as possible using small integers to minimize the number of
!             FM calls.  Reduce NDIG while computing each term in the sum as the terms get smaller.

              CALL FMI2M(2,MXY(2),QX)
              CALL FMI2M(1,MXY(1),QX)
              J = 2
              NBIG = INT(MXBASE)

  110         NTOP = 1
              NBOT = J
  120         IF (NBOT > NBIG/(J+1)) GO TO 130
              J = J + 1
              NTOP = J*NTOP + 1
              NBOT = J*NBOT
              GO TO 120

  130         CALL FMCSDIVI_R1(MXY(1),NBOT,QX)
              IF (NTOP > 1) THEN
                  CALL FMCSMPYI(MXY(1),NTOP,MXY(3),QX)
                  QX%NDIG = NDSAV1
                  CALL FMADD_R1(MXY(2),MXY(3),QX)
                  QX%NDIG = NDSAV1 - INT(MXY(2)%MP(2)-MXY(3)%MP(2))
              ELSE
                  QX%NDIG = NDSAV1
                  CALL FMADD_R1(MXY(2),MXY(1),QX)
                  QX%NDIG = NDSAV1 - INT(MXY(2)%MP(2)-MXY(1)%MP(2))
              ENDIF
              IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
              IF (QX%KFLAG /= 1) THEN
                  J = J + 1
                  GO TO 110
              ENDIF
              QX%NDIG = NDSAVE
              QX%KFLAG = 0
              CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE,QX)
          ELSE

!             If precision is high, use the binary splitting method for summing the direct series.

!             Determine K, the number of terms to sum in the series for e.

              X1 = 1.184*QX%NDIG*QX%DLOGMB/LOG(QX%NDIG*QX%DLOGMB) + 1.95*QX%NDIG**0.777 + 10
              PI = ACOS(-1.0D0)
              F1 = QX%NDIG*QX%DLOGMB - (X1 + 0.5)*LOG(X1) + X1 - LOG(2.0*PI)/2 - 1/(12.0*X1)
              IF (F1 < 0) THEN
                  X2 = 0.9*X1
              ELSE
                  X2 = 1.1*X1
              ENDIF
              F2 = QX%NDIG*QX%DLOGMB - (X2 + 0.5)*LOG(X2) + X2 - LOG(2.0*PI)/2 - 1/(12.0*X2)
              DO J = 1, 5
                 X3 = X2 - F2*(X2 - X1)/(F2 - F1)
                 F3 = QX%NDIG*QX%DLOGMB - (X3 + 0.5)*LOG(X3) + X3 - LOG(2.0*PI)/2 - 1/(12.0*X3)
                 IF (ABS(X3-X2) < 0.1) EXIT
                 X1 = X2
                 F1 = F2
                 X2 = X3
                 F2 = F3
              ENDDO

              K = X3 + 10
              CALL FMEXP2_TQ(0,K,MXY(1),MXY(2),QX)
              IF (MXY(1)%MP(2) >= QX%NDIG .AND. MXY(2)%MP(2) >= QX%NDIG) THEN
                  CALL FMDIV_R2(MXY(1),MXY(2),QX)
                  QX%NDIG = NDSAVE
                  QX%KFLAG = 0
                  CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE,QX)
              ELSE
                  CALL IMI2FM(MXY(1),MXY(3),QX)
                  CALL IMI2FM(MXY(2),MXY(4),QX)
                  CALL FMDIV(MXY(3),MXY(4),MXY(2),QX)
                  QX%NDIG = NDSAVE
                  QX%KFLAG = 0
                  CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE,QX)
              ENDIF
          ENDIF
          RETURN
      ENDIF

!             Here is the general case.  Compute EXP(MA) where 0 < MA < 1.

!             Use the direct series
!                  EXP(X) = 1 + X + X**2/2! + X**3/3! + ...

!             The argument will be halved K2 times before the series is summed.  The series will be
!             added as J2 concurrent series.

      B = REAL(QX%MBASE)
      K = QX%NGRD52
      T = MAX(QX%NDIG-K,2)
      ALOG2 = REAL(QX%DLOGTW)
      ALOGT = LOG(T)
      TJ = 0.87*(QX%NDIG*QX%ALOGMT)**0.3333 - 1.3
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      K2 = MAX(2,INT(2.0*(QX%NDIG*QX%ALOGMT)**0.3333 - 0.5))

      TJ = -(REAL(MA%MP(2))*QX%ALOGMB+LOG(REAL(MA%MP(3))/B +  &
             REAL(MA%MP(4))/(B*B)))/ALOG2 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
          J2 = MAX(1,MIN(J2,LJSUMS))
      ENDIF

      N2 = INT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/QX%ALOGMB)
      QX%NDIG = QX%NDIG + L2
      NDSAV1 = QX%NDIG

!             Halve the argument K2 times.

      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      KTWO = 1
      MAXV = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTWO,QX)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMCSDIVI_R1(MXY(1),KTWO,QX)
      ENDIF

!             Sum the series X + X**2/2! + X**3/3! + ....
!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMEQ(MXY(1),MXY(2),QX)
      NTERM = 1
      DO J = 1, J2
         CALL FMCSDIVI_R1(MXY(2),NTERM,QX)
         NTERM = NTERM + 1
         CALL FMEQ(MXY(2),MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 150
      CALL FMIPWR(MXY(1),J2,MXY(3),QX)

  140 CALL FMCSMPY_R1(MXY(2),MXY(3),QX)
      DO J = 1, J2
         CALL FMCSDIVI_R1(MXY(2),NTERM,QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2),QX)
         IF (QX%KFLAG /= 0) GO TO 150
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(2)%MP(2))
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 140

!             Put the J2 separate sums back together.

  150 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(3),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(1),QX)
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1),QX)
      ENDDO

!             Reverse the effect of halving the argument to compute EXP(MA).

      QX%NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1),QX)
              DO J = 1, K2
                 KEXP = MXY(3)%MP(2)
                 IF (QX%MBASE == 2 .OR. KEXP > 0) THEN
                     CALL FMADD(MXY(3),MXY(1),MXY(2),QX)
                 ELSE
                     DO K = 1, 3-KEXP
                        MXY(2)%MP(K) = MXY(1)%MP(K)
                     ENDDO
                     DO K = 4-KEXP, QX%NDIG+2
                        MXY(2)%MP(K) = MXY(3)%MP(K-1+KEXP)
                     ENDDO
                 ENDIF
                 CALL FMCSMPY_R1(MXY(3),MXY(2),QX)
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2),QX)
                 CALL FMADD(MXY(3),MXY(3),MXY(1),QX)
                 CALL FMADD(MXY(2),MXY(1),MXY(3),QX)
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(1),QX)
      CALL FMADD(MXY(1),MXY(3),MXY(2),QX)

      CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE,QX)
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE FMEXP2

      RECURSIVE SUBROUTINE FMEXP2_TQ(A,B,MT,MQ,QX)

!  This routine does the binary splitting for computing the constant e.
!  When A is zero, e is approximated by MT/MQ.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MT,MQ
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MT,MQ
      TYPE(MULTI) :: MXY(4)
      INTEGER :: J,KM,RESULT_SIZE
      REAL (KIND(0.0D0)) :: DA,DB
      TYPE(FM_SETTINGS) :: QX

      DA = A
      DB = B

      IF (B-A < 25) THEN
          RESULT_SIZE = ( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) + 10 ) / QX%DLOGMB + 8
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          CALL IMI2M(1,MT,QX)
          CALL IMI2M(1,MXY(1),QX)
          DO J = 0, B-A-2, 2
             CALL IMMPYI(MXY(1),B-J,MXY(2),QX)
             CALL IMADD(MT,MXY(2),MXY(3),QX)
             CALL IMMPYI(MXY(2),B-J-1,MXY(1),QX)
             CALL IMADD(MXY(3),MXY(1),MT,QX)
          ENDDO
          IF (MOD(B-A,2) == 1) THEN
              CALL IMMPYI(MXY(1),A+1,MXY(2),QX)
              CALL IMADD(MT,MXY(2),MXY(3),QX)
              CALL IMEQ(MXY(3),MT,QX)
          ENDIF

          IF (A == 0) THEN
              CALL IMI2M(1,MQ,QX)
          ELSE
              CALL IMI2M(A,MQ,QX)
          ENDIF
          DO J = A+1, B-1, 2
             CALL IMMPYI(MQ,J,MXY(1),QX)
             CALL IMMPYI(MXY(1),J+1,MQ,QX)
          ENDDO
          IF (MOD(B-A+1,2) == 0) THEN
              CALL IMMPYI(MQ,B,MXY(1),QX)
              CALL IMEQ(MXY(1),MQ,QX)
          ENDIF
          GO TO 110
      ENDIF

      KM = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMEXP2_TQ(A,KM-1,MXY(1),MXY(2),QX)
      CALL FMEXP2_TQ(KM,B,MXY(3),MXY(4),QX)

      CALL IM_OR_FM_MPY(MXY(2),MXY(4),MQ,QX)

      CALL IM_OR_FM_MPY(MXY(1),MXY(4),MXY(2),QX)
      CALL IM_OR_FM_ADD(MXY(3),MXY(2),MT,QX)

  110 RETURN
      END SUBROUTINE FMEXP2_TQ

      FUNCTION FMFI(N)

!  Format integers for trace output.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(40) :: FMFI,TEMP
      INTEGER :: J,N

      FMFI = ' '
      WRITE (TEMP,*) N
      DO J = 1, 40
         IF (TEMP(J:J) /= ' ') THEN
             FMFI(1:41-J) = TEMP(J:40)
             RETURN
         ENDIF
      ENDDO

      END FUNCTION FMFI

      SUBROUTINE FMFLAG(K,QX)

!  Return the internal condition variable KFLAG to the user.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: K
      TYPE(FM_SETTINGS) :: QX
      K = QX%KFLAG
      RETURN
      END SUBROUTINE FMFLAG

      SUBROUTINE FMFFT_INIT(ROOTS_OF_UNITY,N)

!  Initialize roots of unity.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N
      COMPLEX (KIND(0.0D0)) :: ROOTS_OF_UNITY(0:N-1), S, ST
      DOUBLE PRECISION :: PI, T
      INTEGER :: ITS, J, JS, JSTEP, K, L, LEVEL, NR, N_DEF

      IF (N <= 100000) THEN
          RETURN
      ELSE
          L = NINT(2*LOG10(DBLE(N))-8)
          K = 2**L
          DO J = L, 1, -1
             IF (MOD(N,K) == 0) THEN
                 LEVEL = J
                 EXIT
             ENDIF
             K = K / 2
             LEVEL = 1
          ENDDO
      ENDIF

      N_DEF = N / 2**LEVEL
      IF (N < N_DEF) N_DEF = N
      ITS = NINT( LOG( DBLE(N) / N_DEF ) / LOG(2.0D0) )

      PI = ACOS(-1.0D0)
      T = 2*PI/N
      ST = CMPLX(-2*SIN(PI/N)**2,SIN(2*PI/N), KIND(0.0D0) )
      NR = N/2
      JSTEP = 32
      DO K = 0, NR/JSTEP - 1
         JS = K*JSTEP
         S = CMPLX( COS(JS*T) , SIN(JS*T) , KIND(0.0D0) )
         DO J = 0, JSTEP - 1
            ROOTS_OF_UNITY(J+JS) = S
            S = S + ST*S
         ENDDO
      ENDDO
      K = (NR/JSTEP)*JSTEP
      DO J = K, NR-1
         ROOTS_OF_UNITY(J) = CMPLX( COS(J*T) , SIN(J*T) , KIND(0.0D0) )
      ENDDO
      L = NR - 1
      DO J = 2, ITS
         JSTEP = 2**(J-1)
         DO K = 0, NR-1, JSTEP
            L = L + 1
            ROOTS_OF_UNITY(L) = ROOTS_OF_UNITY(K)
         ENDDO
      ENDDO

      END SUBROUTINE FMFFT_INIT

      SUBROUTINE FMFFT(A,N,ROOTS_OF_UNITY,A2)

!  A is returned as the FFT of the input array A(1:N)

!  This is not a general fft subroutine.  It is designed to be called by FM's multiplication
!  routines, and may not give correct results for arbitrary N.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N
      COMPLEX (KIND(0.0D0)) :: A(N), A2(N), ROOTS_OF_UNITY(0:N-1)
      INTEGER :: H, ITS, J, JLISTS, JS, JSTEP, K, K1, K2, L, LEVEL, LG, NL
      INTEGER, ALLOCATABLE :: FIRST(:)

      IF (N <= 100000) THEN
          CALL FMFFT2(A,N,A2)
          RETURN
      ELSE
          L = NINT(2*LOG10(DBLE(N))-8)
          K = 2**L
          DO J = L, 1, -1
             IF (MOD(N,K) == 0) THEN
                 LEVEL = J
                 EXIT
             ENDIF
             K = K / 2
             LEVEL = 1
          ENDDO
      ENDIF

      NL = 2**LEVEL
      LG = N/NL
      ALLOCATE( FIRST(NL) )

      JLISTS = 1
      FIRST(1) = 1
      H = 1
      DO J = 1, LEVEL
         DO K = JLISTS, 1, -1
            FIRST(2*K-1) = FIRST(K)
            FIRST(2*K)   = FIRST(K) + H
         ENDDO
         H = 2*H
         JLISTS = 2*JLISTS
      ENDDO

      DO J = 1, NL
         DO K = 0, LG-1
            A2(1+K+(J-1)*LG) = A(FIRST(J)+K*H)
         ENDDO
      ENDDO

      DO J = 1, NL
         CALL FMFFT2(A2(1+(J-1)*LG),LG,A)
      ENDDO

      ITS = NINT( LOG( DBLE(NL) ) / LOG(2.0D0) )
      JSTEP = ITS + 1
      DO L = 2, ITS, 2

         JSTEP = JSTEP - 1
         JS = -1
         IF (JSTEP > 1) JS = (N / 2**(JSTEP-1)) * (2**(JSTEP-1) - 1) - 1
         DO K = 2, NL, 2
            K1 = (K-2)*LG
            K2 = K1 + LG
            DO J = 1, LG
               A(J+K1) = A2(J+K1) + ROOTS_OF_UNITY(J+JS) * A2(J+K2)
               A(J+K2) = A2(J+K1) - ROOTS_OF_UNITY(J+JS) * A2(J+K2)
            ENDDO
         ENDDO

         LG = 2 * LG
         NL = NL / 2
         JSTEP = JSTEP - 1
         JS = -1
         IF (JSTEP > 1) JS = (N / 2**(JSTEP-1)) * (2**(JSTEP-1) - 1) - 1
         DO K = 2, NL, 2
            K1 = (K-2)*LG
            K2 = K1 + LG
            DO J = 1, LG
               A2(J+K1) = A(J+K1) + ROOTS_OF_UNITY(J+JS) * A(J+K2)
               A2(J+K2) = A(J+K1) - ROOTS_OF_UNITY(J+JS) * A(J+K2)
            ENDDO
         ENDDO

         LG = 2 * LG
         NL = NL / 2

      ENDDO

      IF (MOD(ITS,2) == 0) THEN
          DO J = 1, N
             A(J) = A2(J)
          ENDDO
      ELSE
          JSTEP = JSTEP - 1
          JS = -1
          IF (JSTEP > 1) JS = (N / 2**(JSTEP-1)) * (2**(JSTEP-1) - 1) - 1
          DO K = 2, NL, 2
             K1 = (K-2)*LG
             K2 = K1 + LG
             DO J = 1, LG
                A(J+K1) = A2(J+K1) + ROOTS_OF_UNITY(J+JS) * A2(J+K2)
                A(J+K2) = A2(J+K1) - ROOTS_OF_UNITY(J+JS) * A2(J+K2)
             ENDDO
          ENDDO
      ENDIF

      DEALLOCATE( FIRST )

      END SUBROUTINE FMFFT

      SUBROUTINE FMFFT2(A,N,W)

!  Internal routine used during very high precision multiplication.

!  A is returned as the FFT of the input array A(1:N).
!  W is a scratch array.
!  This is a slightly modified version of a Fast Fourier Transform routine found at www.netlib.org.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N
      COMPLEX (KIND(0.0D0)) :: A(N),W(N),S,S1,S2,S3,S4,ST,T
      REAL (KIND(0.0D0)) :: PI
      INTEGER :: D,E,F,G,H,I,J,K,L,M,O
      INTEGER, PARAMETER :: P(25) = (/ 2,3,5,7,11,13,17,19,23,29,31,37,41,  &
                                      43,47,53,59,61,67,71,73,79,83,89,97 /)
      INTEGER, PARAMETER :: NP = 25
      M = N
      F = 0
      PI = ACOS(-1.0D0)
  110 IF ( M == 1 ) GO TO 910
      DO I = 1,NP
         IF ( (M/P(I))*P(I) == M ) GO TO 120
      ENDDO
      L = M
      GO TO 130
  120 L = P(I)
  130 O = M
      M = M/L
      ST = CMPLX(-2*SIN(M*PI/N)**2,SIN(2*M*PI/N), KIND(1.0D0) )
      S1 = (1.0D0,0.0D0)
      S = S1
      S2 = (0.0D0,0.0D0)
      H = 0
      IF ( F == 1 ) GO TO 520
      IF ( L == 2 ) GO TO 140
      IF ( L == 3 ) GO TO 250
      GO TO 360
  140 IF ( M == 1 ) GO TO 230
      IF ( M == 2 ) GO TO 210
      IF ( M == 3 ) GO TO 190
      IF ( M == 4 ) GO TO 170
  150 J = -H
  160 I = H + 1
      H = H + M
      E = J + M
      IF (ABS(S-(1.0D0,0.0D0)) < 10*EPSILON(1.0D0)) THEN
          DO K = I, H
             W(K) = A(J+K) + A(E+K)
          ENDDO
      ELSE IF (ABS(S-(-1.0D0,0.0D0)) < 10*EPSILON(1.0D0)) THEN
          DO K = I, H
             W(K) = A(J+K) - A(E+K)
          ENDDO
      ELSE
          DO K = I, H
             W(K) = A(J+K) + S*A(E+K)
          ENDDO
      ENDIF
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 160
      IF ( H < N ) GO TO 150
      F = 1
      GO TO 110
  170 J = -H
  180 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 180
      IF ( H < N ) GO TO 170
      F = 1
      GO TO 110
  190 J = -H
  200 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 200
      IF ( H < N ) GO TO 190
      F = 1
      GO TO 110
  210 J = -H
  220 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 220
      IF ( H < N ) GO TO 210
      F = 1
      GO TO 110
  230 J = -H
  240 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 240
      IF ( H < N ) GO TO 230
      F = 1
      GO TO 110
  250 IF ( M == 1 ) GO TO 340
      IF ( M == 2 ) GO TO 320
      IF ( M == 3 ) GO TO 300
      IF ( M == 4 ) GO TO 280
  260 J = -H
  270 I = H + 1
      H = H + M
      E = J + M
      D = E + M
      T = S*S
      DO K = I, H
         W(K) = A(J+K) + S*A(E+K) + T*A(D+K)
      ENDDO
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 270
      IF ( H < N ) GO TO 260
      F = 1
      GO TO 110
  280 J = -H
  290 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 290
      IF ( H < N ) GO TO 280
      F = 1
      GO TO 110
  300 J = -H
  310 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 310
      IF ( H < N ) GO TO 300
      F = 1
      GO TO 110
  320 J = -H
  330 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 330
      IF ( H < N ) GO TO 320
      F = 1
      GO TO 110
  340 J = -H
  350 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 350
      IF ( H < N ) GO TO 340
      F = 1
      GO TO 110
  360 IF ( M == 1 ) GO TO 490
      IF ( M == 2 ) GO TO 460
      IF ( M == 3 ) GO TO 430
      IF ( M == 4 ) GO TO 400
  370 J = -H
  380 I = H + 1
      H = H + M
      G = J + O
      DO K = I, H
         W(K) = A(J+K)
      ENDDO
      T = S
      J = J + M
  390 DO K = I, H
         W(K) = W(K) + T*A(J+K)
      ENDDO
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 390
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 380
      IF ( H < N ) GO TO 370
      F = 1
      GO TO 110
  400 J = -H
  410 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      D = E + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(E) = (0.0D0,0.0D0)
      W(D) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  420 W(I) = W(I) + T*A(J+I)
      W(E) = W(E) + T*A(J+E)
      W(D) = W(D) + T*A(J+D)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 420
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 410
      IF ( H < N ) GO TO 400
      F = 1
      GO TO 110
  430 J = -H
  440 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(E) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  450 W(I) = W(I) + T*A(J+I)
      W(E) = W(E) + T*A(J+E)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 450
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 440
      IF ( H < N ) GO TO 430
      F = 1
      GO TO 110
  460 J = -H
  470 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  480 W(I) = W(I) + T*A(J+I)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 480
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 470
      IF ( H < N ) GO TO 460
      F = 1
      GO TO 110
  490 J = -H
  500 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
  510 W(I) = W(I) + T*A(J+I)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 510
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 500
      IF ( H < N ) GO TO 490
      F = 1
      GO TO 110
  520 IF ( L == 2 ) GO TO 530
      IF ( L == 3 ) GO TO 640
      GO TO 750
  530 IF ( M == 1 ) GO TO 620
      IF ( M == 2 ) GO TO 600
      IF ( M == 3 ) GO TO 580
      IF ( M == 4 ) GO TO 560
  540 J = -H
  550 I = H + 1
      H = H + M
      E = J + M
      DO K = I, H
         A(K) = W(J+K) + S*W(E+K)
      ENDDO
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 550
      IF ( H < N ) GO TO 540
      F = 0
      GO TO 110
  560 J = -H
  570 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 570
      IF ( H < N ) GO TO 560
      F = 0
      GO TO 110
  580 J = -H
  590 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 590
      IF ( H < N ) GO TO 580
      F = 0
      GO TO 110
  600 J = -H
  610 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 610
      IF ( H < N ) GO TO 600
      F = 0
      GO TO 110
  620 J = -H
  630 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 630
      IF ( H < N ) GO TO 620
      F = 0
      GO TO 110
  640 IF ( M == 1 ) GO TO 730
      IF ( M == 2 ) GO TO 710
      IF ( M == 3 ) GO TO 690
      IF ( M == 4 ) GO TO 670
  650 J = -H
  660 I = H + 1
      H = H + M
      E = J + M
      D = E + M
      T = S*S
      DO K = I, H
         A(K) = W(J+K) + S*W(E+K) + T*W(D+K)
      ENDDO
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 660
      IF ( H < N ) GO TO 650
      F = 0
      GO TO 110
  670 J = -H
  680 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 680
      IF ( H < N ) GO TO 670
      F = 0
      GO TO 110
  690 J = -H
  700 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 700
      IF ( H < N ) GO TO 690
      F = 0
      GO TO 110
  710 J = -H
  720 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 720
      IF ( H < N ) GO TO 710
      F = 0
      GO TO 110
  730 J = -H
  740 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 740
      IF ( H < N ) GO TO 730
      F = 0
      GO TO 110
  750 IF ( M == 1 ) GO TO 880
      IF ( M == 2 ) GO TO 850
      IF ( M == 3 ) GO TO 820
      IF ( M == 4 ) GO TO 790
  760 J = -H
  770 I = H + 1
      H = H + M
      G = J + O
      DO K = I, H
         A(K) =  W(J+K)
      ENDDO
      T = S
      J = J + M
  780 DO K = I, H
         A(K) = A(K) + T*W(J+K)
      ENDDO
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 780
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 770
      IF ( H < N ) GO TO 760
      F = 0
      GO TO 110
  790 J = -H
  800 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      D = E + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(E) = (0.0D0,0.0D0)
      A(D) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  810 A(I) = A(I) + T*W(J+I)
      A(E) = A(E) + T*W(J+E)
      A(D) = A(D) + T*W(J+D)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 810
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 800
      IF ( H < N ) GO TO 790
      F = 0
      GO TO 110
  820 J = -H
  830 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(E) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  840 A(I) = A(I) + T*W(J+I)
      A(E) = A(E) + T*W(J+E)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 840
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 830
      IF ( H < N ) GO TO 820
      F = 0
      GO TO 110
  850 J = -H
  860 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  870 A(I) = A(I) + T*W(J+I)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 870
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 860
      IF ( H < N ) GO TO 850
      F = 0
      GO TO 110
  880 J = -H
  890 I = H + 1
      H = H + M
      G = J + O
      A(I) = W(J+I)
      T = S
      J = J + M
  900 A(I) = A(I) + T*W(J+I)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 900
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 890
      IF ( H < N ) GO TO 880
      F = 0
      GO TO 110
  910 IF ( F /= 0 ) THEN
          DO I = 1, N
             A(I) = W(I)
          ENDDO
      ENDIF
      RETURN
      END SUBROUTINE FMFFT2

      SUBROUTINE FMFORM(FORM,MA,STRING,QX)

!  Convert an FM number (MA) to a character string base 10 (STRING) using character string
!  FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

!  If Iw format is used and MA is not exactly an integer, then the nearest integer to MA is printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: FORM,STRING
      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFF(LMBUFF)
      INTENT (IN) :: FORM,MA
      INTENT (INOUT) :: STRING
      TYPE(FM_SETTINGS) :: QX
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KSAVE,KWD,KWI,LAST,LB,LENGFM,LENGST,LFIRST,ND,NEXP
      TYPE(MULTI) :: MXY(2)


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMFORM'

      KSAVE = QX%KFLAG
      JF1SAV = QX%JFORM1
      JF2SAV = QX%JFORM2
      STRING = ' '
      LENGFM = LEN(FORM)
      LENGST = LEN(STRING)
      KWI = 75
      KWD = 40

      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = LENGST
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          QX%JFORM1 = 2
          QX%JFORM2 = 0
          KWD = KWI + 21
          IF (KWD+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMNINT(MA,MXY(1),QX)
          IF (MXY(1)%MP(3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD,QX)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 STRING(J:J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 2
          QX%JFORM2 = KD
          ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(QX%JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD,QX)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid showing
!             no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(REAL(MA%MP(2)))+1)*LOG10(REAL(QX%MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  QX%JFORM1 = 0
                  QX%JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                          '  Raise its size or change the format being used.'
                      STOP
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI,QX)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 STRING(J:J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 1
          QX%JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI,QX)
          DO J = KWI, 1, -1
             IF (J > LENGST) THEN
                 IF (CMBUFF(J) /= ' ') GO TO 110
             ELSE
                 STRING(J:J) = CMBUFF(J)
             ENDIF
          ENDDO
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 0
          QX%JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI,QX)
          DO J = KWI, 1, -1
             IF (J > LENGST) THEN
                 IF (CMBUFF(J) /= ' ') GO TO 110
             ELSE
                 STRING(J:J) = CMBUFF(J)
             ENDIF
          ENDDO
      ELSE
          GO TO 110
      ENDIF
      GO TO 120

!             Error condition.

  110 QX%KFLAG = -8
      DO J = 1, LENGST
         STRING(J:J) = '*'
      ENDDO

  120 QX%KFLAG = KSAVE
      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMFORM

      SUBROUTINE FMFPRT(FORM,MA,QX)

!  Print an FM number (MA) on unit KW using character string FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

!  If Iw format is used and MA is not exactly an integer, then the nearest integer to MA is printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFF(LMBUFF)
      TYPE(FM_SETTINGS) :: QX
      CHARACTER(20) :: FORM2
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K,K1,K2,K3,KD,KSAVE,KWD,KWI,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: FORM,MA
      TYPE(MULTI) :: MXY(2)


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMFPRT'

      KSAVE = QX%KFLAG
      JF1SAV = QX%JFORM1
      JF2SAV = QX%JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40

      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          QX%JFORM1 = 2
          QX%JFORM2 = 0
          KWD = KWI + 21
          IF (KWD+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMNINT(MA,MXY(1),QX)
          IF (MXY(1)%MP(3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD,QX)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 2
          QX%JFORM2 = KD
          ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(QX%JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD,QX)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid showing
!             no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(REAL(MA%MP(2)))+1)*LOG10(REAL(QX%MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  QX%JFORM1 = 0
                  QX%JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                          '  Raise its size or change the format being used.'
                      STOP
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI,QX)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 1
          QX%JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI,QX)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 0
          QX%JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI,QX)
      ELSE
          GO TO 110
      ENDIF
      GO TO 120

!             Error condition.

  110 QX%KFLAG = -8
      DO J = 1, KWI
         CMBUFF(J) = '*'
      ENDDO

  120 LAST = KWI + 1
      WRITE (FORM2,"(' (6X,',I3,'A1) ')") QX%KSWIDE-7
      IF (QX%KFLAG /= -8) QX%KFLAG = KSAVE
      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      DO J = KWI, 1, -1
         IF (CMBUFF(J) /= ' ' .OR. J == 1) THEN
             WRITE (KW,FORM2) (CMBUFF(K),K=1,J)
             QX%NCALL = QX%NCALL - 1
             RETURN
         ENDIF
      ENDDO
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMFPRT

      SUBROUTINE FMGCDI(N1,N2)

!  Find the Greatest Common Divisor of N1 and N2, and return both having been divided by their GCD.
!  Both must be positive.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: K1,K2,K3,N1,N2
      INTENT (INOUT) :: N1,N2

      K1 = MAX(N1,N2)
      K2 = MIN(N1,N2)
  110 K3 = MOD(K1,K2)
      IF (K3 == 0) THEN
          N1 = N1/K2
          N2 = N2/K2
          RETURN
      ELSE
          K1 = K2
          K2 = K3
          GO TO 110
      ENDIF
      END SUBROUTINE FMGCDI

      SUBROUTINE FMHTBL(QX)

!  Initialize two hash tables that are used for character look-up during input conversion.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: J,KPT
      TYPE(FM_SETTINGS) :: QX

      CHARACTER :: LCHARS(21) = (/                                  &
                  '+','-','0','1','2','3','4','5','6','7','8','9',  &
                  '.','E','D','Q','M','e','d','q','m' /)
      INTEGER :: LTYPES(21) = (/ 1,1,2,2,2,2,2,2,2,2,2,2,3,4,4,4,4,4,4,4,4 /)
      INTEGER :: LVALS(21) = (/ 1,-1,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0 /)

      DO J = LHASH1, LHASH2
         QX%KHASHT(J) = 5
         QX%KHASHV(J) = 0
      ENDDO
      DO J = 1, 21
         KPT = ICHAR(LCHARS(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LCHARS(J),KPT,LHASH1,LHASH2
         ELSE
             QX%KHASHT(KPT) = LTYPES(J)
             QX%KHASHV(KPT) = LVALS(J)
         ENDIF
      ENDDO
      QX%LHASH = 1
      RETURN
      END SUBROUTINE FMHTBL

      SUBROUTINE FMHYPOT(MA,MB,MC,QX)

!  MC = sqrt( x^2 + y^2 )

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: NDSAVE,MXSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMHYPOT  '
      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2

!             Check for special cases.

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MXY(1),QX)
          GO TO 110
      ENDIF
      IF (MA%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(1),QX)
          GO TO 110
      ENDIF

      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
      CALL FMSQR_R1(MXY(1),QX)
      CALL FMSQR_R1(MXY(2),QX)
      CALL FMADD_R1(MXY(1),MXY(2),QX)
      CALL FMSQRT_R1(MXY(1),QX)

  110 QX%MXEXP = MXSAVE
      CALL FMEQU(MXY(1),MC,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMHYPOT

      SUBROUTINE FMI2M(IVAL,MA,QX)

!  MA = IVAL

!  Convert an integer to FM format.

!  The conversion is exact if IVAL is less than MBASE**NDIG, otherwise the result is
!  an approximation.

!  This routine performs the trace printing for the conversion.  FMIM is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMI2M'
          CALL FMNTRI(2,IVAL,1,QX)

          CALL FMIM(IVAL,MA,QX)

          CALL FMNTR(1,MA,MA,1,1,QX)
      ELSE
          CALL FMIM(IVAL,MA,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMI2M

      SUBROUTINE FMIM(IVAL,MA,QX)

!  MA = IVAL.  Internal integer conversion routine.

!  The conversion is exact if IVAL is less than MBASE**NDIG, otherwise FMDM is used to get
!  an approximation.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: MK,ML,MVAL
      INTEGER :: J,JM2,KB,KB1,N1,NMVAL,NV2
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIMS(IVAL,MA,QX)
          RETURN
      ENDIF

!             Check for small IVAL.

      IF (MVAL < QX%MBASE) THEN
          DO J = 3, N1
             MA%MP(J+1) = 0
          ENDDO
          IF (IVAL >= 0) THEN
              MA%MP(3) = IVAL
              MA%MP(1) = 1
          ELSE
              MA%MP(3) = -IVAL
              MA%MP(1) = -1
          ENDIF
          IF (IVAL == 0) THEN
              MA%MP(2) = 0
          ELSE
              MA%MP(2) = 1
          ENDIF
          RETURN
      ENDIF

!             Compute and store the digits, right to left.

      MA%MP(2) = 0
      J = QX%NDIG + 1

  110 MK = AINT (MVAL/QX%MBASE)
      ML = MVAL - MK*QX%MBASE
      MA%MP(2) = MA%MP(2) + 1
      MA%MP(J+1) = ML
      IF (MK > 0) THEN
          MVAL = MK
          J = J - 1
          IF (J >= 2) GO TO 110

!             Here IVAL cannot be expressed exactly.

          X = IVAL
          CALL FMDM(X,MA,QX)
          RETURN
      ENDIF

!             Normalize MA.

      KB = N1 - J + 2
      JM2 = J - 2
      DO J = 2, KB
         MA%MP(J+1) = MA%MP(J+JM2+1)
      ENDDO
      KB1 = KB + 1
      IF (KB1 <= N1) THEN
          DO J = KB1, N1
             MA%MP(J+1) = 0
          ENDDO
      ENDIF

      MA%MP(1) = 1
      IF (IVAL < 0 .AND. MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0) MA%MP(1) = -1

      RETURN
      END SUBROUTINE FMIM

      SUBROUTINE FMIMS(IVAL,MA,QX)

!  MA = IVAL.  Internal integer conversion routine.

!  This routine is called when M-variable precision is less than Integer precision.  This often
!  happens when single precision is chosen for M-variables.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: ML
      INTEGER :: J,JM2,KB,KB1,KBASE,KMK,KVAL,N1
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

!             Check for small IVAL.

      KVAL = ABS(IVAL)
      KBASE = INT(QX%MBASE)
      IF (KVAL < KBASE) THEN
          DO J = 3, N1
             MA%MP(J+1) = 0
          ENDDO
          IF (IVAL >= 0) THEN
              MA%MP(3) = IVAL
              MA%MP(1) = 1
          ELSE
              MA%MP(3) = -IVAL
              MA%MP(1) = -1
          ENDIF
          IF (IVAL == 0) THEN
              MA%MP(2) = 0
          ELSE
              MA%MP(2) = 1
          ENDIF
          RETURN
      ENDIF

!             Compute and store the digits, right to left.

      MA%MP(2) = 0
      J = QX%NDIG + 1

  110 KMK = (KVAL/KBASE)
      ML = KVAL - KMK*KBASE
      MA%MP(2) = MA%MP(2) + 1
      MA%MP(J+1) = ML
      IF (KMK > 0) THEN
          KVAL = KMK
          J = J - 1
          IF (J >= 2) GO TO 110

!             Here IVAL cannot be expressed exactly.

          X = IVAL
          CALL FMDM(X,MA,QX)
          RETURN
      ENDIF

!             Normalize MA.

      KB = N1 - J + 2
      JM2 = J - 2
      DO J = 2, KB
         MA%MP(J+1) = MA%MP(J+JM2+1)
      ENDDO
      KB1 = KB + 1
      IF (KB1 <= N1) THEN
          DO J = KB1, N1
             MA%MP(J+1) = 0
          ENDDO
      ENDIF

      MA%MP(1) = 1
      IF (IVAL < 0 .AND. MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0) MA%MP(1) = -1

      RETURN
      END SUBROUTINE FMIMS

      SUBROUTINE FMINP(LINE,MA,LA,LB,QX)

!  Convert an array of characters to floating point multiple precision format.

!  LINE is an A1 character array of length LB to be converted to FM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.  This allows
!     more than one number to be stored in an array and converted in place.
!  LB is a pointer to the last character of the field for that number.

!  The input number may be in integer or any real format.

!  KESWCH = 1  causes input to FMINP with no digits before the exponent letter to be treated as if
!              there were a leading '1'.  This is sometimes better for interactive input:
!              'E7' converts to 10.0**7.
!         = 0  causes a leading zero to be assumed.  This gives compatibility with Fortran:
!              'E7' converts to 0.0.

!  In exponential format the 'E' may also be 'D', 'Q', or 'M'.

!  So that FMINP will convert any output from FMOUT, LINE is tested to see if the input is one of
!  the special symbols +OVERFLOW, -OVERFLOW, +UNDERFLOW, -UNDERFLOW, or UNKNOWN.
!  For user input the abbreviations OVFL, UNFL, UNKN may be used.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MBSAVE,MXSAV1,MXSAV2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KMN,KOF,KPOWER,KPT,KR_RETRY,KSPEC,KSTART,KSTOP,  &
                 KTYPE,KUF,KUK,KWRNSV,L,ND,NDSAV1,NDSAVE,NEW_MBASE,NEW_NDIG,NTRSAV
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA

      CHARACTER :: KOVFL(4) = (/ 'O','V','F','L' /)
      CHARACTER :: KUNFL(4) = (/ 'U','N','F','L' /)
      CHARACTER :: KUNKN(4) = (/ 'U','N','K','N' /)
      CHARACTER :: LOVFL(4) = (/ 'o','v','f','l' /)
      CHARACTER :: LUNFL(4) = (/ 'u','n','f','l' /)
      CHARACTER :: LUNKN(4) = (/ 'u','n','k','n' /)
      CHARACTER(9) :: NAMEST_SAVE(0:50)
      TYPE(MULTI) :: MXY(5)


!             To avoid recursion, FMINP calls only internal arithmetic routines (FMADD2,
!             FMMPY2, ...), so no trace printout is done during a call to FMINP.

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMINP'
      NDSAVE = QX%NDIG
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      KR_RETRY = 0
      QX%KFLAG = 0
      MXSAV1 = QX%MXEXP
      MXSAV2 = QX%MXEXP2
      IF (QX%MXEXP < 100000) THEN
          QX%MXEXP  = 201000
          QX%MXEXP2 = 201000
      ELSE
          QX%MXEXP = QX%MXEXP2
      ENDIF

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (QX%LHASH == 0) CALL FMHTBL(QX)

!             Check for special symbols.

      KSPEC = 0
      KMN = 1
      KOF = 1
      KUF = 1
      KUK = 1
      DO J = LA, LB
         KPT = ICHAR(LINE(J))
         IF (KPT >= LHASH1 .AND. KPT <= LHASH2) THEN
             KTYPE = QX%KHASHT(KPT)
             IF (KTYPE == 2) GO TO 110
         ENDIF
         IF (LINE(J) == '-') KMN = -1
         IF (LINE(J) == KOVFL(KOF) .OR. LINE(J) == LOVFL(KOF)) THEN
             KOF = KOF + 1
             IF (KOF == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5),QX)
                 MXY(5)%MP(2) = QX%MEXPOV
                 MXY(5)%MP(3) = 1
                 MXY(5)%MP(1) = KMN
                 GO TO 130
             ENDIF
         ENDIF
         IF (LINE(J) == KUNFL(KUF) .OR. LINE(J) == LUNFL(KUF)) THEN
             KUF = KUF + 1
             IF (KUF == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5),QX)
                 MXY(5)%MP(2) = QX%MEXPUN
                 MXY(5)%MP(3) = 1
                 MXY(5)%MP(1) = KMN
                 GO TO 130
             ENDIF
         ENDIF
         IF (LINE(J) == KUNKN(KUK) .OR. LINE(J) == LUNKN(KUK)) THEN
             KUK = KUK + 1
             IF (KUK == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5),QX)
                 MXY(5)%MP(2) = QX%MUNKNO
                 MXY(5)%MP(3) = 1
                 GO TO 130
             ENDIF
         ENDIF
      ENDDO

!             Increase the working precision.

  110 K = QX%NGRD52
      QX%NDIG = MAX(QX%NDIG+K,2)

  120 IF (KR_RETRY >= 1) THEN
          QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      NDSAV1 = QX%NDIG
      KSTART = LA
      KSTOP = LB

!             If MBASE is a power of ten then call FMINP2 for faster input conversion.

      KPOWER = INT(LOG10(DBLE(QX%MBASE)) + 0.5D0)
      IF (QX%MBASE == 10**KPOWER) THEN
          K = 0
          DO J = LA, LB
             IF (LINE(J) /= ' ') THEN
                 DO L = LB, LA, -1
                    IF (LINE(L) /= ' ') THEN
                        K = (L-J+1)*LOG(10.0D0)/LOG(DBLE(QX%MBASE))
                        EXIT
                    ENDIF
                 ENDDO
                 EXIT
             ENDIF
          ENDDO
          IF (QX%NDIG <= K+9) THEN
              QX%NDIG = K + 10
              NDSAV1 = QX%NDIG
          ENDIF
          CALL FMIM(0,MXY(1),QX)
          CALL FMIM(0,MXY(2),QX)
          CALL FMIM(0,MXY(3),QX)
          CALL FMIM(0,MXY(4),QX)
          CALL FMIM(0,MXY(5),QX)
          CALL FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER,QX)
          IF (MXY(5)%MP(2) == QX%MUNKNO) GO TO 140
          GO TO 130
      ENDIF

!             If MBASE is not a power of ten then call FMINP2 first using a power of ten base,
!             then change to base MBASE.

      MBSAVE = QX%MBASE
      KPOWER = INT(LOG10(DBLE(MXBASE)/4) + 0.5D0)
      QX%MBASE = 10**KPOWER
      QX%NDIG = NDSAV1*LOG(DBLE(MBSAVE))/LOG(DBLE(QX%MBASE)) + 3
      K = 0
      DO J = LA, LB
         IF (LINE(J) /= ' ') THEN
             DO L = LB, LA, -1
                IF (LINE(L) /= ' ') THEN
                    K = (L-J+1)*LOG(10.0D0)/LOG(DBLE(QX%MBASE))
                    EXIT
                ENDIF
             ENDDO
             EXIT
         ENDIF
      ENDDO
      IF (QX%NDIG <= K+9) THEN
          QX%NDIG = K + 10
      ENDIF
      CALL FMCONS(QX)
      CALL FMIM(0,MXY(1),QX)
      CALL FMIM(0,MXY(2),QX)
      CALL FMIM(0,MXY(3),QX)
      CALL FMIM(0,MXY(4),QX)
      CALL FMIM(0,MXY(5),QX)
      J = QX%MXEXP2
      K = J*LOG(DBLE(MBSAVE))/LOG(DBLE(QX%MBASE)) + 0.5
      QX%MXEXP2 = K
      CALL FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER,QX)
      QX%MXEXP2 = J
      NEW_MBASE = MBSAVE
      NEW_NDIG = MAX(NDSAV1,QX%NDIG*NINT(LOG(DBLE(QX%MBASE))/LOG(DBLE(MBSAVE))))
      ND = 2
      DO J = QX%NDIG, 3, -1
         IF (MXY(5)%MP(J+2) /= 0) THEN
             ND = J
             EXIT
         ENDIF
      ENDDO
      QX%NDIG = ND
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      J = QX%NCALL
      NAMEST_SAVE(0:QX%NCALL) = QX%NAMEST(0:QX%NCALL)
      QX%NCALL = 0
      IF (ABS(MXY(5)%MP(2)) < QX%MEXPOV) THEN
          CALL FMCHANGEBASE(MXY(5),MXY(4),NEW_MBASE,NEW_NDIG,QX)
      ELSE
          CALL FMEQU(MXY(5),MXY(4),QX%NDIG,NEW_NDIG,QX)
      ENDIF
      QX%NCALL = J
      QX%NAMEST(0:QX%NCALL) = NAMEST_SAVE(0:QX%NCALL)
      QX%NTRACE = NTRSAV
      QX%MBASE = MBSAVE
      QX%NDIG = NEW_NDIG
      CALL FMCONS(QX)
      CALL FMEQ(MXY(4),MXY(5),QX)
      IF (MXY(5)%MP(2) == QX%MUNKNO) GO TO 140

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (KSPEC == 0) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF
      QX%MXEXP = MXSAV1
      QX%MXEXP2 = MXSAV2
      IF (INT(QX%MBASE-AINT (QX%MBASE/2)*2) == 0) THEN
          CALL FMEQU(MXY(5),MA,QX%NDIG,NDSAVE,QX)
      ELSE
          CALL FMEQU(MXY(5),MA,QX%NDIG-1,NDSAVE,QX)
      ENDIF
      IF (KSPEC == 0) THEN
          IF (MA%MP(2) == QX%MUNKNO) GO TO 140
      ELSE
          QX%KFLAG = 0
      ENDIF
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      IF (MA%MP(3) == 0) MA%MP(1) = 1
      QX%NCALL = QX%NCALL - 1
      RETURN

!             Error in converting the number.

  140 CALL FMIM(0,MXY(5),QX)
      CALL FMEQU(MXY(5),MA,QX%NDIG,NDSAVE,QX)
      MA%MP(2) = QX%MUNKNO
      MA%MP(3) = 1
      QX%KWARN = KWRNSV
      QX%KFLAG = -7
      QX%NAMEST(QX%NCALL) = 'FMINP'
      CALL FMWARN(QX)
      QX%NDIG = NDSAVE
      QX%MXEXP = MXSAV1
      QX%MXEXP2 = MXSAV2
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      IF (MA%MP(3) == 0) MA%MP(1) = 1
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMINP

      SUBROUTINE FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER,QX)

!  Internal routine for input conversion for a power of ten MBASE.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MXY(5)
      INTEGER :: KSTART,KSTOP,KPOWER
      CHARACTER :: LINE(KSTOP)
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,JSTATE,K,KDFLAG,KEXP,KF1,KF1DIG,KF2,KF2DIG,KF2PT,KNZDIG,KPT,KSHIFT,KSIGN,  &
                 KSIGNX,KTYPE,KVAL,LARGE,LNZD
      INTENT (IN) :: LINE,KSTART,KSTOP,KPOWER
      INTENT (INOUT) :: MXY

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States of the machine:

!  1.  Initial entry to the subroutine
!  2.  Sign of the number
!  3.  Scanning digits before a decimal point
!  4.  Decimal point
!  5.  Scanning digits after a decimal point
!  6.  E, D, Q, or M -- precision indicator before the exponent
!  7.  Sign of the exponent
!  8.  Scanning exponent
!  9.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (E,D,Q,M)
!  5.  Illegal character for number

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state JSTATE and a character of type JTYPE is encountered the new state of the
!  machine is given by JTRANS(JSTATE,JTYPE).

!  In this initialization, the array is loaded by columns.

!          State   1  2  3  4  5  6  7  8

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/     &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      JSTATE = 1
      KDFLAG = 0
      KSIGN = 1
      KSIGNX = 1
      KF1 = 0
      KNZDIG = 0
      LNZD = 0
      KF1DIG = 0
      KF2 = 0
      KF2DIG = 0
      KF2PT = 2
      KEXP = 0
      LARGE = INT(INTMAX/10)

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == ' ') CYCLE
         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = QX%KHASHT(KPT)
             KVAL  = QX%KHASHV(KPT)
         ENDIF

         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDFLAG = 1
             KF1 = 10*KF1 + KVAL
             IF (KVAL > 0) LNZD = 1
             IF (KVAL > 0 .OR. KNZDIG /= 0) THEN
                 KNZDIG = 1
                 KF1DIG = KF1DIG + 1
             ENDIF
             IF (KF1DIG == KPOWER) THEN
                 MXY(2)%MP(2) = MXY(2)%MP(2) + 1
                 K = MXY(2)%MP(2)
                 IF (K < QX%NDIG) THEN
                     MXY(2)%MP(K+2) = KF1
                 ENDIF
                 KF1 = 0
                 KF1DIG = 0
             ENDIF

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDFLAG = 1
             IF (KVAL > 0) LNZD = 1
             IF (KF2PT > QX%NDIG+1) CYCLE
             KF2 = 10*KF2 + KVAL
             KF2DIG = KF2DIG + 1
             IF (KF2DIG == KPOWER) THEN
                 MXY(3)%MP(KF2PT+1) = KF2
                 IF (KF2 == 0 .AND. KF2PT == 2) THEN
                     MXY(3)%MP(2) = MXY(3)%MP(2) - 1
                 ELSE
                     KF2PT = KF2PT + 1
                 ENDIF
                 KF2 = 0
                 KF2DIG = 0
             ENDIF

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDFLAG == 0 .AND. QX%KESWCH == 1) THEN
                 LNZD = 1
                 CALL FMIM(1,MXY(2),QX)
             ENDIF

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             IF (KEXP >= LARGE) THEN
                 IF (LNZD == 0) THEN
                     CALL FMIM(0,MXY(5),QX)
                     RETURN
                 ENDIF
                 CALL FMINP3(LINE,KSTART,KSTOP,MXY(5),QX)
                 RETURN
             ENDIF
             KEXP = 10*KEXP + KVAL
             IF (KEXP >= 0.75D0*QX%MXEXP2*QX%DLOGMB/QX%DLOGTN .AND. LNZD /= 0) THEN
                 CALL FMINP3(LINE,KSTART,KSTOP,MXY(5),QX)
                 RETURN
             ENDIF

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Form the number and return.  MXY(5) = KSIGN*(MXY(2) + MXY(3))*10.0**(KSIGNX*KEXP)

      IF (KF1DIG /= 0) THEN
          MXY(2)%MP(2) = MXY(2)%MP(2) + 1
          KSHIFT = 10**(KPOWER-KF1DIG)
          K = MXY(2)%MP(2)
          IF (K < QX%NDIG) MXY(2)%MP(2+INT(K)) = KF1*KSHIFT
          IF (KSHIFT > 1) THEN
              CALL FMDIVN_R1(MXY(2),KSHIFT,QX)
          ENDIF
      ENDIF
      IF (MXY(2)%MP(3) == 0) THEN
          MXY(2)%MP(1) = 1
          MXY(2)%MP(2) = 0
      ELSE
          MXY(2)%MP(1) = 1
      ENDIF

      IF (KF2DIG /= 0) THEN
          KSHIFT = 10**(KPOWER-KF2DIG)
          MXY(3)%MP(KF2PT+1) = KF2*KSHIFT
      ENDIF
      IF (MXY(3)%MP(3) == 0) THEN
          MXY(3)%MP(1) = 1
          MXY(3)%MP(2) = 0
      ELSE
          MXY(3)%MP(1) = 1
      ENDIF

      IF (KEXP /= 0) THEN
          IF (KSIGNX == 1) THEN
              MXY(4)%MP(2) = INT(KEXP/KPOWER) + 1
              MXY(4)%MP(3) = 10**(MOD(KEXP,KPOWER))
          ELSE
              MXY(4)%MP(2) = -INT((KEXP-1)/KPOWER)
              KSHIFT = 10**(MOD(KEXP,KPOWER))
              IF (KSHIFT > 1) THEN
                  MXY(4)%MP(3) = QX%MBASE/KSHIFT
              ELSE
                  MXY(4)%MP(3) = 1
              ENDIF
          ENDIF
      ENDIF

      CALL FMADD2(MXY(2),MXY(3),MXY(5),QX)

      IF (KEXP > 0) CALL FMMPY2_R1(MXY(5),MXY(4),QX)
      MXY(5)%MP(1) = KSIGN

      RETURN

!             Error in converting the number.

  110 CALL FMIM(0,MXY(5),QX)
      MXY(5)%MP(2) = QX%MUNKNO
      MXY(5)%MP(3) = 1
      MXY(5)%MP(1) = 1
      QX%KFLAG = -7
      RETURN
      END SUBROUTINE FMINP2

      SUBROUTINE FMINP3(LINE,KSTART,KSTOP,MA,QX)

!  Internal routine to see if the input character string in LINE would overflow or underflow
!  with the current base and precision.

!  MA is returned as + or - over/underflow or unknown.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: KSTART,KSTOP
      CHARACTER :: LINE(KSTOP)
      INTEGER :: J,JSTATE,KDIGFL,KPT,KSIGN,KSIGNX,KTYPE,KVAL,N1,N2
      DOUBLE PRECISION :: X,F1,F2,FEXP,FLARGE
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/     &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      CHARACTER :: KBLANK = ' '
      INTENT (IN) :: LINE,KSTART,KSTOP
      INTENT (INOUT) :: MA

!             X will approximate the log of the magnitude of the number represented by LINE.

      JSTATE = 1
      KSIGN = 1
      F1 = 0
      F2 = 0
      N1 = 0
      N2 = 0
      KSIGNX = 1
      FEXP = 0
      FLARGE = HUGE(F1)/31

!             KDIGFL will be 1 if any digits are found before 'E'.

      KDIGFL = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (QX%LHASH == 0) CALL FMHTBL(QX)

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == KBLANK) CYCLE
         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = QX%KHASHT(KPT)
             KVAL  = QX%KHASHV(KPT)
         ENDIF
         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDIGFL = 1
             IF (F1 < FLARGE) THEN
                 F1 = 10.0D0*F1 + KVAL
             ELSE
                 N1 = N1 + 1
             ENDIF

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDIGFL = 1
             IF (F2 < FLARGE) THEN
                 F2 = 10.0D0*F2 + KVAL
                 N2 = N2 + 1
             ENDIF

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDIGFL == 0) F1 = 1.0D0

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             IF (FEXP < FLARGE) THEN
                 FEXP = 10*FEXP + KVAL
             ENDIF

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Check to see if the number would over/underflow.

      IF (F1 > 0) THEN
          X = LOG(F1) + (FEXP+N1)*LOG(10.0D0)
      ELSE IF (F2 > 0) THEN
          X = LOG(F2) - N2*LOG(10.0D0) + FEXP*LOG(10.0D0)
      ENDIF
      IF (X > (QX%MXEXP2/2.0D0)*LOG(DBLE(QX%MBASE)) .AND. KSIGNX > 0) THEN
          CALL FMIM(0,MA,QX)
          MA%MP(2) = QX%MEXPOV
          MA%MP(3) = 1
          MA%MP(1) = KSIGN
          QX%KFLAG = -5
      ELSE IF (X > (QX%MXEXP2/2.0D0)*LOG(DBLE(QX%MBASE)) .AND. KSIGNX < 0) THEN
          CALL FMIM(0,MA,QX)
          MA%MP(2) = QX%MEXPUN
          MA%MP(3) = 1
          MA%MP(1) = KSIGN
          QX%KFLAG = -6
      ELSE
          GO TO 110
      ENDIF

      RETURN

!             Error in converting the number.

  110 CALL FMIM(0,MA,QX)
      MA%MP(2) = QX%MUNKNO
      MA%MP(3) = 1
      MA%MP(1) = 1
      QX%KFLAG = -7
      RETURN
      END SUBROUTINE FMINP3

      SUBROUTINE FMINT(MA,MB,QX)

!  MB = INT(MA)

!  The integer part of MA is computed and returned in MB as a multiple precision floating
!  point number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,KA,KB,KRESLT,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMINT'
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMARGS('FMINT    ',1,MA,MB,KRESLT,QX)
          IF (KRESLT /= 0) THEN
              CALL FMRSLT(MA,MA,MB,KRESLT,QX)
              IF (QX%NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
      ENDIF

      N1 = QX%NDIG + 1

!             If MA is less than one in magnitude, return zero.

      IF (MA%MP(2) <= 0) THEN
          DO J = 1, N1
             MB%MP(J+1) = 0
          ENDDO
          GO TO 110
      ENDIF

!             If the radix point is off the right end of MA then MA is already an integer.
!             Return MA.

      IF (MA%MP(2) >= QX%NDIG) THEN
          DO J = 1, N1
             MB%MP(J+1) = MA%MP(J+1)
          ENDDO
          GO TO 110
      ENDIF

!             Here MA has both integer and fraction parts.  Replace the digits right of the
!             radix point by zeros.

      KA = INT(MA%MP(2)) + 2
      KB = KA - 1
      DO J = 1, KB
         MB%MP(J+1) = MA%MP(J+1)
      ENDDO

      DO J = KA, N1
         MB%MP(J+1) = 0
      ENDDO

  110 MB%MP(1) = MA%MP(1)
      IF (MB%MP(3) == 0) MB%MP(1) = 1
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMINT

      SUBROUTINE FMIPWR(MA,IVAL,MB,QX)

!  MB = MA ** IVAL

!  This routine performs the trace printing for integer power.  FMIPWR2 is used to do
!  the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMIPWR'
          CALL FMNTR(2,MA,MA,1,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)

          CALL FMIPWR2(MA,IVAL,MB,QX)

          CALL FMNTR(1,MB,MB,1,1,QX)
      ELSE
          CALL FMIPWR2(MA,IVAL,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMIPWR

      SUBROUTINE FMIPWR2(MA,IVAL,MB,QX)

!  MB = MA ** IVAL

!  Raise an FM number to an integer power.
!  The binary multiplication method used requires an average of 1.5 * LOG2(IVAL) multiplications.
!  MA may be negative.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JSIGN,K,KL,KR_RETRY,KWRNSV,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0

!             Check for special cases.

      IF (MA%MP(2) == QX%MUNKNO .OR. (IVAL <= 0 .AND. MA%MP(3) == 0)) THEN
          QX%KFLAG = -4
          IF (IVAL <= 0 .AND. MA%MP(3) == 0) THEN
              QX%NAMEST(QX%NCALL) = 'FMIPWR'
              CALL FMWARN(QX)
          ENDIF
          CALL FMIM(0,MB,QX)
          MB%MP(2) = QX%MUNKNO
          MB%MP(3) = 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(1,MB,QX)
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          KWRNSV = QX%KWARN
          QX%KWARN = 0
          IF (IVAL == 1) THEN
              CALL FMEQ(MA,MB,QX)
          ELSE
              CALL FMIM(1,MXY(1),QX)
              CALL FMDIV2(MXY(1),MA,MB,QX)
          ENDIF
          QX%KWARN = KWRNSV
          RETURN
      ENDIF

      IF (MA%MP(3) == 0) THEN
          CALL FMEQ(MA,MB,QX)
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPOV) THEN
          JSIGN = 1
          IF (MA%MP(1) < 0) JSIGN = -1
          CALL FMIM(0,MB,QX)
          IF (IVAL > 0) THEN
              CALL FMIM(1,MB,QX)
              MB%MP(2) = QX%MEXPOV
              MB%MP(3) = 1
              MB%MP(1) = JSIGN**MOD(IVAL,2)
              QX%KFLAG = -5
          ELSE
              CALL FMIM(1,MB,QX)
              MB%MP(2) = QX%MEXPUN
              MB%MP(3) = 1
              MB%MP(1) = JSIGN**MOD(IVAL,2)
              QX%KFLAG = -6
          ENDIF
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPUN) THEN
          JSIGN = 1
          IF (MA%MP(1) < 0) JSIGN = -1
          CALL FMIM(0,MB,QX)
          IF (IVAL > 0) THEN
              CALL FMIM(1,MB,QX)
              MB%MP(2) = QX%MEXPUN
              MB%MP(3) = 1
              MB%MP(1) = JSIGN**MOD(IVAL,2)
              QX%KFLAG = -6
          ELSE
              CALL FMIM(1,MB,QX)
              MB%MP(2) = QX%MEXPOV
              MB%MP(3) = 1
              MB%MP(1) = JSIGN**MOD(IVAL,2)
              QX%KFLAG = -5
          ENDIF
          RETURN
      ENDIF
      KR_RETRY = 0

!             Increase the working precision.

      NDSAVE = QX%NDIG
  110 IF (QX%NCALL == 1) THEN
          XVAL = ABS(IVAL)
          K = INT((5.0*REAL(QX%DLOGTN) + LOG(XVAL))/QX%ALOGMB + QX%NGRD52 - 1)
          QX%NDIG = MAX(QX%NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = ABS(IVAL)
          IF (XVAL > 10.0 .OR. REAL(QX%MBASE) <= 999.0) THEN
              K = INT(LOG(XVAL)/QX%ALOGMB + 1.0)
              QX%NDIG = QX%NDIG + K
          ENDIF
      ENDIF

!             Initialize.

      K = ABS(IVAL)
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

!             Handle small exponents by hand.

      IF (K == 2) THEN
          CALL FMSQR2(MXY(1),MXY(2),QX)
          GO TO 130
      ENDIF
      IF (K == 3) THEN
          CALL FMSQR2(MXY(1),MXY(2),QX)
          CALL FMMPY2_R1(MXY(2),MXY(1),QX)
          GO TO 130
      ENDIF
      IF (K == 4) THEN
          CALL FMSQR2(MXY(1),MXY(2),QX)
          CALL FMSQR2_R1(MXY(2),QX)
          GO TO 130
      ENDIF
      IF (K == 5) THEN
          CALL FMSQR2(MXY(1),MXY(2),QX)
          CALL FMSQR2_R1(MXY(2),QX)
          CALL FMMPY2_R1(MXY(2),MXY(1),QX)
          GO TO 130
      ENDIF

      IF (MOD(K,2) == 0) THEN
          CALL FMIM(1,MXY(2),QX)
      ELSE
          CALL FMEQ(MXY(1),MXY(2),QX)
      ENDIF

!             This is the multiplication loop.

  120 K = K/2
      CALL FMSQR2_R1(MXY(1),QX)
      IF (MOD(K,2) == 1) CALL FMMPY2_R2(MXY(1),MXY(2),QX)
      IF (K > 1) GO TO 120

!             Invert if the exponent is negative.

  130 IF (IVAL < 0) THEN
          CALL FMIM(1,MXY(1),QX)
          CALL FMDIV2_R2(MXY(1),MXY(2),QX)
      ENDIF
      QX%KWARN = KWRNSV

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result and return.

      CALL FMEQU(MXY(2),MB,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMIPWR'
          CALL FMWARN(QX)
      ENDIF
      RETURN
      END SUBROUTINE FMIPWR2

      SUBROUTINE FMLG10(MA,MB,QX)

!  MB = LOG10(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MLN2,MLN3,MLN5,MLN7
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      REAL :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGLI = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0 .OR. MA%MP(1) < 0) THEN
          CALL FMENTR('FMLG10   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMLG10'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF

      IF (MA%MP(2) == 0 .OR. MA%MP(2) == 1) THEN
          X = REAL(QX%MBASE)
          X = X**(INT(MA%MP(2))-1)*(REAL(MA%MP(3))+REAL(MA%MP(4))/X)
      ELSE
          X = 2.0
      ENDIF
      IF (X > 0.9 .AND. X < 1.1) QX%NDIG = QX%NDIG + 1

      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)

      CALL FMLN(MXY(2),MXY(3),QX)
          CALL FMLNI(10,MXY(1),MLN2,MLN3,MLN5,MLN7,QX)
      CALL FMDIV(MXY(3),MXY(1),MXY(2),QX)

!             Round the result and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMLG10

      SUBROUTINE FMLN(MA,MB,QX)

!  MB = LOG(MA)     (Natural logarithm)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      DOUBLE PRECISION :: Y
      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MLBSAV,MLN2,MLN3,MLN5,MLN7
      INTEGER :: JEXP(8,4),KEXP(4),NSTACK(49)
      REAL (KIND(1.0D0)) :: MA1,MXSAVE
      DOUBLE PRECISION :: ERR,XV(8)
      INTEGER :: IEXTRA,IVAL,J,J2,K,K2,K2EXP,KE1,KL,KM1,KR_RETRY,KOVUN,KRESLT,KSCALE,KST,  &
                 KWRNSV,LAST,M,N1,N3,NDSAV1,NDSAVE,NDSV,NMETHD,NTERM
      REAL :: TJ,X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(6),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGLI = 0
      QX%NDIGLB = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0 .OR. MA%MP(1) < 0) THEN
          CALL FMENTR('FMLN     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMLN'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      MA1 = MA%MP(2)
      CALL FMEQU(MA,MXY(5),NDSAVE,QX%NDIG,QX)

!             Check to see if the argument is a small integer.  If so use FMLNI.

      KM1 = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(5),IVAL,QX)
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 0 .AND. IVAL < MXBASE) THEN
          CALL FMLNI(IVAL,MXY(6),MLN2,MLN3,MLN5,MLN7,QX)
          GO TO 180
      ENDIF

!             See if the argument can be scaled to a small integer.

      N3 = QX%NDIG + 3
      N1 = QX%NDIG + 1
      DO J = 2, N1
         IF (MXY(5)%MP(N3-J+1) /= 0) THEN
             LAST = N3 - J - 1
             GO TO 120
         ENDIF
      ENDDO

  120 KSCALE = INT(MA1) - LAST
      MXY(5)%MP(2) = LAST
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(5),IVAL,QX)
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 0 .AND. IVAL < MXBASE) THEN
          CALL FMLNI(IVAL,MXY(4),MLN2,MLN3,MLN5,MLN7,QX)
          IF (IVAL == 1) KM1 = 1
          K2EXP = 0
          GO TO 170
      ENDIF

      NMETHD = 1
      IF (QX%NDIG*QX%DLOGMB/QX%DLOGTN > 110000) NMETHD = 2
      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 160

!             Method 1.  Convert MA to a value x close to 1, then use the Taylor series:
!                        Ln(x) = 2*( t + t^3/3 + t^5/5 + ...), where t = (x-1)/(x+1).

!             The argument will be moved closer to 1 by removing the base mbase exponent, and then
!             multiplying by powers of 2, 3, 5, 7 before the series is summed.  The series will be
!             added as J2 concurrent series.

      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
      MXY(2)%MP(2) = 0
      CALL FMM2DP(MXY(2),Y,QX)
      KE1 = 0
      IF (Y*QX%MBASE < 1 + 1.0D-7) THEN
          Y = Y * QX%MBASE
          MXY(2)%MP(2) = 1
          KE1 = 1
      ENDIF
      JEXP(1,1:4) = (/    1,   1,  -1,   0 /)
      JEXP(2,1:4) = (/    2,   2,  -1,  -1 /)
      JEXP(3,1:4) = (/    6,   0,  -5,   2 /)
      JEXP(4,1:4) = (/   -5,  -1,  -2,   4 /)
      JEXP(5,1:4) = (/    3, -13,  10,  -2 /)
      JEXP(6,1:4) = (/   51, -13,  -1, -10 /)
      JEXP(7,1:4) = (/    9, -28,  37, -18 /)
      JEXP(8,1:4) = (/ -193,  -6,   5,  68 /)
      KEXP(1:4) = 0
      XV(1:8) = (/ 1.2000000000000000D0, 1.0285714285714286D0, 1.0035200000000000D0,  &
                   1.0004166666666667D0, 1.0000406160495965D0, 1.0000070529094230D0,  &
                   1.0000006193987026D0, 1.0000001178537107D0  /)
      DO
         IF (7*Y <= 1 + 1.0D-7) THEN
             Y = 7*Y
             KEXP(4) = KEXP(4) + 1
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (5*Y <= 1 + 1.0D-7) THEN
          Y = 5*Y
          KEXP(3) = KEXP(3) + 1
      ENDIF
      IF (3*Y <= 1 + 1.0D-7) THEN
          Y = 3*Y
          KEXP(2) = KEXP(2) + 1
      ENDIF
      IF (2*Y <= 1 + 1.0D-7) THEN
          Y = 2*Y
          KEXP(1) = KEXP(1) + 1
      ENDIF
      K2 = 5 + SQRT(NDSAVE*QX%DLOGMB/QX%DLOGTN)/15
      IF (K2 < 5) K2 = 5
      IF (K2 > 8) K2 = 8
      DO J = 1, K2
         K = -LOG(Y)/LOG(XV(J))
         Y = Y * 2.0D0**(K*JEXP(J, 1))
         KEXP(1) = KEXP(1) + K*JEXP(J, 1)
         Y = Y * 3.0D0**(K*JEXP(J, 2))
         KEXP(2) = KEXP(2) + K*JEXP(J, 2)
         Y = Y * 5.0D0**(K*JEXP(J, 3))
         KEXP(3) = KEXP(3) + K*JEXP(J, 3)
         Y = Y * 7.0D0**(K*JEXP(J, 4))
         KEXP(4) = KEXP(4) + K*JEXP(J, 4)
      ENDDO
      CALL FMI2M(1,MXY(3),QX)
      IF (KEXP(1) > 0) THEN
          CALL FMCSMPYIN_R1(MXY(2),2,KEXP(1),QX)
      ELSE IF (KEXP(1) < 0) THEN
          CALL FMCSMPYIN_R1(MXY(3),2,-KEXP(1),QX)
      ENDIF
      IF (KEXP(2) > 0) THEN
          CALL FMCSMPYIN_R1(MXY(2),3,KEXP(2),QX)
      ELSE IF (KEXP(2) < 0) THEN
          CALL FMCSMPYIN_R1(MXY(3),3,-KEXP(2),QX)
      ENDIF
      IF (KEXP(3) > 0) THEN
          CALL FMCSMPYIN_R1(MXY(2),5,KEXP(3),QX)
      ELSE IF (KEXP(3) < 0) THEN
          CALL FMCSMPYIN_R1(MXY(3),5,-KEXP(3),QX)
      ENDIF
      IF (KEXP(4) > 0) THEN
          CALL FMCSMPYIN_R1(MXY(2),7,KEXP(4),QX)
      ELSE IF (KEXP(4) < 0) THEN
          CALL FMCSMPYIN_R1(MXY(3),7,-KEXP(4),QX)
      ENDIF
      IF (KEXP(1) < 0 .OR. KEXP(2) < 0 .OR. KEXP(3) < 0 .OR. KEXP(4) < 0) THEN
          CALL FMDIV_R1(MXY(2),MXY(3),QX)
      ENDIF
      CALL FMI2M(1,MXY(3),QX)
      CALL FMSUB(MXY(2),MXY(3),MXY(4),QX)
      CALL FMADD(MXY(2),MXY(3),MXY(5),QX)
      CALL FMDIV(MXY(4),MXY(5),MXY(1),QX)

      TJ = 1.25D0 + (NDSAVE*QX%DLOGMB/QX%DLOGTN)**0.6D0/18
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMI2M(1,MXY(2),QX)
      NTERM = 1
      DO J = 1, J2
         CALL FMCSDIVI(MXY(2),NTERM,MJSUMS(J),QX)
         NTERM = NTERM + 2
      ENDDO
      CALL FMIPWR(MXY(1),2*J2,MXY(3),QX)

  130 IF (NTERM > 2*J2+1) THEN
          CALL FMCSMPY_R1(MXY(2),MXY(3),QX)
      ELSE
          CALL FMEQ(MXY(3),MXY(2),QX)
      ENDIF
      DO J = 1, J2
         CALL FMCSDIVI(MXY(2),NTERM,MXY(4),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMSQR(MXY(1),MXY(4),QX)
      CALL FMEQ(MJSUMS(J2),MXY(3),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(4),QX)
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1),QX)
      ENDDO
      CALL FMMPY(MXY(3),MXY(1),MXY(6),QX)
      CALL FMMPYI_R1(MXY(6),2,QX)
      K = MA%MP(2) - KE1
      J = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD21
      CALL FMEQU_R1(MXY(6),J,QX%NDIG,QX)
      IF (K /= 0) THEN
              CALL FMLNI(INT(QX%MBASE),MLBSAV,MLN2,MLN3,MLN5,MLN7,QX)
              QX%MBSLB = QX%MBASE
              QX%NDIGLB = QX%NDIG
              CALL FMMPYI(MLBSAV,K,MXY(5),QX)
          CALL FMADD_R1(MXY(6),MXY(5),QX)
      ENDIF
      IF (QX%NDIGLI < QX%NDIG .OR. QX%MBASE /= QX%MBSLI) THEN
          CALL FMLNI(210,MXY(2),MLN2,MLN3,MLN5,MLN7,QX)
      ENDIF
      IF (KEXP(1) /= 0) THEN
          CALL FMCSMPYI(MLN2,KEXP(1),MXY(3),QX)
          CALL FMSUB_R1(MXY(6),MXY(3),QX)
      ENDIF
      IF (KEXP(2) /= 0) THEN
          CALL FMCSMPYI(MLN3,KEXP(2),MXY(3),QX)
          CALL FMSUB_R1(MXY(6),MXY(3),QX)
      ENDIF
      IF (KEXP(3) /= 0) THEN
          CALL FMCSMPYI(MLN5,KEXP(3),MXY(3),QX)
          CALL FMSUB_R1(MXY(6),MXY(3),QX)
      ENDIF
      IF (KEXP(4) /= 0) THEN
          CALL FMCSMPYI(MLN7,KEXP(4),MXY(3),QX)
          CALL FMSUB_R1(MXY(6),MXY(3),QX)
      ENDIF
      GO TO 180

!             Method 2.  Use AGM iteration.

  150 CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      MXY(1)%MP(2) = 0
      CALL FMM2DP(MXY(1),Y,QX)
      M = MAX(1,INT((QX%NDIG*QX%DLOGMB/36 - LOG(Y))/QX%DLOGTW + 1))
      CALL FMCSMPYIN_R1(MXY(1),2,M,QX)
      CALL FMI2M(1,MXY(2),QX)
      CALL FMDIV(MXY(2),MXY(1),MXY(4),QX)
      CALL FMEQ(MXY(4),MXY(2),QX)
      CALL FMSQR(MXY(2),MXY(5),QX)
      CALL FMSQR(MXY(5),MXY(3),QX)
      CALL FMSQR(MXY(3),MXY(5),QX)
      CALL FMMPY(MXY(4),MXY(5),MXY(6),QX)
      CALL FMADD_R1(MXY(2),MXY(6),QX)
      CALL FMSQR_R1(MXY(5),QX)
      CALL FMADD_R1(MXY(3),MXY(5),QX)
      CALL FMMPY_R1(MXY(5),MXY(6),QX)
      CALL FMADD_R1(MXY(2),MXY(5),QX)
      CALL FMMPYI_R1(MXY(2),2,QX)
      CALL FMMPYI_R1(MXY(3),2,QX)
      CALL FMI2M(1,MXY(5),QX)
      CALL FMADD_R1(MXY(3),MXY(5),QX)
      CALL FMMPY(MXY(2),MXY(3),MXY(5),QX)
      CALL FMSQR_R1(MXY(2),QX)
      CALL FMSQR_R1(MXY(3),QX)
      CALL FMADD(MXY(2),MXY(3),MXY(4),QX)
      CALL FMDIVI(MXY(4),2,MXY(2),QX)
      CALL FMEQ(MXY(5),MXY(3),QX)
      DO
         CALL FMSUB(MXY(3),MXY(2),MXY(4),QX)
         IF (MXY(4)%MP(3) == 0 .OR.  &
             MXY(4)%MP(2) - MAX(MXY(2)%MP(2),MXY(3)%MP(2)) <= -QX%NDIG+1) EXIT
         CALL FMDIVI_R1(MXY(4),2,QX)
         CALL FMMPY(MXY(2),MXY(3),MXY(5),QX)
         CALL FMSQRT(MXY(5),MXY(3),QX)
         CALL FMADD_R1(MXY(2),MXY(4),QX)
      ENDDO

      CALL FMPI(MXY(1),QX)
      CALL FMMPYI_R1(MXY(2),4,QX)
      CALL FMDIV_R1(MXY(1),MXY(2),QX)
      IF (QX%NDIGLI >= QX%NDIG .AND. QX%MBASE == QX%MBSLI) THEN
          CALL FMMPYI(MLN2,M,MXY(3),QX)
      ELSE
          CALL FMLNI(2,MXY(2),MLN2,MLN3,MLN5,MLN7,QX)
          CALL FMMPYI(MXY(2),M,MXY(3),QX)
      ENDIF
      CALL FMSUB(MXY(1),MXY(3),MXY(6),QX)
      K = MA%MP(2)
      IF (K /= 0) THEN
              CALL FMLNI(INT(QX%MBASE),MLBSAV,MLN2,MLN3,MLN5,MLN7,QX)
              QX%MBSLB = QX%MBASE
              QX%NDIGLB = QX%NDIG
              CALL FMMPYI(MLBSAV,K,MXY(5),QX)
          CALL FMADD_R1(MXY(6),MXY(5),QX)
      ENDIF
      GO TO 180

!             Method 3.  Use Newton iteration.

  160 MA1 = MA%MP(2)
      CALL FMEQU(MA,MXY(5),NDSAVE,QX%NDIG,QX)

!             Compute IEXTRA, the number of extra digits required.

      CALL FMI2M(1,MXY(4),QX)
      CALL FMSUB_R1(MXY(4),MXY(5),QX)
      IF (MA%MP(2) == 0 .OR. MA%MP(2) == 1) THEN
          X = REAL(QX%MBASE)
          X = X**(INT(MA%MP(2))-1)*(REAL(MA%MP(3))+REAL(MA%MP(4))/X)
      ELSE
          X = 2.0
      ENDIF
      IEXTRA = MAX(0-INT(MXY(4)%MP(2)),0)
      IF (X > 0.9 .AND. X < 1.1) IEXTRA = IEXTRA + 1
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(5),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA

!             Scale the argument to lie between e/2 and e to speed up the calls to FMEXP.

      MXY(5)%MP(2) = 1
      KSCALE = INT(MA1) - 1
      CALL FMM2DP(MXY(5),Y,QX)
      K2EXP = INT(LOG(2.0*REAL(Y)/2.71828)/0.693147)
      IF (Y < 1.359141) THEN
          K2EXP = -1
          CALL FMMPYI_R1(MXY(5),2,QX)
          Y = 2.0D0*Y
      ELSE
          K2 = 2**K2EXP
          CALL FMDIVI_R1(MXY(5),K2,QX)
          Y = Y/K2
      ENDIF

!             Generate the initial approximation.

      CALL FMI2M(0,MXY(2),QX)
      CALL FMI2M(0,MXY(6),QX)
      Y = LOG(Y)
      CALL FMDPM(Y,MXY(4),QX)
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration.

      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         CALL FMEXP(MXY(4),MXY(6),QX)
         CALL FMSUB(MXY(5),MXY(6),MXY(2),QX)
         CALL FMDIV_R2(MXY(2),MXY(6),QX)
         CALL FMADD_R1(MXY(4),MXY(6),QX)
      ENDDO

!             Compute LN(MBASE**KSCALE).

  170     NDSV = QX%NDIG
          QX%NDIG = QX%NDIG + 2 + QX%NDIG/100
          CALL FMLNI(INT(QX%MBASE),MLBSAV,MLN2,MLN3,MLN5,MLN7,QX)
          QX%MBSLB = QX%MBASE
          QX%NDIGLB = QX%NDIG
          IF (ABS(MLBSAV%MP(2)) > 10) QX%NDIGLB = 0
          QX%NDIG = NDSV

      IF (KSCALE /= 0 .AND. KM1 == 0) THEN
          CALL FMMPYI(MLBSAV,KSCALE,MXY(6),QX)
          CALL FMADD_R2(MXY(4),MXY(6),QX)
      ELSE IF (KSCALE /= 0 .AND. KM1 == 1) THEN
          CALL FMMPYI(MLBSAV,KSCALE,MXY(6),QX)
      ELSE IF (KSCALE == 0 .AND. KM1 == 0) THEN
          CALL FMEQ(MXY(4),MXY(6),QX)
      ELSE IF (KSCALE == 0 .AND. KM1 == 1) THEN
          CALL FMI2M(0,MXY(6),QX)
      ENDIF

      IF (K2EXP /= 0) THEN
          IF (QX%MBASE /= QX%MBSLI .OR. QX%NDIG > QX%NDIGLI) THEN
              CALL FMLNI(2,MXY(4),MLN2,MLN3,MLN5,MLN7,QX)
          ENDIF
          CALL FMMPYI(MLN2,K2EXP,MXY(4),QX)
          CALL FMADD_R1(MXY(6),MXY(4),QX)
      ENDIF

!             Round the result and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(6)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KOVUN,QX)
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      RETURN
      END SUBROUTINE FMLN

      SUBROUTINE FMLNI(IVAL,MA,MLN2,MLN3,MLN5,MLN7,QX)

!  MA = LOG(IVAL)

!  Compute the natural logarithm of an integer IVAL.

!  If IVAL has only powers of 2, 3, 5, and 7 in its factorization then FMLNI is faster than FMLN.
!  Otherwise, if IVAL >= MXBASE (i.e., IVAL does not fit in 1/2 word) then FMLN is usually faster.

!  Use FMLN instead of FMLNI if 10*IVAL would cause integer overflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(MULTI) :: MLN2,MLN3,MLN5,MLN7
      INTEGER :: IVAL
      CHARACTER(155) :: STRING
      INTEGER :: INT2,J,J2,J3,J5,J7,JTEMP2,JTEMP3,JTEMP5,JTEMP7,K,K2,K3,K5,K7,KDELTA,KL,  &
                 KR_RETRY,LAST,N,ND,NDMB,NDSAVE,NDSV,NT
      REAL :: XVAL
      DOUBLE PRECISION :: ERR
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(6)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMLNI'
      IF (QX%NTRACE /= 0) CALL FMNTRI(2,IVAL,1,QX)

!             Check for special cases.

      IF (IVAL <= 0) THEN
          QX%KFLAG = -4
          CALL FMWARN(QX)
          CALL FMST2M('UNKNOWN',MA,QX)
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      IF (IVAL == 1) THEN
          CALL FMI2M(0,MA,QX)
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

!             Increase the working precision.

      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = QX%NGRD52
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF

!             Find integers K2, K3, K5, and K7 such that
!                NT = 2**K2 * 3**K3 * 5**K5 * 7**K7
!             is a good approximation of IVAL.
!             KDELTA = ABS(IVAL - NT).

      INT2 = IVAL
      IF (IVAL > INTMAX/100) INT2 = IVAL/100
      KDELTA = INT2
      NT = 0
      K2 = 0
      K3 = 0
      K5 = 0
      K7 = 0

!             Start the search loop.

      XVAL = INT2
      LAST = INT(LOG(DBLE(XVAL))/QX%DLOGTW + 2.0D0)

      JTEMP7 = 1
      DO J7 = 1, LAST
         IF (JTEMP7 > INT2 .AND. ABS(JTEMP7-INT2) > KDELTA) GO TO 150

         JTEMP5 = JTEMP7
         DO J5 = 1, LAST
            IF (JTEMP5 > INT2 .AND. ABS(JTEMP5-INT2) > KDELTA) GO TO 140

            JTEMP3 = JTEMP5
            DO J3 = 1, LAST
               IF (JTEMP3 > INT2 .AND. ABS(JTEMP3-INT2) > KDELTA) GO TO 130

               JTEMP2 = JTEMP3
               DO J2 = 1, LAST
                  IF (ABS(JTEMP2-INT2) <= KDELTA) THEN
                      IF (ABS(JTEMP2-INT2) == KDELTA .AND. JTEMP2 < INT2) GO TO 120
                      KDELTA = ABS(JTEMP2-INT2)
                      NT = JTEMP2
                      K2 = J2 - 1
                      K3 = J3 - 1
                      K5 = J5 - 1
                      K7 = J7 - 1
                      IF (KDELTA == 0) GO TO 150
                  ENDIF
                  IF (JTEMP2 > INT2) GO TO 120

                  JTEMP2 = 2*JTEMP2
               ENDDO

  120          JTEMP3 = 3*JTEMP3
            ENDDO

  130       JTEMP5 = 5*JTEMP5
         ENDDO

  140    JTEMP7 = 7*JTEMP7
      ENDDO

!             If IVAL was too close to the integer overflow limit, restore NT to an
!             approximation of IVAL.

  150 IF (INT2 /= IVAL) THEN
          IF (NT <= INT2) THEN
              NT = NT*100
              K2 = K2 + 2
              K5 = K5 + 2
          ELSE IF (NT <= IVAL/98) THEN
              NT = NT*98
              K2 = K2 + 1
              K7 = K7 + 2
          ELSE
              NT = NT*70
              K2 = K2 + 1
              K5 = K5 + 1
              K7 = K7 + 1
          ENDIF
      ENDIF

!             End of the search.
!             Now compute LN(NT) as a linear combination of LN(2), LN(3), LN(5), and LN(7).

          NDMB = INT(150.0*2.302585/QX%ALOGMB)
          IF (NDMB >= QX%NDIG) THEN
              NDSV = QX%NDIG
              QX%NDIG = NDMB
              STRING = '0.693147180559945309417232121458176568075500'//  &
              '13436025525412068000949339362196969471560586332699641'//  &
              '8687542001481020570685733685520235758130557032670751635'
              CALL FMST2M(STRING,MLN2,QX)
              STRING = '1.098612288668109691395245236922525704647490'//  &
              '55782274945173469433363749429321860896687361575481373'//  &
              '2088787970029065957865742368004225930519821052801870767'
              CALL FMST2M(STRING,MLN3,QX)
              STRING = '1.609437912434100374600759333226187639525601'//  &
              '35426851772191264789147417898770765776463013387809317'//  &
              '9610799966303021715562899724005229324676199633616617464'
              CALL FMST2M(STRING,MLN5,QX)
              STRING = '1.945910149055313305105352743443179729637084'//  &
              '72958186118845939014993757986275206926778765849858787'//  &
              '1526993061694205851140911723752257677786843148958095164'
              CALL FMST2M(STRING,MLN7,QX)
              QX%MBSLI = QX%MBASE
              QX%NDIGLI = QX%NDIG
              IF (ABS(MLN2%MP(2)) > 10 .OR. ABS(MLN3%MP(2)) > 10 .OR.  &
                  ABS(MLN5%MP(2)) > 10 .OR. ABS(MLN7%MP(2)) > 10) QX%NDIGLI = 0
          ELSE
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2 + QX%NDIG/100
              QX%MBSLI = QX%MBASE
              QX%NDIGLI = QX%NDIG

!                 If precision is high, use the binary splitting method.

              IF (QX%NDIG < 40) THEN

                  CALL FMLNI2(1,126,MLN2,QX)
                  CALL FMLNI2(1,225,MLN3,QX)
                  CALL FMLNI2(1,2401,MLN5,QX)
                  CALL FMLNI2(1,4375,MLN7,QX)

!                    Get Ln(2).

                  CALL FMMPYI_R1(MLN2,-72,QX)
                  CALL FMMPYI(MLN3,-27,MXY(3),QX)
                  CALL FMADD_R1(MLN2,MXY(3),QX)
                  CALL FMMPYI(MLN5,19,MXY(3),QX)
                  CALL FMADD_R1(MLN2,MXY(3),QX)
                  CALL FMMPYI(MLN7,-31,MXY(3),QX)
                  CALL FMADD_R1(MLN2,MXY(3),QX)

!                    Get Ln(3).

                  CALL FMMPYI_R1(MLN3,-3,QX)
                  CALL FMMPYI(MLN2,19,MXY(3),QX)
                  CALL FMADD_R1(MLN3,MXY(3),QX)
                  CALL FMSUB_R1(MLN3,MLN5,QX)
                  CALL FMADD_R1(MLN3,MLN7,QX)
                  CALL FMDIVI_R1(MLN3,12,QX)

!                    Get Ln(5).

                  CALL FMSUB_R1(MLN5,MLN2,QX)
                  CALL FMMPYI(MLN3,27,MXY(3),QX)
                  CALL FMADD_R1(MLN5,MXY(3),QX)
                  CALL FMMPYI(MLN7,-4,MXY(3),QX)
                  CALL FMADD_R1(MLN5,MXY(3),QX)
                  CALL FMDIVI_R1(MLN5,18,QX)

!                    Get Ln(7).

                  CALL FMSUB_R2(MLN2,MLN7,QX)
                  CALL FMMPYI(MLN3,7,MXY(3),QX)
                  CALL FMADD_R1(MLN7,MXY(3),QX)
                  CALL FMMPYI(MLN5,-4,MXY(3),QX)
                  CALL FMADD_R1(MLN7,MXY(3),QX)
              ELSE
                  CALL FMLNI3(MLN2,MLN3,MLN5,MLN7,QX)
              ENDIF
          ENDIF
          IF (ABS(MLN2%MP(2)) > 10 .OR. ABS(MLN3%MP(2)) > 10 .OR.  &
              ABS(MLN5%MP(2)) > 10 .OR. ABS(MLN7%MP(2)) > 10) QX%NDIGLI = 0
          QX%NDIG = NDSV

!             If NT /= IVAL then the final step is to compute LN(IVAL/NT) and then use
!             LN(IVAL) = LN(IVAL/NT) + LN(NT).

      IF (NT /= IVAL) THEN
          ND = NT - IVAL
          IF (QX%NDIG < 40) THEN
              CALL FMLNI2(ND,NT,MXY(3),QX)
          ELSE
              IF (IVAL == NT-1) THEN
                  N = 2*IVAL + 1
                  K = QX%NDIG*QX%DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3),QX)
                  CALL IMI2FM(MXY(1),MXY(4),QX)
                  CALL IMI2FM(MXY(2),MXY(5),QX)
                  CALL IMI2FM(MXY(3),MXY(6),QX)
                  CALL FMDIV(MXY(6),MXY(5),MXY(2),QX)
                  CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
                  CALL FMMPYI(MXY(1),-2,MXY(2),QX)
                  CALL FMDIVI(MXY(2),N,MXY(3),QX)
              ELSE IF (IVAL == NT+1) THEN
                  N = 2*IVAL - 1
                  K = QX%NDIG*QX%DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3),QX)
                  CALL IMI2FM(MXY(1),MXY(4),QX)
                  CALL IMI2FM(MXY(2),MXY(5),QX)
                  CALL IMI2FM(MXY(3),MXY(6),QX)
                  CALL FMDIV(MXY(6),MXY(5),MXY(2),QX)
                  CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
                  CALL FMMPYI(MXY(1),2,MXY(2),QX)
                  CALL FMDIVI(MXY(2),N,MXY(3),QX)
              ELSE IF (IVAL == NT-2) THEN
                  N = IVAL + 1
                  K = QX%NDIG*QX%DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3),QX)
                  CALL IMI2FM(MXY(1),MXY(4),QX)
                  CALL IMI2FM(MXY(2),MXY(5),QX)
                  CALL IMI2FM(MXY(3),MXY(6),QX)
                  CALL FMDIV(MXY(6),MXY(5),MXY(2),QX)
                  CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
                  CALL FMMPYI(MXY(1),-2,MXY(2),QX)
                  CALL FMDIVI(MXY(2),N,MXY(3),QX)
              ELSE IF (IVAL == NT+2) THEN
                  N = IVAL - 1
                  K = QX%NDIG*QX%DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3),QX)
                  CALL IMI2FM(MXY(1),MXY(4),QX)
                  CALL IMI2FM(MXY(2),MXY(5),QX)
                  CALL IMI2FM(MXY(3),MXY(6),QX)
                  CALL FMDIV(MXY(6),MXY(5),MXY(2),QX)
                  CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
                  CALL FMMPYI(MXY(1),2,MXY(2),QX)
                  CALL FMDIVI(MXY(2),N,MXY(3),QX)
              ELSE
                  CALL FMLNI4(IVAL,NT,MXY(3),QX)
              ENDIF
          ENDIF
      ENDIF

      CALL FMMPYI(MLN2,K2,MXY(2),QX)
      CALL FMMPYI(MLN3,K3,MXY(1),QX)
      CALL FMADD_R1(MXY(2),MXY(1),QX)
      CALL FMMPYI(MLN5,K5,MXY(1),QX)
      CALL FMADD_R1(MXY(2),MXY(1),QX)
      CALL FMMPYI(MLN7,K7,MXY(1),QX)
      IF (NT /= IVAL) CALL FMADD_R1(MXY(2),MXY(3),QX)
      CALL FMADD(MXY(2),MXY(1),MXY(3),QX)

!             Round and move the result to MA.


!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEQU(MXY(3),MA,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMLNI

      SUBROUTINE FMLNI2(INT1,INT2,MA,QX)

!  MA = LN(1 - INT1/INT2)

!  Taylor series for computing the logarithm of a rational number near 1.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: INT1,INT2
      TYPE(MULTI) :: MA
      INTEGER :: J,NDSAVE
      INTENT (IN) :: INT1,INT2
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX


      CALL FMI2M(INT1,MXY(2),QX)
      CALL FMDIVI_R1(MXY(2),INT2,QX)
      CALL FMEQ(MXY(2),MA,QX)
      NDSAVE = QX%NDIG
      J = 1

  110 J = J + 1
      IF (INT1 /= 1) CALL FMMPYI_R1(MXY(2),INT1,QX)
      CALL FMDIVI_R1(MXY(2),INT2,QX)
      CALL FMDIVI(MXY(2),J,MXY(1),QX)
      QX%NDIG = NDSAVE
      CALL FMADD_R1(MA,MXY(1),QX)
      QX%NDIG = NDSAVE - INT(MA%MP(2)-MXY(1)%MP(2))
      IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      IF (QX%KFLAG /= 1) GO TO 110

      QX%NDIG = NDSAVE
      IF (MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0) MA%MP(1) = -MA%MP(1)
      RETURN
      END SUBROUTINE FMLNI2

      SUBROUTINE FMLNI3(MLN2,MLN3,MLN5,MLN7,QX)

!  Binary splitting version.  Faster for large NDIG.

!  Compute the four saved constants Ln(2), Ln(3), Ln(5), Ln(7).

      USE FMVALS_PARALLEL
      IMPLICIT NONE


      TYPE(MULTI) :: MLN2,MLN3,MLN5,MLN7
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: K,NDSAVE,N
      TYPE(MULTI) :: MXY(6)
      TYPE(FM_SETTINGS) :: QX

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = MAX(QX%NGRD52-1,2)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2

!             Determine K, the number of terms to sum in the series for
!             Ln( (N+1) / (N-1) ) = (2/N)*( 1 + 1/(3*d) + 1/(5*d**2) + ...), with d = N**2.
!             Four calls are made:  N = 251, 449, 4801, 8549.

      N = 251
      K = QX%NDIG*QX%DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3),QX)
      CALL IMI2FM(MXY(1),MXY(4),QX)
      CALL IMI2FM(MXY(2),MXY(5),QX)
      CALL IMI2FM(MXY(3),MXY(6),QX)
      CALL FMDIV(MXY(6),MXY(5),MXY(2),QX)
      CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
      CALL FMMPYI(MXY(1),2,MXY(2),QX)
      CALL FMDIVI(MXY(2),N,MLN2,QX)

      N = 449
      K = QX%NDIG*QX%DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3),QX)
      CALL IMI2FM(MXY(1),MXY(4),QX)
      CALL IMI2FM(MXY(2),MXY(5),QX)
      CALL IMI2FM(MXY(3),MXY(6),QX)
      CALL FMDIV(MXY(6),MXY(5),MXY(2),QX)
      CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
      CALL FMMPYI(MXY(1),2,MXY(2),QX)
      CALL FMDIVI(MXY(2),N,MLN3,QX)

      N = 4801
      K = QX%NDIG*QX%DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3),QX)
      CALL IMI2FM(MXY(1),MXY(4),QX)
      CALL IMI2FM(MXY(2),MXY(5),QX)
      CALL IMI2FM(MXY(3),MXY(6),QX)
      CALL FMDIV(MXY(6),MXY(5),MXY(2),QX)
      CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
      CALL FMMPYI(MXY(1),2,MXY(2),QX)
      CALL FMDIVI(MXY(2),N,MLN5,QX)

      N = 8749
      K = QX%NDIG*QX%DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3),QX)
      CALL IMI2FM(MXY(1),MXY(4),QX)
      CALL IMI2FM(MXY(2),MXY(5),QX)
      CALL IMI2FM(MXY(3),MXY(6),QX)
      CALL FMDIV(MXY(6),MXY(5),MXY(2),QX)
      CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
      CALL FMMPYI(MXY(1),2,MXY(2),QX)
      CALL FMDIVI(MXY(2),N,MLN7,QX)

!             Get Ln(2).

      CALL FMMPYI_R1(MLN2,72,QX)
      CALL FMMPYI(MLN3,27,MXY(3),QX)
      CALL FMADD_R1(MLN2,MXY(3),QX)
      CALL FMMPYI(MLN5,-19,MXY(3),QX)
      CALL FMADD_R1(MLN2,MXY(3),QX)
      CALL FMMPYI(MLN7,31,MXY(3),QX)
      CALL FMADD_R1(MLN2,MXY(3),QX)

!             Get Ln(3).

      CALL FMMPYI_R1(MLN3,3,QX)
      CALL FMMPYI(MLN2,19,MXY(3),QX)
      CALL FMADD_R1(MLN3,MXY(3),QX)
      CALL FMADD_R1(MLN3,MLN5,QX)
      CALL FMSUB_R1(MLN3,MLN7,QX)
      CALL FMDIVI_R1(MLN3,12,QX)

!             Get Ln(5).

      CALL FMADD_R1(MLN5,MLN2,QX)
      CALL FMMPYI(MLN3,27,MXY(3),QX)
      CALL FMSUB_R2(MXY(3),MLN5,QX)
      CALL FMMPYI(MLN7,4,MXY(3),QX)
      CALL FMADD_R1(MLN5,MXY(3),QX)
      CALL FMDIVI_R1(MLN5,18,QX)

!             Get Ln(7).

      CALL FMADD_R2(MLN2,MLN7,QX)
      CALL FMMPYI(MLN3,7,MXY(3),QX)
      CALL FMADD_R1(MLN7,MXY(3),QX)
      CALL FMMPYI(MLN5,-4,MXY(3),QX)
      CALL FMADD_R1(MLN7,MXY(3),QX)

      QX%MXEXP = MXSAVE
      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMLNI3

      RECURSIVE SUBROUTINE FMLNI3_QBT(A,B,N,MQ,MB,MT,QX)

!  This routine does the binary splitting for computing the constant Ln( (N+1) / (N-1) ).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MQ,MB,MT
      INTEGER :: A,B,N
      INTENT (IN) :: A,B,N
      INTENT (INOUT) :: MQ,MB,MT
      TYPE(MULTI) :: MXY(6)
      INTEGER :: J,KM,RESULT_SIZE
      REAL (KIND(0.0D0)) :: DA,DB
      TYPE(FM_SETTINGS) :: QX

      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(N)**2) ) / QX%DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      J = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -          &
                      ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 +  &
                      (DB-DA+1)*LOG(2.0D0) ) / QX%DLOGMB + 7
      RESULT_SIZE = RESULT_SIZE + J

      IF (B-A < 6) THEN
          CALL IMI2M(N,MXY(2),QX)
          CALL IMSQR(MXY(2),MXY(1),QX)
          CALL IMI2M(B-A+1,MXY(2),QX)
          CALL IMPWR(MXY(1),MXY(2),MQ,QX)

          CALL IMI2M(1,MB,QX)
          DO J = A+1, B, 2
             CALL IMMPYI(MB,2*J-1,MXY(1),QX)
             CALL IMMPYI(MXY(1),2*J+1,MB,QX)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MB,2*B+1,MXY(1),QX)
              CALL IMEQ(MXY(1),MB,QX)
          ENDIF

!             MT is the sum
!             MXY(2) is (N*N)^(J+1)

          CALL IMDIVI(MB,2*B+1,MXY(1),QX)
          CALL IMMPYI(MXY(1),N,MXY(2),QX)
          CALL IMMPYI(MXY(2),N,MT,QX)
          CALL IMI2M(N,MXY(1),QX)
          CALL IMSQR(MXY(1),MXY(2),QX)
          DO J = 1, B-A
             CALL IMDIVI(MB,2*B+1-2*J,MXY(3),QX)
             CALL IMMPYI(MXY(2),N,MXY(4),QX)
             CALL IMMPYI(MXY(4),N,MXY(2),QX)
             CALL IMMPY(MXY(2),MXY(3),MXY(4),QX)
             CALL IMADD(MT,MXY(4),MXY(5),QX)
             CALL IMEQ(MXY(5),MT,QX)
          ENDDO
          RETURN
      ENDIF

      KM = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMLNI3_QBT(A,KM-1,N,MXY(1),MXY(2),MXY(3),QX)
      CALL FMLNI3_QBT(KM,B,N,MXY(4),MXY(5),MXY(6),QX)
      CALL IMMPY(MXY(1),MXY(4),MQ,QX)
      CALL IMMPY(MXY(2),MXY(5),MB,QX)
      CALL IMMPY(MXY(5),MXY(4),MT,QX)
      CALL IMMPY(MXY(3),MT,MXY(1),QX)
      CALL IMMPY(MXY(2),MXY(6),MXY(3),QX)
      CALL IMADD(MXY(1),MXY(3),MT,QX)

      RETURN
      END SUBROUTINE FMLNI3_QBT

      SUBROUTINE FMLNI4(IVAL,NT,MA,QX)

!  Binary splitting version.  Faster for large NDIG.

!  MA = Ln(IVAL/NT).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL,NT
      INTENT (IN) :: IVAL,NT
      INTENT (INOUT) :: MA
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: A,B,K,NDSAVE,LEVEL_OF_RECURSION
      TYPE(MULTI) :: MXY(7)
      TYPE(FM_SETTINGS) :: QX

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = MAX(QX%NGRD52-1,2)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2

!             Determine K, the number of terms to sum in the series for
!             Ln( (B+A) / (B-A) ) = (2*A/B)*( 1 + 1/(3*d) + 1/(5*d^2) + ...), with d = (B/A)^2.

      A = ABS(IVAL - NT)
      B = IVAL + NT
      CALL FMGCDI(A,B)
      IF (IVAL-NT < 0) A = -A
      K = QX%NDIG*QX%DLOGMB/LOG(DBLE(B)**2/DBLE(A)**2) + 10
      LEVEL_OF_RECURSION = 0
      CALL FMLNI4_PQBT(0,K,A,B,MXY(1),MXY(2),MXY(3),MXY(4),LEVEL_OF_RECURSION,QX)
      CALL IMI2FM(MXY(2),MXY(5),QX)
      CALL IMI2FM(MXY(3),MXY(6),QX)
      CALL IMI2FM(MXY(4),MXY(7),QX)
      CALL FMDIV(MXY(7),MXY(6),MXY(2),QX)
      CALL FMDIV(MXY(2),MXY(5),MXY(1),QX)
      CALL FMMPYI(MXY(1),2*A,MXY(2),QX)
      CALL FMDIVI(MXY(2),B,MXY(3),QX)

      CALL FMEQU(MXY(3),MA,QX%NDIG,NDSAVE,QX)
      QX%MXEXP = MXSAVE
      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMLNI4

      RECURSIVE SUBROUTINE FMLNI4_PQBT(A,B,C,D,MP,MQ,MB,MT,LEVEL_OF_RECURSION,QX)

!  This routine does the binary splitting for computing the constant Ln( (B+A) / (B-A) ).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MP,MQ,MB,MT
      INTEGER :: A,B,C,D
      INTENT (IN) :: A,B,C,D
      INTENT (INOUT) :: MP,MQ,MB,MT
      TYPE(MULTI) :: MXY(8)
      INTEGER :: J,KM,RESULT_SIZE,LEVEL_OF_RECURSION
      REAL (KIND(0.0D0)) :: DA,DB
      TYPE(FM_SETTINGS) :: QX

      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(C)**2) ) / QX%DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(D)**2) ) / QX%DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      J = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -          &
                      ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 +  &
                      (DB-DA+1)*LOG(2.0D0) ) / QX%DLOGMB + 7
      RESULT_SIZE = RESULT_SIZE + J
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 6) THEN
          CALL IMI2M(C,MXY(2),QX)
          CALL IMSQR(MXY(2),MXY(1),QX)
          CALL IMI2M(B-A+1,MXY(2),QX)
          CALL IMPWR(MXY(1),MXY(2),MP,QX)

          CALL IMI2M(D,MXY(2),QX)
          CALL IMSQR(MXY(2),MXY(1),QX)
          CALL IMI2M(B-A+1,MXY(2),QX)
          CALL IMPWR(MXY(1),MXY(2),MQ,QX)

          CALL IMI2M(1,MB,QX)
          DO J = A+1, B, 2
             CALL IMMPYI(MB,2*J-1,MXY(1),QX)
             CALL IMMPYI(MXY(1),2*J+1,MB,QX)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MB,2*B+1,MXY(1),QX)
              CALL IMEQ(MXY(1),MB,QX)
          ENDIF

          CALL IMI2M(D,MXY(1),QX)
          CALL IMSQR(MXY(1),MXY(2),QX)
          CALL IMI2M(B-A+1,MXY(1),QX)
          CALL IMPWR(MXY(2),MXY(1),MXY(3),QX)

          CALL IMI2M(1,MXY(4),QX)
          CALL IMI2M(0,MT,QX)

          DO J = A, B
             CALL IMDIVI(MB,2*J+1,MXY(1),QX)
             CALL IMMPY(MXY(1),MXY(3),MXY(2),QX)
             CALL IMMPY(MXY(2),MXY(4),MXY(1),QX)
             CALL IMADD(MT,MXY(1),MXY(5),QX)
             CALL IMEQ(MXY(5),MT,QX)
             CALL IMDIVI(MXY(3),D,MXY(5),QX)
             CALL IMDIVI(MXY(5),D,MXY(3),QX)
             CALL IMMPYI(MXY(4),C,MXY(5),QX)
             CALL IMMPYI(MXY(5),C,MXY(4),QX)
          ENDDO
          GO TO 110
      ENDIF

      KM = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMLNI4_PQBT(A,KM-1,C,D,MXY(1),MXY(2),MXY(3),MXY(4),LEVEL_OF_RECURSION,QX)
      CALL FMLNI4_PQBT(KM,B,C,D,MXY(5),MXY(6),MXY(7),MXY(8),LEVEL_OF_RECURSION,QX)

!             MP is not needed in FMLNI4, so this multiplication can be skipped at the top level
!             of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IMMPY(MXY(1),MXY(5),MP,QX)
      ELSE
          CALL IMI2M(0,MP,QX)
      ENDIF
      CALL IMMPY(MXY(2),MXY(6),MQ,QX)
      CALL IMMPY(MXY(3),MXY(7),MB,QX)
      CALL IMMPY(MXY(6),MXY(7),MT,QX)
      CALL IMMPY(MXY(4),MT,MXY(5),QX)
      CALL IMMPY(MXY(1),MXY(3),MT,QX)
      CALL IMMPY(MXY(8),MT,MXY(2),QX)
      CALL IMADD(MXY(5),MXY(2),MT,QX)

  110 LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMLNI4_PQBT

      SUBROUTINE FMM2DP(MA,X,QX)

!  X = MA

!  Convert an FM number to double precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's double
!  precision number system, change the definition of DPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      DOUBLE PRECISION :: X
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KRESLT
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMM2DP'
      KRESLT = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMARGS('FMM2DP   ',1,MA,MA,KRESLT,QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.
!             Set X to some value that the user is likely to recognize as wrong.

          X = DBLE(QX%RUNKNO)
          QX%KFLAG = -4
          IF (MA%MP(2) /= QX%MUNKNO) CALL FMWARN(QX)
          IF (QX%NTRACE /= 0) CALL FMNTRR(1,X,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      CALL FMMD(MA,X,QX)

      IF (QX%NTRACE /= 0) CALL FMNTRR(1,X,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMM2DP

      SUBROUTINE FMM2I(MA,IVAL,QX)

!  IVAL = MA

!  Convert an FM number to integer.

!  KFLAG =  0 is returned if the conversion is exact.
!        = -4 is returned if MA is larger than INTMAX in magnitude.  IVAL = IUNKNO is returned
!             as an indication that IVAL could not be computed without integer overflow.
!        =  2 is returned if MA is smaller than INTMAX in magnitude but MA is not an integer.
!             The next integer toward zero is returned in IVAL.
!  It is sometimes convenient to call FMM2I to see if an FM number can be represented as a one-word
!  integer, by checking KFLAG upon return.  To avoid an unwanted error message being printed in the
!  KFLAG=-4 case, set KWARN=0 before the call to FMM2I and reset it after the call.

!  This routine performs the trace printing for the conversion.  FMMI is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMM2I'
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)

      CALL FMMI(MA,IVAL,QX)

      IF (QX%NTRACE /= 0) CALL FMNTRI(1,IVAL,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMM2I

      SUBROUTINE FMM2SP(MA,X,QX)

!  X = MA

!  Convert an FM number to single precision.

!  MA is converted and the result is returned in X.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's single
!  precision number system, change the definition of SPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      REAL :: X
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: Y
      INTEGER :: KRESLT
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMM2SP'
      KRESLT = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMARGS('FMM2SP   ',1,MA,MA,KRESLT,QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.
!             Set X to some value that the user is likely to recognize as wrong.

          X = QX%RUNKNO
          QX%KFLAG = -4
          IF (MA%MP(2) /= QX%MUNKNO) CALL FMWARN(QX)
          Y = DBLE(X)
          IF (QX%NTRACE /= 0) CALL FMNTRR(1,Y,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      CALL FMMD(MA,Y,QX)
      X = REAL(Y)

      IF (QX%NTRACE /= 0) THEN
          Y = DBLE(X)
          CALL FMNTRR(1,Y,1,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMM2SP

      SUBROUTINE FMMAX(MA,MB,MC,QX)

!  MC = MAX(MA,MB)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC


      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMMAX'
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
      ELSE IF (FMCOMP(MA,'<',MB,QX)) THEN
          CALL FMEQ(MB,MC,QX)
      ELSE
          CALL FMEQ(MA,MC,QX)
      ENDIF

      QX%KWARN = KWRNSV
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMMAX

      SUBROUTINE FMMD(MA,X,QX)

!  X = MA

!  Internal routine for conversion to double precision.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      DOUBLE PRECISION :: X
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: AQ(2),XQ(2),YQ(2),Y1(2),Y2(2),XBASE,PMAX,DLOGDP,  &
                          A1,A2,C,C1,C2,C21,C22,Q1,Q2,T,Z1,Z2
      REAL (KIND(1.0D0)) :: MA1,MAS
      INTEGER :: J,K,KWRNSV,NCASE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

!             Check to see if MA is in range for single or double precision.

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      PMAX = DPMAX
      IF (QX%NCALL > 0) THEN
          IF (QX%NAMEST(QX%NCALL) == 'FMM2SP') PMAX = DBLE(SPMAX)
      ENDIF
      DLOGDP = LOG(PMAX)
      MA1 = MA%MP(2)
      NCASE = 0
      X = DBLE(QX%RUNKNO)
      IF (DBLE(MA%MP(2)-1)*QX%DLOGMB > DLOGDP) THEN
          QX%KFLAG = -4
          X = DBLE(QX%RUNKNO)
          CALL FMWARN(QX)
          RETURN
      ELSE IF (DBLE(MA%MP(2)+1)*QX%DLOGMB > DLOGDP) THEN
          MA1 = MA1 - 2
          NCASE = 1
      ELSE IF (DBLE(MA%MP(2)+1)*QX%DLOGMB < -DLOGDP) THEN
          QX%KFLAG = -10
          X = 0.0D0
          CALL FMWARN(QX)
          RETURN
      ELSE IF (DBLE(MA%MP(2)-1)*QX%DLOGMB < -DLOGDP) THEN
          MA1 = MA1 + 2
          NCASE = 2
      ENDIF

!             Try FMMI first so that small integers will be converted quickly.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMMI(MA,J,QX)
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 0) THEN
          X = J
          RETURN
      ENDIF
      QX%KFLAG = 0

!             General case.
!             In order to get the correctly rounded X, the arithmetic for computing X is done
!             with simulated quadruple-precision using the arrays of length 2.

      MAS = MA%MP(1)
      XBASE = QX%MBASE
      XQ = (/ 0.0D0 , 0.0D0 /)
      YQ = (/ 1.0D0 , 0.0D0 /)
      C = RADIX(X)**(DIGITS(X) - DIGITS(X)/2) + 1
      K = (LOG(DBLE(RADIX(X)))/QX%DLOGMB)*DIGITS(X) + QX%NGRD52
      DO J = 2, MIN(K+1,QX%NDIG+1)
         Z1 = YQ(1) / XBASE
         T = XBASE*C
         A1 = (XBASE - T) + T
         A2 = XBASE - A1
         T = Z1*C
         C1 = (Z1 - T) + T
         C2 = Z1 - C1
         T = C2*C
         C21 = (C2 - T) + T
         C22 = C2 - C21
         Q1 = XBASE*Z1
         Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
         Z2 = ((((YQ(1)-Q1) - Q2) + YQ(2))) / XBASE
         YQ(1) = Z1 + Z2
         YQ(2) = (Z1-YQ(1)) + Z2
         T = YQ(1)*C
         A1 = (YQ(1) - T) + T
         A2 = YQ(1) - A1
         T = DBLE(MA%MP(J+1))*C
         C1 = (DBLE(MA%MP(J+1)) - T) + T
         C2 = DBLE(MA%MP(J+1)) - C1
         T = C2*C
         C21 = (C2 - T) + T
         C22 = C2 - C21
         Q1 = YQ(1)*DBLE(MA%MP(J+1))
         Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
         Z2 = YQ(2)*DBLE(MA%MP(J+1)) + Q2
         AQ(1) = Q1 + Z2
         AQ(2) = (Q1-AQ(1)) + Z2
         Z1 = XQ(1) + AQ(1)
         Q1 = XQ(1) - Z1
         Z2 = (((Q1+AQ(1)) + (XQ(1)-(Q1+Z1))) + XQ(2)) + AQ(2)
         XQ(1) = Z1 + Z2
         XQ(2) = (Z1-XQ(1)) + Z2
      ENDDO

      Y1 = (/ XBASE , 0.0D0 /)
      K = ABS(MA1)
      IF (MOD(K,2) == 0) THEN
          Y2 = (/ 1.0D0 , 0.0D0 /)
      ELSE
          Y2 = (/ XBASE , 0.0D0 /)
      ENDIF

  110 K = K/2
      T = Y1(1)*C
      A1 = (Y1(1) - T) + T
      A2 = Y1(1) - A1
      T = Y1(1)*C
      C1 = (Y1(1) - T) + T
      C2 = Y1(1) - C1
      T = C2*C
      C21 = (C2 - T) + T
      C22 = C2 - C21
      Q1 = Y1(1)*Y1(1)
      Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
      Z2 = ((Y1(1) + Y1(2))*Y1(2) + Y1(2)*Y1(1)) + Q2
      Y1(1) = Q1 + Z2
      Y1(2) = (Q1-Y1(1)) + Z2
      IF (MOD(K,2) == 1) THEN
          T = Y1(1)*C
          A1 = (Y1(1) - T) + T
          A2 = Y1(1) - A1
          T = Y2(1)*C
          C1 = (Y2(1) - T) + T
          C2 = Y2(1) - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = Y1(1)*Y2(1)
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((Y1(1) + Y1(2))*Y2(2) + Y1(2)*Y2(1)) + Q2
          Y2(1) = Q1 + Z2
          Y2(2) = (Q1-Y2(1)) + Z2
      ENDIF
      IF (K > 1) GO TO 110

      IF (MA1 < 0) THEN
          Z1 = XQ(1) / Y2(1)
          T = Y2(1)*C
          A1 = (Y2(1) - T) + T
          A2 = Y2(1) - A1
          T = Z1*C
          C1 = (Z1 - T) + T
          C2 = Z1 - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = Y2(1)*Z1
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((((XQ(1)-Q1) - Q2) + XQ(2)) - Z1*Y2(2)) / (Y2(1) + Y2(2))
          AQ(1) = Z1 + Z2
          AQ(2) = (Z1-AQ(1)) + Z2
      ELSE
          T = XQ(1)*C
          A1 = (XQ(1) - T) + T
          A2 = XQ(1) - A1
          T = Y2(1)*C
          C1 = (Y2(1) - T) + T
          C2 = Y2(1) - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = XQ(1)*Y2(1)
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((XQ(1) + XQ(2))*Y2(2) + XQ(2)*Y2(1)) + Q2
          AQ(1) = Q1 + Z2
          AQ(2) = (Q1-AQ(1)) + Z2
      ENDIF

      X = AQ(1) + AQ(2)

      IF (MAS < 0) X = -X

!             Check the result if it is near overflow or underflow.

      IF (NCASE == 1) THEN
          IF (X <= PMAX/(XBASE*XBASE)) THEN
              X = X*XBASE*XBASE
          ELSE
              QX%KFLAG = -4
              X = DBLE(QX%RUNKNO)
              CALL FMWARN(QX)
          ENDIF
      ELSE IF (NCASE == 2) THEN
          IF (X >= (1.0D0/PMAX)*XBASE*XBASE) THEN
              X = X/(XBASE*XBASE)
          ELSE
              QX%KFLAG = -10
              X = 0.0D0
              CALL FMWARN(QX)
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMMD

      SUBROUTINE FMMI(MA,IVAL,QX)

!  IVAL = MA.  Internal FM to integer conversion routine.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,KA,KB,LARGE,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL

      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      LARGE = INT(INTMAX/QX%MBASE)
      IVAL = 0
      IF (MA%MP(2) <= 0) THEN
          IF (MA%MP(3) /= 0) QX%KFLAG = 2
          RETURN
      ENDIF

      KB = INT(MA%MP(2)) + 1
      IVAL = INT(ABS(MA%MP(3)))
      IF (KB >= 3) THEN
          DO J = 3, KB
             IF (IVAL > LARGE) THEN
                 QX%KFLAG = -4
                 IF (MA%MP(2) /= QX%MUNKNO) CALL FMWARN(QX)
                 IVAL = QX%IUNKNO
                 RETURN
             ENDIF
             IF (J <= N1) THEN
                 IVAL = IVAL*INT(QX%MBASE)
                 IF (IVAL > INTMAX-MA%MP(J+1)) THEN
                     QX%KFLAG = -4
                     IF (MA%MP(2) /= QX%MUNKNO) CALL FMWARN(QX)
                     IVAL = QX%IUNKNO
                     RETURN
                 ELSE
                     IVAL = IVAL + INT(MA%MP(J+1))
                 ENDIF
             ELSE
                 IVAL = IVAL*INT(QX%MBASE)
             ENDIF
          ENDDO
      ENDIF

      IF (MA%MP(1) < 0) IVAL = -IVAL

!             Check to see if MA is an integer.

      KA = KB + 1
      IF (KA <= N1) THEN
          DO J = KA, N1
             IF (MA%MP(J+1) /= 0) THEN
                 QX%KFLAG = 2
                 RETURN
             ENDIF
          ENDDO
      ENDIF

      RETURN
      END SUBROUTINE FMMI

      SUBROUTINE FMMIN(MA,MB,MC,QX)

!  MC = MIN(MA,MB)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC


      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMMIN'
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
      ELSE IF (FMCOMP(MA,'>',MB,QX)) THEN
          CALL FMEQ(MB,MC,QX)
      ELSE
          CALL FMEQ(MA,MC,QX)
      ENDIF

      QX%KWARN = KWRNSV
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMMIN

      SUBROUTINE FMMOD(MA,MB,MC,QX)

!  MC = MA(MOD MB).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MVB,MVC,MVY,MVZ,MXSAVE
      INTEGER :: J,K,KB,KE,KN,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB) THEN
          CALL FMENTR('FMMOD    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMMOD'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KWRNSV = QX%KWARN
      QX%KWARN = 0

      IF (MB%MP(2) > MA%MP(2) .AND. MB%MP(3) /= 0) THEN
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      ELSE

!             Special cases when MB is a small integer.

          CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(3),NDSAVE,QX%NDIG,QX)
          MXY(2)%MP(1) = 1
          MXY(3)%MP(1) = 1

          CALL FMM2I(MXY(3),KB,QX)
          IF (QX%KFLAG == 0 .AND. KB < MXBASE) THEN
              IF (KB == 1 .OR. KB == -1) THEN
                  IF (MXY(2)%MP(2) >= QX%NDIG) THEN
                      CALL FMI2M(0,MXY(1),QX)
                      GO TO 130
                  ELSE
                      CALL FMINT(MXY(2),MXY(3),QX)
                      CALL FMSUB(MXY(2),MXY(3),MXY(1),QX)
                      IF (MA%MP(1) < 0 .AND. MXY(1)%MP(2) /= QX%MUNKNO .AND.  &
                          MXY(1)%MP(3) /= 0) MXY(1)%MP(1) = -MXY(1)%MP(1)
                      GO TO 130
                  ENDIF
              ELSE IF (MXY(2)%MP(2) == QX%MEXPOV .OR. KB == 0) THEN
                  QX%KFLAG = -4
                  QX%KWARN = KWRNSV
                  QX%MXEXP = MXSAVE
                  CALL FMWARN(QX)
                  QX%NDIG = NDSAVE
                  CALL FMST2M('UNKNOWN',MC,QX)
                  IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
                  RETURN
              ELSE IF (MXY(2)%MP(2) > QX%NDIG.AND.MOD(INT(QX%MBASE),KB) == 0) THEN
                  CALL FMI2M(0,MXY(1),QX)
                  GO TO 130
              ENDIF
              IF (MXY(2)%MP(2) < QX%NDIG) THEN
                  DO J = INT(MXY(2)%MP(2))+1, QX%NDIG+1
                     IF (MXY(2)%MP(J+1) /= 0) GO TO 120
                  ENDDO
              ENDIF
              KE = MIN(INT(MXY(2)%MP(2)),QX%NDIG)
              MVB = KB
              MVC = MOD(MXY(2)%MP(3),MVB)
              DO J = 3, KE+1
                 MVC = MOD(MVC*QX%MBASE+MXY(2)%MP(J+1),MVB)
              ENDDO
              IF (MVC == 0) THEN
                   CALL FMI2M(0,MXY(1),QX)
                   GO TO 130
              ENDIF
              KN = INT(MXY(2)%MP(2)) - KE
              MVY = MOD(QX%MBASE,MVB)
              MVZ = 1
              IF (MOD(KN,2) == 1) MVZ = MVY

              IF (MVY /= 1) THEN
  110             KN = KN/2
                  MVY = MOD(MVY*MVY,MVB)
                  IF (MOD(KN,2) == 1) MVZ = MOD(MVZ*MVY,MVB)
                  IF (KN > 1) GO TO 110
              ENDIF
              MVZ = MOD(MVZ*MVC,MVB)
              KE = INT(MVZ)
              CALL FMI2M(KE,MXY(1),QX)
              IF (MA%MP(1) < 0 .AND. MXY(1)%MP(2) /= QX%MUNKNO .AND.  &
                  MXY(1)%MP(3) /= 0) MXY(1)%MP(1) = -MXY(1)%MP(1)
              GO TO 130
          ENDIF
          IF (MA%MP(2)-MB%MP(2) > 3*10**5) THEN
              QX%KFLAG = -4
              CALL FMWARN(QX)
              CALL FMST2M('UNKNOWN',MXY(1),QX)
              GO TO 130
          ENDIF

!             General case.

  120     IF (MA%MP(3) /= 0) THEN
              QX%NDIG = QX%NDIG + INT(MA%MP(2)-MB%MP(2))
          ENDIF
          IF (MB%MP(3) == 0) THEN
              QX%KFLAG = -9
              IF (MA%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN .OR.   &
                  MB%MP(3) == 0) QX%KFLAG = -4
              QX%KWARN = KWRNSV
              QX%MXEXP = MXSAVE
              CALL FMWARN(QX)
              QX%NDIG = NDSAVE
              CALL FMST2M('UNKNOWN',MC,QX)
              IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF

          CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(3),NDSAVE,QX%NDIG,QX)

          MXY(2)%MP(1) = 1
          MXY(3)%MP(1) = 1
          CALL FMDIV(MXY(2),MXY(3),MXY(1),QX)
          CALL FMINT(MXY(1),MXY(4),QX)
          CALL FMMPY_R1(MXY(4),MXY(3),QX)
          CALL FMSUB(MXY(2),MXY(4),MXY(1),QX)

!             Due to rounding, MXY(1) may not be between 0 and MB here.

          NTRSAV = QX%NTRACE
          QX%NTRACE = 0
          IF (FMCOMP(MXY(1),'>=',MXY(3),QX)) THEN
              QX%NTRACE = NTRSAV
              CALL FMSUB_R1(MXY(1),MXY(3),QX)
          ENDIF
          QX%NTRACE = NTRSAV
          IF (MXY(1)%MP(1) < 0) CALL FMADD_R1(MXY(1),MXY(3),QX)
          IF (MA%MP(1) < 0 .AND. MXY(1)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(1)%MP(3) /=0) MXY(1)%MP(1) = -MXY(1)%MP(1)
      ENDIF

  130 IF (QX%KFLAG == 1) QX%KFLAG = 0
      QX%KWARN = KWRNSV
      CALL FMEXIT(MXY(1),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMMOD

      SUBROUTINE FMMOVE(MW,MA,QX)

!  Move a result from a work area (MW) to MA.

!  If the result has MW%MP(3)=0, then it is shifted and the exponent adjusted when it is
!  moved to MA.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(WORK_AREA) :: MW
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,N1,N2
      INTENT (IN) :: MW
      INTENT (INOUT) :: MA

      IF (MW%MP(3) /= 0) THEN
          N1 = QX%NDIG + 1

!             Major (Inner Loop)

          DO J = 2, N1+1
             MA%MP(J) = MW%MP(J)
          ENDDO
      ELSE
          N2 = QX%NDIG + 2
          DO J = 3, N2
             MA%MP(J) = MW%MP(J+1)
          ENDDO
          IF (MA%MP(3) /= 0) THEN
              MA%MP(2) = MW%MP(2) - 1
          ELSE
              MA%MP(2) = 0
          ENDIF
      ENDIF

      MA%MP(1) = 1
      IF (ABS(MA%MP(2)) > QX%MXEXP) CALL FMTRAP(MA,QX)

      RETURN
      END SUBROUTINE FMMOVE

      SUBROUTINE FMMPY(MA,MB,MC,QX)

!  MC = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPY'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMMPY2(MA,MB,MC,QX)

          CALL FMNTR(1,MC,MC,1,1,QX)
      ELSE
          CALL FMMPY2(MA,MB,MC,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMMPY

      SUBROUTINE FMMPY2(MA,MB,MC,QX)

!  Internal multiplication routine.  MC = MA * MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(WORK_AREA) :: MWA
      TYPE(MULTI) :: MPMA,MPMB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      QX%NDIGL = 0
      QX%NDIGN = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      KR_RETRY = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT,QX)
          IF (KRESLT /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMMPY'
              CALL FMRSLT(MA,MB,MC,KRESLT,QX)
              QX%JRSIGN = JRSSAV
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
      ELSE IF (MA%MP(3) == 0 .OR. MB%MP(3) == 0) THEN
          CALL FMIM(0,MC,QX)
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF
      QX%KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD22
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 2
          ELSE IF (QX%MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,QX%NDIG+2)
          ENDIF
      ENDIF
      IF (MA%MP(3)*MB%MP(3) < QX%MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = QX%NDIG + 1

      IF (QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (QX%NDIGL /= QX%NDIG .OR. QX%MBASEL /= QX%MBASE .OR. QX%NGUARL /= NGUARD) THEN
              QX%MBASEL = QX%MBASE
              QX%NDIGL = QX%NDIG
              QX%NGUARL = NGUARD
              DO J = 2, 1000
                 MR = QX%MBASE*QX%MBASEL
                 IF (4*MR > MXBASE) THEN
                     QX%N21 = J - 1
                     QX%NDIG = (QX%NDIGL-1)/QX%N21 + 1
                     IF (QX%NDIG < 2) QX%NDIG = 2
                     QX%NGRDN = (QX%NDIGL+NGUARD-1)/QX%N21 + 2 - QX%NDIG
                     IF (QX%NGRDN < 1) QX%NGRDN = 1
                     EXIT
                 ENDIF
                 QX%MBASE = MR
              ENDDO
              QX%MBASEN = QX%MBASE
              QX%NDIGN = QX%NDIG
          ELSE
              QX%MBASE = QX%MBASEN
              QX%NDIG = QX%NDIGN
          ENDIF
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
          J = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRDN + 5
          QX%NDIG = J
          MPMA%MP(1) = MA%MP(1)
          MPMB%MP(1) = MB%MP(1)
          MPMA%MP(2) = 0
          MPMB%MP(2) = 0
          L = 2 - QX%N21
          DO J = 2, QX%NDIGL+2-QX%N21, QX%N21
             MT1 = MA%MP(J+1)
             MT2 = MB%MP(J+1)
             DO K = J+1, J+QX%N21-1
                MT1 = MT1*QX%MBASEL + MA%MP(K+1)
                MT2 = MT2*QX%MBASEL + MB%MP(K+1)
             ENDDO
             MPMA%MP(3+J/QX%N21) = MT1
             MPMB%MP(3+J/QX%N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/QX%N21, QX%NDIG+QX%NGRDN+1
             MPMA%MP(J+1) = 0
             MPMB%MP(J+1) = 0
          ENDDO
          IF (L+QX%N21 <= QX%NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+QX%N21, L+2*QX%N21-1
                 IF (J <= QX%NDIGL+1) THEN
                     MT1 = MT1*QX%MBASEL + MA%MP(J+1)
                     MT2 = MT2*QX%MBASEL + MB%MP(J+1)
                 ELSE
                     MT1 = MT1*QX%MBASEL
                     MT2 = MT2*QX%MBASEL
                 ENDIF
              ENDDO
              MPMA%MP(3+(L+QX%N21)/QX%N21) = MT1
              MPMB%MP(3+(L+QX%N21)/QX%N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,MWA,QX%NGRDN,KSHIFT,QX)
          IF (MWA%MP(3) == 0) THEN
              DO J = 3, 1+QX%NDIG+QX%NGRDN
                 MWA%MP(J) = MWA%MP(J+1)
              ENDDO
              MWA%MP(QX%NDIG+QX%NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (QX%MBASEL == 2 .AND. QX%MBASE < INTMAX) THEN
              DO J = 1+QX%NDIG+QX%NGRDN, 2, -1
                 KT1 = MWA%MP(J+1)
                 KT = 2 + (J-2)*QX%N21
                 KT2 = QX%N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2)
                    MWA%MP(K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = QX%MBASEL**(QX%N21-1)
              DO J = 1+QX%NDIG+QX%NGRDN, 2, -1
                 MR = MS
                 MT1 = MWA%MP(J+1)
                 DO K = 2+(J-2)*QX%N21, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2)
                    MWA%MP(K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWA%MP(K+1)*MR
                    MR = AINT (MR/QX%MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWA%MP(3) == 0) KSHIFT = 1
          MWA%MP(2) = MA%MP(2) + MB%MP(2)
          QX%NDIG = QX%NDIGL
          QX%MBASE = QX%MBASEL
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,MWA,NGUARD,KSHIFT,QX)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MC, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWA%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(KSHIFT+N1+1) = MWA%MP(KSHIFT+N1+1) + 1
                  MWA%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MC,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPY'
          CALL FMWARN(QX)
      ENDIF

      MC%MP(1) = 1
      IF (MAS*MBS < 0 .AND. MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0)  &
          MC%MP(1) = -1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMMPY2

      SUBROUTINE FMMPY_R1(MA,MB,QX)

!  MA = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2_R1 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPY_R1'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMMPY2_R1(MA,MB,QX)

          QX%NAMEST(QX%NCALL) = 'FMMPY_R1'
          CALL FMNTR(1,MA,MA,1,1,QX)
      ELSE
          CALL FMMPY2_R1(MA,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMMPY_R1

      SUBROUTINE FMMPY2_R1(MA,MB,QX)

!  Internal multiplication routine.  MA = MA * MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(MULTI) :: MPMA,MPMB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MXY(2)

      QX%NDIGL = 0
      QX%NDIGN = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      KR_RETRY = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT,QX)
          IF (KRESLT /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMMPY_R1'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT,QX)
              CALL FMEQ(MXY(1),MA,QX)
              QX%JRSIGN = JRSSAV
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
      ELSE IF (MA%MP(3) == 0 .OR. MB%MP(3) == 0) THEN
          CALL FMIM(0,MA,QX)
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF
      QX%KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD22
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 2
          ELSE IF (QX%MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,QX%NDIG+2)
          ENDIF
      ENDIF
      IF (MA%MP(3)*MB%MP(3) < QX%MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = QX%NDIG + 1

      IF (QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (QX%NDIGL /= QX%NDIG .OR. QX%MBASEL /= QX%MBASE .OR. QX%NGUARL /= NGUARD) THEN
              QX%MBASEL = QX%MBASE
              QX%NDIGL = QX%NDIG
              QX%NGUARL = NGUARD
              DO J = 2, 1000
                 MR = QX%MBASE*QX%MBASEL
                 IF (4*MR > MXBASE) THEN
                     QX%N21 = J - 1
                     QX%NDIG = (QX%NDIGL-1)/QX%N21 + 1
                     IF (QX%NDIG < 2) QX%NDIG = 2
                     QX%NGRDN = (QX%NDIGL+NGUARD-1)/QX%N21 + 2 - QX%NDIG
                     IF (QX%NGRDN < 1) QX%NGRDN = 1
                     EXIT
                 ENDIF
                 QX%MBASE = MR
              ENDDO
              QX%MBASEN = QX%MBASE
              QX%NDIGN = QX%NDIG
          ELSE
              QX%MBASE = QX%MBASEN
              QX%NDIG = QX%NDIGN
          ENDIF
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
          J = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRDN + 5
          QX%NDIG = J
          MPMA%MP(1) = MA%MP(1)
          MPMB%MP(1) = MB%MP(1)
          MPMA%MP(2) = 0
          MPMB%MP(2) = 0
          L = 2 - QX%N21
          DO J = 2, QX%NDIGL+2-QX%N21, QX%N21
             MT1 = MA%MP(J+1)
             MT2 = MB%MP(J+1)
             DO K = J+1, J+QX%N21-1
                MT1 = MT1*QX%MBASEL + MA%MP(K+1)
                MT2 = MT2*QX%MBASEL + MB%MP(K+1)
             ENDDO
             MPMA%MP(3+J/QX%N21) = MT1
             MPMB%MP(3+J/QX%N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/QX%N21, QX%NDIG+QX%NGRDN+1
             MPMA%MP(J+1) = 0
             MPMB%MP(J+1) = 0
          ENDDO
          IF (L+QX%N21 <= QX%NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+QX%N21, L+2*QX%N21-1
                 IF (J <= QX%NDIGL+1) THEN
                     MT1 = MT1*QX%MBASEL + MA%MP(J+1)
                     MT2 = MT2*QX%MBASEL + MB%MP(J+1)
                 ELSE
                     MT1 = MT1*QX%MBASEL
                     MT2 = MT2*QX%MBASEL
                 ENDIF
              ENDDO
              MPMA%MP(3+(L+QX%N21)/QX%N21) = MT1
              MPMB%MP(3+(L+QX%N21)/QX%N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,MWA,QX%NGRDN,KSHIFT,QX)
          IF (MWA%MP(3) == 0) THEN
              DO J = 3, 1+QX%NDIG+QX%NGRDN
                 MWA%MP(J) = MWA%MP(J+1)
              ENDDO
              MWA%MP(QX%NDIG+QX%NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (QX%MBASEL == 2 .AND. QX%MBASE < INTMAX) THEN
              DO J = 1+QX%NDIG+QX%NGRDN, 2, -1
                 KT1 = MWA%MP(J+1)
                 KT = 2 + (J-2)*QX%N21
                 KT2 = QX%N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2)
                    MWA%MP(K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = QX%MBASEL**(QX%N21-1)
              DO J = 1+QX%NDIG+QX%NGRDN, 2, -1
                 MR = MS
                 MT1 = MWA%MP(J+1)
                 DO K = 2+(J-2)*QX%N21, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2)
                    MWA%MP(K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWA%MP(K+1)*MR
                    MR = AINT (MR/QX%MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWA%MP(3) == 0) KSHIFT = 1
          MWA%MP(2) = MA%MP(2) + MB%MP(2)
          QX%NDIG = QX%NDIGL
          QX%MBASE = QX%MBASEL
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,MWA,NGUARD,KSHIFT,QX)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MA, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWA%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(KSHIFT+N1+1) = MWA%MP(KSHIFT+N1+1) + 1
                  MWA%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPY_R1'
          CALL FMWARN(QX)
      ENDIF

      MA%MP(1) = 1
      IF (MAS*MBS < 0 .AND. MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0)  &
          MA%MP(1) = -1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMMPY2_R1

      SUBROUTINE FMMPY_R2(MA,MB,QX)

!  MB = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2_R2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPY_R2'
          CALL FMNTR(2,MA,MB,2,1,QX)

          CALL FMMPY2_R2(MA,MB,QX)

          QX%NAMEST(QX%NCALL) = 'FMMPY_R2'
          CALL FMNTR(1,MB,MB,1,1,QX)
      ELSE
          CALL FMMPY2_R2(MA,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMMPY_R2

      SUBROUTINE FMMPY2_R2(MA,MB,QX)

!  Internal multiplication routine.  MB = MA * MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(MULTI) :: MPMA,MPMB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)

      QX%NDIGL = 0
      QX%NDIGN = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      KR_RETRY = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT,QX)
          IF (KRESLT /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMMPY_R2'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT,QX)
              CALL FMEQ(MXY(1),MB,QX)
              QX%JRSIGN = JRSSAV
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
      ELSE IF (MA%MP(3) == 0 .OR. MB%MP(3) == 0) THEN
          CALL FMIM(0,MB,QX)
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF
      QX%KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD22
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 2
          ELSE IF (QX%MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,QX%NDIG+2)
          ENDIF
      ENDIF
      IF (MA%MP(3)*MB%MP(3) < QX%MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = QX%NDIG + 1

      IF (QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (QX%NDIGL /= QX%NDIG .OR. QX%MBASEL /= QX%MBASE .OR. QX%NGUARL /= NGUARD) THEN
              QX%MBASEL = QX%MBASE
              QX%NDIGL = QX%NDIG
              QX%NGUARL = NGUARD
              DO J = 2, 1000
                 MR = QX%MBASE*QX%MBASEL
                 IF (4*MR > MXBASE) THEN
                     QX%N21 = J - 1
                     QX%NDIG = (QX%NDIGL-1)/QX%N21 + 1
                     IF (QX%NDIG < 2) QX%NDIG = 2
                     QX%NGRDN = (QX%NDIGL+NGUARD-1)/QX%N21 + 2 - QX%NDIG
                     IF (QX%NGRDN < 1) QX%NGRDN = 1
                     EXIT
                 ENDIF
                 QX%MBASE = MR
              ENDDO
              QX%MBASEN = QX%MBASE
              QX%NDIGN = QX%NDIG
          ELSE
              QX%MBASE = QX%MBASEN
              QX%NDIG = QX%NDIGN
          ENDIF
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
          J = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRDN + 5
          QX%NDIG = J
          MPMA%MP(1) = MA%MP(1)
          MPMB%MP(1) = MB%MP(1)
          MPMA%MP(2) = 0
          MPMB%MP(2) = 0
          L = 2 - QX%N21
          DO J = 2, QX%NDIGL+2-QX%N21, QX%N21
             MT1 = MA%MP(J+1)
             MT2 = MB%MP(J+1)
             DO K = J+1, J+QX%N21-1
                MT1 = MT1*QX%MBASEL + MA%MP(K+1)
                MT2 = MT2*QX%MBASEL + MB%MP(K+1)
             ENDDO
             MPMA%MP(3+J/QX%N21) = MT1
             MPMB%MP(3+J/QX%N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/QX%N21, QX%NDIG+QX%NGRDN+1
             MPMA%MP(J+1) = 0
             MPMB%MP(J+1) = 0
          ENDDO
          IF (L+QX%N21 <= QX%NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+QX%N21, L+2*QX%N21-1
                 IF (J <= QX%NDIGL+1) THEN
                     MT1 = MT1*QX%MBASEL + MA%MP(J+1)
                     MT2 = MT2*QX%MBASEL + MB%MP(J+1)
                 ELSE
                     MT1 = MT1*QX%MBASEL
                     MT2 = MT2*QX%MBASEL
                 ENDIF
              ENDDO
              MPMA%MP(3+(L+QX%N21)/QX%N21) = MT1
              MPMB%MP(3+(L+QX%N21)/QX%N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,MWA,QX%NGRDN,KSHIFT,QX)
          IF (MWA%MP(3) == 0) THEN
              DO J = 3, 1+QX%NDIG+QX%NGRDN
                 MWA%MP(J) = MWA%MP(J+1)
              ENDDO
              MWA%MP(QX%NDIG+QX%NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (QX%MBASEL == 2 .AND. QX%MBASE < INTMAX) THEN
              DO J = 1+QX%NDIG+QX%NGRDN, 2, -1
                 KT1 = MWA%MP(J+1)
                 KT = 2 + (J-2)*QX%N21
                 KT2 = QX%N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2)
                    MWA%MP(K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = QX%MBASEL**(QX%N21-1)
              DO J = 1+QX%NDIG+QX%NGRDN, 2, -1
                 MR = MS
                 MT1 = MWA%MP(J+1)
                 DO K = 2+(J-2)*QX%N21, MIN(1+(J-1)*QX%N21,QX%NDIGL+NGUARD+2)
                    MWA%MP(K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWA%MP(K+1)*MR
                    MR = AINT (MR/QX%MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWA%MP(3) == 0) KSHIFT = 1
          MWA%MP(2) = MA%MP(2) + MB%MP(2)
          QX%NDIG = QX%NDIGL
          QX%MBASE = QX%MBASEL
          IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,MWA,NGUARD,KSHIFT,QX)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MB, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWA%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(KSHIFT+N1+1) = MWA%MP(KSHIFT+N1+1) + 1
                  MWA%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPY_R2'
          CALL FMWARN(QX)
      ENDIF

      MB%MP(1) = 1
      IF (MAS*MBS < 0 .AND. MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0)  &
          MB%MP(1) = -1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMMPY2_R2

      SUBROUTINE FMMPY3(MA,MB,MWA,NGUARD,KSHIFT,QX)

!  Internal multiplication of MA*MB.  The result is returned in MWA.  Both MA and MB are positive.

!  NGUARD is the number of guard digits that will be used.
!  KSHIFT = 1 is returned if a left shift is pending (i.e., MWA%MP(3)=0).  The shift will
!             be done in FMMOVE.  KSHIFT = 0 is returned if no shift is pending.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      INTEGER :: NGUARD,KSHIFT
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MK,MKT,MMAX,MT
      INTEGER :: J,JM1,K,KB,KI,KJ,KL,KNZ,KWA,L,N1,NMETHD,NZDA,NZDB
      REAL :: C
      INTENT (IN) :: MA,MB,NGUARD
      INTENT (INOUT) :: KSHIFT

      N1 = QX%NDIG + 1
      MWA%MP(2) = MA%MP(2) + MB%MP(2)

!             Check for using an FFT-based method if precision is very high.

      C = 900
      IF (QX%NDIG >= C) THEN
          NZDA = 2
          NZDB = QX%NDIG
          DO J = QX%NDIG, 2, -1
             IF (MA%MP(J+2) /= 0) THEN
                 NZDA = J
                 EXIT
             ENDIF
          ENDDO
          DO J = 2, QX%NDIG
             IF (MB%MP(J+2) == 0) NZDB = NZDB - 1
          ENDDO
          C = 0.9 * C / LOG(C)
          IF (REAL(NZDA)*NZDB < C*QX%NDIG*LOG(REAL(QX%NDIG))) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPYFFT(MA,MB,MWA,QX)
          IF (MWA%MP(3) == 0) THEN
              KSHIFT = 1
          ELSE
              KSHIFT = 0
          ENDIF
          RETURN
      ENDIF

      L = N1 + NGUARD
      MWA%MP(L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = QX%MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - QX%MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MB%MP(3)

!             Count the trailing zeros in MA.

          IF (MA%MP(N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = QX%NDIG, 2, -1
                 IF (MA%MP(J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWA%MP(3) = 0
          DO K = QX%NDIG+2, L
             MWA%MP(K+1) = 0
          ENDDO

!             (Inner Loop)

          DO K = 3, N1+1
             MWA%MP(K+1) = MA%MP(K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, N1
             MBJ = MB%MP(J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 DO K = J+2, J+KL
                    MWA%MP(K) = MWA%MP(K) + MA%MP(K-JM1)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWA%MP(KB+1)/QX%MBASE)
                    MWA%MP(KB) = MWA%MP(KB) + MKT
                    MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          DO KB = L+1, 4, -1
             MKT = INT (MWA%MP(KB)/QX%MBASE)
             MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
             MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWA%MP(J+1) = 0
          ENDDO
          KJ = QX%NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MB%MP(KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MA%MP(KI-K+1)*MBKJ + MWA%MP(KWA-K+1) + MK
                MK = INT (MT/QX%MBASE)
                MWA%MP(KWA-K+1) = MT - QX%MBASE*MK
             ENDDO
             MWA%MP(KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWA%MP(3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

      RETURN
      END SUBROUTINE FMMPY3

      SUBROUTINE FMMPYD(MA,MB,MC,MD,ME,QX)

!  Double multiplication routine.  MD = MA * MB,   ME = MA * MC

!  It is usually slightly faster to do two multiplications that have a common factor with one call.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC,MD,ME
      TYPE(MULTI) :: MTD
      TYPE(WORK_AREA) :: MWA,MWD
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MAXMWA,MBS,MBJ,MBKJ,MBNORM,MBP1,MCJ,MCKJ,MCS,  &
                            MKB,MKC,MKT,MMAX,MR,MT,MTEMP
      DOUBLE PRECISION :: ERR
      REAL :: C
      INTEGER :: J,JM1,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KSHIFT,KWA,L,N1,NGUARD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD,ME


      QX%NCALL = QX%NCALL + 1
      JRSSAV = QX%JRSIGN
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYD'
          CALL FMNTR(2,MA,MB,2,1,QX)
          IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL FMNTRJ(MC,QX%NDIG,QX)
              ELSE
                  CALL FMPRNT(MC,QX)
              ENDIF
          ENDIF
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      C = 1000
      IF (QX%NDIG >= C .OR.                                              &
          ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR.  &
          ABS(MC%MP(2)) > QX%MEXPAB .OR. QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN .OR.  &
              MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN .OR.  &
              MC%MP(2) == QX%MEXPOV .OR. MC%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO .OR.  &
              MC%MP(2) == QX%MUNKNO) KOVUN = 2
          QX%NCALL = QX%NCALL + 1
          CALL FMMPY2(MA,MB,MTD,QX)
          KB = QX%KFLAG
          CALL FMMPY2(MA,MC,ME,QX)
          QX%NCALL = QX%NCALL - 1
          IF (((QX%KFLAG < 0 .OR. KB < 0) .AND. KOVUN == 0) .OR.  &
              ((QX%KFLAG == -4 .OR. KB == -4) .AND. KOVUN == 1)) THEN
              IF (QX%KFLAG == -4 .OR. KB == -4) THEN
                  QX%KFLAG = -4
              ELSE IF (QX%KFLAG == -5 .OR. KB == -5) THEN
                  QX%KFLAG = -5
              ELSE
                  QX%KFLAG = MIN(QX%KFLAG,KB)
              ENDIF
              QX%NAMEST(QX%NCALL) = 'FMMPYD'
              CALL FMWARN(QX)
          ENDIF
          CALL FMEQ(MTD,MD,QX)
          GO TO 140
      ENDIF
      IF (MA%MP(3) == 0) THEN
          CALL FMIM(0,MD,QX)
          CALL FMIM(0,ME,QX)
          GO TO 140
      ENDIF
      IF (MB%MP(3) == 0) THEN
          CALL FMMPY2(MA,MC,ME,QX)
          CALL FMIM(0,MD,QX)
          GO TO 140
      ENDIF
      IF (MC%MP(3) == 0) THEN
          CALL FMMPY2(MA,MB,MD,QX)
          CALL FMIM(0,ME,QX)
          GO TO 140
      ENDIF
      QX%KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD22
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (QX%MBASE < 10**6) NGUARD = MIN(NGUARD+1,QX%NDIG+2)
      ENDIF
      IF ((MA%MP(3)*MB%MP(3) < QX%MBASE .OR.  &
           MA%MP(3)*MC%MP(3) < QX%MBASE) .AND. NGUARD < 3) NGUARD = 3

!             Save the sign of MA, MB, and MC and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)
      MCS = MC%MP(1)

      N1 = QX%NDIG + 1
      MWA%MP(2) = MA%MP(2) + MB%MP(2)
      MWD%MP(2) = MA%MP(2) + MC%MP(2)
      L = QX%NDIG + 1 + NGUARD
      MWA%MP(L+2) = 0
      MWD%MP(L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = QX%MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - QX%MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MB%MP(3)
          MCJ = MC%MP(3)

!             Count the trailing zeros in MA.

          IF (MA%MP(N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = QX%NDIG, 2, -1
                 IF (MA%MP(J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWA%MP(3) = 0
          MWD%MP(3) = 0
          DO K = QX%NDIG+2, L
             MWA%MP(K+1) = 0
             MWD%MP(K+1) = 0
          ENDDO

!             (Inner Loop)

          DO K = 2, N1
             MTEMP = MA%MP(K+1)
             MWA%MP(K+2) = MTEMP*MBJ
             MWD%MP(K+2) = MTEMP*MCJ
          ENDDO
          IF (MBJ > MCJ) THEN
              MAXMWA = MBJ
          ELSE
              MAXMWA = MCJ
          ENDIF
          DO J = 3, N1
             MBJ = MB%MP(J+1)
             MCJ = MC%MP(J+1)
             IF (MBJ > MCJ) THEN
                 MAXMWA = MAXMWA + MBJ
             ELSE
                 MAXMWA = MAXMWA + MCJ
             ENDIF
             JM1 = J - 1
             KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

             DO K = J+2, J+KL
                MTEMP = MA%MP(K-JM1)
                MWA%MP(K) = MWA%MP(K) + MTEMP*MBJ
                MWD%MP(K) = MWD%MP(K) + MTEMP*MCJ
             ENDDO

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWA%MP(KB+1)/QX%MBASE)
                    MWA%MP(KB) = MWA%MP(KB) + MKT
                    MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
                    MKT = INT (MWD%MP(KB+1)/QX%MBASE)
                    MWD%MP(KB) = MWD%MP(KB) + MKT
                    MWD%MP(KB+1) = MWD%MP(KB+1) - MKT*QX%MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          DO KB = L+1, 4, -1
             MKT = INT (MWA%MP(KB)/QX%MBASE)
             MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
             MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
             MKT = INT (MWD%MP(KB)/QX%MBASE)
             MWD%MP(KB-1) = MWD%MP(KB-1) + MKT
             MWD%MP(KB) = MWD%MP(KB) - MKT*QX%MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWA%MP(J+1) = 0
             MWD%MP(J+1) = 0
          ENDDO
          KJ = QX%NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MB%MP(KJ+1)
             MCKJ = MC%MP(KJ+1)
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MKB = 0
             MKC = 0
             DO K = 2, KL
                MT = MA%MP(KI-K+1)*MBKJ + MWA%MP(KWA-K+1) + MKB
                MKB = INT (MT/QX%MBASE)
                MWA%MP(KWA-K+1) = MT - QX%MBASE*MKB
                MT = MA%MP(KI-K+1)*MCKJ + MWD%MP(KWA-K+1) + MKC
                MKC = INT (MT/QX%MBASE)
                MWD%MP(KWA-K+1) = MT - QX%MBASE*MKC
             ENDDO
             MWA%MP(KWA-KL) = MKB
             MWD%MP(KWA-KL) = MKC
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWA%MP(3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplications are complete.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MB,MD,QX)
              GO TO 120
          ENDIF
      ENDIF
      MR = 2*MWA%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(KSHIFT+N1+1) = MWA%MP(KSHIFT+N1+1) + 1
                  MWA%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MD,QX)

  120 IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (MWD%MP(3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWD%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MC,ME,QX)
              GO TO 130
          ENDIF
      ENDIF
      MR = 2*MWD%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWD,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWD%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWD%MP(KSHIFT+N1+1) = MWD%MP(KSHIFT+N1+1) + 1
                  MWD%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWD,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,ME,QX)

  130 IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYD'
          CALL FMWARN(QX)
      ENDIF

      MD%MP(1) = 1
      IF (MAS*MBS < 0 .AND. MD%MP(2) /= QX%MUNKNO .AND. MD%MP(3) /= 0)  &
          MD%MP(1) = -1
      ME%MP(1) = 1
      IF (MAS*MCS < 0 .AND. ME%MP(2) /= QX%MUNKNO .AND. ME%MP(3) /= 0)  &
          ME%MP(1) = -1

  140 IF (QX%NTRACE /= 0) THEN
          CALL FMNTR(1,MD,MD,1,1,QX)
          IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL FMNTRJ(ME,QX%NDIG,QX)
              ELSE
                  CALL FMPRNT(ME,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMMPYD

      SUBROUTINE FMMPYE(MA,MB,MC,MD,ME,MF,MG,QX)

!  Triple multiplication routine.

!      ME = MA * MB,   MF = MA * MC,   MG = MA * MD

!  It is usually slightly faster to do three multiplications that have a common factor with
!  one call.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC,MD,ME,MF,MG
      TYPE(MULTI) :: MTD,MTE
      TYPE(WORK_AREA) :: MWA,MWD,MWE
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MAXJ,MAXMWA,MBS,MBJ,MBKJ,MBNORM,MBP1,  &
                            MCJ,MCKJ,MCS,MDJ,MDKJ,MDS,MKB,MKC,MKD,MKT,MMAX,MR,MT,MTEMP
      DOUBLE PRECISION :: ERR
      REAL :: C
      INTEGER :: J,JM1,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KSHIFT,KWA,L,N1,NGUARD
      INTENT (IN) :: MA,MB,MC,MD
      INTENT (INOUT) :: ME,MF,MG


      QX%NCALL = QX%NCALL + 1
      JRSSAV = QX%JRSIGN
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYE'
          CALL FMNTR(2,MA,MB,2,1,QX)
          IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL FMNTRJ(MC,QX%NDIG,QX)
                  CALL FMNTRJ(MD,QX%NDIG,QX)
              ELSE
                  CALL FMPRNT(MC,QX)
                  CALL FMPRNT(MD,QX)
              ENDIF
          ENDIF
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      C = 1000
      IF (QX%NDIG >= C .OR.                                              &
          ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR.  &
          ABS(MC%MP(2)) > QX%MEXPAB .OR. ABS(MD%MP(2)) > QX%MEXPAB .OR.  &
          QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN .OR.  &
              MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN .OR.  &
              MC%MP(2) == QX%MEXPOV .OR. MC%MP(2) == QX%MEXPUN .OR.  &
              MD%MP(2) == QX%MEXPOV .OR. MD%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO .OR.  &
              MC%MP(2) == QX%MUNKNO .OR. MD%MP(2) == QX%MUNKNO) KOVUN = 2
          QX%NCALL = QX%NCALL + 1
          CALL FMMPY2(MA,MB,MTD,QX)
          KB = QX%KFLAG
          CALL FMMPY2(MA,MC,MTE,QX)
          KJ = QX%KFLAG
          CALL FMMPY2(MA,MD,MG,QX)
          QX%NCALL = QX%NCALL - 1
          IF (((QX%KFLAG < 0 .OR. KB < 0 .OR. KJ < 0) .AND. KOVUN == 0)  &
              .OR. ((QX%KFLAG == -4 .OR. KB == -4 .OR. KJ == -4) .AND.   &
              KOVUN == 1)) THEN
              IF (QX%KFLAG == -4 .OR. KB == -4 .OR. KJ == -4) THEN
                  QX%KFLAG = -4
              ELSE IF (QX%KFLAG == -5 .OR. KB == -5 .OR. KJ == -5) THEN
                  QX%KFLAG = -5
              ELSE
                  QX%KFLAG = MIN(QX%KFLAG,KB,KJ)
              ENDIF
              QX%NAMEST(QX%NCALL) = 'FMMPYE'
              CALL FMWARN(QX)
          ENDIF
          CALL FMEQ(MTD,ME,QX)
          CALL FMEQ(MTE,MF,QX)
          GO TO 150
      ENDIF
      IF (MA%MP(3) == 0) THEN
          CALL FMIM(0,ME,QX)
          CALL FMIM(0,MF,QX)
          CALL FMIM(0,MG,QX)
          GO TO 150
      ENDIF
      IF (MB%MP(3) == 0 .OR. MC%MP(3) == 0 .OR. MD%MP(3) == 0) THEN
          CALL FMMPY2(MA,MB,MTD,QX)
          CALL FMMPY2(MA,MC,MTE,QX)
          CALL FMMPY2(MA,MD,MG,QX)
          CALL FMEQ(MTD,ME,QX)
          CALL FMEQ(MTE,MF,QX)
          GO TO 150
      ENDIF
      QX%KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD22
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (QX%MBASE < 10**6) NGUARD = MIN(NGUARD+1,QX%NDIG+2)
      ENDIF
      IF ((MA%MP(3)*MB%MP(3) < QX%MBASE .OR.  &
           MA%MP(3)*MC%MP(3) < QX%MBASE .OR.  &
           MA%MP(3)*MD%MP(3) < QX%MBASE) .AND. NGUARD < 3) NGUARD = 3

!             Save the signs and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)
      MCS = MC%MP(1)
      MDS = MD%MP(1)

      N1 = QX%NDIG + 1
      MWA%MP(2) = MA%MP(2) + MB%MP(2)
      MWD%MP(2) = MA%MP(2) + MC%MP(2)
      MWE%MP(2) = MA%MP(2) + MD%MP(2)
      L = QX%NDIG + 1 + NGUARD
      MWA%MP(L+2) = 0
      MWD%MP(L+2) = 0
      MWE%MP(L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = QX%MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - QX%MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MB%MP(3)
          MCJ = MC%MP(3)
          MDJ = MD%MP(3)

!             Count the trailing zeros in MA.

          IF (MA%MP(N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = QX%NDIG, 2, -1
                 IF (MA%MP(J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWA%MP(3) = 0
          MWD%MP(3) = 0
          MWE%MP(3) = 0
          DO K = QX%NDIG+2, L
             MWA%MP(K+1) = 0
             MWD%MP(K+1) = 0
             MWE%MP(K+1) = 0
          ENDDO

!             (Inner Loop)

          DO K = 2, N1
             MTEMP = MA%MP(K+1)
             MWA%MP(K+2) = MTEMP*MBJ
             MWD%MP(K+2) = MTEMP*MCJ
             MWE%MP(K+2) = MTEMP*MDJ
          ENDDO
          MAXMWA = MBJ
          IF (MCJ > MAXMWA) MAXMWA = MCJ
          IF (MDJ > MAXMWA) MAXMWA = MDJ
          DO J = 3, N1
             MBJ = MB%MP(J+1)
             MCJ = MC%MP(J+1)
             MDJ = MD%MP(J+1)
             MAXJ = MBJ
             IF (MCJ > MAXJ) MAXJ = MCJ
             IF (MDJ > MAXJ) MAXJ = MDJ
             MAXMWA = MAXMWA + MAXJ
             JM1 = J - 1
             KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

             DO K = J+2, J+KL
                MTEMP = MA%MP(K-JM1)
                MWA%MP(K) = MWA%MP(K) + MTEMP*MBJ
                MWD%MP(K) = MWD%MP(K) + MTEMP*MCJ
                MWE%MP(K) = MWE%MP(K) + MTEMP*MDJ
             ENDDO

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWA%MP(KB+1)/QX%MBASE)
                    MWA%MP(KB) = MWA%MP(KB) + MKT
                    MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
                    MKT = INT (MWD%MP(KB+1)/QX%MBASE)
                    MWD%MP(KB) = MWD%MP(KB) + MKT
                    MWD%MP(KB+1) = MWD%MP(KB+1) - MKT*QX%MBASE
                    MKT = INT (MWE%MP(KB+1)/QX%MBASE)
                    MWE%MP(KB) = MWE%MP(KB) + MKT
                    MWE%MP(KB+1) = MWE%MP(KB+1) - MKT*QX%MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          DO KB = L+1, 4, -1
             MKT = INT (MWA%MP(KB)/QX%MBASE)
             MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
             MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
             MKT = INT (MWD%MP(KB)/QX%MBASE)
             MWD%MP(KB-1) = MWD%MP(KB-1) + MKT
             MWD%MP(KB) = MWD%MP(KB) - MKT*QX%MBASE
             MKT = INT (MWE%MP(KB)/QX%MBASE)
             MWE%MP(KB-1) = MWE%MP(KB-1) + MKT
             MWE%MP(KB) = MWE%MP(KB) - MKT*QX%MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWA%MP(J+1) = 0
             MWD%MP(J+1) = 0
             MWE%MP(J+1) = 0
          ENDDO
          KJ = QX%NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MB%MP(KJ+1)
             MCKJ = MC%MP(KJ+1)
             MDKJ = MD%MP(KJ+1)
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MKB = 0
             MKC = 0
             MKD = 0
             DO K = 2, KL
                MT = MA%MP(KI-K+1)*MBKJ + MWA%MP(KWA-K+1) + MKB
                MKB = INT (MT/QX%MBASE)
                MWA%MP(KWA-K+1) = MT - QX%MBASE*MKB
                MT = MA%MP(KI-K+1)*MCKJ + MWD%MP(KWA-K+1) + MKC
                MKC = INT (MT/QX%MBASE)
                MWD%MP(KWA-K+1) = MT - QX%MBASE*MKC
                MT = MA%MP(KI-K+1)*MDKJ + MWE%MP(KWA-K+1) + MKD
                MKD = INT (MT/QX%MBASE)
                MWE%MP(KWA-K+1) = MT - QX%MBASE*MKD
             ENDDO
             MWA%MP(KWA-KL) = MKB
             MWD%MP(KWA-KL) = MKC
             MWE%MP(KWA-KL) = MKD
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWA%MP(3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplications are complete.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MB,ME,QX)
              GO TO 120
          ENDIF
      ENDIF
      MR = 2*MWA%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(KSHIFT+N1+1) = MWA%MP(KSHIFT+N1+1) + 1
                  MWA%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,ME,QX)

  120 IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (MWD%MP(3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWD%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MC,MF,QX)
              GO TO 130
          ENDIF
      ENDIF
      MR = 2*MWD%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWD,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWD%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWD%MP(KSHIFT+N1+1) = MWD%MP(KSHIFT+N1+1) + 1
                  MWD%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWD,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,MF,QX)

  130 IF ((MAS > 0 .AND. MDS > 0) .OR. (MAS < 0 .AND. MDS < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (MWE%MP(3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWE%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MD,MG,QX)
              GO TO 140
          ENDIF
      ENDIF
      MR = 2*MWE%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWE,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWE%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWE%MP(KSHIFT+N1+1) = MWE%MP(KSHIFT+N1+1) + 1
                  MWE%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWE,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWE,MG,QX)

  140 IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYE'
          CALL FMWARN(QX)
      ENDIF

      ME%MP(1) = 1
      IF (MAS*MBS < 0 .AND. ME%MP(2) /= QX%MUNKNO .AND. ME%MP(3) /= 0)  &
          ME%MP(1) = -1
      MF%MP(1) = 1
      IF (MAS*MCS < 0 .AND. MF%MP(2) /= QX%MUNKNO .AND. MF%MP(3) /= 0)  &
          MF%MP(1) = -1
      MG%MP(1) = 1
      IF (MAS*MDS < 0 .AND. MG%MP(2) /= QX%MUNKNO .AND. MG%MP(3) /= 0)  &
          MG%MP(1) = -1

  150 IF (QX%NTRACE /= 0) THEN
          CALL FMNTR(1,ME,ME,1,1,QX)
          IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL FMNTRJ(MF,QX%NDIG,QX)
                  CALL FMNTRJ(MG,QX%NDIG,QX)
              ELSE
                  CALL FMPRNT(MF,QX)
                  CALL FMPRNT(MG,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMMPYE

      RECURSIVE SUBROUTINE FMMPYFFT(MA,MB,MWA,QX)

!  Internal multiplication routine MA*MB for very high precision.
!  The result is returned in the internal work area MWA.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.

!  Use one of two methods, depending on the base MBASE.  When precision is high enough, the size of
!  the digits being convolved using FFT's must be reduced in order to keep the convolution products
!  from being too big to exactly recover the integer results.  The FFT operation has double
!  precision rounding errors, but the result of the convolution of two lists of integers is really
!  an integer.

!  For example, assume double precision carries 53 bits giving about 16 significant digit accuracy,
!  all the (positive) numbers in the two lists are less than K, and there are N numbers in each
!  list.  Then the convolution is an integer less than N*K*K.  A typical case might have MA and MB
!  in base 10**7 with 50,000 digits for about 350,000 significant digit precision.  This means
!  K = 10**7 and N = 5*10**4, so N*K*K = 5*10**18.  That is too big for this double precision.

!  Method 1:  If the base is a power of a small base ( MBASE = B**L for 2 <= B <= 19 ), then change
!             MA and MB to a base that is a smaller power of B to reduce the size of the individual
!             digits.  Changing to this smaller base is a fast O(N) operation.

!             In the example above, MA and MB could be changed to numbers with about 120,000 digits
!             in base 10**3.  Then N*K*K = 1.2*10**11, so even after losing 2 or 3 digits to
!             rounding in the FFT the results could be reliably rounded to the nearest integer.

!             This is the method used for the default FM power-of-ten base chosen in FMSET.
!             It is faster than method 2.

!  Method 2:  Here a fast change to a smaller base is not available, so each of MA and MB is split
!             into two pieces.  Each piece is a number with the same base and precision as MA and
!             MB have, but has artificially small digits.

!             Suppose the base is near 10**7 but not a power, say MBASE = B = 12345678, and MA or
!             MB is
!                       X = 1234567/B + 2345678/B**2 + ... + 9876543/B**N

!             Let K = SQRT(B) = 3513 be the upper bound on the size of the digits in the two
!             pieces, X1 and X2.  We write X = X1 + K*X2 by defining the digits of X1 to be the
!             digits of X mod K, and the digits of X2 to be the digits of X / K.  That gives

!                       X1 = 1504/B + 2507/B**2 + ... + 1500/B**N
!                       X2 =  351/B +  667/B**2 + ... + 2811/B**N

!             Now, X*Y = ( X1 + K*X2 ) ( Y1 + K*Y2 )
!                      =   X1*Y1 + K*(X1*Y2 + X2*Y1) + K**2*X2*Y2

!             Since the digits of X1 and X2 are formed one at a time from the corresponding digits
!             of X, generating X1 and X2 is a fast O(N) operation.

!             The terms in these products are still written in base b, but the digits are small,
!             no more than K.  These four multiplications are reduced to three, computing
!             X1*Y1, X2*Y2, and (X1+X2)*(Y1+Y2).
!             Then X1*Y2 + X2*Y1 = (X1+X2)*(Y1+Y2) - X1*Y1 - X2*Y2.  See Knuth, V 2, section 4.3.3.

!             Method 2 is recursive, since if N is large enough N*K*K may still be too large for
!             the double precision rounding errors.  In that case another splitting is done, giving
!             digits less than SQRT(AINT(SQRT(B))) = 59 in this example.

!             For B = 12345678 and 53-bit double precision, the first splitting is done for all N,
!             since B**2 > 10**14 is already too close to 16-digit integers.
!             A second splitting is done for N larger than about 4*10**5 (about 2.8 million decimal
!             digits), and a third for N > 1.4*10**9 (about 10 billion decimals).

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MXY(8)
      INTEGER :: J,K,L,NDSAVE
      DOUBLE PRECISION :: B,BL,D,DMAX


!             Check to see if the base is a power of a small integer.

      DO J = 2, 19
         IF (J == 2 .OR. J == 10) THEN
             B = 12 - J
         ELSE
             B = J
         ENDIF
         BL = 1
         DO L = 1, 100
            BL = BL*B
            IF (QX%MBASE == BL) THEN
                CALL FMMPYFFT1(MA,MB,MWA,B,L,QX)
                MWA%MP(2) = MA%MP(2) + MB%MP(2)
                RETURN
            ENDIF
            IF (QX%MBASE < BL) EXIT
         ENDDO
      ENDDO

!             Use method 2.

!             Find the maximum size of the digits in MA and MB.

      DMAX = 0
      DO J = 1, QX%NDIG
         D = MA%MP(J+2)
         IF (D > DMAX) DMAX = D
         D = MB%MP(J+2)
         IF (D > DMAX) DMAX = D
      ENDDO

!             Check to see if splitting is needed.

      IF (DMAX**2 > 1/(4.0D3*QX%NDIG*EPSILON(1.0D0))) THEN
          K = INT(SQRT(DMAX))
          NDSAVE = QX%NDIG
          QX%NDIG = 2*QX%NDIG + 2
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(3),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(4),NDSAVE,QX%NDIG,QX)
          CALL FMIM(0,MXY(5),QX)
          CALL FMIM(0,MXY(6),QX)
          CALL FMIM(0,MXY(7),QX)
          CALL FMIM(0,MXY(8),QX)
          DO J = 1, QX%NDIG
             L = MXY(1)%MP(J+2)
             MXY(1)%MP(J+2) = MOD(L,K)
             MXY(2)%MP(J+2) = L/K
             L = MXY(3)%MP(J+2)
             MXY(3)%MP(J+2) = MOD(L,K)
             MXY(4)%MP(J+2) = L/K
          ENDDO

!             Normalize any of these having a zero leading digit.

          IF (MXY(1)%MP(3) == 0) CALL FMMPYFFT_NORM(MXY(1),QX)
          IF (MXY(2)%MP(3) == 0) CALL FMMPYFFT_NORM(MXY(2),QX)
          IF (MXY(3)%MP(3) == 0) CALL FMMPYFFT_NORM(MXY(3),QX)
          IF (MXY(4)%MP(3) == 0) CALL FMMPYFFT_NORM(MXY(4),QX)

          QX%NDIG = NDSAVE
          CALL FMMPYFFT(MXY(1),MXY(3),MWA,QX)
          QX%NDIG = 2*QX%NDIG + 2
          CALL FMMOVE(MWA,MXY(5),QX)
          QX%NDIG = NDSAVE
          CALL FMMPYFFT(MXY(2),MXY(4),MWA,QX)
          QX%NDIG = 2*QX%NDIG + 2
          CALL FMMOVE(MWA,MXY(6),QX)
          CALL FMADD2(MXY(1),MXY(2),MXY(7),QX)
          CALL FMADD2(MXY(3),MXY(4),MXY(8),QX)
          QX%NDIG = NDSAVE
          CALL FMMPYFFT(MXY(7),MXY(8),MWA,QX)
          QX%NDIG = 2*QX%NDIG + 2
          CALL FMMOVE(MWA,MXY(7),QX)
          QX%KSUB = 1
          CALL FMADD2(MXY(7),MXY(5),MXY(1),QX)
          CALL FMADD2(MXY(1),MXY(6),MXY(2),QX)
          QX%KSUB = 0
          CALL FMMPYFFTI(MXY(6),K,MXY(3),QX)
          CALL FMADD2(MXY(3),MXY(2),MXY(4),QX)
          CALL FMMPYFFTI(MXY(4),K,MXY(3),QX)
          CALL FMADD2(MXY(3),MXY(5),MXY(4),QX)
          MWA%MP(1) = MXY(4)%MP(1)
          MWA%MP(2) = MXY(4)%MP(2)
          IF (MWA%MP(3) == 0) MWA%MP(2) = MWA%MP(2) + 1
          QX%NDIG = NDSAVE
      ELSE
          CALL FMMPYFFT2(MA,MB,MWA,QX)
          MWA%MP(2) = MA%MP(2) + MB%MP(2)
      ENDIF

      RETURN
      END SUBROUTINE FMMPYFFT

      SUBROUTINE FMMPYFFT1(MA,MB,MWA,B,L,QX)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

!  Internal multiplication routine MA*MB for very high precision.
!  The base for the arithmetic (MBASE) is a power of B, B**L, for 2 <= B <= 19.  This includes the
!  usual case where the default base chosen in FMSET is a power of 10.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      INTEGER :: J,K,K2,K3,K5,KA,L,L1,L2,L3,L5,N,N2,ND,NUM,NUMAR,NUMAI,NUMBR,NUMBI
      REAL (KIND(0.0D0)) :: D2,D3,DMIN,DPROD
      REAL (KIND(0.0D0)) :: B,BASE,C,D,T,T2,THETA,TMA,TMB
      TYPE(FM_SETTINGS) :: QX
      COMPLEX (KIND(0.0D0)), DIMENSION(:), ALLOCATABLE :: CX,CY,CZ,ROOTS_OF_UNITY
      COMPLEX (KIND(0.0D0)) :: CI,H1,H2,ST,W0,W

!             Initialize guard digits in MWA.

      DO J = 2*QX%NDIG, MIN(2*QX%NDIG+30, SIZE(MWA%MP)-2)
         MWA%MP(J+2) = 0
      ENDDO

!             If the base and/or number of digits is too large, rounding errors in the FFT
!             calculation will cause the result to be wrong.
!             Reduce the base if necessary.

      ND = QX%NDIG
      BASE = QX%MBASE
      IF (QX%MBASE**2 > 1/(1.0D3*ND*EPSILON(1.0D0))) THEN
          BASE = 1/SQRT(1.0D3*ND*EPSILON(1.0D0))
          K = LOG(BASE)/LOG(B)
          BASE = B**K
          ND = QX%NDIG*DBLE(L)/K + 1
      ENDIF

!             Choose the number of digits to use for the FFT.  Make the size of the array have no
!             prime factors other than 2, 3, or 5.

      L2 = LOG(10.0D0*ND)/LOG(2.0D0) + 2
      L3 = LOG(10.0D0*ND)/LOG(3.0D0) + 2
      L5 = 0
      IF (ND <= 100000) THEN
          L1 = 1
      ELSE
          L1 = MAX(2,NINT(2*LOG10(DBLE(ND))-8))
      ENDIF
      DMIN = HUGE(2.0D0)
      D2 = 2.0D0 ** L1
      DO K2 = L1, L2
         D3 = 1.0D0
         DO K3 = 0, L3
            DPROD = D2*D3
            DO K5 = 0, L5
               IF (DPROD > DMIN) EXIT
               IF (DPROD >= ND) THEN
                   IF (DPROD < DMIN) DMIN = DPROD
               ENDIF
               DPROD = 5*DPROD
            ENDDO
            D3 = 3*D3
         ENDDO
         D2 = 2*D2
      ENDDO
      N = DMIN
      N2 = N*2
      ALLOCATE(CX(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      ALLOCATE(CY(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      ALLOCATE(CZ(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      ALLOCATE(ROOTS_OF_UNITY(0:N-1),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      CALL FMFFT_INIT(ROOTS_OF_UNITY,N)

!             Pad the lists of digits with zeros, then pack the length 2*N real arrays into
!             length N complex arrays to speed up the FFT operations.

      IF (BASE == QX%MBASE) THEN
          DO J = QX%NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          DO J = 2, QX%NDIG, 2
             CX(J/2) = CMPLX( MA%MP(J+1) , MA%MP(J+2) , KIND(0.0D0) )
             CY(J/2) = CMPLX( MB%MP(J+1) , MB%MP(J+2) , KIND(0.0D0) )
          ENDDO
          IF (MOD(QX%NDIG,2) == 1) THEN
              CX(QX%NDIG/2+1) = MA%MP(QX%NDIG+2)
              CY(QX%NDIG/2+1) = MB%MP(QX%NDIG+2)
          ENDIF
      ELSE
          DO J = QX%NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          D = QX%MBASE/BASE
          C = QX%MBASE*D
          TMA = MA%MP(3)*QX%MBASE + MA%MP(4)
          NUMAR = TMA/C
          TMA = TMA - C*NUMAR
          TMB = MB%MP(3)*QX%MBASE + MB%MP(4)
          NUMBR = TMB/C
          TMB = TMB - C*NUMBR
          K = 0
          DO J = 3, QX%NDIG
             DO
                IF (C >= BASE) THEN
                    C = C/BASE
                ELSE
                    TMA = TMA*QX%MBASE + MA%MP(J+2)
                    TMB = TMB*QX%MBASE + MB%MP(J+2)
                    C = C*QX%MBASE
                    EXIT
                ENDIF
                NUMAI = TMA/C
                TMA = TMA - C*NUMAI
                NUMBI = TMB/C
                TMB = TMB - C*NUMBI
                IF (NUMAR < 0) THEN
                    NUMAR = NUMAI
                    NUMBR = NUMBI
                ELSE
                    K = K + 1
                    CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                    CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                    NUMAR = -1
                ENDIF
             ENDDO
          ENDDO
          DO
             IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 NUMAI = TMA*(BASE/C)
                 NUMBI = TMB*(BASE/C)
                 IF (NUMAR < 0) THEN
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAI) , 0.0D0 , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBI) , 0.0D0 , KIND(0.0D0) )
                 ELSE
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 ENDIF
                 EXIT
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
          ENDDO
      ENDIF

!             Transform.

      CALL FMFFT(CX,N,ROOTS_OF_UNITY,CZ)
      IF (QX%KSQR /= 1) THEN
          CALL FMFFT(CY,N,ROOTS_OF_UNITY,CZ)
      ENDIF

!             Unpack the two transforms.

      THETA = ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CX(J)+CONJG(CX(N+2-J)))
         H2 = -0.5D0*CI*(CX(J)-CONJG(CX(N+2-J)))
         CX(J) = H1 + W*H2
         CX(N+2-J) = CONJG(H1 - W*H2)
         IF (QX%KSQR /= 1) THEN
             H1 = 0.5D0*(CY(J)+CONJG(CY(N+2-J)))
             H2 = -0.5D0*CI*(CY(J)-CONJG(CY(N+2-J)))
             CY(J) = H1 + W*H2
             CY(N+2-J) = CONJG(H1 - W*H2)
         ENDIF
         W = W + ST*W
      ENDDO
      CX(1) = CMPLX( REAL(CX(1))+AIMAG(CX(1)) , REAL(CX(1))-AIMAG(CX(1)) , KIND(0.0D0) )
      IF (QX%KSQR /= 1) THEN
          CY(1) = CMPLX( REAL(CY(1))+AIMAG(CY(1)) , REAL(CY(1))-AIMAG(CY(1)) , KIND(0.0D0) )
      ENDIF

!             Multiply.

      IF (QX%KSQR /= 1) THEN
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CY(1)) , AIMAG(CX(1))*AIMAG(CY(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CY(J)
          ENDDO
      ELSE
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CX(1)) , AIMAG(CX(1))*AIMAG(CX(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CX(J)
          ENDDO
      ENDIF

!             Pack the product for input to the final FFT.

      THETA = -ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CZ(J)+CONJG(CZ(N+2-J)))
         H2 = 0.5D0*CI*(CZ(J)-CONJG(CZ(N+2-J)))
         CZ(J) = H1 + W*H2
         CZ(N+2-J) = CONJG(H1 - W*H2)
         W = W + ST*W
      ENDDO
      CZ(1) = CMPLX( REAL(CZ(1))+AIMAG(CZ(1)) , REAL(CZ(1))-AIMAG(CZ(1)) , KIND(0.0D0) )*0.5D0

!             Transform the product to get the convolution of the original inputs.

      CALL FMFFT(CZ,N,ROOTS_OF_UNITY,CY)
      T = 1.0D0/N
      DO J = 1, N
         CZ(J) = CZ(J)*T
      ENDDO

!             Normalize the digits.

!             The CZ array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in CZ(1), then the next two
!             are in CZ(N), then CZ(N-1), ..., CZ(2).
!             The imaginary part of CZ(2) is zero (up to roundoff), for a total of 2*N-1
!             digits in the convolution.
!             These digits can be as big as N*BASE^2 here.
!
!             First normalize and unscramble.

      IF (BASE == QX%MBASE) THEN
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N2
          IF (KA <= SIZE(MWA%MP)-3) THEN
              MWA%MP(KA+2) = T2
          ENDIF
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE(MWA%MP)-3) THEN
                 MWA%MP(KA+2) = T2
             ENDIF
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE(MWA%MP)-3) THEN
                 MWA%MP(KA+2) = T2
             ENDIF
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWA%MP(KA+2) = T2
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWA%MP(KA+2) = T2
          KA = KA - 1
          MWA%MP(KA+2) = T
      ELSE
          CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N
          CX(KA) = CI*T2
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             CX(KA) = T2 + CX(KA)
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             CX(KA) = CI*T2
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          CX(KA) = T2 + CX(KA)
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          CX(KA) = T + CI*T2
          TMA = 0
          C = 1
          K = 0
          DO J = 1, N2
             IF (MOD(J,2) == 1) THEN
                 NUM = REAL(CX((J+1)/2))
             ELSE
                 NUM = AIMAG(CX((J+1)/2))
             ENDIF
             TMA = TMA*BASE + NUM
             C = C*BASE
             IF (C < QX%MBASE) CYCLE
             C = C/QX%MBASE
             NUM = TMA/C
             TMA = TMA - C*NUM
             K = K + 1
             IF (K <= SIZE(MWA%MP)-3 .AND. K <= 2*QX%NDIG+2) THEN
                 MWA%MP(K+2) = NUM
             ELSE
                 EXIT
             ENDIF
          ENDDO
          K = K + 1
          IF (K <= SIZE(MWA%MP)-3 .AND. K <= 2*QX%NDIG+2) MWA%MP(K+2) = TMA*(QX%MBASE/C)
      ENDIF

      DEALLOCATE(CX,CY,CZ,ROOTS_OF_UNITY)
      RETURN
      END SUBROUTINE FMMPYFFT1

      SUBROUTINE FMMPYFFT2(MA,MB,MWA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

!  Internal multiplication routine MA*MB for very high precision.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.
!  This routine is used for method 2 of FMMPYFFT, where the base is not a power of a small number
!  and a different kind of splitting is used to avoid fft convolutions becoming too large.

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      INTEGER :: J,K,K2,K3,K5,KA,L1,L2,L3,L5,N,N2,ND,NUM,NUMAR,NUMAI,NUMBR,NUMBI
      REAL (KIND(0.0D0)) :: D2,D3,DMIN,DPROD
      REAL (KIND(0.0D0)) :: BASE,C,D,T,T2,THETA,TMA,TMB
      TYPE(FM_SETTINGS) :: QX
      COMPLEX (KIND(0.0D0)), DIMENSION(:), ALLOCATABLE :: CX,CY,CZ,ROOTS_OF_UNITY
      COMPLEX (KIND(0.0D0)) :: CI,H1,H2,ST,W0,W

      ND = QX%NDIG
      BASE = QX%MBASE

!             Initialize guard digits in MWA.

      DO J = 2*QX%NDIG, MIN(2*QX%NDIG+30,SIZE(MWA%MP)-2)
         MWA%MP(J+2) = 0
      ENDDO

!             Choose the number of digits to use for the FFT.  Make the size of the array have no
!             prime factors other than 2, 3, or 5.

      L2 = LOG(10.0D0*ND)/LOG(2.0D0) + 2
      L3 = LOG(10.0D0*ND)/LOG(3.0D0) + 2
      L5 = 0
      IF (ND <= 100000) THEN
          L1 = 1
      ELSE
          L1 = MAX(2,NINT(2*LOG10(DBLE(ND))-8))
      ENDIF
      DMIN = HUGE(2.0D0)
      D2 = 2.0D0
      DO K2 = L1, L2
         D3 = 1.0D0
         DO K3 = 0, L3
            DPROD = D2*D3
            DO K5 = 0, L5
               IF (DPROD > DMIN) EXIT
               IF (DPROD >= ND) THEN
                   IF (DPROD < DMIN) DMIN = DPROD
               ENDIF
               DPROD = 5*DPROD
            ENDDO
            D3 = 3*D3
         ENDDO
         D2 = 2*D2
      ENDDO
      N = DMIN
      N2 = N*2
      ALLOCATE(CX(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      ALLOCATE(CY(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      ALLOCATE(CZ(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      ALLOCATE(ROOTS_OF_UNITY(0:N-1),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      CALL FMFFT_INIT(ROOTS_OF_UNITY,N)

!             Pad the lists of digits with zeros, then pack the length 2*N real arrays into
!             length N complex arrays to speed up the FFT operations.

      IF (BASE == QX%MBASE) THEN
          DO J = QX%NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          DO J = 2, QX%NDIG, 2
             CX(J/2) = CMPLX( MA%MP(J+1) , MA%MP(J+2) , KIND(0.0D0) )
             CY(J/2) = CMPLX( MB%MP(J+1) , MB%MP(J+2) , KIND(0.0D0) )
          ENDDO
          IF (MOD(QX%NDIG,2) == 1) THEN
              CX(QX%NDIG/2+1) = MA%MP(QX%NDIG+2)
              CY(QX%NDIG/2+1) = MB%MP(QX%NDIG+2)
          ENDIF
      ELSE
          DO J = QX%NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          D = QX%MBASE/BASE
          C = QX%MBASE*D
          TMA = MA%MP(3)*QX%MBASE + MA%MP(4)
          NUMAR = TMA/C
          TMA = TMA - C*NUMAR
          TMB = MB%MP(3)*QX%MBASE + MB%MP(4)
          NUMBR = TMB/C
          TMB = TMB - C*NUMBR
          K = 0
          DO J = 3, QX%NDIG
             DO
                IF (C >= BASE) THEN
                    C = C/BASE
                ELSE
                    TMA = TMA*QX%MBASE + MA%MP(J+2)
                    TMB = TMB*QX%MBASE + MB%MP(J+2)
                    C = C*QX%MBASE
                    EXIT
                ENDIF
                NUMAI = TMA/C
                TMA = TMA - C*NUMAI
                NUMBI = TMB/C
                TMB = TMB - C*NUMBI
                IF (NUMAR < 0) THEN
                    NUMAR = NUMAI
                    NUMBR = NUMBI
                ELSE
                    K = K + 1
                    CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                    CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                    NUMAR = -1
                ENDIF
             ENDDO
          ENDDO
          DO
             IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 NUMAI = TMA*(BASE/C)
                 NUMBI = TMB*(BASE/C)
                 IF (NUMAR < 0) THEN
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAI) , 0.0D0 , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBI) , 0.0D0 , KIND(0.0D0) )
                 ELSE
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 ENDIF
                 EXIT
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
          ENDDO
      ENDIF

!             Transform.

      CALL FMFFT(CX,N,ROOTS_OF_UNITY,CZ)
      IF (QX%KSQR /= 1) THEN
          CALL FMFFT(CY,N,ROOTS_OF_UNITY,CZ)
      ENDIF

!             Unpack the two transforms.

      THETA = ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CX(J)+CONJG(CX(N+2-J)))
         H2 = -0.5D0*CI*(CX(J)-CONJG(CX(N+2-J)))
         CX(J) = H1 + W*H2
         CX(N+2-J) = CONJG(H1 - W*H2)
         IF (QX%KSQR /= 1) THEN
             H1 = 0.5D0*(CY(J)+CONJG(CY(N+2-J)))
             H2 = -0.5D0*CI*(CY(J)-CONJG(CY(N+2-J)))
             CY(J) = H1 + W*H2
             CY(N+2-J) = CONJG(H1 - W*H2)
         ENDIF
         W = W + ST*W
      ENDDO
      CX(1) = CMPLX( REAL(CX(1))+AIMAG(CX(1)) , REAL(CX(1))-AIMAG(CX(1)) , KIND(0.0D0) )
      IF (QX%KSQR /= 1) THEN
          CY(1) = CMPLX( REAL(CY(1))+AIMAG(CY(1)) , REAL(CY(1))-AIMAG(CY(1)) , KIND(0.0D0) )
      ENDIF

!             Multiply.

      IF (QX%KSQR /= 1) THEN
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CY(1)) , AIMAG(CX(1))*AIMAG(CY(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CY(J)
          ENDDO
      ELSE
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CX(1)) , AIMAG(CX(1))*AIMAG(CX(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CX(J)
          ENDDO
      ENDIF

!             Pack the product for input to the final FFT.

      THETA = -ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CZ(J)+CONJG(CZ(N+2-J)))
         H2 = 0.5D0*CI*(CZ(J)-CONJG(CZ(N+2-J)))
         CZ(J) = H1 + W*H2
         CZ(N+2-J) = CONJG(H1 - W*H2)
         W = W + ST*W
      ENDDO
      CZ(1) = CMPLX( REAL(CZ(1))+AIMAG(CZ(1)) , REAL(CZ(1))-AIMAG(CZ(1)) , KIND(0.0D0) )*0.5D0

!             Transform the product to get the convolution of the original inputs.

      CALL FMFFT(CZ,N,ROOTS_OF_UNITY,CY)
      T = 1.0D0/N
      DO J = 1, N
         CZ(J) = CZ(J)*T
      ENDDO

!             Normalize the digits.

!             The CZ array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in CZ(1), then the next two
!             are in CZ(N), then CZ(N-1), ..., CZ(2).
!             The imaginary part of CZ(2) is zero (up to roundoff), for a total of 2*N-1
!             digits in the convolution.
!             These digits can be as big as N*BASE^2 here.
!
!             First normalize and unscramble.

      IF (BASE == QX%MBASE) THEN
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N2
          IF (KA <= SIZE(MWA%MP)-3) THEN
              MWA%MP(KA+2) = T2
          ENDIF
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE(MWA%MP)-3) THEN
                 MWA%MP(KA+2) = T2
             ENDIF
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE(MWA%MP)-3) THEN
                 MWA%MP(KA+2) = T2
             ENDIF
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWA%MP(KA+2) = T2
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWA%MP(KA+2) = T2
          KA = KA - 1
          MWA%MP(KA+2) = T
      ELSE
          CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N
          CX(KA) = CI*T2
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             CX(KA) = T2 + CX(KA)
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             CX(KA) = CI*T2
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          CX(KA) = T2 + CX(KA)
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          CX(KA) = T + CI*T2
          TMA = 0
          C = 1
          K = 0
          DO J = 1, N2
             IF (MOD(J,2) == 1) THEN
                 NUM = REAL(CX((J+1)/2))
             ELSE
                 NUM = AIMAG(CX((J+1)/2))
             ENDIF
             TMA = TMA*BASE + NUM
             C = C*BASE
             IF (C < QX%MBASE) CYCLE
             C = C/QX%MBASE
             NUM = TMA/C
             TMA = TMA - C*NUM
             K = K + 1
             IF (K <= SIZE(MWA%MP)-3 .AND. K <= 2*QX%NDIG+2) THEN
                 MWA%MP(K+2) = NUM
             ELSE
                 EXIT
             ENDIF
          ENDDO
          K = K + 1
          IF (K <= SIZE(MWA%MP)-3 .AND. K <= 2*QX%NDIG+2) MWA%MP(K+2) = TMA*(QX%MBASE/C)
      ENDIF

      DEALLOCATE(CX,CY,CZ,ROOTS_OF_UNITY)
      RETURN
      END SUBROUTINE FMMPYFFT2

      SUBROUTINE FMMPYFFTI(MA,IVAL,MB,QX)

!  MB = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is used during fft-based multiplication.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      QX%NCALL = QX%NCALL + 1
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

!             Check for special cases.

      IF (MA%MP(3) == 0) THEN
          CALL FMEQ(MA,MB,QX)
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (ABS(MA%MP(2)) < QX%MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MA%MP(2) == QX%MUNKNO) THEN
          CALL FMIM(0,MB,QX)
          MB%MP(2) = QX%MUNKNO
          MB%MP(3) = 1
          QX%KFLAG = -4
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MB,QX)
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          DO J = 1, QX%NDIG+2
             MB%MP(J) = MA%MP(J)
          ENDDO
          IF (MA%MP(2) == QX%MEXPOV) QX%KFLAG = -5
          IF (MA%MP(2) == QX%MEXPUN) QX%KFLAG = -6
          MB%MP(1) = MA%MP(1)*IVAL
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPOV) THEN
          MAS = MA%MP(1)
          QX%KFLAG = -5
          CALL FMIM(0,MB,QX)
          MB%MP(2) = QX%MEXPOV
          MB%MP(3) = 1
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MB%MP(1) = -1
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -4
          CALL FMIM(0,MB,QX)
          MB%MP(2) = QX%MUNKNO
          MB%MP(3) = 1
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MA%MP(1)
      MVAL = ABS(IVAL)

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MA%MP(3)+1)*DBLE(MVAL)))/QX%DLOGMB)
      MWA%MP(2) = MA%MP(2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = QX%NDIG + 5
      DO J = KB, KC
         MWA%MP(J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MA%MP(J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/QX%MBASE)
         MWA%MP(J+1) = MKT - MCARRY*QX%MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/QX%MBASE)
         MWA%MP(J+1) = MCARRY - MKT*QX%MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWA%MP(3) or MWA%MP(4).
!             Round the result and move it to MB.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (MWA%MP(3) == 0) THEN
          MLR = 2*MWA%MP(QX%NDIG+4) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+2) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+2) = MWA%MP(N1+2) + 1
                      MWA%MP(N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWA%MP(QX%NDIG+3) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,KSHIFT,0,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                      MWA%MP(N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,KSHIFT,0,QX)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB,QX)

!             Put the sign on the result.

      MB%MP(1) = QX%JRSIGN
      QX%NCALL = QX%NCALL - 1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMMPYFFTI

      SUBROUTINE FMMPYFFT_NORM(MA,QX)

!  Normalize a number formed by the x1,x2 splitting done in FMMPYFFT.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA
      INTEGER :: J,KZ
      TYPE(FM_SETTINGS) :: QX

      KZ = 0
      DO J = 1, QX%NDIG
         IF (MA%MP(J+2) == 0) THEN
             KZ = J
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (KZ == 0) RETURN
      IF (KZ == QX%NDIG) THEN
          CALL FMIM(0,MA,QX)
          RETURN
      ENDIF
      DO J = 1, QX%NDIG-KZ
         MA%MP(J+2) = MA%MP(J+KZ+2)
      ENDDO
      DO J = QX%NDIG-KZ+1, QX%NDIG
         MA%MP(J+2) = 0
      ENDDO
      MA%MP(2) = MA%MP(2) - KZ

      RETURN
      END SUBROUTINE FMMPYFFT_NORM

      SUBROUTINE FMMPYI(MA,IVAL,MB,QX)

!  MB = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is faster than FMMPY when IVAL*MBASE is a one word integer.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYI'
          CALL FMNTR(2,MA,MA,1,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

!             Check for special cases.

      IF (MA%MP(3) == 0) THEN
          CALL FMEQ(MA,MB,QX)
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (ABS(MA%MP(2)) < QX%MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MA%MP(2) == QX%MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB,QX)
          QX%KFLAG = -4
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MB,QX)
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          DO J = 1, QX%NDIG+2
             MB%MP(J) = MA%MP(J)
          ENDDO
          IF (MA%MP(2) == QX%MEXPOV) QX%KFLAG = -5
          IF (MA%MP(2) == QX%MEXPUN) QX%KFLAG = -6
          MB%MP(1) = MA%MP(1)*IVAL
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPOV) THEN
          MAS = MA%MP(1)
          QX%KFLAG = -5
          CALL FMST2M('OVERFLOW',MB,QX)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MB%MP(1) = -1
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPUN) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYI'
          QX%KFLAG = -4
          CALL FMWARN(QX)
          CALL FMST2M('UNKNOWN',MB,QX)
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MA%MP(1)
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MA%MP(3)+1)*DBLE(MVAL)))/QX%DLOGMB)

!             If IVAL is too big use FMMPY.

      IF (KSHIFT > QX%NDIG .OR. MVAL > MAXINT/QX%MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1),QX)
          CALL FMMPY2(MA,MXY(1),MB,QX)
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      MWA%MP(2) = MA%MP(2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = QX%NDIG + 5
      DO J = KB, KC
         MWA%MP(J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MA%MP(J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/QX%MBASE)
         MWA%MP(J+1) = MKT - MCARRY*QX%MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/QX%MBASE)
         MWA%MP(J+1) = MCARRY - MKT*QX%MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWA%MP(3) or MWA%MP(4).
!             Round the result and move it to MB.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (MWA%MP(3) == 0) THEN
          MLR = 2*MWA%MP(QX%NDIG+4) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+2) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+2) = MWA%MP(N1+2) + 1
                      MWA%MP(N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWA%MP(QX%NDIG+3) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,KSHIFT,0,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                      MWA%MP(N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,KSHIFT,0,QX)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYI'
          CALL FMWARN(QX)
      ENDIF

!             Put the sign on the result.

      MB%MP(1) = QX%JRSIGN
      IF (QX%NTRACE /= 0) THEN
          CALL FMNTR(1,MB,MB,1,1,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMMPYI

      SUBROUTINE FMMPYI_R1(MA,IVAL,QX)

!  MA = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is faster than FMMPY when IVAL*MBASE is a one word integer.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(WORK_AREA) :: MWA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD,NMVAL,NV2
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JRSSAV = QX%JRSIGN
      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYI_R1'
          CALL FMNTR(2,MA,MA,1,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)
      ENDIF
      QX%KFLAG = 0
      N1 = QX%NDIG + 1

!             Check for special cases.

      IF (MA%MP(3) == 0) THEN
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (ABS(MA%MP(2)) < QX%MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MA%MP(2) == QX%MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MA,QX)
          QX%KFLAG = -4
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MA,QX)
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          IF (MA%MP(2) == QX%MEXPOV) QX%KFLAG = -5
          IF (MA%MP(2) == QX%MEXPUN) QX%KFLAG = -6
          MA%MP(1) = MA%MP(1)*IVAL
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPOV) THEN
          MAS = MA%MP(1)
          QX%KFLAG = -5
          CALL FMST2M('OVERFLOW',MA,QX)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MA%MP(1) = -1
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      IF (MA%MP(2) == QX%MEXPUN) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYI_R1'
          QX%KFLAG = -4
          CALL FMWARN(QX)
          CALL FMST2M('UNKNOWN',MA,QX)
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MA%MP(1)
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MA%MP(3)+1)*DBLE(MVAL)))/QX%DLOGMB)

!             If IVAL is too big use FMMPY.

      IF (KSHIFT > QX%NDIG .OR. MVAL > MAXINT/QX%MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1),QX)
          CALL FMMPY2_R1(MA,MXY(1),QX)
          IF (QX%NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%JRSIGN = JRSSAV
          RETURN
      ENDIF

      MWA%MP(2) = MA%MP(2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = QX%NDIG + 5
      DO J = KB, KC
         MWA%MP(J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MA%MP(J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/QX%MBASE)
         MWA%MP(J+1) = MKT - MCARRY*QX%MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/QX%MBASE)
         MWA%MP(J+1) = MCARRY - MKT*QX%MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWA%MP(3) or MWA%MP(4).
!             Round the result and move it to MA.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          QX%JRSIGN = 1
      ELSE
          QX%JRSIGN = -1
      ENDIF
      IF (MWA%MP(3) == 0) THEN
          MLR = 2*MWA%MP(QX%NDIG+4) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+2) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+2) = MWA%MP(N1+2) + 1
                      MWA%MP(N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,QX%NDIG,NGUARD,1,QX)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWA%MP(QX%NDIG+3) + 1
          IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
              CALL FMRND(MWA,QX%NDIG,KSHIFT,0,QX)
          ELSE IF (MLR >= QX%MBASE) THEN
              IF (MLR-1 > QX%MBASE .AND. MWA%MP(N1+1) < QX%MBASE-1) THEN
                  IF (QX%KROUND /= 0) THEN
                      MWA%MP(N1+1) = MWA%MP(N1+1) + 1
                      MWA%MP(N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,QX%NDIG,KSHIFT,0,QX)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMMPYI_R1'
          CALL FMWARN(QX)
      ENDIF

!             Put the sign on the result.

      MA%MP(1) = QX%JRSIGN
      IF (QX%NTRACE /= 0) THEN
          CALL FMNTR(1,MA,MA,1,1,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMMPYI_R1

      SUBROUTINE FMNINT(MA,MB,QX)

!  MB = NINT(MA)  --  MB is returned as the nearest integer to MA.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MA2,MXSAVE
      INTEGER :: K,KOVUN,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMENTR('FMNINT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMNINT'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
      IF (NDSAVE > INT(MA%MP(2))) THEN
          MA2 = MA%MP(1)
          MXY(2)%MP(1) = 1
          CALL FMI2M(1,MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMADD(MXY(2),MXY(1),MXY(3),QX)
          CALL FMINT(MXY(3),MXY(2),QX)
          IF (MA2 < 0 .AND. MXY(2)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(3) /= 0)  &
              MXY(2)%MP(1) = -MXY(2)%MP(1)
      ENDIF
      QX%KWARN = KWRNSV

!             Round the result and return.

      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMNINT

      SUBROUTINE FMNORM2(X,N,MB,QX)

!  MB = sqrt( x(1)^2 + x(2)^2 + ... + x(n)^2 )

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N
      TYPE(MULTI) :: X(N),MB
      INTEGER :: J,NDSAVE,MXSAVE
      INTENT (IN) :: X,N
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMNORM2  '
      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2

!             Check for special cases.

      DO J = 1, N
         IF (X(J)%MP(2) == QX%MUNKNO) THEN
             CALL FMST2M('UNKNOWN',MXY(1),QX)
             GO TO 110
         ENDIF
      ENDDO
      DO J = 1, N
         IF (X(J)%MP(2) == QX%MEXPOV) THEN
             CALL FMST2M('OVERFLOW',MXY(1),QX)
             GO TO 110
         ENDIF
      ENDDO

      CALL FMI2M(0,MXY(2),QX)
      DO J = 1, N
         CALL FMEQU(X(J),MXY(1),NDSAVE,QX%NDIG,QX)
         CALL FMSQR_R1(MXY(1),QX)
         CALL FMADD_R1(MXY(2),MXY(1),QX)
      ENDDO
      CALL FMSQRT_R1(MXY(2),QX)

  110 QX%MXEXP = MXSAVE
      CALL FMEQU(MXY(2),MB,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMNORM2

      FUNCTION FMNTERMS(Y,C1,C2,JN,CONV,QX)

!  Internal routine for estimating the number of terms needed in a series.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      DOUBLE PRECISION :: A,B,C,FB,FC,TOL,Y,Z,FMNTERMS
      DOUBLE PRECISION, EXTERNAL :: FMDPLG
      INTEGER :: C1,C2,JN,CONV
      TYPE(FM_SETTINGS) :: QX

      IF (CONV /= 1) GO TO 110

!             Convergent series.

      Z = Y*LOG(Y) - FMDPLG(Y+1,QX)
      C = 1
      IF (C2 == 1) THEN
          C = (SQRT(4*Y + JN**2) - JN)/2
          Z = C*LOG(Y) - FMDPLG(C+1,QX) - FMDPLG(C+JN+1,QX)
      ELSE IF (C2 == -1) THEN
          Z = (Y*Y/2)*LOG(Y) + FMDPLG(Y*Y/4+1,QX) - FMDPLG(Y*Y/2+1,QX)
      ENDIF
      IF (ABS(Y) < 1) Z = 0
      TOL = Z - QX%NDIG*QX%DLOGMB
      A = Y/C1
      IF (C2 == 1) THEN
          A = C
      ENDIF
      IF (A < 1) A = 1
      B = 2*A
      IF (C2 == 0) THEN
          FB = C1*B*LOG(Y) - FMDPLG(C1*B+1,QX)
      ELSE IF (C2 == 1) THEN
          FB = C1*B*LOG(Y) - FMDPLG(C1*B+1,QX) - FMDPLG(C1*(B+JN)+1,QX)
      ELSE IF (C2 == -1) THEN
          FB = C1*B*LOG(Y) + FMDPLG(B+1,QX) - FMDPLG(C1*B+1,QX)
      ENDIF
      DO WHILE (FB > TOL)
         A = B
         B = 2*B
         IF (C2 == 0) THEN
             FB = C1*B*LOG(Y) - FMDPLG(C1*B+1,QX)
         ELSE IF (C2 == 1) THEN
             FB = C1*B*LOG(Y) - FMDPLG(C1*B+1,QX) - FMDPLG(C1*(B+JN)+1,QX)
         ELSE IF (C2 == -1) THEN
             FB = C1*B*LOG(Y) + FMDPLG(B+1,QX) - FMDPLG(C1*B+1,QX)
         ENDIF
      ENDDO
      DO WHILE (B-A > 1)
         C = (A+B)/2
         IF (C2 == 0) THEN
             FC = C1*C*LOG(Y) - FMDPLG(C1*C+1,QX)
         ELSE IF (C2 == 1) THEN
             FC = C1*C*LOG(Y) - FMDPLG(C1*C+1,QX) - FMDPLG(C1*(C+JN)+1,QX)
         ELSE IF (C2 == -1) THEN
             FC = C1*C*LOG(Y) + FMDPLG(C+1,QX) - FMDPLG(C1*C+1,QX)
         ELSE
             FC = C1*C*LOG(Y) - FMDPLG(C1*C+1,QX)
         ENDIF
         IF (FC < TOL) THEN
             B = C
         ELSE
             A = C
         ENDIF
      ENDDO
      FMNTERMS = (A+B)/2
      RETURN

!             Asymptotic series.

  110 TOL = -QX%NDIG*QX%DLOGMB
      A = 1
      B = Y/C1
      IF (C2 == 1) THEN
          B = Y/2
      ENDIF
      IF (C2 == 0) THEN
          FB = FMDPLG(C1*B+1,QX) - C1*B*LOG(Y)
      ELSE IF (C2 == 1) THEN
          IF (-C1*B + JN >= 0) THEN
              FB = FMDPLG(C1*B+JN+1,QX) - C1*B*LOG(Y) - FMDPLG(C1*B+1,QX) - FMDPLG(-C1*B+JN+1,QX)
          ELSE
              FB = FMDPLG(C1*B+JN+1,QX) + FMDPLG(C1*B-JN+1,QX) - C1*B*LOG(Y) - FMDPLG(C1*B+1,QX)
          ENDIF
      ENDIF
      DO WHILE (B-A > 1)
         IF (ABS(FB)/1.0D10 > ABS(TOL) .AND. B/1.0D10 > A*1.1) THEN
             C = B/1.0D10
         ELSE IF (ABS(FB)/1.0D2 > ABS(TOL) .AND. B/1.0D2 > A*1.1) THEN
             C = B/1.0D2
         ELSE
             C = (A+B)/2
         ENDIF
         IF (C2 == 0) THEN
             FC = FMDPLG(C1*C+1,QX) - C1*C*LOG(Y)
         ELSE IF (C2 == 1) THEN
             IF (-C1*C + JN >= 0) THEN
                 FC = FMDPLG(C1*C+JN+1,QX) - C1*C*LOG(Y) - FMDPLG(C1*C+1,QX) - FMDPLG(-C1*C+JN+1,QX)
             ELSE
                 FC = FMDPLG(C1*C+JN+1,QX) + FMDPLG(C1*C-JN+1,QX) - C1*C*LOG(Y) - FMDPLG(C1*C+1,QX)
             ENDIF
         ENDIF
         IF (FC < TOL) THEN
             B = C
         ELSE
             A = C
         ENDIF
      ENDDO
      FMNTERMS = (A+B)/2

      END FUNCTION FMNTERMS

      SUBROUTINE FMNTR(NTR,MA,MB,NARG,KNAM,QX)

!  Print FM numbers in base 10 format using FMOUT for conversion.
!  This is used for trace output from the FM routines.

!  NTR =  1 if a result of an FM call is to be printed.
!      =  2 to print input argument(s) to an FM call.

!  MA  -  the FM number to be printed.

!  MB  -  an optional second FM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be printed, and NARG = 2 if
!         both MA and MB are to be printed.

!  KNAM - positive if the routine name is to be printed.


!  NTRACE and LVLTRC (in module FMVALS_PARALLEL) control trace printout.

!  NTRACE = 0        No printout except warnings and errors.

!  NTRACE = 1        The result of each call to one of the routines is printed in base 10,
!                    using FMOUT.

!  NTRACE = -1       The result of each call to one of the routines is printed in internal
!                    base MBASE format.

!  NTRACE = 2        The input arguments and result of each call to one of the routines is
!                    printed in base 10, using FMOUT.

!  NTRACE = -2       The input arguments and result of each call to one of the routines is
!                    printed in base MBASE format.

!  LVLTRC defines the call level to which the trace is done.  LVLTRC = 1 means only FM routines
!         called directly by the user are traced, LVLTRC = K prints traces for FM routines with
!         call levels up to and including level K.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: KNAM,NTR,NARG
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MA,MB,NARG,KNAM

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          IF (KNAM > 0) THEN
              NAME = QX%NAMEST(QX%NCALL)
              IF (QX%KROUND == 1) THEN
                  WRITE (KW,"(' Input to ',A)") TRIM(NAME)
              ELSE IF (QX%KROUND == 2) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
              ELSE IF (QX%KROUND == 0) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
              ELSE IF (QX%KROUND == -1) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
              ELSE
                  WRITE (KW,"(' Input to ',A)") TRIM(NAME)
              ENDIF
          ENDIF
      ELSE
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG,QX%KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (QX%NTRACE < 0) THEN
          CALL FMNTRJ(MA,QX%NDIG,QX)
          IF (NARG == 2) CALL FMNTRJ(MB,QX%NDIG,QX)
      ENDIF

!             Check for base 10 trace using FMOUT.

      IF (QX%NTRACE > 0) THEN
          CALL FMPRNT(MA,QX)
          IF (NARG == 2) THEN
              CALL FMPRNT(MB,QX)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE FMNTR

      SUBROUTINE FMNTRI(NTR,N,KNAM,QX)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (QX%KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (QX%KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (QX%KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG,QX%KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I20)") N

      RETURN
      END SUBROUTINE FMNTRI

      SUBROUTINE FMNTRJ(MA,ND,QX)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: ND
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(99) :: FORM
      CHARACTER(40), EXTERNAL :: FMFI
      CHARACTER(40) :: ST1,ST2
      INTEGER :: J,L,N
      INTENT (IN) :: MA,ND

      L = INT(LOG10(DBLE(QX%MBASE-1))) + 2
      N = (QX%KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,'/"  //  &
                      "(22X,',I3,'I',I2,')) ')"                &
                ) L+2, N-1, L, N, L
      ENDIF

      ST1 = FMFI(INT(MA%MP(1)))
      ST2 = FMFI(INT(MA%MP(2)))
      WRITE (KW,"(A,A,A,A,A)") '            Sign = ',TRIM(ST1),  &
                 '   Exponent = ',TRIM(ST2),'   Digits:'
      WRITE (FORM,*) '(13X,', N, 'I', L, ')'
      WRITE (KW,FORM) (INT(MA%MP(J)),J=3,ND+2)

      RETURN
      END SUBROUTINE FMNTRJ

      SUBROUTINE FMNTRR(NTR,X,KNAM,QX)

!  Internal routine for trace output of real variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Double precision value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      DOUBLE PRECISION :: X
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,X,KNAM

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (QX%KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (QX%KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (QX%KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG,QX%KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,D30.20)") X

      RETURN
      END SUBROUTINE FMNTRR

      SUBROUTINE FMOUT(MA,LINE,LB,QX)

!  Convert a floating multiple precision number to a character array for output.

!  MA   is an FM number to be converted to an A1 character array in base 10 format.
!  LINE is the character(1) array in which the result is returned.
!  LB   is the length of LINE.

! JFORM1 and JFORM2 (in module FMVALS_PARALLEL) determine the format of LINE.

! JFORM1 = 0  normal setting  ( .314159M+6 )
!        = 1  ES  format      ( 3.14159M+5 )
!        = 2  F   format      ( 314159.000 )

! JFORM2 = number of significant digits to display (if JFORM1 = 0, 1)
!        = number of digits after the decimal point (if JFORM1 = 2)

!          If JFORM2 == 0 and JFORM1 /= 2 then a default number of digits is chosen.
!          The default is roughly the full precision of MA.

!          If JFORM2 == 0 and JFORM1 == 2 then the number is returned in integer format with no
!          decimal point.  Rounding is done as with other settings, so the value displayed is the
!          nearest integer to MA.

!  If JFORM1 == 2 and MA is too large or too small to display in the requested format, it is
!  converted using JFORM1=0, JFORM2=0.

!  LINE should be dimensioned at least LOG10(MBASE)*NDIG + 15 on a 32-bit machine to allow for up to
!  10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit integers, ....

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: LB
      CHARACTER :: LINE(LB)
      TYPE(FM_SETTINGS) :: QX

      CHARACTER :: KCHAR
      REAL (KIND(1.0D0)) :: MBSAVE,MEXP,MEXP10,MKT,MS1,MS2,MSD2,MT10,MXSAVE
      INTEGER :: J,JDPT,JF1SAV,JF2SAV,K,K1,K2,KA,KB,KC,KDIGIT,KEXP,KMS2SD,KWRNSV,L,  &
                 NEW_MBASE,NEW_NDIG,ND,NDE,NDE2,NDSAVE,NPOWER,NSD1,NSD2,NVAL,NTRSAV, &
                 NWORD,NWORD1,NWORD2
      DOUBLE PRECISION :: X

      CHARACTER :: NUMB(10) = (/ '0','1','2','3','4','5','6','7','8','9' /)
      CHARACTER :: NUNKNO(12) = (/ ' ',' ',' ','U','N','K','N','O','W','N',' ',' ' /)
      CHARACTER :: NEXPOV(12) = (/ ' ',' ',' ','O','V','E','R','F','L','O','W',' ' /)
      CHARACTER :: NEXPUN(12) = (/ ' ',' ',' ','U','N','D','E','R','F','L','O','W' /)
      CHARACTER(9) :: NAMEST_SAVE(0:50)
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE
      TYPE(MULTI) :: MXY(2)


!             To avoid recursion, FMOUT calls only internal arithmetic routines
!             (FMADD2, FMMPY2, ...), so no trace printout is done during a call to FMOUT.

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMOUT'
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      DO J = 1, LB
         LINE(J) = ' '
      ENDDO

!             Check for special cases.

      IF (MA%MP(2) == QX%MUNKNO) THEN
          DO J = 1, 12
             LINE(J) = NUNKNO(J)
          ENDDO
          QX%KWARN = KWRNSV
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      IF (MA%MP(2) == QX%MEXPOV) THEN
          DO J = 1, 12
             LINE(J) = NEXPOV(J)
          ENDDO
          LINE(2) = '+'
          IF (MA%MP(1) < 0) LINE(2) = '-'
          QX%KWARN = KWRNSV
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      IF (MA%MP(2) == QX%MEXPUN) THEN
          DO J = 1, 12
             LINE(J) = NEXPUN(J)
          ENDDO
          LINE(2) = '+'
          IF (MA%MP(1) < 0) LINE(2) = '-'
          QX%KWARN = KWRNSV
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      IF (MA%MP(3) == 0 .AND. QX%JFORM1 == 2 .AND. QX%JFORM2 == 0) THEN
          LINE(2) = '0'
          QX%KWARN = KWRNSV
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      JF1SAV = QX%JFORM1
      JF2SAV = QX%JFORM2
      MBSAVE = QX%MBASE
      NDSAVE = QX%NDIG
      MXSAVE = QX%MXEXP

!             ND is the number of base 10 digits required.

  110 ND = QX%JFORM2
      IF (QX%JFORM1 == 2 .AND. MA%MP(2) > 0) THEN
          ND = QX%JFORM2 + INT(REAL(MA%MP(2))*LOG10(REAL(QX%MBASE))) + 1
          IF (ND <= 1 .AND. QX%JFORM2 == 0) ND = 10
      ENDIF
      IF (ND <= 1) THEN
          K = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE)))
          ND = MAX(K,QX%JFORM2)
      ENDIF
      IF (QX%JFORM2 <= 0 .AND. QX%JFORM1 <= 1) ND = INT(1.1 + REAL(QX%NDIG-1)*LOG10(REAL(QX%MBASE)))
      IF (ND < 2) ND = 2

      IF (LB < ND+6) THEN
          IF (QX%JFORM1 == 2) THEN
              QX%JFORM1 = 0
              QX%JFORM2 = 0
              GO TO 110
          ENDIF
          GO TO 170
      ENDIF

!             Convert to the base that is the largest power of 10 less than MXBASE and build the
!             output number.

      NPOWER = INT(LOG10(REAL(MXBASE)/4))
      QX%MXEXP = QX%MXEXP2
      QX%MBASE = 10**NPOWER
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NDIG = ND/NPOWER + 3
      K = NDSAVE*LOG(DBLE(MBSAVE))/LOG(DBLE(QX%MBASE))
      IF (QX%NDIG + 3000 < K) THEN
          QX%NDIG = ND/NPOWER + 3000
      ELSE IF (QX%NDIG < K) THEN
          QX%NDIG = K
      ENDIF
      IF (QX%NDIG < 2) QX%NDIG = 2

      IF (MA%MP(3) == 0) THEN
          CALL FMIM(0,MXY(2),QX)
          GO TO 120
      ENDIF

!             Check to see if MA is already in a base that is a power of ten.
!             If so, the conversion can be skipped.

      K = NPOWER
      DO J = 1, K
         QX%MBASE = 10**J
         IF (QX%MBASE == MBSAVE) THEN
             IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
             NPOWER = J
             QX%NDIG = MAX(NDSAVE,ND/NPOWER+3)
             IF (QX%NDIG < 2) QX%NDIG = 2
             IF (QX%NDIG > NDSAVE) THEN
                 CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
             ELSE
                 CALL FMIM(0,MXY(2),QX)
                 DO K1 = 1, MIN(QX%NDIG,SIZE(MA%MP)-3)
                    MXY(2)%MP(K1+2) = MA%MP(K1+2)
                 ENDDO
                 MXY(2)%MP(1) = MA%MP(1)
                 MXY(2)%MP(2) = MA%MP(2)
             ENDIF
             MXY(2)%MP(1) = 1
             GO TO 120
         ENDIF
      ENDDO

      NEW_MBASE = QX%MBASE
      NEW_NDIG = QX%NDIG
      QX%MBASE = MBSAVE
      QX%NDIG = MIN(NDSAVE,NINT(NEW_NDIG*LOG(DBLE(NEW_MBASE))/LOG(DBLE(QX%MBASE))))
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      J = QX%NCALL
      NAMEST_SAVE(0:QX%NCALL) = QX%NAMEST(0:QX%NCALL)
      QX%NCALL = 0
      CALL FMCHANGEBASE(MA,MXY(2),NEW_MBASE,NEW_NDIG,QX)
      QX%NCALL = J
      QX%NAMEST(0:QX%NCALL) = NAMEST_SAVE(0:QX%NCALL)
      QX%NTRACE = NTRSAV
      QX%MBASE = NEW_MBASE
      QX%NDIG = NEW_NDIG
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Now MXY(2) is the value of MA converted to a power of ten base.

!             Convert it to a character string base 10 for output.

!             MEXP10 is the base 10 exponent.
!             KMS2SD is the number of base 10 significant digits in the first digit of MXY(2).

  120 MS1 = MXY(2)%MP(2)
  130 MEXP10 = NPOWER*MXY(2)%MP(2)
      KMS2SD = NPOWER
      K = INT(QX%MBASE)
      DO J = 1, NPOWER
         K = K/10
         IF (MXY(2)%MP(3) < K .AND. MXY(2)%MP(3) /= 0) THEN
             MEXP10 = MEXP10 - 1
             KMS2SD = KMS2SD - 1
         ENDIF
      ENDDO

!             For printing using JFORM1 = 1, reduce the exponent to account for the fact that the
!             decimal point and first significant digit will later be swapped.

      IF (QX%JFORM1 == 1 .AND. MXY(2)%MP(3) /= 0) MEXP10 = MEXP10 - 1

!             Find the position in the unpacked number for rounding.
!             NWORD is the word in which rounding is done, or zero if no rounding is necessary.
!                   NWORD is set to -1 if JFORM1 is 2 (F format) but no significant digits would
!                   be printed.  This case defaults to JFORM1 = 0.
!             NVAL gives the position within that word where rounding occurs.
!             NSD1 is the maximum number of base 10 S.D.'s in NWORD digits of base 10**NPOWER.
!             NSD2 is the number of base 10 S.D.'s needed to get ND base 10 digits after
!                  the decimal.

      NSD2 = ND
      IF (QX%JFORM1 == 2) THEN
          MSD2 = QX%JFORM2 + MEXP10
          IF (MSD2 > ND) THEN
              NSD2 = ND
          ELSE
              NSD2 = INT(MSD2)
          ENDIF
          NWORD = (NSD2-KMS2SD-1+NPOWER)/NPOWER + 2
          IF (NWORD < 2) NWORD = -1
          IF (NWORD > QX%NDIG) NWORD = 0
          IF (NWORD >= 2 .AND. NSD2 <= 0) NWORD = -1
      ELSE
          NWORD = (ND-KMS2SD-1+NPOWER)/NPOWER + 2
      ENDIF
      NSD1 = KMS2SD + NPOWER*(NWORD-2)
      IF (NWORD < 2) THEN
          NVAL = 0
      ELSE
          NVAL = 10**(NSD1-NSD2)
      ENDIF

!             Now do the base 10 rounding.

      IF (NWORD >= 2) THEN
          X = 0
          IF (NVAL > 1) X = MOD(INT(MXY(2)%MP(NWORD+1)),NVAL)
          IF (NWORD < QX%NDIG+1) THEN
              X = X + DBLE(MXY(2)%MP(NWORD+2))/DBLE(QX%MBASE)
          ENDIF
          X = X/NVAL
          IF (QX%KROUND == 1 .AND. X < 0.5) GO TO 150
          IF (QX%KROUND == 1 .AND. X == 0.5) THEN
              DO J = NWORD+1, QX%NDIG
                 IF (MXY(2)%MP(J+2) /= 0) GO TO 140
              ENDDO
              J = MOD(INT(MXY(2)%MP(NWORD+1))/NVAL,10)
              IF (MOD(J,2) /= 0) GO TO 140
              GO TO 150
          ENDIF
          IF (QX%KROUND == 0) GO TO 150
          IF (QX%KROUND == -1 .AND. MA%MP(1) > 0) GO TO 150
          IF (QX%KROUND ==  2 .AND. MA%MP(1) < 0) GO TO 150
          IF (QX%KROUND == -1 .AND. X == 0.0) THEN
              DO J = NWORD+1, QX%NDIG
                 IF (MXY(2)%MP(J+2) /= 0) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
          IF (QX%KROUND ==  2 .AND. X == 0.0) THEN
              DO J = NWORD+1, QX%NDIG
                 IF (MXY(2)%MP(J+2) /= 0) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
  140     MS2 = MXY(2)%MP(3)
          MXY(2)%MP(NWORD+1) = INT(MXY(2)%MP(NWORD+1)/NVAL)*NVAL
          IF (NWORD+3 <= SIZE(MXY(2)%MP)) THEN
              MXY(2)%MP(NWORD+2) = 0
              IF (NWORD+4 <= SIZE(MXY(2)%MP)) THEN
                  MXY(2)%MP(NWORD+3) = 0
              ENDIF
              IF (QX%KROUND /= 1) THEN
                  DO J = NWORD, SIZE(MXY(2)%MP)-3
                     MXY(2)%MP(J+2) = 0
                  ENDDO
              ENDIF
          ENDIF
          MXY(2)%MP(NWORD+1) = MXY(2)%MP(NWORD+1) + NVAL
          IF (MXY(2)%MP(NWORD+1) >= QX%MBASE) THEN
              NWORD1 = NWORD - 1
              NWORD2 = NWORD - 2
              IF (NWORD > 2) THEN
                  CALL FMEQU_R1(MXY(2),NWORD1,NWORD2,QX)
              ELSE
                  MXY(2)%MP(2) = MXY(2)%MP(2) + 1
                  MXY(2)%MP(3) = INT(MXY(2)%MP(3)/QX%MBASE)
                  MXY(2)%MP(4) = 0
              ENDIF
          ENDIF
          IF (MXY(2)%MP(2) /= MS1 .OR. MXY(2)%MP(3) /= MS2) GO TO 130
      ENDIF

!             Build the base 10 character string.

  150 IF (MA%MP(1) < 0) LINE(1) = '-'
      LINE(2) = '.'
      K = 10**KMS2SD
      L = 2
      IF (NWORD == -1) NSD2 = ND
      DO J = 1, NSD2
         K = K/10
         IF (K == 0) THEN
             K = INT(QX%MBASE)/10
             L = L + 1
         ENDIF
         KDIGIT = INT(MXY(2)%MP(L+1))/K
         MXY(2)%MP(L+1) = MOD(INT(MXY(2)%MP(L+1)),K)
         LINE(J+2) = NUMB(KDIGIT+1)
      ENDDO

      KA = NSD2 + 3
      KB = ND + 2
      IF (KB >= KA) THEN
          DO J = KA, KB
             LINE(J) = NUMB(1)
          ENDDO
      ENDIF

      LINE(ND+3) = QX%CMCHAR
      LINE(ND+4) = '+'
      IF (MEXP10 < 0) LINE(ND+4) = '-'
      IF (MA%MP(3) == 0) LINE(ND+4) = ' '

!             Build the digits of the base 10 exponent backwards, then reverse them.

      NDE = 1
      MEXP = ABS(MEXP10)
      MT10 = 10
      DO J = 1, LB
         MKT = AINT (MEXP/MT10)
         KDIGIT = INT(MEXP-MKT*MT10)
         LINE(ND+4+J) = NUMB(KDIGIT+1)
         MEXP = MKT
         IF (MEXP == 0) EXIT

         IF (ND+5+J > LB) THEN
             DO K = 1, LB
                LINE(K) = '*'
             ENDDO
             GO TO 160
         ENDIF

         NDE = NDE + 1
      ENDDO

      NDE2 = NDE/2
      IF (NDE2 < 1) GO TO 160
      K1 = ND + 4
      K2 = ND + 5 + NDE
      DO J = 1, NDE2
         K1 = K1 + 1
         K2 = K2 - 1
         KCHAR = LINE(K1)
         LINE(K1) = LINE(K2)
         LINE(K2) = KCHAR
      ENDDO

!             If JFORM1 is 1 put the first digit left of the decimal.

  160 IF (QX%JFORM1 == 1) THEN
          KCHAR = LINE(2)
          LINE(2) = LINE(3)
          LINE(3) = KCHAR
      ENDIF

!             If JFORM1 is 2 put the number into fixed format.

      IF (QX%JFORM1 == 2 .AND. QX%JFORM2 >= 0) THEN
          IF (MEXP10 <= -QX%JFORM2 .OR. MEXP10+2 > LB .OR. LINE(1) == '*') THEN
              QX%JFORM1 = 0
              QX%JFORM2 = 0
              QX%MBASE = MBSAVE
              IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
              QX%NDIG = NDSAVE
              QX%MXEXP = MXSAVE
              DO J = 1, LB
                 LINE(J) = ' '
              ENDDO
              GO TO 110
          ENDIF
          KA = ND + 3
          DO J = KA, LB
             LINE(J) = NUMB(1)
          ENDDO

          KEXP = INT(MEXP10)
          IF (MEXP10 > 0) THEN
              DO J = 1, KEXP
                 LINE(J+1) = LINE(J+2)
              ENDDO
              LINE(KEXP+2) = '.'
          ENDIF

          IF (MEXP10 < 0) THEN
              KEXP = -INT(MEXP10)
              KA = 3 + KEXP
              KB = LB + 1
              KC = KB - KEXP
              DO J = KA, LB
                 KB = KB - 1
                 KC = KC - 1
                 LINE(KB) = LINE(KC)
                 LINE(KC) = NUMB(1)
              ENDDO
          ENDIF

          JDPT = 0
          DO J = 1, LB
             IF (LINE(J) == '.') JDPT = J
             IF (JDPT > 0 .AND. J > JDPT+QX%JFORM2) LINE(J) = ' '
          ENDDO
          IF (QX%JFORM2 == 0 .AND. JDPT > 0) LINE(KEXP+2) = ' '

      ENDIF

!             Restore values and return

      GO TO 180

!             LINE is not big enough to hold the number of digits specified.

  170 QX%KFLAG = -8
      DO J = 1, LB
         LINE(J) = '*'
      ENDDO
      QX%KWARN = KWRNSV
      CALL FMWARN(QX)

  180 QX%MBASE = MBSAVE
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NDIG = NDSAVE
      QX%MXEXP = MXSAVE
      QX%KWARN = KWRNSV
      QX%NCALL = QX%NCALL - 1
      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      RETURN
      END SUBROUTINE FMOUT


      SUBROUTINE FMPI(MA,QX)

!  MA = pi

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(MULTI) :: MPISAV
      CHARACTER(155) :: STRING
      INTEGER :: K,NDMB,NDSAVE,NDSV
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGPI = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMPI'
      IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
          WRITE (KW,"(' Input to FMPI')")
      ENDIF

!             Increase the working precision.

      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = QX%NGRD52
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF

      NDMB = INT(150.0*2.302585/QX%ALOGMB)
      IF (NDMB >= QX%NDIG) THEN
          NDSV = QX%NDIG
          QX%NDIG = NDMB
          STRING = '3.141592653589793238462643383279502884197169'//  &
          '39937510582097494459230781640628620899862803482534211'//  &
          '7067982148086513282306647093844609550582231725359408128'
          CALL FMST2M(STRING,MPISAV,QX)
          QX%MBSPI = QX%MBASE
          QX%NDIGPI = QX%NDIG
          IF (ABS(MPISAV%MP(2)) > 10) QX%NDIGPI = 0
      ELSE
          NDSV = QX%NDIG
          QX%NDIG = QX%NDIG + 2 + QX%NDIG/100
          CALL FMPI2(MXY(1),QX)
          CALL FMEQ(MXY(1),MPISAV,QX)
          QX%MBSPI = QX%MBASE
          QX%NDIGPI = QX%NDIG
          IF (ABS(MPISAV%MP(2)) > 10) QX%NDIGPI = 0
      ENDIF
      CALL FMEQU(MPISAV,MA,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSV

      QX%NDIG = NDSAVE
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMPI

      SUBROUTINE FMPI2(MPI,QX)

!  Internal routine to compute pi.
!  The formula used is due to S. Ramanujan.  For low to moderate precision, this routine uses
!  the series
!                                                (4n)!(1103+26390n)
!  1/pi = (sqrt(8)/9801) * sum(n=0 to infinity) --------------------
!                                               ((n!)**4)(396**(4n))
!
!  For higher precision, see routine FMPI3.
!
!  The result is returned in MPI.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MPI
      INTENT (INOUT) :: MPI
      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: MX
      INTEGER :: NSTACK(49),J,K,KST,LARGE,N,NDIGRD,NDSAVE,NMETHD
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX


!             Check for using binary splitting if precision is high.

      IF (QX%NDIG >= 100) THEN
          NMETHD = 2
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMPI3(MPI,QX)
          RETURN
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      NDSAVE = QX%NDIG
      N = -1
      CALL FMI2M(1103,MPI,QX)
      CALL FMI2M(0,MXY(1),QX)
      CALL FMI2M(1,MXY(2),QX)
      CALL FMI2M(26390,MXY(3),QX)
      CALL FMI2M(1103,MXY(4),QX)
      MX = MXBASE**2/QX%MBASE
      IF (MX > QX%MXEXP2) MX = QX%MXEXP2

  110 N = N + 1
      LARGE = INT(MX)/(4*N + 3)
      J = 4*N + 1
      IF (J > LARGE) THEN
          CALL FMMPYI_R1(MXY(2),J,QX)
          J = J + 1
          CALL FMMPYI_R1(MXY(2),J,QX)
          J = J + 1
          CALL FMMPYI_R1(MXY(2),J,QX)
      ELSE IF (J*(J+1) > LARGE) THEN
          K = J*(J+1)
          CALL FMMPYI_R1(MXY(2),K,QX)
          J = J + 2
          CALL FMMPYI_R1(MXY(2),J,QX)
      ELSE
          K = J*(J+1)*(J+2)
          CALL FMMPYI_R1(MXY(2),K,QX)
      ENDIF

      J = N + 1
      LARGE = INT(MXBASE)/J
      IF (J > LARGE) THEN
          CALL FMDIVI_R1(MXY(2),J,QX)
          CALL FMDIVI_R1(MXY(2),J,QX)
          CALL FMDIVI_R1(MXY(2),J,QX)
      ELSE IF (J*J > LARGE) THEN
          K = J*J
          CALL FMDIVI_R1(MXY(2),K,QX)
          CALL FMDIVI_R1(MXY(2),J,QX)
      ELSE
          K = J*J*J
          CALL FMDIVI_R1(MXY(2),K,QX)
      ENDIF

!             Break 4/396**4 into 1/(2178*2178*1296).

      J = 2178
      LARGE = INT(MXBASE)/J
      IF (J > LARGE) THEN
          CALL FMDIVI_R1(MXY(2),J,QX)
          CALL FMDIVI_R1(MXY(2),J,QX)
          CALL FMDIVI_R1(MXY(2),1296,QX)
      ELSE
          K = J*J
          CALL FMDIVI_R1(MXY(2),K,QX)
          CALL FMDIVI_R1(MXY(2),1296,QX)
      ENDIF

      NDIGRD = QX%NDIG
      QX%NDIG = NDSAVE
      CALL FMADD_R2(MXY(3),MXY(4),QX)
      QX%NDIG = NDIGRD
      CALL FMMPY(MXY(2),MXY(4),MXY(1),QX)

      QX%NDIG = NDSAVE
      CALL FMADD_R1(MPI,MXY(1),QX)
      QX%NDIG = MAX(QX%NGRD22,NDSAVE - INT(MPI%MP(2) - MXY(1)%MP(2)))
      IF (QX%KFLAG /= 1) GO TO 110
      QX%NDIG = NDSAVE

      CALL FMI2M(8,MXY(2),QX)
      X = 8
      X = SQRT(X)
      CALL FMDPM(X,MXY(4),QX)
      CALL FMDIG(NSTACK,KST,QX)
      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         CALL FMDIV(MXY(2),MXY(4),MXY(1),QX)
         CALL FMADD_R1(MXY(4),MXY(1),QX)
         CALL FMDIVI_R1(MXY(4),2,QX)
      ENDDO
      CALL FMI2M(9801,MXY(3),QX)
      CALL FMMPY_R1(MPI,MXY(4),QX)
      CALL FMDIV_R2(MXY(3),MPI,QX)

      RETURN
      END SUBROUTINE FMPI2

      SUBROUTINE FMPI3(MPI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

!  Internal pi routine for very high precision.

!  The algorithm used is Chudnovskys' Ramanujan-style series with binary splitting.

!                                                  (-1)**n*(6n)!(13591409+545140134*n)
!  1/pi = (12/640320**(3/2)) * sum(n=0 to infinity) -----------------------------------
!                                                     (n!)**3*(3*n)!*(640320**(3n))
!  The result is returned in MPI.

      TYPE(MULTI) :: MPI
      INTENT (INOUT) :: MPI
      INTEGER :: K,LEVEL_OF_RECURSION
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX


!             Determine K, the number of terms to sum in the series for pi.

      K = QX%NDIG*QX%DLOGMB/3.2654441D+1 + 10
      LEVEL_OF_RECURSION = 0
      CALL FMPI3_PQT(0,K,MXY(1),MXY(2),MXY(3),LEVEL_OF_RECURSION,QX)

      IF (MXY(2)%MP(2) >= QX%NDIG .AND. MXY(3)%MP(2) >= QX%NDIG) THEN
          CALL FMDIV(MXY(2),MXY(3),MXY(1),QX)
          CALL FMI2M(640320,MXY(2),QX)
          CALL FMSQRT(MXY(2),MXY(3),QX)
          CALL FMMPYI_R1(MXY(3),53360,QX)
          CALL FMMPY(MXY(1),MXY(3),MPI,QX)
      ELSE
          IF (MXY(2)%MP(2) >= QX%NDIG) THEN
              CALL FMEQ(MXY(2),MXY(1),QX)
          ELSE
              CALL IMI2FM(MXY(2),MXY(1),QX)
          ENDIF
          IF (MXY(3)%MP(2) >= QX%NDIG) THEN
              CALL FMEQ(MXY(3),MXY(4),QX)
          ELSE
              CALL IMI2FM(MXY(3),MXY(4),QX)
          ENDIF
          CALL FMDIV(MXY(1),MXY(4),MXY(3),QX)
          CALL FMI2M(640320,MXY(1),QX)
          CALL FMSQRT(MXY(1),MXY(2),QX)
          CALL FMMPYI_R1(MXY(2),53360,QX)
          CALL FMMPY(MXY(2),MXY(3),MPI,QX)
      ENDIF
      RETURN
      END SUBROUTINE FMPI3

      RECURSIVE SUBROUTINE FMPI3_PQT(A,B,MP,MQ,MT,LEVEL_OF_RECURSION,QX)

!  This routine does the binary splitting for computing the constant pi.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MP,MQ,MT
      INTEGER :: A,B,LEVEL_OF_RECURSION
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP,MQ,MT
      TYPE(MULTI) :: MXY(6)
      INTEGER :: J,KA,KM,RESULT_SIZE
      REAL (KIND(0.0D0)) :: DA,DB
      TYPE(FM_SETTINGS) :: QX

      DA = A
      DB = B
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 10) THEN
          RESULT_SIZE = ( (DB-DA)*4.276666 + 3*( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) ) ) * 1.01 / QX%DLOGMB + 15
          RESULT_SIZE = MAX(5,RESULT_SIZE) + 5*LOG(DBLE(QX%NDIG))/QX%DLOGMB + 15
          RESULT_SIZE = ( (DB-DA)*36.93111 + 3*( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) ) ) * 1.01 / QX%DLOGMB + 15
          RESULT_SIZE = MAX(5,RESULT_SIZE) + 5*LOG(DBLE(QX%NDIG))/QX%DLOGMB + 15
          CALL IMI2M(1,MP,QX)
          KA = A
          IF (KA == 0) KA = 1
          DO J = KA, B
             CALL IMMPYI(MP,-(6*J-5),MXY(2),QX)
             CALL IMMPYI(MXY(2),2*J-1,MXY(1),QX)
             CALL IMMPYI(MXY(1),6*J-1,MP,QX)
          ENDDO

          CALL IMI2M(640320,MXY(1),QX)
          CALL IMSQR(MXY(1),MXY(3),QX)
          CALL IMMPY(MXY(3),MXY(1),MXY(2),QX)
          CALL IMDIVI(MXY(2),24,MXY(1),QX)
          CALL IMI2M(1,MQ,QX)
          DO J = KA, B
             CALL IMMPYI(MQ,J,MXY(3),QX)
             CALL IMMPYI(MXY(3),J,MXY(2),QX)
             CALL IMMPYI(MXY(2),J,MXY(3),QX)
             CALL IMMPY(MXY(3),MXY(1),MQ,QX)
          ENDDO

          CALL IMI2M(0,MT,QX)
          IF (A == 0) THEN
              CALL IMMPYI(MQ,13591409,MT,QX)
          ENDIF
          CALL IMEQ(MQ,MXY(2),QX)
          DO J = KA, B
             CALL IMMPYI(MXY(2),-(6*J-5),MXY(3),QX)
             CALL IMMPYI(MXY(3),2*J-1,MXY(4),QX)
             CALL IMMPYI(MXY(4),6*J-1,MXY(2),QX)
             CALL IMDIVI(MXY(2),J,MXY(3),QX)
             CALL IMDIVI(MXY(3),J,MXY(4),QX)
             CALL IMDIVI(MXY(4),J,MXY(3),QX)
             CALL IMDIV(MXY(3),MXY(1),MXY(2),QX)
             CALL IMI2M(545140134,MXY(3),QX)
             CALL IMMPYI(MXY(3),J,MXY(4),QX)
             CALL IMI2M(13591409,MXY(3),QX)
             CALL IMADD(MXY(3),MXY(4),MXY(5),QX)
             CALL IMMPY(MXY(2),MXY(5),MXY(3),QX)
             CALL IMADD(MT,MXY(3),MXY(4),QX)
             CALL IMEQ(MXY(4),MT,QX)
          ENDDO

          GO TO 110
      ENDIF

      KM = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMPI3_PQT(A,KM-1,MXY(1),MXY(2),MXY(3),LEVEL_OF_RECURSION,QX)
      CALL FMPI3_PQT(KM,B,MXY(4),MXY(5),MXY(6),LEVEL_OF_RECURSION,QX)

!             MP is not needed in FMPI3, so this multiplication can be skipped at the top level
!             of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(1),MXY(4),MP,QX)
      ELSE
          CALL IMI2M(0,MP,QX)
      ENDIF
      CALL IM_OR_FM_MPY(MXY(2),MXY(5),MQ,QX)

      CALL IM_OR_FM_MPY(MXY(5),MXY(3),MXY(2),QX)
      CALL IM_OR_FM_MPY(MXY(1),MXY(6),MXY(4),QX)
      CALL IM_OR_FM_ADD(MXY(2),MXY(4),MT,QX)

  110 LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMPI3_PQT

      SUBROUTINE FMPRNT(MA,QX)

!  Print MA in base 10 format.

!  FMPRNT can be called directly by the user for easy output in M format.
!  MA is converted using FMOUT and printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFF(LMBUFF)
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(20) :: FORM
      INTEGER :: J,K,KSAVE,L,LAST,LB,ND,NEXP
      INTENT (IN) :: MA

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMPRNT'
      KSAVE = QX%KFLAG
      ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = MAX(QX%JFORM2+NEXP,ND+NEXP)
      IF (LB+50 > LMBUFF) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF
      CALL FMOUT(MA,CMBUFF,LB,QX)
      QX%KFLAG = KSAVE
      LAST = LB + 1
      WRITE (FORM,"(' (6X,',I3,'A1) ')") QX%KSWIDE-7
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             WRITE (KW,FORM) (CMBUFF(K),K=1,L)
             QX%NCALL = QX%NCALL - 1
             RETURN
         ENDIF
      ENDDO
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMPRNT

      SUBROUTINE FMPWR(MA,MB,MC,QX)

!  MC = MA ** MB

!  If MB can be expressed exactly as a one word integer, then FMIPWR is used.  This is much faster
!  when MB is small, and using FMIPWR allows MA to be negative.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTMB,J,K,KFL,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(4)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX


!             Convert MB to an integer before changing NDIG.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMMI(MB,INTMB,QX)
      QX%KWARN = KWRNSV
      KFL = QX%KFLAG
      KR_RETRY = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(1) >= 0 .AND. MA%MP(3) > 0 .AND.  &
          MA%MP(2) /= QX%MUNKNO .AND. MB%MP(2) /= QX%MUNKNO) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          QX%NCALL = QX%NCALL + 1
          IF (MB%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MB,MXY(3),QX)
              IF (MA%MP(2) <= 0) CALL FMMPYI_R1(MXY(3),-1,QX)
          ELSE
              CALL FMLN(MA,MXY(1),QX)
              CALL FMMPY(MXY(1),MB,MXY(3),QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (MXY(3)%MP(2) < -QX%NDIG) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMPWR'
                  CALL FMNTR(2,MA,MB,2,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              J = QX%NTRACE
              QX%NTRACE = 0
              K = QX%KWARN
              QX%KWARN = 0
              CALL FMI2M(1,MXY(1),QX)
              CALL FMSUB(MA,MXY(1),MXY(2),QX)
              IF (MXY(2)%MP(3) == 0) THEN
                  CALL FMI2M(1,MXY(2),QX)
              ELSE
                  CALL FMADD(MXY(1),MXY(3),MXY(2),QX)
              ENDIF
              IF (MXY(2)%MP(2) /= QX%MUNKNO) THEN
                  QX%KFLAG = 0
                  QX%NTRACE = J
                  QX%KWARN = K
                  CALL FMEQ(MXY(2),MC,QX)
                  IF (QX%NTRACE /= 0) THEN
                      QX%NCALL = QX%NCALL + 1
                      QX%NAMEST(QX%NCALL) = 'FMPWR'
                      CALL FMNTR(1,MC,MC,1,1,QX)
                      QX%NCALL = QX%NCALL - 1
                  ENDIF
                  RETURN
              ENDIF
          ENDIF
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR.  &
          MA%MP(3) == 0 .OR. MA%MP(1) < 0) THEN
          CALL FMENTR('FMPWR    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMPWR'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF

!             If the exponent is large or the base is very large, raise the precision.

      IF (MA%MP(2) /= 0) THEN
          IEXTRA = MAX(0,INT(MB%MP(2)))+INT(LOG(ABS(REAL(MA%MP(2))))/QX%ALOGMB)
      ELSE
          IEXTRA = MAX(0,INT(MB%MP(2)))
      ENDIF
      IF (MB%MP(2)-QX%NDIG > LOG(QX%ALOGMB*REAL(QX%MXEXP2))) THEN
          IEXTRA = 0
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF

!             If the exponent is a small integer, call FMIPWR.

      KWRNSV = QX%KWARN
      QX%KWARN = 0

      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)

      IF (KFL == 0) THEN
          CALL FMIPWR(MXY(2),INTMB,MXY(4),QX)
      ELSE IF (MXY(2)%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(4),QX)
          QX%KFLAG = -4
      ELSE
          CALL FMEQU(MB,MXY(1),NDSAVE,QX%NDIG,QX)
          IF (MXY(2)%MP(1) < 0) THEN
              CALL FMINT(MXY(1),MXY(3),QX)
              IF (FMCOMP(MXY(1),'==',MXY(3),QX)) THEN
                  CALL FMI2M(2,MXY(3),QX)
                  CALL FMMOD(MXY(1),MXY(3),MXY(4),QX)
                  J = -1
                  IF (MXY(4)%MP(3) == 0) J = 1
                  CALL FMMPYI_R1(MXY(2),-1,QX)
                  CALL FMLN(MXY(2),MXY(3),QX)
                  CALL FMMPY_R1(MXY(3),MXY(1),QX)
                  CALL FMEXP(MXY(3),MXY(4),QX)
                  IF (J == -1) CALL FMMPYI_R1(MXY(4),-1,QX)
              ELSE
                  CALL FMST2M('UNKNOWN',MXY(4),QX)
                  QX%KFLAG = -4
              ENDIF
          ELSE
              CALL FMLN(MXY(2),MXY(3),QX)
              CALL FMMPY_R1(MXY(3),MXY(1),QX)
              CALL FMEXP(MXY(3),MXY(4),QX)
          ENDIF
      ENDIF
      QX%KWARN = KWRNSV

!             Round the result and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(4)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(4),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMPWR

      SUBROUTINE FMRDC(MA,JSIN,JCOS,JSWAP,QX)

!  Reduce MA using various trigonometric identities to an equivalent angle between 0 and 45 degrees.
!  The reduction is done in radians if KRAD (in module FMVALS_PARALLEL) is 1, in degrees if
!  KRAD is 0.
!  JSIN and JCOS are returned +1 or -1 and JSWAP is returned to indicate that the sin and cos
!  functions have been interchanged as follows:

!  JSWAP = 0 means   SIN(MA) = JSIN*SIN(returned value of MA)
!                    COS(MA) = JCOS*COS(returned value of MA)

!  JSWAP = 1 means   SIN(MA) = JSIN*COS(returned value of MA)
!                    COS(MA) = JCOS*SIN(returned value of MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(MULTI) :: MPISAV
      INTEGER :: JSIN,JCOS,JSWAP
      DOUBLE PRECISION :: X
      INTEGER :: J,NDSAVE,NDSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (INOUT) :: MA
      INTENT (INOUT) :: JSIN,JCOS,JSWAP
      TYPE(MULTI) :: MXY(5)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGPI = 0
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      JSIN = 1
      JCOS = 1
      JSWAP = 0
      NDSAVE = QX%NDIG
      IF (QX%KRAD == 0) THEN
          CALL FMI2M(360,MXY(2),QX)
          CALL FMEQ(MA,MXY(4),QX)
          CALL FMMOD(MXY(4),MXY(2),MA,QX)
      ENDIF

      QX%NDIG = QX%NDIG + MAX(0,INT(MA%MP(2)))

!             If MA is less than 1/MBASE, no reduction is needed.

      IF (MA%MP(2) < 0) THEN
          QX%NDIG = NDSAVE
          IF (MA%MP(1) < 0) THEN
              MA%MP(1) = 1
              JSIN = -1
          ENDIF
          RETURN
      ENDIF

      J = 1
      IF (QX%KRAD == 1) THEN
  110     IF (QX%MBSPI /= QX%MBASE .OR. QX%NDIGPI < QX%NDIG)  THEN
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(4),QX)
              QX%NDIG = NDSV
          ENDIF
          CALL FMEQU(MA,MXY(4),NDSAVE,QX%NDIG,QX)
          IF (MA%MP(1) < 0) JSIN = -1
          MXY(4)%MP(1) = 1
          IF (MXY(4)%MP(2) == 0) THEN
              CALL FMM2DP(MXY(4),X,QX)
              IF (X <= 0.75) THEN
                  QX%NDIG = NDSAVE
                  CALL FMEQ(MXY(4),MA,QX)
                  RETURN
              ENDIF
          ENDIF
          CALL FMPI(MPISAV,QX)
          CALL FMADD(MPISAV,MPISAV,MXY(2),QX)
          IF (FMCOMP(MXY(4),'>=',MXY(2),QX)) THEN
              CALL FMDIV(MXY(4),MXY(2),MXY(1),QX)
              CALL FMINT(MXY(1),MXY(5),QX)
              CALL FMMPY_R1(MXY(5),MXY(2),QX)
              CALL FMSUB_R1(MXY(4),MXY(5),QX)
          ENDIF
          CALL FMEQ(MPISAV,MXY(3),QX)
          IF (FMCOMP(MXY(4),'>=',MXY(3),QX)) THEN
              JSIN = -JSIN
              CALL FMSUB_R2(MXY(2),MXY(4),QX)
          ENDIF
          CALL FMDIVI_R1(MXY(2),4,QX)
          IF (FMCOMP(MXY(4),'>=',MXY(2),QX)) THEN
              JCOS = -JCOS
              CALL FMSUB_R2(MXY(3),MXY(4),QX)
          ENDIF
          CALL FMDIVI_R1(MXY(3),4,QX)
          IF (FMCOMP(MXY(4),'>=',MXY(3),QX)) THEN
              JSWAP = 1
              CALL FMSUB_R2(MXY(2),MXY(4),QX)
          ENDIF

!             If the reduced argument is close to zero, then cancellation has produced an
!             inaccurate value.
!             Raise NDIG and do the reduction again.

          IF (J == 1 .AND. (MXY(4)%MP(2) < 0 .OR. MXY(4)%MP(3) == 0)) THEN
              J = 2
              IF (MXY(4)%MP(3) == 0) THEN
                  QX%NDIG = 2*QX%NDIG
              ELSE
                  QX%NDIG = QX%NDIG - INT(MXY(4)%MP(2))
              ENDIF
              JSIN = 1
              JCOS = 1
              JSWAP = 0
              GO TO 110
          ENDIF

      ELSE

          CALL FMEQU(MA,MXY(4),NDSAVE,QX%NDIG,QX)
          IF (MA%MP(1) < 0) JSIN = -1
          MXY(4)%MP(1) = 1
          IF (MXY(4)%MP(2) == 0) THEN
              CALL FMM2DP(MXY(4),X,QX)
              IF (X <= 44.0) THEN
                  QX%NDIG = NDSAVE
                  CALL FMEQ(MXY(4),MA,QX)
                  RETURN
              ENDIF
          ENDIF
          CALL FMI2M(360,MXY(2),QX)
          IF (FMCOMP(MXY(4),'>=',MXY(2),QX)) THEN
              CALL FMDIV(MXY(4),MXY(2),MXY(1),QX)
              CALL FMINT(MXY(1),MXY(5),QX)
              CALL FMMPY_R1(MXY(5),MXY(2),QX)
              CALL FMSUB_R1(MXY(4),MXY(5),QX)
          ENDIF
          CALL FMI2M(180,MXY(3),QX)
          IF (FMCOMP(MXY(4),'>=',MXY(3),QX)) THEN
              JSIN = -JSIN
              CALL FMSUB_R2(MXY(2),MXY(4),QX)
          ENDIF
          CALL FMI2M(90,MXY(2),QX)
          IF (FMCOMP(MXY(4),'>=',MXY(2),QX)) THEN
              JCOS = -JCOS
              CALL FMSUB_R2(MXY(3),MXY(4),QX)
          ENDIF
          CALL FMI2M(45,MXY(3),QX)
          IF (FMCOMP(MXY(4),'>=',MXY(3),QX)) THEN
              JSWAP = 1
              CALL FMSUB_R2(MXY(2),MXY(4),QX)
          ENDIF

      ENDIF

!             Round the result and return.

      CALL FMEQU(MXY(4),MA,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE FMRDC

      SUBROUTINE FMREAD(KREAD,MA,QX)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: KREAD
      CHARACTER :: CMBUFF(LMBUFF)
      TYPE(FM_SETTINGS) :: QX
      CHARACTER :: LINE(132)
      INTEGER :: J,LB,NDSAVE
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(2)


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMREAD'
      NDSAVE = QX%NDIG
      QX%NDIG = MAX(QX%NDIG+QX%NGRD52,2)
      LB = 0

  110 READ (KREAD,"(132A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 132
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFF) THEN
                 WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                     '  Raise its size or change the format being used.'
                 STOP
             ENDIF
             CMBUFF(LB) = LINE(J)
         ENDIF
      ENDDO

      QX%NCALL = QX%NCALL - 1
      CALL FMINP(CMBUFF,MXY(1),1,LB,QX)
      QX%NCALL = QX%NCALL + 1

      CALL FMEQU(MXY(1),MA,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN

!             If there is an error, return UNKNOWN.

  120 QX%KFLAG = -4
      CALL FMWARN(QX)
      QX%NDIG = NDSAVE
      CALL FMST2M('UNKNOWN',MA,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMREAD

      SUBROUTINE FMRND(MW,ND,NGUARD,KSHIFT,QX)

!  Round MW to ND digits (base MBASE).

!  MW is non-negative and has ND+NGUARD+KSHIFT digits.

!  NGUARD is the number of guard digits carried.
!  KSHIFT is 1 if a left shift is pending when MW%MP(3)=0.

!  Round to position MW%MP(1+ND+1+KSHIFT) using the guard digits
!  MW%MP(1+ND+2+KSHIFT), ..., MW%MP(1+ND+1+NGUARD+KSHIFT).

!  This routine is designed to be called only from within the FM package.
!  The user should call FMEQU to round numbers.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(WORK_AREA) :: MW
      INTEGER :: ND,NGUARD,KSHIFT
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: M2,MKT
      INTEGER :: J,K,KB,L
      INTENT (IN) :: ND,KSHIFT,NGUARD
      INTENT (INOUT) :: MW

      IF (QX%KROUND == -1) THEN
          IF (QX%JRSIGN == 1) RETURN
          DO J = ND+2+KSHIFT, ND+1+NGUARD+KSHIFT
             IF (MW%MP(J+1) > 0) THEN
                 MW%MP(KSHIFT+ND+2) = MW%MP(KSHIFT+ND+2) + 1
                 MW%MP(KSHIFT+ND+3) = 0
                 IF (MW%MP(KSHIFT+ND+2) < QX%MBASE) RETURN
                 L = ND + 2 + KSHIFT
                 GO TO 120
             ENDIF
          ENDDO
          RETURN
      ENDIF

      IF (QX%KROUND == 2) THEN
          IF (QX%JRSIGN == -1) RETURN
          DO J = ND+2+KSHIFT, ND+1+NGUARD+KSHIFT
             IF (MW%MP(J+1) > 0) THEN
                 MW%MP(KSHIFT+ND+2) = MW%MP(KSHIFT+ND+2) + 1
                 MW%MP(KSHIFT+ND+3) = 0
                 IF (MW%MP(KSHIFT+ND+2) < QX%MBASE) RETURN
                 L = ND + 2 + KSHIFT
                 GO TO 120
             ENDIF
          ENDDO
          RETURN
      ENDIF

      IF (QX%KROUND == 0) RETURN
      L = ND + 2 + KSHIFT
      IF (2*(MW%MP(L+1)+1) < QX%MBASE) RETURN
      IF (2*MW%MP(L+1) > QX%MBASE) THEN
          MW%MP(L) = MW%MP(L) + 1
          MW%MP(L+1) = 0
          IF (MW%MP(L) < QX%MBASE) RETURN
          GO TO 120
      ENDIF

!             If the first guard digit gives a value close to 1/2 then further guard digits must
!             be examined.

      M2 = 2
      IF (INT(QX%MBASE-AINT (QX%MBASE/M2)*M2) == 0) THEN
          IF (2*MW%MP(L+1) < QX%MBASE) RETURN
          IF (2*MW%MP(L+1) == QX%MBASE) THEN
              IF (NGUARD >= 2) THEN
                  DO J = 2, NGUARD
                     IF (MW%MP(J+L) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MW%MP(L)-AINT (MW%MP(L)/M2)*M2) == 0) RETURN
          ENDIF
      ELSE
          IF (2*MW%MP(L+1)+1 == QX%MBASE) THEN
              IF (NGUARD >= 2) THEN
                  DO J = 2, NGUARD
                     IF (2*(MW%MP(J+L)+1) < QX%MBASE) RETURN
                     IF (2*MW%MP(J+L) > QX%MBASE) GO TO 110
                  ENDDO
                  IF (NGUARD <= QX%NDIG) RETURN
                  M2 = 2
                  IF (INT(MW%MP(L)-AINT (MW%MP(L)/M2)*M2) == 0) THEN
                      RETURN
                  ELSE
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

!             Round up.

  110 MW%MP(L) = MW%MP(L) + 1
      MW%MP(L+1) = 0

!             Check whether there was a carry in the rounded digit.

  120 KB = L - 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MW%MP(K+1) < QX%MBASE) RETURN
             MKT = AINT (MW%MP(K+1)/QX%MBASE)
             MW%MP(K) = MW%MP(K) + MKT
             MW%MP(K+1) = MW%MP(K+1) - MKT*QX%MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MW%MP(3) >= QX%MBASE) THEN
          IF (KB >= 4) THEN
              K = KB + 1
              DO J = 4, KB
                 K = K - 1
                 MW%MP(K+1) = MW%MP(K)
              ENDDO
          ENDIF

          MKT = AINT (MW%MP(3)/QX%MBASE)
          IF (KB >= 3) MW%MP(4) = MW%MP(3) - MKT*QX%MBASE
          MW%MP(3) = MKT
          MW%MP(2) = MW%MP(2) + 1
      ENDIF

      RETURN
      END SUBROUTINE FMRND

      SUBROUTINE FMRPWR(MA,IVAL,JVAL,MB,QX)

!  MB = MA ** (IVAL/JVAL)   rational exponentiation.

!  This routine is faster than FMPWR when IVAL and JVAL are small integers.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL,JVAL
      DOUBLE PRECISION :: X,F
      REAL (KIND(1.0D0)) :: MA1,MA2,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: NSTACK(49),IJSIGN,INVERT,IVAL2,J,JVAL2,K,KL,KOVUN,KR_RETRY,KST,  &
                 KWRNSV,L,LVAL,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX

      KR_RETRY = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMRPWR'
      IF (QX%NTRACE /= 0) THEN
          CALL FMNTR(2,MA,MA,1,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)
          CALL FMNTRI(2,JVAL,0,QX)
      ENDIF
      KOVUN = 0
      IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
      NDSAVE = QX%NDIG
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2

  110 IF (QX%NCALL == 1) THEN
          XVAL = MAX(ABS(IVAL),ABS(JVAL))
          IF (XVAL == 0.0) XVAL = 1.0
          K = INT((5.0*REAL(QX%DLOGTN) + 2.0*LOG(XVAL))/QX%ALOGMB + 2.0)
          QX%NDIG = MAX(QX%NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = MAX(ABS(IVAL),ABS(JVAL))
          IF (XVAL == 0.0) XVAL = 1.0
          K = INT(LOG(XVAL)/QX%ALOGMB + 1.0)
          QX%NDIG = QX%NDIG + K
      ENDIF

      MAS = MA%MP(1)
      MA1 = MA%MP(2)
      MA2 = MA%MP(3)
      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)

!             Use GCD-reduced positive exponents.

      IJSIGN = 1
      IVAL2 = ABS(IVAL)
      JVAL2 = ABS(JVAL)
      IF (IVAL > 0 .AND. JVAL < 0) IJSIGN = -1
      IF (IVAL < 0 .AND. JVAL > 0) IJSIGN = -1
      IF (IVAL2 > 0 .AND. JVAL2 > 0) CALL FMGCDI(IVAL2,JVAL2)

!             Check for special cases.

  120 IF (MA1 == QX%MUNKNO .OR. JVAL2 == 0 .OR. (IJSIGN <= 0 .AND. MA2 == 0)) THEN
          CALL FMST2M('UNKNOWN',MXY(4),QX)
          QX%KFLAG = -4
          GO TO 130
      ENDIF

      IF (IVAL2 == 0) THEN
          CALL FMIM(1,MXY(4),QX)
          GO TO 130
      ENDIF

      IF (JVAL2 == 1) THEN
          CALL FMIPWR(MXY(2),IJSIGN*IVAL2,MXY(4),QX)
          GO TO 130
      ENDIF

      IF (MA2 == 0) THEN
          CALL FMEQ(MA,MXY(4),QX)
          GO TO 130
      ENDIF

      IF (MAS < 0) THEN
          IF (MOD(JVAL2,2) == 0) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
      ENDIF

      IF (MA1 == QX%MEXPOV) THEN
          IF (IVAL2 < JVAL2) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
          CALL FMIM(0,MXY(4),QX)
          IF (IJSIGN == 1 .AND. MAS > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(4),QX)
              QX%KFLAG = -5
          ELSE IF (IJSIGN == -1 .AND. MAS > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(4),QX)
              QX%KFLAG = -6
          ELSE IF (IJSIGN == 1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(4),QX)
                  QX%KFLAG = -5
              ELSE
                  CALL FMST2M('-OVERFLOW',MXY(4),QX)
                  QX%KFLAG = -5
              ENDIF
          ELSE IF (IJSIGN == -1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('UNDERFLOW',MXY(4),QX)
                  QX%KFLAG = -6
              ELSE
                  CALL FMST2M('-UNDERFLOW',MXY(4),QX)
                  QX%KFLAG = -6
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

      IF (MA1 == QX%MEXPUN) THEN
          IF (IVAL2 < JVAL2) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
          CALL FMIM(0,MXY(4),QX)
          IF (IJSIGN == 1 .AND. MAS > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(4),QX)
              QX%KFLAG = -6
          ELSE IF (IJSIGN == -1 .AND. MAS > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(4),QX)
              QX%KFLAG = -5
          ELSE IF (IJSIGN == 1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('UNDERFLOW',MXY(4),QX)
                  QX%KFLAG = -6
              ELSE
                  CALL FMST2M('-UNDERFLOW',MXY(4),QX)
                  QX%KFLAG = -6
              ENDIF
          ELSE IF (IJSIGN == -1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(4),QX)
                  QX%KFLAG = -5
              ELSE
                  CALL FMST2M('-OVERFLOW',MXY(4),QX)
                  QX%KFLAG = -5
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

!             Invert MA if MA > 1 and IVAL or JVAL is large.

      INVERT = 0
      IF (MA%MP(2) > 0) THEN
          IF (IVAL > 5 .OR. JVAL > 5) THEN
              INVERT = 1
              CALL FMI2M(1,MXY(1),QX)
              CALL FMDIV_R2(MXY(1),MXY(2),QX)
          ENDIF
      ENDIF

!             Generate the first approximation to ABS(MA)**(1/JVAL2).

      MA1 = MXY(2)%MP(2)
      MXY(2)%MP(2) = 0
      MXY(2)%MP(1) = 1
      CALL FMM2DP(MXY(2),X,QX)
      L = INT(MA1/JVAL2)
      F = MA1/DBLE(JVAL2) - L
      X = X**(1.0D0/JVAL2) * DBLE(QX%MBASE)**F
      CALL FMDPM(X,MXY(4),QX)
      MXY(4)%MP(2) = MXY(4)%MP(2) + L
      MXY(2)%MP(2) = MA1

!             Initialize.

      CALL FMI2M(0,MXY(3),QX)
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration.

      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         IF (J < KST) QX%NDIG = QX%NDIG + 1
         LVAL = JVAL2 - 1
         CALL FMIPWR(MXY(4),LVAL,MXY(3),QX)
         CALL FMDIV_R2(MXY(2),MXY(3),QX)
         CALL FMMPYI_R1(MXY(4),LVAL,QX)
         CALL FMADD_R1(MXY(4),MXY(3),QX)
         CALL FMDIVI_R1(MXY(4),JVAL2,QX)
      ENDDO

      IF (MXY(4)%MP(2) /= QX%MUNKNO .AND. MXY(4)%MP(3) /= 0 .AND. MAS < 0)  &
          MXY(4)%MP(1) = -MXY(4)%MP(1)
      CALL FMIPWR(MXY(4),IJSIGN*IVAL2,MXY(3),QX)
      CALL FMEQ(MXY(3),MXY(4),QX)
      IF (INVERT == 1) THEN
          CALL FMI2M(1,MXY(1),QX)
          CALL FMDIV_R2(MXY(1),MXY(4),QX)
      ENDIF

!             Round the result and return.

  130 KWRNSV = QX%KWARN
      IF (MA1 == QX%MUNKNO) QX%KWARN = 0

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(4)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(4),MB,NDSAVE,MXSAVE,KOVUN,QX)
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      QX%KWARN = KWRNSV
      RETURN
      END SUBROUTINE FMRPWR

      SUBROUTINE FMRSLT(MA,MB,MC,KRESLT,QX)

!  Handle results that are special cases, such as overflow, underflow, and unknown.

!  MA and MB are the input arguments to an FM subroutine.

!  MC is the result that is returned.

!  KRESLT is the result code from FMARGS.  Result codes handled here:

!   0 - Perform the normal operation
!   1 - The result is the first input argument
!   2 - The result is the second input argument
!   3 - The result is -OVERFLOW
!   4 - The result is +OVERFLOW
!   5 - The result is -UNDERFLOW
!   6 - The result is +UNDERFLOW
!   7 - The result is -1.0
!   8 - The result is +1.0
!  11 - The result is 0.0
!  12 - The result is UNKNOWN

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: KRESLT
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      KFSAVE = QX%KFLAG
      IF (KRESLT == 1) THEN
          CALL FMEQ(MA,MC,QX)
          IF (QX%NAMEST(QX%NCALL) == 'FMADD' .OR. QX%NAMEST(QX%NCALL) == 'FMADD_R1' .OR.  &
              QX%NAMEST(QX%NCALL) == 'FMADD_R2' .OR. QX%NAMEST(QX%NCALL) == 'FMSUB' .OR.  &
              QX%NAMEST(QX%NCALL) == 'FMSUB_R1' .OR. QX%NAMEST(QX%NCALL) == 'FMSUB_R2') THEN
              QX%KFLAG = 1
          ELSE
              QX%KFLAG = KFSAVE
          ENDIF
          RETURN
      ENDIF

      IF (KRESLT == 2) THEN
          CALL FMEQ(MB,MC,QX)
          IF (QX%NAMEST(QX%NCALL) == 'FMADD' .OR. QX%NAMEST(QX%NCALL) == 'FMADD_R1' .OR.  &
              QX%NAMEST(QX%NCALL) == 'FMADD_R2') THEN
              QX%KFLAG = 1
          ELSE
              QX%KFLAG = KFSAVE
          ENDIF
          IF (QX%NAMEST(QX%NCALL) == 'FMSUB' .OR. QX%NAMEST(QX%NCALL) == 'FMSUB_R1' .OR.  &
              QX%NAMEST(QX%NCALL) == 'FMSUB_R2') THEN
              IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0)  &
                  MC%MP(1) = -MC%MP(1)
              QX%KFLAG = KFSAVE
          ENDIF
          RETURN
      ENDIF

      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          CALL FMIM(0,MC,QX)
          MC%MP(2) = QX%MEXPOV
          MC%MP(3) = 1
          IF (KRESLT == 3) MC%MP(1) = -1
          QX%KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          CALL FMIM(0,MC,QX)
          MC%MP(2) = QX%MEXPUN
          MC%MP(3) = 1
          IF (KRESLT == 5) MC%MP(1) = -1
          QX%KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 7) THEN
          CALL FMIM(-1,MC,QX)
          QX%KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 8) THEN
          CALL FMIM(1,MC,QX)
          QX%KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 11) THEN
          CALL FMIM(0,MC,QX)
          QX%KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 12 .OR. KRESLT < 0 .OR. KRESLT > 15) THEN
          CALL FMIM(0,MC,QX)
          MC%MP(2) = QX%MUNKNO
          MC%MP(3) = 1
          QX%KFLAG = KFSAVE
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE FMRSLT

      SUBROUTINE FMSETVAR(STRING,QX)

!  Change the value of one of the internal FM variables.
!  STRING must have the format  ' variablename = value ', with no embedded blanks in variablename.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      TYPE(FM_SETTINGS) :: QX

      IF (STRING(1:1) /= ' ' .OR. QX%MBASE > -31) THEN
          WRITE (KW,"(//A//)") ' Internal variables cannot be changed in the thread-safe version of FM.'
      ENDIF
      STOP

      END SUBROUTINE FMSETVAR

      SUBROUTINE FMSIGN(MA,MB,MC,QX)

!  MC = SIGN(MA,MB)

!  MC is set to ABS(MA) if MB is positive or zero, or -ABS(MA) if MB is negative.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KWRNSV
      TYPE(FM_SETTINGS) :: QX


      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMSIGN'
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
      ELSE IF (MB%MP(1) >= 0) THEN
          CALL FMEQ(MA,MC,QX)
          MC%MP(1) = 1
      ELSE
          CALL FMEQ(MA,MC,QX)
          IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0) MC%MP(1) = -1
      ENDIF

      QX%KWARN = KWRNSV
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMSIGN

      SUBROUTINE FMSIN(MA,MB,QX)

!  MB = SIN(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MPISAV
      REAL (KIND(1.0D0)) :: MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(6)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGPI = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG .AND. QX%KRAD == 1) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMSIN'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMMPY(MXY(1),MA,MXY(2),QX)
          CALL FMDIVI(MXY(2),-6,MXY(3),QX)
          IF (MXY(3)%MP(2) > QX%MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB,QX)
          ELSE IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MA,MB,QX)
          ELSE IF (MA%MP(1) < 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              MXY(3)%MP(2) = MA%MP(2) + MXY(3)%MP(2)
              CALL FMEQ(MXY(3),MB,QX)
          ELSE IF (MA%MP(1) >= 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              MXY(3)%MP(2) = MA%MP(2) + MXY(3)%MP(2)
              CALL FMEQ(MXY(3),MB,QX)
          ELSE
              CALL FMEQ(MA,MB,QX)
          ENDIF
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMSIN'
              QX%KFLAG = -4
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMSIN'
              IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
              IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMSIN'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0) THEN
          CALL FMENTR('FMSIN    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMSIN'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      MAS = MA%MP(1)
      CALL FMEQU(MA,MXY(6),NDSAVE,QX%NDIG,QX)
      MXY(6)%MP(1) = 1
      CALL FMEQ(MXY(6),MXY(5),QX)
      IF (MA%MP(2) > 3*10**5 .AND. QX%KRAD == 1) THEN
          QX%KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(6),QX)
          GO TO 120
      ENDIF

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP,QX)
      IF (QX%KROUND /= 1 .AND. QX%KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1),QX)
          CALL FMSUB(MXY(6),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0 .AND. JSWAP == 0) THEN
              CALL FMST2M('0.5',MXY(1),QX)
              CALL FMMPYI(MXY(1),JSIN,MXY(6),QX)
              GO TO 120
          ENDIF
      ENDIF
      QX%KWARN = KWRNSV
      IF (MXY(6)%MP(2) == QX%MUNKNO) THEN
          IF (QX%KRAD /= 1 .OR. JSWAP == 0) THEN
              CALL FMEQ(MXY(5),MXY(6),QX)
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP,QX)
              GO TO 120
          ENDIF
          IF (QX%MBSPI /= QX%MBASE .OR. QX%NDIGPI < QX%NDIG)  THEN
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(3),QX)
              QX%NDIG = NDSV
          ENDIF
          CALL FMPI(MPISAV,QX)
          CALL FMDIV(MXY(5),MPISAV,MXY(3),QX)
          CALL FMMPYI_R1(MXY(3),2,QX)
          CALL FMNINT(MXY(3),MXY(2),QX)
          CALL FMMPY(MXY(2),MPISAV,MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMSUB_R2(MXY(5),MXY(1),QX)
          IF (MXY(1)%MP(3) == 0) CALL FMULP(MXY(5),MXY(1),QX)
          CALL FMI2M(1,MXY(3),QX)
          CALL FMSQR_R1(MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMSUB_R2(MXY(3),MXY(1),QX)
          CALL FMSUB_R1(MXY(1),MXY(3),QX)
          IF (MXY(1)%MP(3) == 0) THEN
              CALL FMI2M(JSIN,MXY(6),QX)
          ELSE
              CALL FMEQ(MXY(5),MXY(6),QX)
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP,QX)
          ENDIF
          GO TO 120
      ENDIF
      IF (QX%KRAD == 0) THEN
          IF (QX%MBSPI /= QX%MBASE .OR. QX%NDIGPI < QX%NDIG)  THEN
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(4),QX)
              QX%NDIG = NDSV
          ENDIF
          CALL FMPI(MPISAV,QX)
          CALL FMMPY_R1(MXY(6),MPISAV,QX)
          CALL FMDIVI_R1(MXY(6),180,QX)
      ENDIF
      IF (MXY(6)%MP(2) /= QX%MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MXY(6)%MP(2) < 0 .OR. QX%NDIG <= 50) THEN
                  CALL FMSIN2(MXY(6),MXY(4),QX)
                  CALL FMEQ(MXY(4),MXY(6),QX)
              ELSE
                  CALL FMCOS2(MXY(6),MXY(4),QX)
                  CALL FMI2M(1,MXY(2),QX)
                  CALL FMSQR_R1(MXY(4),QX)
                  CALL FMSUB_R2(MXY(2),MXY(4),QX)
                  CALL FMSQRT(MXY(4),MXY(6),QX)
              ENDIF
          ELSE
              CALL FMCOS2(MXY(6),MXY(4),QX)
              CALL FMEQ(MXY(4),MXY(6),QX)
          ENDIF
      ENDIF

!             Append the sign, round, and return.

      IF (JSIN == -1 .AND. MXY(6)%MP(2) /= QX%MUNKNO .AND. MXY(6)%MP(3) /= 0)  &
          MXY(6)%MP(1) = -MXY(6)%MP(1)
  120 IF (MAS < 0 .AND. MXY(6)%MP(2) /= QX%MUNKNO .AND. MXY(6)%MP(3) /= 0)  &
          MXY(6)%MP(1) = -MXY(6)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(6)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMSIN

      SUBROUTINE FMSIN2(MA,MB,QX)

!  Internal subroutine for MB = SIN(MA) where 0 <= MA <= 1.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MAXV
      INTEGER :: J,J2,K,K2,KTHREE,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG3,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (MA%MP(3) == 0) THEN
          CALL FMEQ(MA,MB,QX)
          RETURN
      ENDIF
      NDSAVE = QX%NDIG
      KWRNSV = QX%KWARN
      QX%KWARN = 0

!             Use the direct series
!                  SIN(X) = X - X**3/3! + X**5/5! - ...

!             The argument will be divided by 3**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.

      B = REAL(QX%MBASE)
      K = QX%NGRD52
      T = MAX(QX%NDIG-K,2)
      ALOG3 = LOG(3.0)
      ALOGT = LOG(T)
      TJ = 0.55*(QX%NDIG*QX%ALOGMT)**0.3333
      J2 = INT(TJ)
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      K2 = MAX(1,INT(0.62*(QX%NDIG*QX%ALOGMT)**0.3333 - 0.8))

      TJ = -(REAL(MA%MP(2))*QX%ALOGMB+LOG(REAL(MA%MP(3))/B +  &
             REAL(MA%MP(4))/(B*B)))/ALOG3 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG3)) + .33)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ENDIF

      N2 = INT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG3))
      L2 = INT((LOG(1+REAL(N2)/3.0D0**K2)+K2*LOG(3.0D0))/QX%ALOGMB)
      QX%NDIG = QX%NDIG + L2
      NDSAV1 = QX%NDIG

!             Divide the argument by 3**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      KTHREE = 1
      MAXV = MXBASE/3
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTHREE = 3*KTHREE
             IF (KTHREE > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTHREE,QX)
                 KTHREE = 1
             ENDIF
          ENDDO
          IF (KTHREE > 1) CALL FMCSDIVI_R1(MXY(1),KTHREE,QX)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      CALL FMI2M(1,MJSUMS(1),QX)
      CALL FMI2M(1,MXY(2),QX)
      NTERM = 3
      DO J = 2, J2
         NBOT = NTERM*(NTERM-1)
         CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         CALL FMEQ(MXY(2),MJSUMS(J),QX)
         NTERM = NTERM + 2
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 120
      CALL FMIPWR(MXY(1),2*J2,MXY(3),QX)
      IF (MXY(3)%MP(2) < -QX%NDIG) GO TO 120

  110 CALL FMCSMPY_R1(MXY(2),MXY(3),QX)
      DO J = 1, J2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(2),NTERM,QX)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         ENDIF
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2),QX)
         IF (QX%KFLAG /= 0) GO TO 120
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(2)%MP(2))
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMSQR(MXY(1),MXY(2),QX)
      IF (MXY(2)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(3) /= 0)  &
          MXY(2)%MP(1) = -MXY(2)%MP(1)
      CALL FMEQ(MJSUMS(J2),MXY(3),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(2),QX)
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1),QX)
      ENDDO
      CALL FMCSMPY_R1(MXY(3),MXY(1),QX)

!             Reverse the effect of reducing the argument to compute SIN(MA).

      QX%NDIG = NDSAV1
      IF (K2 > 0) THEN
          CALL FMI2M(3,MXY(1),QX)
          DO J = 1, K2
             CALL FMSQR(MXY(3),MXY(2),QX)
             CALL FMCSMPYI_R1(MXY(2),-4,QX)
             CALL FMADD_R2(MXY(1),MXY(2),QX)
             CALL FMCSMPY_R1(MXY(3),MXY(2),QX)
          ENDDO
      ENDIF

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV

      RETURN
      END SUBROUTINE FMSIN2

      SUBROUTINE FMSINH(MA,MB,QX)

!  MB = SINH(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMSINH'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMMPY(MXY(1),MA,MXY(2),QX)
          CALL FMDIVI(MXY(2),6,MXY(3),QX)
          IF (MXY(3)%MP(2) > QX%MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB,QX)
          ELSE IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MA,MB,QX)
          ELSE IF (MA%MP(1) < 0 .AND. QX%KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
              MB%MP(2) = MA%MP(2) + MB%MP(2)
          ELSE IF (MA%MP(1) >= 0 .AND. QX%KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
              MB%MP(2) = MA%MP(2) + MB%MP(2)
          ELSE
              CALL FMEQ(MA,MB,QX)
          ENDIF
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMSINH'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMENTR('FMSINH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMSINH'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      MAS = MA%MP(1)
      CALL FMEQU(MA,MXY(3),NDSAVE,QX%NDIG,QX)
      IF (MA%MP(3) == 0) THEN
          GO TO 120
      ENDIF
      MXY(3)%MP(1) = 1

!             Use a series for small arguments, FMEXP for large ones.

      IF (MXY(3)%MP(2) == QX%MUNKNO) GO TO 120
      IF (QX%MBASE > 99) THEN
          IF (MXY(3)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE IF (MXY(3)%MP(2) >= 2) THEN
              NMETHD = 2
          ELSE IF (ABS(MXY(3)%MP(3)) < 10) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MXY(3)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 1) THEN
          IF (MXY(3)%MP(2) < 0 .OR. QX%NDIG <= 50) THEN
              CALL FMSNH2(MXY(3),MXY(4),QX)
              CALL FMEQ(MXY(4),MXY(3),QX)
          ELSE
              CALL FMCSH2(MXY(3),MXY(4),QX)
              CALL FMI2M(1,MXY(2),QX)
              CALL FMSQR_R1(MXY(4),QX)
              CALL FMSUB_R1(MXY(4),MXY(2),QX)
              CALL FMSQRT(MXY(4),MXY(3),QX)
          ENDIF
      ELSE
          CALL FMEXP(MXY(3),MXY(5),QX)
          CALL FMEQ(MXY(5),MXY(3),QX)
          IF (MXY(3)%MP(2) == QX%MEXPOV) THEN
              GO TO 120
          ELSE IF (MXY(3)%MP(2) == QX%MEXPUN) THEN
              MXY(3)%MP(2) = QX%MEXPOV
              GO TO 120
          ENDIF
          IF (INT(MXY(3)%MP(2)) <= (QX%NDIG+1)/2) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMDIV_R1(MXY(1),MXY(3),QX)
              CALL FMSUB_R1(MXY(3),MXY(1),QX)
          ENDIF
          CALL FMDIVI_R1(MXY(3),2,QX)
      ENDIF

!             Round and return.

  120 IF (MAS < 0 .AND. MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(3)%MP(3) /= 0)  &
          MXY(3)%MP(1) = -MXY(3)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMSINH

      SUBROUTINE FMSNH2(MA,MB,QX)

!  Internal subroutine for MB = SINH(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MAXV
      INTEGER :: J,J2,K,K2,KTHREE,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG3,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (MA%MP(3) == 0) THEN
          CALL FMEQ(MA,MB,QX)
          RETURN
      ENDIF
      NDSAVE = QX%NDIG
      KWRNSV = QX%KWARN
      QX%KWARN = 0

!             Use the direct series
!                  SINH(X) = X + X**3/3! + X**5/5! - ...

!             The argument will be divided by 3**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.

      B = REAL(QX%MBASE)
      K = QX%NGRD52
      T = MAX(QX%NDIG-K,2)
      ALOG3 = LOG(3.0)
      ALOGT = LOG(T)
      TJ = 0.67*(QX%NDIG*QX%ALOGMT)**0.3333 - 0.3
      J2 = INT(TJ)
      J2 = MAX(2,MIN(J2,LJSUMS))
      K2 = MAX(2,INT(0.6*(QX%NDIG*QX%ALOGMT)**0.3333 - 0.8))

      TJ = -(REAL(MA%MP(2))*QX%ALOGMB+LOG(REAL(MA%MP(3))/B +  &
             REAL(MA%MP(4))/(B*B)))/ALOG3 - 0.3
      IF (TJ >= K2) THEN
          L = K2
      ELSE IF (TJ > 0) THEN
          L = INT(TJ)
      ELSE
          L = 0
      ENDIF
      K2 = K2 - L
      IF (K2 <= 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG3)) + .33)
          J2 = MAX(1,MIN(J2,LJSUMS))
      ENDIF

      N2 = INT(T*QX%ALOGMB/(ALOGT+REAL(L)*ALOG3))
      L2 = INT(LOG(REAL(N2)+3.0D0**K2)/QX%ALOGMB)
      QX%NDIG = QX%NDIG + L2
      NDSAV1 = QX%NDIG

!             Divide the argument by 3**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      KTHREE = 1
      MAXV = MXBASE/3
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTHREE = 3*KTHREE
             IF (KTHREE > MAXV) THEN
                 CALL FMCSDIVI_R1(MXY(1),KTHREE,QX)
                 KTHREE = 1
             ENDIF
          ENDDO
          IF (KTHREE > 1) CALL FMCSDIVI_R1(MXY(1),KTHREE,QX)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      CALL FMEQ(MXY(1),MXY(2),QX)
      NTERM = 1
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         IF (NBOT > 1) CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         NTERM = NTERM + 2
         CALL FMEQ(MXY(2),MJSUMS(J),QX)
      ENDDO
      CALL FMSQR_R1(MXY(1),QX)
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 120
      CALL FMIPWR(MXY(1),J2,MXY(3),QX)

  110 CALL FMCSMPY_R1(MXY(2),MXY(3),QX)
      DO J = 1, J2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(2),NTERM,QX)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(2),NBOT,QX)
         ENDIF
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2),QX)
         IF (QX%KFLAG /= 0) GO TO 120
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(2)%MP(2))
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(3),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(1),QX)
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1),QX)
      ENDDO

!             Reverse the effect of reducing the argument to compute SINH(MA).

      QX%NDIG = NDSAV1
      IF (K2 > 0) THEN
          CALL FMI2M(3,MXY(1),QX)
          DO J = 1, K2
             CALL FMSQR(MXY(3),MXY(2),QX)
             CALL FMCSMPYI_R1(MXY(2),4,QX)
             CALL FMADD_R2(MXY(1),MXY(2),QX)
             CALL FMCSMPY_R1(MXY(3),MXY(2),QX)
          ENDDO
      ENDIF

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV

      RETURN
      END SUBROUTINE FMSNH2

      SUBROUTINE FMSP2M(X,MA,QX)

!  MA = X

!  Convert a single precision number to FM format.

!  This version tries to convert the single precision machine number to FM with accuracy of nearly
!  full FM precision.
!  If conversion to FM with approximately double precision accuracy is good enough, it is faster to
!  CALL FMDPM(DBLE(X),MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      REAL :: X
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: XDP,Y,YT
      INTEGER :: J,K
      INTENT (IN) :: X
      INTENT (INOUT) :: MA


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMSP2M'
      XDP = DBLE(X)
      IF (QX%NTRACE /= 0) CALL FMNTRR(2,XDP,1,QX)

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (X > HUGE(X) .OR. X < -HUGE(X) .OR. (.NOT.(X == X))) THEN
          DO J = 2, QX%NDIG
             MA%MP(J+2) = 0
          ENDDO
          QX%KFLAG = -4
          MA%MP(2) = QX%MUNKNO
          MA%MP(3) = 1
          MA%MP(1) = 1
          CALL FMWARN(QX)
          GO TO 110
      ENDIF

!             Check to see if X is exactly a small integer.  If so, converting as an integer
!             is better.  Also see if X is exactly a small integer divided by a small power of two.

      Y = QX%MXEXP2
      IF (ABS(XDP) < Y) THEN
          K = INT(XDP)
          Y = K
          IF (Y == XDP) THEN
              CALL FMIM(K,MA,QX)
              GO TO 110
          ENDIF
      ENDIF
      IF (ABS(XDP) < 1.0D0) THEN
          Y = 4096.0D0 * XDP
          K = INT(Y)
          YT = K
          IF (Y == YT) THEN
              CALL FMIM(K,MA,QX)
              CALL FMDIVI_R1(MA,4096,QX)
              GO TO 110
          ENDIF
      ENDIF

      CALL FMDM2(XDP,MA,QX)

  110 IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMSP2M

      SUBROUTINE FMSQR(MA,MB,QX)

!  MB = MA*MA    Faster than using FMMPY.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMSQR'
          CALL FMNTR(2,MA,MA,1,1,QX)

          CALL FMSQR2(MA,MB,QX)

          CALL FMNTR(1,MB,MB,1,1,QX)
      ELSE
          CALL FMSQR2(MA,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMSQR

      SUBROUTINE FMSQR2(MA,MB,QX)

!  MB = MA*MA.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAXMAX,MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MK,MKA,MKT,MMAX,MR,MT
      DOUBLE PRECISION :: ERR
      REAL :: C
      INTEGER :: J,JM1,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KR_RETRY,KSHIFT,KWA,L,N1,NGUARD,NMETHD,NZDA
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB


      QX%KSQR = 1
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      KR_RETRY = 0
      JRSSAV = QX%JRSIGN
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1 .OR. QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MA%MP(2) == QX%MUNKNO) KOVUN = 2
          QX%NCALL = QX%NCALL + 1
          CALL FMMPY2(MA,MA,MB,QX)
          QX%NCALL = QX%NCALL - 1
          IF ((QX%KFLAG < 0 .AND. KOVUN == 0) .OR. (QX%KFLAG == -4 .AND. KOVUN == 1)) THEN
              QX%NAMEST(QX%NCALL) = 'FMSQR'
              CALL FMWARN(QX)
          ENDIF
          GO TO 130
      ELSE IF (MA%MP(3) == 0) THEN
          CALL FMEQ(MA,MB,QX)
          GO TO 130
      ENDIF
      QX%KFLAG = 0

!             Check for using an FFT-based method if precision is very high.

      C = 1300
      IF (QX%NDIG >= C) THEN
          NZDA = 0
          DO J = 2, QX%NDIG
             IF (MA%MP(J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (QX%NDIG-NZDA < 50 .OR. REAL(NZDA)/QX%NDIG > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPY2(MA,MA,MB,QX)
          GO TO 130
      ENDIF

      MAXMAX = 0
      N1 = QX%NDIG + 1
      MWA%MP(2) = MA%MP(2) + MA%MP(2)

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD22
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 2
          ELSE IF (QX%MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,QX%NDIG+2)
          ENDIF
      ENDIF
      IF (MA%MP(3)*MA%MP(3) < QX%MBASE .AND. NGUARD < 3) NGUARD = 3

      L = N1 + NGUARD
      MWA%MP(L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = QX%MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - QX%MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MA%MP(3)

!             Count the trailing zeros in MA.

          IF (MA%MP(N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = QX%NDIG, 2, -1
                 IF (MA%MP(J+1) /= 0) THEN
                     KNZ = J
                     GO TO 120
                 ENDIF
              ENDDO
          ENDIF

  120     MWA%MP(3) = 0
          MWA%MP(4) = 0
          DO K = QX%NDIG+2, L
             MWA%MP(K+1) = 0
          ENDDO

!             (Inner Loop)

          DO K = 4, N1+1
             MWA%MP(K+1) = MA%MP(K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, MIN(L/2,N1)
             MBJ = MA%MP(J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 DO K = 2*J+1, JM1+KL+1
                    MWA%MP(K) = MWA%MP(K) + MA%MP(K-JM1)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWA%MP(KB+1)/QX%MBASE)
                    MWA%MP(KB) = MWA%MP(KB) + MKT
                    MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          IF (2*MAX(MAXMAX,MAXMWA)+QX%MBASE > MMAX) THEN
              DO KB = L+1, 5, -1
                 MKT = INT (MWA%MP(KB)/QX%MBASE)
                 MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
                 MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
              ENDDO
          ENDIF

          DO J = 4, L, 2
             IF (J/2 <= N1) THEN
                 MKA = MA%MP(1+J/2)
                 MWA%MP(J) = 2*MWA%MP(J) + MKA*MKA
                 MWA%MP(J+1) = 2*MWA%MP(J+1)
             ELSE
                 MWA%MP(J) = 2*MWA%MP(J)
                 MWA%MP(J+1) = 2*MWA%MP(J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MA%MP(1+(L+1)/2)
                  MWA%MP(L+1) = 2*MWA%MP(L+1) + MKA*MKA
              ELSE
                  MWA%MP(L+1) = 2*MWA%MP(L+1)
              ENDIF
          ENDIF

          DO KB = L+1, 4, -1
             MKT = INT (MWA%MP(KB)/QX%MBASE)
             MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
             MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWA%MP(J+1) = 0
          ENDDO
          KJ = QX%NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MA%MP(KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MA%MP(KI-K+1)*MBKJ + MWA%MP(KWA-K+1) + MK
                MK = INT (MT/QX%MBASE)
                MWA%MP(KWA-K+1) = MT - QX%MBASE*MK
             ENDDO
             MWA%MP(KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWA%MP(3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplication is complete.  Round the result and move it to MB.

      QX%JRSIGN = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWA%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(KSHIFT+N1+1) = MWA%MP(KSHIFT+N1+1) + 1
                  MWA%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMSQR'
          CALL FMWARN(QX)
      ENDIF

  130 MB%MP(1) = 1
      QX%KSQR = 0
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMSQR2

      SUBROUTINE FMSQR_R1(MA,QX)

!  MA = MA*MA    Faster than using FMMPY.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMSQR_R1'
          CALL FMNTR(2,MA,MA,1,1,QX)

          CALL FMSQR2_R1(MA,QX)

          QX%NAMEST(QX%NCALL) = 'FMSQR_R1'
          CALL FMNTR(1,MA,MA,1,1,QX)
      ELSE
          CALL FMSQR2_R1(MA,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMSQR_R1

      SUBROUTINE FMSQR2_R1(MA,QX)

!  MA = MA*MA.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAXMAX,MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MK,MKA,MKT,MMAX,MR,MT
      DOUBLE PRECISION :: ERR
      REAL :: C
      INTEGER :: J,JM1,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KR_RETRY,KSHIFT,KWA,L,N1,NGUARD,NMETHD,NZDA
      TYPE(MULTI) :: MXY(2)


      QX%KSQR = 1
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      KR_RETRY = 0
      JRSSAV = QX%JRSIGN
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. QX%KDEBUG == 1 .OR. QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MA%MP(2) == QX%MUNKNO) KOVUN = 2
          QX%NCALL = QX%NCALL + 1
          CALL FMMPY2(MA,MA,MXY(1),QX)
          CALL FMEQ(MXY(1),MA,QX)
          QX%NCALL = QX%NCALL - 1
          IF ((QX%KFLAG < 0 .AND. KOVUN == 0) .OR. (QX%KFLAG == -4 .AND. KOVUN == 1)) THEN
              QX%NAMEST(QX%NCALL) = 'FMSQR_R1'
              CALL FMWARN(QX)
          ENDIF
          GO TO 130
      ELSE IF (MA%MP(3) == 0) THEN
          GO TO 130
      ENDIF
      QX%KFLAG = 0

!             Check for using an FFT-based method if precision is very high.

      C = 1300
      IF (QX%NDIG >= C) THEN
          NZDA = 0
          DO J = 2, QX%NDIG
             IF (MA%MP(J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (QX%NDIG-NZDA < 50 .OR. REAL(NZDA)/QX%NDIG > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPY2(MA,MA,MXY(1),QX)
          CALL FMEQ(MXY(1),MA,QX)
          GO TO 130
      ENDIF

      MAXMAX = 0
      N1 = QX%NDIG + 1
      MWA%MP(2) = MA%MP(2) + MA%MP(2)

!             NGUARD is the number of guard digits used.

  110 IF (QX%NCALL > 1) THEN
          NGUARD = QX%NGRD22
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
      ELSE
          NGUARD = QX%NGRD52
          IF (NGUARD > QX%NDIG) NGUARD = QX%NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = QX%NDIG + 2
          ELSE IF (QX%MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,QX%NDIG+2)
          ENDIF
      ENDIF
      IF (MA%MP(3)*MA%MP(3) < QX%MBASE .AND. NGUARD < 3) NGUARD = 3

      L = N1 + NGUARD
      MWA%MP(L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = QX%MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - QX%MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MA%MP(3)

!             Count the trailing zeros in MA.

          IF (MA%MP(N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = QX%NDIG, 2, -1
                 IF (MA%MP(J+1) /= 0) THEN
                     KNZ = J
                     GO TO 120
                 ENDIF
              ENDDO
          ENDIF

  120     MWA%MP(3) = 0
          MWA%MP(4) = 0
          DO K = QX%NDIG+2, L
             MWA%MP(K+1) = 0
          ENDDO

!             (Inner Loop)

          DO K = 4, N1+1
             MWA%MP(K+1) = MA%MP(K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, MIN(L/2,N1)
             MBJ = MA%MP(J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 DO K = 2*J+1, JM1+KL+1
                    MWA%MP(K) = MWA%MP(K) + MA%MP(K-JM1)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWA%MP(KB+1)/QX%MBASE)
                    MWA%MP(KB) = MWA%MP(KB) + MKT
                    MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          IF (2*MAX(MAXMAX,MAXMWA)+QX%MBASE > MMAX) THEN
              DO KB = L+1, 5, -1
                 MKT = INT (MWA%MP(KB)/QX%MBASE)
                 MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
                 MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
              ENDDO
          ENDIF

          DO J = 4, L, 2
             IF (J/2 <= N1) THEN
                 MKA = MA%MP(1+J/2)
                 MWA%MP(J) = 2*MWA%MP(J) + MKA*MKA
                 MWA%MP(J+1) = 2*MWA%MP(J+1)
             ELSE
                 MWA%MP(J) = 2*MWA%MP(J)
                 MWA%MP(J+1) = 2*MWA%MP(J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MA%MP(1+(L+1)/2)
                  MWA%MP(1+L) = 2*MWA%MP(1+L) + MKA*MKA
              ELSE
                  MWA%MP(1+L) = 2*MWA%MP(1+L)
              ENDIF
          ENDIF

          DO KB = L+1, 4, -1
             MKT = INT (MWA%MP(KB)/QX%MBASE)
             MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
             MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize
!             as the digits are multiplied.

          DO J = 2, L
             MWA%MP(J+1) = 0
          ENDDO
          KJ = QX%NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MA%MP(KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MA%MP(KI-K+1)*MBKJ + MWA%MP(KWA-K+1) + MK
                MK = INT (MT/QX%MBASE)
                MWA%MP(KWA-K+1) = MT - QX%MBASE*MK
             ENDDO
             MWA%MP(KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWA%MP(3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplication is complete.  Round the result and move it to MA.

      QX%JRSIGN = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(NGUARD,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWA%MP(J+KSHIFT+QX%NDIG+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < QX%NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWA%MP(KSHIFT+QX%NDIG+3) + 1
      IF (QX%KROUND == -1 .OR. QX%KROUND == 2) THEN
          CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
      ELSE IF (MR >= QX%MBASE) THEN
          IF (MR-1 > QX%MBASE .AND. MWA%MP(KSHIFT+N1+1) < QX%MBASE-1) THEN
              IF (QX%KROUND /= 0) THEN
                  MWA%MP(KSHIFT+N1+1) = MWA%MP(KSHIFT+N1+1) + 1
                  MWA%MP(KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,QX%NDIG,NGUARD,KSHIFT,QX)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMSQR_R1'
          CALL FMWARN(QX)
      ENDIF

  130 MA%MP(1) = 1
      QX%KSQR = 0
      QX%JRSIGN = JRSSAV
      RETURN
      END SUBROUTINE FMSQR2_R1

      SUBROUTINE FMSQRT(MA,MB,QX)

!  MB = SQRT(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: DC,DP,ERR,X,XB
      REAL (KIND(1.0D0)) :: MA1,MKE,MXSAVE
      INTEGER :: NSTACK(49),J,JPT,K,KL,KMA1,KN,KOVUN,KRESLT,KST,KR_RETRY,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0 .OR. MA%MP(1) < 0) THEN
          CALL FMENTR2('FMSQRT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'FMSQRT'
              CALL FMNTR(2,MA,MA,1,1,QX)
          ENDIF
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF

      MA1 = MA%MP(2)

      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)

      NMETHD = 1
      IF (QX%MBASE >= 1000 .AND. QX%MBASE <= MXBASE/1.5D0 .AND. QX%NDIG*QX%ALOGMT < 1400) THEN
          NMETHD = 4
      ELSE IF (QX%NDIG*QX%ALOGMT > 50000) THEN
          NMETHD = 3
      ELSE IF (QX%NDIG*QX%ALOGMT > 2750) THEN
          NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 130
      IF (NMETHD == 3) GO TO 140
      IF (NMETHD == 4) GO TO 150

!             Method 1.  Ordinary Newton iteration.

!             Generate the first approximation.

  120 MXY(2)%MP(2) = 0
      CALL FMM2DP(MXY(2),X,QX)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = QX%MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3),QX)
      MXY(3)%MP(2) = MXY(3)%MP(2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1),QX)
      MXY(2)%MP(2) = MA1
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration.

      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         CALL FMCSDIV(MXY(2),MXY(3),MXY(1),QX)
         CALL FMCSADD_R1(MXY(3),MXY(1),QX)
         CALL FMCSDIVI_R1(MXY(3),2,QX)
      ENDDO

      GO TO 160

!             Method 2.  Modified Newton iteration.
!                        x2 = x1 - (x1^2 - a) / (2*x1)
!                        where the square is done at full current precision,
!                        and the division is done at half current precision.

!             Generate the first approximation.

  130 MXY(2)%MP(2) = 0
      CALL FMM2DP(MXY(2),X,QX)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = QX%MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3),QX)
      MXY(3)%MP(2) = MXY(3)%MP(2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1),QX)
      CALL FMI2M(0,MXY(4),QX)
      MXY(2)%MP(2) = MA1
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration.

      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(1),QX)
         CALL FMSUB_R1(MXY(1),MXY(2),QX)
         IF (J > 1) QX%NDIG = NSTACK(J-1)
         CALL FMADD(MXY(3),MXY(3),MXY(4),QX)
         CALL FMDIV_R2(MXY(1),MXY(4),QX)
         QX%NDIG = NSTACK(J)
         CALL FMSUB_R1(MXY(3),MXY(4),QX)
      ENDDO

      GO TO 160

!             Method 3.  Karp's method.  Newton iteration for 1/sqrt(a)
!                        x2 = x1 + (1 - a*x1**2)*x1/2
!                        where a*x1**2 is done at full current precision,
!                        and *x1/2 is done at half current precision.

!             Generate the first approximation to 1/sqrt(a).

  140 MXY(2)%MP(2) = 0
      CALL FMM2DP(MXY(2),X,QX)
      X = 1.0D0/SQRT(X)
      MKE = -MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = QX%MBASE
          X = X*SQRT(XB)
          MKE = -(MA1+1)/2
      ENDIF
      CALL FMDPM(X,MXY(3),QX)
      MXY(3)%MP(2) = MXY(3)%MP(2) + MKE

!             Initialize.

      CALL FMI2M(1,MXY(1),QX)
      CALL FMI2M(0,MXY(4),QX)
      MXY(2)%MP(2) = MA1
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration for 1/sqrt(a).

      DO J = 1, KST-1
         QX%NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(4),QX)
         CALL FMMPY_R2(MXY(2),MXY(4),QX)
         CALL FMSUB_R2(MXY(1),MXY(4),QX)
         IF (J > 1) QX%NDIG = NSTACK(J-1)
         CALL FMMPY_R2(MXY(3),MXY(4),QX)
         CALL FMDIVI_R1(MXY(4),2,QX)
         QX%NDIG = NSTACK(J)
         CALL FMADD_R1(MXY(3),MXY(4),QX)
      ENDDO

!             Karp's method for speeding up the last iteration and getting sqrt(a).
!             For the last iteration, combine a*x1 to get
!             a*x1 + x1*(a - (a*x1)**2)/2
!             where only the square, -, and + need full precision.

      QX%NDIG = NSTACK(KST)
      IF (KST > 1) QX%NDIG = NSTACK(KST-1)
      CALL FMMPY(MXY(2),MXY(3),MXY(4),QX)
      QX%NDIG = NSTACK(KST)
      CALL FMSQR(MXY(4),MXY(1),QX)
      CALL FMSUB_R2(MXY(2),MXY(1),QX)
      IF (KST > 1) QX%NDIG = NSTACK(KST-1)
      CALL FMMPY_R2(MXY(3),MXY(1),QX)
      CALL FMDIVI_R1(MXY(1),2,QX)
      QX%NDIG = NSTACK(KST)
      CALL FMADD(MXY(4),MXY(1),MXY(3),QX)
      GO TO 160

!             Method 4.  Direct method.

  150 CALL FMI2M(1,MXY(1),QX)
      CALL FMI2M(1,MXY(3),QX)
      CALL FMI2M(1,MXY(4),QX)
      MXY(1)%MP(3) = MXY(2)%MP(3)
      MXY(1)%MP(2) = 1
      DC = MXY(1)%MP(3)
      JPT = 2
      KN = MAX(1,INT(MAXINT/(2*QX%MBASE**2)-5))
      IF (MOD(INT(ABS(MXY(2)%MP(2))),2) == 0) THEN
          MXY(1)%MP(2) = 1
          MXY(1)%MP(3) = MXY(2)%MP(3) * QX%MBASE + MXY(2)%MP(4)
          DC = MXY(1)%MP(3)
          JPT = 3
      ENDIF
      X = INT(SQRT(DC))
      MKE = 2
      IF (MOD(MXY(2)%MP(2),MKE) == 0) THEN
          MXY(3)%MP(2) = MXY(2)%MP(2) / 2
      ELSE
          MXY(3)%MP(2) = (MXY(2)%MP(2)+1) / 2
      ENDIF
      MXY(3)%MP(3) = X
      MXY(4)%MP(2) = 1
      MKE = X
      MXY(4)%MP(3) = MKE*MKE
      MXY(1)%MP(3) = MXY(1)%MP(3) - MXY(4)%MP(3)
      DO J = 2, QX%NDIG
         MXY(1)%MP(2) = MXY(1)%MP(2) + 2
         IF (JPT <= QX%NDIG) THEN
             MXY(1)%MP(J+2) = MXY(2)%MP(JPT+2)
         ENDIF
         IF (JPT+1 <= QX%NDIG) THEN
             MXY(1)%MP(J+3) = MXY(2)%MP(JPT+3)
         ENDIF
         JPT = JPT + 2
         DC = MXY(1)%MP(3)
         IF (QX%NDIG >= 4) THEN
             DC = ((DC*QX%MBASE + MXY(1)%MP(4))*QX%MBASE + MXY(1)%MP(5))*QX%MBASE +  &
                   MXY(1)%MP(6)
         ELSE IF (QX%NDIG == 3) THEN
             DC = ((DC*QX%MBASE + MXY(1)%MP(4))*QX%MBASE + MXY(1)%MP(5))*QX%MBASE
         ELSE
             DC = ((DC*QX%MBASE + MXY(1)%MP(4))*QX%MBASE)*QX%MBASE
         ENDIF
         IF (J <= 4) THEN
             DP = MXY(3)%MP(3)
             IF (QX%NDIG >= 3) THEN
                 DP = (DP*QX%MBASE + MXY(3)%MP(4))*QX%MBASE + MXY(3)%MP(5)
             ELSE
                 DP = (DP*QX%MBASE + MXY(3)%MP(4))*QX%MBASE
             ENDIF
         ENDIF
         IF (J <= 2) THEN
             DC = DC*DBLE(QX%MBASE)**INT(MXY(1)%MP(2)-4)
             DP = DP*DBLE(QX%MBASE)**(J-4)
             X = FLOOR(DP*QX%MBASE*(SQRT(1+DC/(DP*QX%MBASE)**2)-1))
         ELSE
             IF (INT(MXY(1)%MP(2))-J-1 /= 0) THEN
                 DC = DC*DBLE(QX%MBASE)**(INT(MXY(1)%MP(2))-J-1)
             ENDIF
             X = FLOOR(DC/(2.0D0*DP))
         ENDIF
         IF (ABS(2.0D0 * X * QX%MBASE) >= MAXINT) THEN
             GO TO 120
         ENDIF
         MXY(4)%MP(2) = J
         KL = MIN(J,QX%NDIG/2+2+QX%NDIG/10)
         DO K = 3, KL+1
            MKE = X
            MXY(4)%MP(K) = 2 * MKE * MXY(3)%MP(K)
         ENDDO
         MKE = X
         MXY(4)%MP(J+2) = MKE * MKE
         MXY(3)%MP(J+2) = X
         IF (J == QX%NDIG) EXIT
         IF (MXY(1)%MP(2) - MXY(4)%MP(2) /= 1) THEN
             GO TO 120
         ENDIF
         MXY(1)%MP(2) = MXY(1)%MP(2) - 1
         MXY(1)%MP(3) = MXY(1)%MP(3) * QX%MBASE + MXY(1)%MP(4) -  &
                                  MXY(4)%MP(3)
         KL = MIN(J,QX%NDIG/2+2+QX%NDIG/10)
         DO K = 4, KL+2
            MXY(1)%MP(K) = MXY(1)%MP(K+1) - MXY(4)%MP(K)
         ENDDO
         MXY(1)%MP(J+3) = 0
         IF (MOD(J,KN) == 0) THEN
             DO K = J+2, 4, -1
                IF (MOD(MXY(1)%MP(K),QX%MBASE) == 0) THEN
                    KL = MXY(1)%MP(K) / QX%MBASE
                ELSE IF (MXY(1)%MP(K) > 0) THEN
                    KL = MXY(1)%MP(K) / QX%MBASE
                ELSE
                    KL = MXY(1)%MP(K) / QX%MBASE - 1
                ENDIF
                MXY(1)%MP(K-1) = MXY(1)%MP(K-1) + KL
                MXY(1)%MP(K) = MXY(1)%MP(K) - KL*QX%MBASE
             ENDDO
         ENDIF
      ENDDO
      DO K = QX%NDIG+2, 4, -1
         IF (MXY(3)%MP(K) >= 0 .AND. MXY(3)%MP(K) < QX%MBASE) CYCLE
         IF (MOD(MXY(3)%MP(K),QX%MBASE) == 0) THEN
             KL = MXY(3)%MP(K) / QX%MBASE
         ELSE IF (MXY(3)%MP(K) > 0) THEN
             KL = MXY(3)%MP(K) / QX%MBASE
         ELSE
             KL = MXY(3)%MP(K) / QX%MBASE - 1
         ENDIF
         MXY(3)%MP(K-1) = MXY(3)%MP(K-1) + KL
         MXY(3)%MP(K) = MXY(3)%MP(K) - KL*QX%MBASE
      ENDDO

!             Round the result and return.

  160 MXY(3)%MP(1) = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MB,NDSAVE,MXSAVE,0,QX)
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      RETURN
      END SUBROUTINE FMSQRT

      SUBROUTINE FMSQRT_R1(MA,QX)

!  MA = SQRT(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      DOUBLE PRECISION :: DC,DP,ERR,X,XB
      REAL (KIND(1.0D0)) :: MA1,MKE,MXSAVE
      INTEGER :: NSTACK(49),J,JPT,K,KL,KMA1,KN,KOVUN,KRESLT,KST,KR_RETRY,NDSAVE,NMETHD
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0 .OR. MA%MP(1) < 0) THEN
          CALL FMENTR2('FMSQRT_R1',MA,MA,1,1,MXY(3),KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              CALL FMEQ(MXY(3),MA,QX)
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'FMSQRT_R1'
              CALL FMNTR(2,MA,MA,1,1,QX)
          ENDIF
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF

      MA1 = MA%MP(2)

      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)

      NMETHD = 1
      IF (QX%MBASE >= 1000 .AND. QX%MBASE <= MXBASE/1.5D0 .AND. QX%NDIG*QX%ALOGMT < 1400) THEN
          NMETHD = 4
      ELSE IF (QX%NDIG*QX%ALOGMT > 50000) THEN
          NMETHD = 3
      ELSE IF (QX%NDIG*QX%ALOGMT > 2750) THEN
          NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 130
      IF (NMETHD == 3) GO TO 140
      IF (NMETHD == 4) GO TO 150

!             Method 1.  Ordinary Newton iteration.

!             Generate the first approximation.

  120 MXY(2)%MP(2) = 0
      CALL FMM2DP(MXY(2),X,QX)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = QX%MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3),QX)
      MXY(3)%MP(2) = MXY(3)%MP(2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1),QX)
      MXY(2)%MP(2) = MA1
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration.

      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         CALL FMCSDIV(MXY(2),MXY(3),MXY(1),QX)
         CALL FMCSADD_R1(MXY(3),MXY(1),QX)
         CALL FMCSDIVI_R1(MXY(3),2,QX)
      ENDDO

      GO TO 160

!             Method 2.  Modified Newton iteration.
!                        x2 = x1 - (x1^2 - a) / (2*x1)
!                        where the square is done at full current precision,
!                        and the division is done at half current precision.

!             Generate the first approximation.

  130 MXY(2)%MP(2) = 0
      CALL FMM2DP(MXY(2),X,QX)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = QX%MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3),QX)
      MXY(3)%MP(2) = MXY(3)%MP(2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1),QX)
      CALL FMI2M(0,MXY(4),QX)
      MXY(2)%MP(2) = MA1
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration.

      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(1),QX)
         CALL FMSUB_R1(MXY(1),MXY(2),QX)
         IF (J > 1) QX%NDIG = NSTACK(J-1)
         CALL FMADD(MXY(3),MXY(3),MXY(4),QX)
         CALL FMDIV_R2(MXY(1),MXY(4),QX)
         QX%NDIG = NSTACK(J)
         CALL FMSUB_R1(MXY(3),MXY(4),QX)
      ENDDO

      GO TO 160

!             Method 3.  Karp's method.  Newton iteration for 1/sqrt(a)
!                        x2 = x1 + (1 - a*x1**2)*x1/2
!                        where a*x1**2 is done at full current precision,
!                        and *x1/2 is done at half current precision.

!             Generate the first approximation to 1/sqrt(a).

  140 MXY(2)%MP(2) = 0
      CALL FMM2DP(MXY(2),X,QX)
      X = 1.0D0/SQRT(X)
      MKE = -MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = QX%MBASE
          X = X*SQRT(XB)
          MKE = -(MA1+1)/2
      ENDIF
      CALL FMDPM(X,MXY(3),QX)
      MXY(3)%MP(2) = MXY(3)%MP(2) + MKE

!             Initialize.

      CALL FMI2M(1,MXY(1),QX)
      CALL FMI2M(0,MXY(4),QX)
      MXY(2)%MP(2) = MA1
      CALL FMDIG(NSTACK,KST,QX)

!             Newton iteration for 1/sqrt(a).

      DO J = 1, KST-1
         QX%NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(4),QX)
         CALL FMMPY_R2(MXY(2),MXY(4),QX)
         CALL FMSUB_R2(MXY(1),MXY(4),QX)
         IF (J > 1) QX%NDIG = NSTACK(J-1)
         CALL FMMPY_R2(MXY(3),MXY(4),QX)
         CALL FMDIVI_R1(MXY(4),2,QX)
         QX%NDIG = NSTACK(J)
         CALL FMADD_R1(MXY(3),MXY(4),QX)
      ENDDO

!             Karp's method for speeding up the last iteration and getting sqrt(a).
!             For the last iteration, combine a*x1 to get
!             a*x1 + x1*(a - (a*x1)**2)/2
!             where only the square, -, and + need full precision.

      QX%NDIG = NSTACK(KST)
      IF (KST > 1) QX%NDIG = NSTACK(KST-1)
      CALL FMMPY(MXY(2),MXY(3),MXY(4),QX)
      QX%NDIG = NSTACK(KST)
      CALL FMSQR(MXY(4),MXY(1),QX)
      CALL FMSUB_R2(MXY(2),MXY(1),QX)
      IF (KST > 1) QX%NDIG = NSTACK(KST-1)
      CALL FMMPY_R2(MXY(3),MXY(1),QX)
      CALL FMDIVI_R1(MXY(1),2,QX)
      QX%NDIG = NSTACK(KST)
      CALL FMADD(MXY(4),MXY(1),MXY(3),QX)
      GO TO 160

!             Method 4.  Direct method.

  150 CALL FMI2M(1,MXY(1),QX)
      CALL FMI2M(1,MXY(3),QX)
      CALL FMI2M(1,MXY(4),QX)
      MXY(1)%MP(3) = MXY(2)%MP(3)
      MXY(1)%MP(2) = 1
      DC = MXY(1)%MP(3)
      JPT = 2
      KN = MAX(1,INT(MAXINT/(2*QX%MBASE**2)-5))
      IF (MOD(INT(ABS(MXY(2)%MP(2))),2) == 0) THEN
          MXY(1)%MP(2) = 1
          MXY(1)%MP(3) = MXY(2)%MP(3) * QX%MBASE + MXY(2)%MP(4)
          DC = MXY(1)%MP(3)
          JPT = 3
      ENDIF
      X = INT(SQRT(DC))
      MKE = 2
      IF (MOD(MXY(2)%MP(2),MKE) == 0) THEN
          MXY(3)%MP(2) = MXY(2)%MP(2) / 2
      ELSE
          MXY(3)%MP(2) = (MXY(2)%MP(2)+1) / 2
      ENDIF
      MXY(3)%MP(3) = X
      MXY(4)%MP(2) = 1
      MKE = X
      MXY(4)%MP(3) = MKE*MKE
      MXY(1)%MP(3) = MXY(1)%MP(3) - MXY(4)%MP(3)
      DO J = 2, QX%NDIG
         MXY(1)%MP(2) = MXY(1)%MP(2) + 2
         IF (JPT <= QX%NDIG) THEN
             MXY(1)%MP(J+2) = MXY(2)%MP(JPT+2)
         ENDIF
         IF (JPT+1 <= QX%NDIG) THEN
             MXY(1)%MP(J+3) = MXY(2)%MP(JPT+3)
         ENDIF
         JPT = JPT + 2
         DC = MXY(1)%MP(3)
         IF (QX%NDIG >= 4) THEN
             DC = ((DC*QX%MBASE + MXY(1)%MP(4))*QX%MBASE + MXY(1)%MP(5))*QX%MBASE +  &
                   MXY(1)%MP(6)
         ELSE IF (QX%NDIG == 3) THEN
             DC = ((DC*QX%MBASE + MXY(1)%MP(4))*QX%MBASE + MXY(1)%MP(5))*QX%MBASE
         ELSE
             DC = ((DC*QX%MBASE + MXY(1)%MP(4))*QX%MBASE)*QX%MBASE
         ENDIF
         IF (J <= 4) THEN
             DP = MXY(3)%MP(3)
             IF (QX%NDIG >= 3) THEN
                 DP = (DP*QX%MBASE + MXY(3)%MP(4))*QX%MBASE + MXY(3)%MP(5)
             ELSE
                 DP = (DP*QX%MBASE + MXY(3)%MP(4))*QX%MBASE
             ENDIF
         ENDIF
         IF (J <= 2) THEN
             DC = DC*DBLE(QX%MBASE)**INT(MXY(1)%MP(2)-4)
             DP = DP*DBLE(QX%MBASE)**(J-4)
             X = FLOOR(DP*QX%MBASE*(SQRT(1+DC/(DP*QX%MBASE)**2)-1))
         ELSE
             IF (INT(MXY(1)%MP(2))-J-1 /= 0) THEN
                 DC = DC*DBLE(QX%MBASE)**(INT(MXY(1)%MP(2))-J-1)
             ENDIF
             X = FLOOR(DC/(2.0D0*DP))
         ENDIF
         IF (ABS(2.0D0 * X * QX%MBASE) >= MAXINT) THEN
             GO TO 120
         ENDIF
         MXY(4)%MP(2) = J
         KL = MIN(J,QX%NDIG/2+2+QX%NDIG/10)
         DO K = 3, KL+1
            MKE = X
            MXY(4)%MP(K) = 2 * MKE * MXY(3)%MP(K)
         ENDDO
         MKE = X
         MXY(4)%MP(J+2) = MKE * MKE
         MXY(3)%MP(J+2) = X
         IF (J == QX%NDIG) EXIT
         IF (MXY(1)%MP(2) - MXY(4)%MP(2) /= 1) THEN
             GO TO 120
         ENDIF
         MXY(1)%MP(2) = MXY(1)%MP(2) - 1
         MXY(1)%MP(3) = MXY(1)%MP(3) * QX%MBASE + MXY(1)%MP(4) -  &
                                  MXY(4)%MP(3)
         KL = MIN(J,QX%NDIG/2+2+QX%NDIG/10)
         DO K = 4, KL+2
            MXY(1)%MP(K) = MXY(1)%MP(K+1) - MXY(4)%MP(K)
         ENDDO
         MXY(1)%MP(J+3) = 0
         IF (MOD(J,KN) == 0) THEN
             DO K = J+2, 4, -1
                IF (MOD(MXY(1)%MP(K),QX%MBASE) == 0) THEN
                    KL = MXY(1)%MP(K) / QX%MBASE
                ELSE IF (MXY(1)%MP(K) > 0) THEN
                    KL = MXY(1)%MP(K) / QX%MBASE
                ELSE
                    KL = MXY(1)%MP(K) / QX%MBASE - 1
                ENDIF
                MXY(1)%MP(K-1) = MXY(1)%MP(K-1) + KL
                MXY(1)%MP(K) = MXY(1)%MP(K) - KL*QX%MBASE
             ENDDO
         ENDIF
      ENDDO
      DO K = QX%NDIG+2, 4, -1
         IF (MXY(3)%MP(K) >= 0 .AND. MXY(3)%MP(K) < QX%MBASE) CYCLE
         IF (MOD(MXY(3)%MP(K),QX%MBASE) == 0) THEN
             KL = MXY(3)%MP(K) / QX%MBASE
         ELSE IF (MXY(3)%MP(K) > 0) THEN
             KL = MXY(3)%MP(K) / QX%MBASE
         ELSE
             KL = MXY(3)%MP(K) / QX%MBASE - 1
         ENDIF
         MXY(3)%MP(K-1) = MXY(3)%MP(K-1) + KL
         MXY(3)%MP(K) = MXY(3)%MP(K) - KL*QX%MBASE
      ENDDO

!             Round the result and return.

  160 MXY(3)%MP(1) = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MA,NDSAVE,MXSAVE,0,QX)
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      RETURN
      END SUBROUTINE FMSQRT_R1

      SUBROUTINE FMST2D(STRING,X,QX)

!  STRING contains a free-format number that is converted to double precision and returned in X.

!  The input number may be in integer or any real format. The convention is made that if no digits
!  appear before 'E' then 1.0 is assumed.  For example 'E6' is converted as '1.0E+6'.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: J,JSTATE,KDIGFL,KEXP,KPT,KSIGN,KSIGNX,KSTART,KSTOP,KTYPE,KVAL,N2
      DOUBLE PRECISION :: X,F1,F2
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/     &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      CHARACTER :: KBLANK = ' '
      INTENT (IN) :: STRING
      INTENT (INOUT) :: X

      JSTATE = 1
      KSIGN = 1
      F1 = 0.0D0
      F2 = 0.0D0
      N2 = 0
      KSIGNX = 1
      KEXP = 0
      KSTART = 1
      KSTOP = LEN(STRING)
      QX%KFLAG = 0

!             KDIGFL will be 1 if any digits are found before 'E'.

      KDIGFL = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (QX%LHASH == 0) CALL FMHTBL(QX)

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (STRING(J:J) == KBLANK) CYCLE
         KPT = ICHAR(STRING(J:J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) STRING(J:J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = QX%KHASHT(KPT)
             KVAL  = QX%KHASHV(KPT)
         ENDIF
         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDIGFL = 1
             F1 = 10.0D0*F1 + KVAL

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDIGFL = 1
             F2 = 10.0D0*F2 + KVAL
             N2 = N2 + 1

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDIGFL == 0) F1 = 1.0D0

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             KEXP = 10*KEXP + KVAL

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Form the number and return.

      KEXP = KSIGNX*KEXP
      X = KSIGN*(F1 + F2/10.0D0**N2)*10.0D0**KEXP

      RETURN

!             Error in converting the number.

  110 X = -1.0D+31
      QX%KFLAG = -4
      RETURN
      END SUBROUTINE FMST2D

      SUBROUTINE FMST2M(STRING,MA,QX)

!  MA = STRING

!  Convert a character string to FM format.
!  This is often more convenient than using FMINP, which converts an array of character(1) values.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFF(LMBUFF)
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMST2M'
      LB = LEN(STRING)
      IF (LB > LMBUFF) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF
      KFSAVE = QX%KFLAG

      DO J = 1, LB
         CMBUFF(J) = STRING(J:J)
      ENDDO
      QX%NCALL = QX%NCALL - 1
      CALL FMINP(CMBUFF,MA,1,LB,QX)
      QX%NCALL = QX%NCALL + 1

      IF (KFSAVE /= 0) QX%KFLAG = KFSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMST2M

      SUBROUTINE FMSUB(MA,MB,MC,QX)

!  MC = MA - MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFLG1
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC


      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMSUB'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)

          KFLG1 = 0
          IF (MB%MP(2) > MA%MP(2) .OR. MA%MP(3) == 0) KFLG1 = 1
          IF (MB%MP(3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          QX%KSUB = 1
          CALL FMADD2(MA,MB,MC,QX)
          QX%KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (QX%KFLAG == 1 .AND. KFLG1 == 1) QX%KFLAG = 0

          IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
      ELSE
          KFLG1 = 0
          IF (MB%MP(2) > MA%MP(2) .OR. MA%MP(3) == 0) KFLG1 = 1
          IF (MB%MP(3) == 0) KFLG1 = 0
          QX%KSUB = 1
          CALL FMADD2(MA,MB,MC,QX)
          QX%KSUB = 0
          IF (QX%KFLAG == 1 .AND. KFLG1 == 1) QX%KFLAG = 0
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMSUB

      SUBROUTINE FMSUB_R1(MA,MB,QX)

!  MA = MA - MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFLG1
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMSUB_R1'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)

          KFLG1 = 0
          IF (MB%MP(2) > MA%MP(2) .OR. MA%MP(3) == 0) KFLG1 = 1
          IF (MB%MP(3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          QX%KSUB = 1
          CALL FMADD2_R1(MA,MB,QX)
          QX%KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (QX%KFLAG == 1 .AND. KFLG1 == 1) QX%KFLAG = 0

          IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      ELSE
          KFLG1 = 0
          IF (MB%MP(2) > MA%MP(2) .OR. MA%MP(3) == 0) KFLG1 = 1
          IF (MB%MP(3) == 0) KFLG1 = 0
          QX%KSUB = 1
          CALL FMADD2_R1(MA,MB,QX)
          QX%KSUB = 0
          IF (QX%KFLAG == 1 .AND. KFLG1 == 1) QX%KFLAG = 0
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMSUB_R1

      SUBROUTINE FMSUB_R2(MA,MB,QX)

!  MB = MA - MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFLG1

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'FMSUB_R2'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1,QX)

          KFLG1 = 0
          IF (MB%MP(2) > MA%MP(2) .OR. MA%MP(3) == 0) KFLG1 = 1
          IF (MB%MP(3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          QX%KSUB = 1
          CALL FMADD2_R2(MA,MB,QX)
          QX%KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (QX%KFLAG == 1 .AND. KFLG1 == 1) QX%KFLAG = 0

          IF (QX%NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1,QX)
      ELSE
          KFLG1 = 0
          IF (MB%MP(2) > MA%MP(2) .OR. MA%MP(3) == 0) KFLG1 = 1
          IF (MB%MP(3) == 0) KFLG1 = 0
          QX%KSUB = 1
          CALL FMADD2_R2(MA,MB,QX)
          QX%KSUB = 0
          IF (QX%KFLAG == 1 .AND. KFLG1 == 1) QX%KFLAG = 0
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMSUB_R2

      SUBROUTINE FMTAN(MA,MB,QX)

!  MB = TAN(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MPISAV
      REAL (KIND(1.0D0)) :: MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NDSV,NTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5)
      TYPE(FM_SETTINGS) :: QX

      QX%NDIGPI = 0
      KR_RETRY = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG .AND. QX%KRAD == 1) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMTAN'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMMPY(MXY(1),MA,MXY(2),QX)
          CALL FMDIVI(MXY(2),3,MXY(3),QX)
          IF (MXY(3)%MP(2) > QX%MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB,QX)
          ELSE IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MA,MB,QX)
          ELSE IF (MA%MP(1) < 0 .AND. QX%KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
              MB%MP(2) = MA%MP(2) + MB%MP(2)
          ELSE IF (MA%MP(1) >= 0 .AND. QX%KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMADD(MXY(1),MXY(2),MB,QX)
              MB%MP(2) = MA%MP(2) + MB%MP(2)
          ELSE
              CALL FMEQ(MA,MB,QX)
          ENDIF
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMTAN'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. MA%MP(3) == 0) THEN
          CALL FMENTR('FMTAN    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMTAN'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52-1,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF

      MAS = MA%MP(1)
      NTRY = 1
      IF (MA%MP(2) > 3*10**5 .AND. QX%KRAD == 1) THEN
          QX%KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(5),QX)
          GO TO 130
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
  120 CALL FMEQU(MA,MXY(5),NDSAVE,QX%NDIG,QX)
      MXY(5)%MP(1) = 1

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      CALL FMRDC(MXY(5),JSIN,JCOS,JSWAP,QX)
      IF (QX%KROUND /= 1 .AND. QX%KRAD /= 1) THEN
          CALL FMI2M(45,MXY(1),QX)
          CALL FMSUB(MXY(5),MXY(1),MXY(2),QX)
          IF (MXY(2)%MP(3) == 0) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMMPYI(MXY(1),JSIN/JCOS,MXY(5),QX)
              GO TO 130
          ENDIF
      ENDIF
      IF (MXY(5)%MP(2) == QX%MUNKNO) GO TO 130
      IF (MXY(5)%MP(3) == 0) THEN
          IF (JSWAP == 1) THEN
              QX%KFLAG = -4
              CALL FMWARN(QX)
              CALL FMST2M('UNKNOWN',MXY(5),QX)
          ENDIF
          GO TO 130
      ENDIF
      IF (QX%KRAD == 0) THEN
          IF (QX%MBSPI /= QX%MBASE .OR. QX%NDIGPI < QX%NDIG)  THEN
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(4),QX)
              QX%NDIG = NDSV
          ENDIF
          CALL FMPI(MPISAV,QX)
          CALL FMMPY_R1(MXY(5),MPISAV,QX)
          CALL FMDIVI_R1(MXY(5),180,QX)
      ENDIF
      IF (MXY(5)%MP(2) /= QX%MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MXY(5)%MP(2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4),QX)
                  MXY(4)%MP(1) = JSIN*MXY(4)%MP(1)
                  CALL FMSQR(MXY(4),MXY(2),QX)
                  CALL FMI2M(1,MXY(1),QX)
                  CALL FMSUB_R2(MXY(1),MXY(2),QX)
                  IF (MXY(2)%MP(2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      QX%NDIG = QX%NDIG - MXY(2)%MP(2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3),QX)
                  MXY(3)%MP(1) = JCOS*MXY(3)%MP(1)
                  CALL FMDIV(MXY(4),MXY(3),MXY(5),QX)
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4),QX)
                  MXY(4)%MP(1) = JCOS*MXY(4)%MP(1)
                  CALL FMSQR(MXY(4),MXY(2),QX)
                  CALL FMI2M(1,MXY(1),QX)
                  CALL FMSUB_R2(MXY(1),MXY(2),QX)
                  IF (MXY(2)%MP(2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      QX%NDIG = QX%NDIG - MXY(2)%MP(2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3),QX)
                  MXY(3)%MP(1) = JSIN*MXY(3)%MP(1)
                  CALL FMDIV(MXY(3),MXY(4),MXY(5),QX)
              ENDIF
          ELSE
              IF (MXY(5)%MP(2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4),QX)
                  MXY(4)%MP(1) = JCOS*MXY(4)%MP(1)
                  CALL FMSQR(MXY(4),MXY(2),QX)
                  CALL FMI2M(1,MXY(1),QX)
                  CALL FMSUB_R2(MXY(1),MXY(2),QX)
                  IF (MXY(2)%MP(2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      QX%NDIG = QX%NDIG - MXY(2)%MP(2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3),QX)
                  MXY(3)%MP(1) = JSIN*MXY(3)%MP(1)
                  CALL FMDIV(MXY(3),MXY(4),MXY(5),QX)
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4),QX)
                  MXY(4)%MP(1) = JSIN*MXY(4)%MP(1)
                  CALL FMSQR(MXY(4),MXY(2),QX)
                  CALL FMI2M(1,MXY(1),QX)
                  CALL FMSUB_R2(MXY(1),MXY(2),QX)
                  IF (MXY(2)%MP(2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      QX%NDIG = QX%NDIG - MXY(2)%MP(2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3),QX)
                  MXY(3)%MP(1) = JCOS*MXY(3)%MP(1)
                  CALL FMDIV(MXY(4),MXY(3),MXY(5),QX)
              ENDIF
          ENDIF
      ENDIF

!             Round and return.

  130 IF (MAS < 0 .AND. MXY(5)%MP(2) /= QX%MUNKNO .AND. MXY(5)%MP(3) /= 0)  &
          MXY(5)%MP(1) = -MXY(5)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMTAN

      SUBROUTINE FMTANH(MA,MB,QX)

!  MB = TANH(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      LOGICAL :: LCOMP
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X,XT
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(5)

      KR_RETRY = 0

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMTANH'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMMPY(MXY(1),MA,MXY(2),QX)
          CALL FMDIVI(MXY(2),-3,MXY(3),QX)
          IF (MXY(3)%MP(2) > QX%MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB,QX)
          ELSE IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MA,MB,QX)
          ELSE IF (MA%MP(1) < 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              MXY(3)%MP(2) = MA%MP(2) + MXY(3)%MP(2)
              CALL FMEQ(MXY(3),MB,QX)
          ELSE IF (MA%MP(1) >= 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1),QX)
              MXY(1)%MP(2) = 0
              CALL FMULP(MXY(1),MXY(2),QX)
              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
              MXY(3)%MP(2) = MA%MP(2) + MXY(3)%MP(2)
              CALL FMEQ(MXY(3),MB,QX)
          ELSE
              CALL FMEQ(MA,MB,QX)
          ENDIF
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMTANH'
              QX%KFLAG = -4
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMTANH'
              IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
              IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
              CALL FMWARN(QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMTANH'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      J = QX%NTRACE
      QX%NTRACE = 0
      CALL FMABS(MA,MXY(1),QX)
      CALL FMDP2M(QX%DLOGMB*QX%NDIG,MXY(2),QX)
      LCOMP = FMCOMP(MXY(1),'>',MXY(2),QX)
      QX%NTRACE = J
      IF (QX%KROUND /= 1 .AND. LCOMP .AND. MA%MP(2) /= QX%MUNKNO) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMTANH'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          IF (MA%MP(1) < 0 .AND. (QX%KROUND == 0 .OR. QX%KROUND == 2)) THEN
              CALL FMI2M(-1,MXY(1),QX)
              CALL FMTINY(MXY(2),QX)
              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
          ELSE IF (MA%MP(1) > 0 .AND. (QX%KROUND == 0 .OR. QX%KROUND == -1)) THEN
              CALL FMI2M(1,MXY(1),QX)
              CALL FMTINY(MXY(2),QX)
              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
          ELSE IF (MA%MP(1) < 0) THEN
              CALL FMI2M(-1,MXY(3),QX)
          ELSE
              CALL FMI2M(1,MXY(3),QX)
          ENDIF
          CALL FMEQ(MXY(3),MB,QX)
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMTANH'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMENTR('FMTANH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMTANH'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = MAX(QX%NGRD52,2)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      MAS = MA%MP(1)

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(5),NDSAVE,QX%NDIG,QX)
      IF (MA%MP(3) == 0) THEN
          GO TO 120
      ENDIF
      MXY(5)%MP(1) = 1

      IF (MA%MP(2) >= 1) THEN
          XT = REAL((QX%NDIG+1)/2)*QX%ALOGMB
          K = INT(LOG(XT)/QX%ALOGMB)
          IF (MA%MP(2) > K+1) THEN
              CALL FMI2M(1,MXY(5),QX)
              GO TO 120
          ELSE
              X = REAL(MXY(5)%MP(3)*QX%MBASE+MXY(5)%MP(4))*  &
                  REAL(QX%MBASE)**INT(MXY(5)%MP(2)-2)
              IF (X > XT+5.0) THEN
                  CALL FMI2M(1,MXY(5),QX)
                  GO TO 120
              ENDIF
          ENDIF
      ENDIF
      IF (MXY(5)%MP(2) == 0 .AND. QX%NDIG < 50) THEN
          CALL FMEXP2(MXY(5),MXY(3),QX)
          CALL FMSQR_R1(MXY(3),QX)
          CALL FMI2M(1,MXY(1),QX)
          CALL FMSUB(MXY(3),MXY(1),MXY(2),QX)
          CALL FMADD_R2(MXY(3),MXY(1),QX)
          CALL FMDIV(MXY(2),MXY(1),MXY(5),QX)
          GO TO 120
      ENDIF
      IF (MXY(5)%MP(2) >= 0 .AND. MXY(5)%MP(3) /= 0) THEN
          CALL FMCOSH(MXY(5),MXY(4),QX)
          IF (MXY(4)%MP(2) > QX%NDIG) THEN
              IF (MAS > 0) THEN
                  CALL FMI2M(1,MXY(5),QX)
                  GO TO 120
              ELSE
                  CALL FMI2M(-1,MXY(5),QX)
                  GO TO 120
              ENDIF
          ENDIF
          CALL FMSQR(MXY(4),MXY(2),QX)
          CALL FMI2M(-1,MXY(1),QX)
          CALL FMADD_R1(MXY(2),MXY(1),QX)
          CALL FMSQRT_R1(MXY(2),QX)
          CALL FMDIV(MXY(2),MXY(4),MXY(5),QX)
      ELSE
          CALL FMSINH(MXY(5),MXY(4),QX)
          CALL FMSQR(MXY(4),MXY(2),QX)
          CALL FMI2M(1,MXY(1),QX)
          CALL FMADD_R1(MXY(2),MXY(1),QX)
          CALL FMSQRT_R1(MXY(2),QX)
          CALL FMDIV(MXY(4),MXY(2),MXY(5),QX)
      ENDIF

!             Round and return.

  120 QX%KWARN = KWRNSV
      IF (MAS < 0 .AND. MXY(5)%MP(2) /= QX%MUNKNO .AND. MXY(5)%MP(3) /= 0)  &
          MXY(5)%MP(1) = -MXY(5)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(5)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMTANH

      SUBROUTINE FMTINY(MA,QX)

!     MA = The smallest positive representable FM number using the current base and precision.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: J,N1
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMTINY'

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      N1 = QX%NDIG + 1
      DO J = 3, N1
         MA%MP(J+1) = 0
      ENDDO
      MA%MP(2) = -QX%MXEXP
      MA%MP(1) = 1
      MA%MP(3) = 1

      IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMTINY

      SUBROUTINE FMTRAP(MA,QX)

!  If MA has overflowed or underflowed, replace it by the appropriate symbol.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      IF (QX%NCALL <= 0) RETURN
      IF (MA%MP(2) > QX%MXEXP+1) THEN
          IF (MA%MP(1) > 0) THEN
              CALL FMIM(0,MA,QX)
              MA%MP(2) = QX%MEXPOV
              MA%MP(3) = 1
          ELSE
              CALL FMIM(0,MA,QX)
              MA%MP(2) = QX%MEXPOV
              MA%MP(3) = 1
              MA%MP(1) = -1
          ENDIF
          QX%KFLAG = -5
      ENDIF
      IF (MA%MP(2) < -QX%MXEXP) THEN
          IF (MA%MP(1) > 0) THEN
              CALL FMIM(0,MA,QX)
              MA%MP(2) = QX%MEXPUN
              MA%MP(3) = 1
          ELSE
              CALL FMIM(0,MA,QX)
              MA%MP(2) = QX%MEXPUN
              MA%MP(3) = 1
              MA%MP(1) = -1
          ENDIF
          QX%KFLAG = -6
      ENDIF

      RETURN
      END SUBROUTINE FMTRAP

      SUBROUTINE FMULP(MA,MB,QX)

!  MB = The value of one Unit in the Last Place of MA at the current base and precision.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MA1
      INTEGER :: J,KWRNSV,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMULP'
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1,QX)

      MA1 = MA%MP(2)
      N1 = QX%NDIG + 1
      DO J = 3, N1
         MWA%MP(J+1) = 0
      ENDDO
      MWA%MP(3) = 1
      MWA%MP(2) = MA%MP(2) - QX%NDIG + 1
      IF (MA%MP(3) == 0 .OR. MA%MP(2) >= QX%MEXPOV) THEN
          QX%KFLAG = -4
          IF (MA1 /= QX%MUNKNO) CALL FMWARN(QX)
          CALL FMST2M('UNKNOWN',MB,QX)
      ELSE
          KWRNSV = QX%KWARN
          IF (MA1 == QX%MEXPUN) QX%KWARN = 0
          IF (MA%MP(1) < 0) THEN
              CALL FMMOVE(MWA,MB,QX)
              MB%MP(1) = 1
              IF (MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0) MB%MP(1) = -1
          ELSE
              CALL FMMOVE(MWA,MB,QX)
              MB%MP(1) = 1
          ENDIF
          IF (QX%KFLAG < 0) THEN
              QX%NAMEST(QX%NCALL) = 'FMULP'
              CALL FMWARN(QX)
          ENDIF
          QX%KWARN = KWRNSV
      ENDIF

      IF (QX%NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMULP

      SUBROUTINE FMVARS(QX)

!  Write the values of the FM global variables in module FMVALS_PARALLEL.

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: J
      TYPE(FM_SETTINGS) :: QX

      WRITE (KW,*) ' '
      WRITE (KW,*) ' Current values of the FM global variables.'
      WRITE (KW,*) ' '
      WRITE (KW,*) ' ALOGM2 = ',QX%ALOGM2
      WRITE (KW,*) ' ALOGMB = ',QX%ALOGMB
      WRITE (KW,*) ' ALOGMT = ',QX%ALOGMT
      WRITE (KW,*) ' ALOGMX = ',QX%ALOGMX
      WRITE (KW,*) ' CMCHAR = ',QX%CMCHAR
      WRITE (KW,*) ' DLOGEB = ',QX%DLOGEB
      WRITE (KW,*) ' DLOGMB = ',QX%DLOGMB
      WRITE (KW,*) ' DLOGPI = ',QX%DLOGPI
      WRITE (KW,*) ' DLOGTN = ',QX%DLOGTN
      WRITE (KW,*) ' DLOGTP = ',QX%DLOGTP
      WRITE (KW,*) ' DLOGTW = ',QX%DLOGTW
      WRITE (KW,*) ' DPEPS  = ',QX%DPEPS
      WRITE (KW,*) ' DPMAX  = ',DPMAX
      WRITE (KW,*) ' DPPI   = ',QX%DPPI
      WRITE (KW,*) ' INTMAX = ',INTMAX
      WRITE (KW,*) ' IUNKNO = ',QX%IUNKNO
      WRITE (KW,*) ' JFORM1 = ',QX%JFORM1
      WRITE (KW,*) ' JFORM2 = ',QX%JFORM2
      WRITE (KW,*) ' JFORMZ = ',QX%JFORMZ
      WRITE (KW,*) ' JPRNTZ = ',QX%JPRNTZ
      WRITE (KW,*) ' KDEBUG = ',QX%KDEBUG
      WRITE (KW,*) ' KESWCH = ',QX%KESWCH
      WRITE (KW,*) ' KFLAG  = ',QX%KFLAG
      WRITE (KW,*) ' KRAD   = ',QX%KRAD
      WRITE (KW,*) ' KROUND = ',QX%KROUND
      WRITE (KW,*) ' KSUB   = ',QX%KSUB
      WRITE (KW,*) ' KSWIDE = ',QX%KSWIDE
      WRITE (KW,*) ' KW     = ',KW
      WRITE (KW,*) ' KWARN  = ',QX%KWARN
      WRITE (KW,*) ' LHASH  = ',QX%LHASH
      WRITE (KW,*) ' LHASH1 = ',LHASH1
      WRITE (KW,*) ' LHASH2 = ',LHASH2
      WRITE (KW,*) ' LJSUMS = ',LJSUMS
      WRITE (KW,*) ' LMBERN = ',LMBERN
      WRITE (KW,*) ' LMBUFF = ',LMBUFF
      WRITE (KW,*) ' LMBUFZ = ',LMBUFZ
      WRITE (KW,*) ' LVLTRC = ',QX%LVLTRC
      WRITE (KW,*) ' MAXINT = ',MAXINT
      WRITE (KW,*) ' MBASE  = ',QX%MBASE
      WRITE (KW,*) ' MBLOGS = ',QX%MBLOGS
      WRITE (KW,*) ' MBSE   = ',QX%MBSE
      WRITE (KW,*) ' MBSLB  = ',QX%MBSLB
      WRITE (KW,*) ' MBSLI  = ',QX%MBSLI
      WRITE (KW,*) ' MBSPI  = ',QX%MBSPI
      WRITE (KW,*) ' MEXPAB = ',QX%MEXPAB
      WRITE (KW,*) ' MEXPOV = ',QX%MEXPOV
      WRITE (KW,*) ' MEXPUN = ',QX%MEXPUN
      WRITE (KW,*) ' MUNKNO = ',QX%MUNKNO
      WRITE (KW,*) ' MXBASE = ',MXBASE
      WRITE (KW,*) ' MXEXP  = ',QX%MXEXP
      WRITE (KW,*) ' MXEXP2 = ',QX%MXEXP2
      WRITE (KW,*) ' NCALL  = ',QX%NCALL
      WRITE (KW,*) ' NDIG   = ',QX%NDIG
      WRITE (KW,*) ' NGRD21 = ',QX%NGRD21
      WRITE (KW,*) ' NGRD22 = ',QX%NGRD22
      WRITE (KW,*) ' NGRD52 = ',QX%NGRD52
      J = QX%NTRACE
      WRITE (KW,*) ' NTRACE = ',J
      WRITE (KW,*) ' RUNKNO = ',QX%RUNKNO
      WRITE (KW,*) ' SPMAX  = ',SPMAX
      WRITE (KW,*) ' '
      WRITE (KW,*) ' RADIX(1) = ',RADIX(1),'    DIGITS(1) = ',DIGITS(1)
      WRITE (KW,*) '    HUGE(1) = ',HUGE(1)
      WRITE (KW,*) ' RADIX(1.0) = ',RADIX(1.0),'    DIGITS(1.0) = ',DIGITS(1.0)
      WRITE (KW,*) '    HUGE(1.0)    = ',HUGE(1.0)
      WRITE (KW,*) '    TINY(1.0)    = ',TINY(1.0)
      WRITE (KW,*) '    EPSILON(1.0) = ',EPSILON(1.0)
      WRITE (KW,*) ' RADIX(1.0D0) = ',RADIX(1.0D0),'    DIGITS(1.0D0) = ',DIGITS(1.0D0)
      WRITE (KW,*) '    HUGE(1.0D0)    = ',HUGE(1.0D0)
      WRITE (KW,*) '    TINY(1.0D0)    = ',TINY(1.0D0)
      WRITE (KW,*) '    EPSILON(1.0D0) = ',EPSILON(1.0D0)
      WRITE (KW,*) ' '

      RETURN
      END SUBROUTINE FMVARS

      SUBROUTINE FMWARN(QX)

!  Called by one of the FM routines to print a warning message if any error condition arises
!  in that routine.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: NAME
      INTEGER :: NCS
      TYPE(FM_SETTINGS) :: QX

      IF (QX%KFLAG >= 0 .OR. QX%NCALL /= 1 .OR. QX%KWARN <= 0) RETURN
      NCS = QX%NCALL
      NAME = QX%NAMEST(QX%NCALL)
      WRITE (KW,                                   &
             "(/' Error of type KFLAG =',I3,"  //  &
             "' in FM package in routine ',A/)"    &
            ) QX%KFLAG,TRIM(NAME)

  110 QX%NCALL = QX%NCALL - 1
      IF (QX%NCALL > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (QX%KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (QX%KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (QX%KFLAG == -3) THEN
          WRITE (KW,                                                     &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (QX%KFLAG == -4 .OR. QX%KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (QX%KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (QX%KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (QX%KFLAG == -8 .AND. NAME == 'FMOUT') THEN
          WRITE (KW,                                                          &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (QX%KFLAG == -8 .AND. NAME == 'FMREAD') THEN
          WRITE (KW,                                                        &
                 "(' The CMBUFF array is not big enough to hold the',"  //  &
                 "' input character string'/"                           //  &
                 "' UNKNOWN has been returned.'/)"                          &
                )
      ELSE IF (QX%KFLAG == -9) THEN
          WRITE (KW,                                                &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,                                        &
                 "(I23,' digits were requested (NDIG).'/)"  &
                ) QX%NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (QX%KFLAG == -10) THEN
          IF (QX%NAMEST(NCS) == 'FMM2SP') THEN
              WRITE (KW,                                                     &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to single precision.'/)"                      &
                    )
          ELSE
              WRITE (KW,                                                     &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to double precision.'/)"                      &
                    )
          ENDIF
          WRITE (KW,"(' Zero has been returned.'/)")
      ENDIF

      QX%NCALL = NCS
      IF (QX%KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE FMWARN

      SUBROUTINE FMWRIT(KWRITE,MA,QX)

!  Write MA on unit KWRITE.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using FMREAD.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: KWRITE
      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFF(LMBUFF)
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,JF1SAV,JF2SAV,K,KSAVE,L,LAST,LB,ND,NDSAVE,NEXP
      INTENT (IN) :: MA,KWRITE

      TYPE(MULTI) :: MXY(2)


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMWRIT'
      NDSAVE = QX%NDIG
      QX%NDIG = MAX(QX%NDIG+QX%NGRD52,2)

      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      KSAVE = QX%KFLAG
      ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = ND + NEXP

      JF1SAV = QX%JFORM1
      JF2SAV = QX%JFORM2
      QX%JFORM1 = 1
      QX%JFORM2 = ND + 6
      IF (LB > LMBUFF) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF

      CALL FMOUT(MXY(1),CMBUFF,LB,QX)

      QX%KFLAG = KSAVE
      QX%NDIG = NDSAVE
      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      LAST = LB + 1
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L)
             ELSE
                 IF (L > 73) WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFF(K),K=L-72,L)
             ENDIF
             QX%NCALL = QX%NCALL - 1
             RETURN
         ENDIF
      ENDDO
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMWRIT




!  The IM routines perform integer multiple-precision arithmetic.

      SUBROUTINE IMABS(MA,MB,QX)

!  MB = ABS(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KWRNSV,NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      RESULT_SIZE = MAX(5,INT(MA%MP(2)+3))
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMABS    ',1,MA,MA,QX)
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMABS'
          CALL IMNTR(2,MA,MA,1,QX)
      ENDIF

      QX%KFLAG = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL IMEQ(MA,MB,QX)
      MB%MP(1) = 1
      QX%KWARN = KWRNSV

      IF (QX%NTRACE /= 0) CALL IMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMABS

      FUNCTION IMABS_GREATER_THAN(U, V)

!  Return true if abs(U) > abs(V) for IM numbers U, V.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: J
      TYPE(MULTI) :: U, V
      INTENT (IN) :: U, V
      LOGICAL :: IMABS_GREATER_THAN

      IF (U%MP(2) > V%MP(2)) THEN
          IMABS_GREATER_THAN = .TRUE.
          RETURN
      ELSE IF (U%MP(2) < V%MP(2)) THEN
          IMABS_GREATER_THAN = .FALSE.
          RETURN
      ENDIF

      IMABS_GREATER_THAN = .FALSE.
      DO J = 1, INT(U%MP(2))
         IF (U%MP(J+2) > V%MP(J+2)) THEN
             IMABS_GREATER_THAN = .TRUE.
             RETURN
         ELSE IF(U%MP(J+2) < V%MP(J+2)) THEN
             IMABS_GREATER_THAN = .FALSE.
             RETURN
         ENDIF
      ENDDO

      END FUNCTION IMABS_GREATER_THAN

      SUBROUTINE IMADD(MA,MB,MC,QX)

!  MC = MA + MB

!  This routine performs the trace printing.  IMADD2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMADD'
          CALL IMNTR(2,MA,MB,2,QX)

          CALL IMADD2(MA,MB,MC,QX)

          CALL IMNTR(1,MC,MC,1,QX)
      ELSE
          CALL IMADD2(MA,MB,MC,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMADD

      SUBROUTINE IMADD2(MA,MB,MC,QX)

!  MC = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB
      INTEGER :: NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      RESULT_SIZE = MAX(MA%MP(2),MB%MP(2)) + 4
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      IF (QX%KDEBUG == 1) CALL IMARGS('IMADD    ',2,MA,MB,QX)
      NDSAVE = QX%NDIG
      QX%KFLAG = 0

      IF (MA%MP(2) <= 2) THEN
          IF (MB%MP(2) > 2 .OR. MA%MP(2) < 0 .OR. MB%MP(2) < 0) GO TO 110
          IF (MA%MP(2) <= 1) THEN
              MDA = MA%MP(1) * MA%MP(3)
          ELSE
              MDA = MA%MP(1) * (MA%MP(3)*QX%MBASE + MA%MP(4))
          ENDIF
          IF (MB%MP(2) <= 1) THEN
              MDB = MB%MP(1) * MB%MP(3)
          ELSE
              MDB = MB%MP(1) * (MB%MP(3)*QX%MBASE + MB%MP(4))
          ENDIF
          MDAB = MDA + MDB
          IF (ABS(MDAB) < QX%MBASE) THEN
              MC%MP(2) = 1
              IF (MDAB == 0) MC%MP(2) = 0
              IF (MDAB < 0) THEN
                  MC%MP(3) = -MDAB
                  MC%MP(1) = -1
              ELSE
                  MC%MP(3) = MDAB
                  MC%MP(1) = 1
              ENDIF
              MC%MP(4) = 0
              IF (MDA == 0 .OR. MDB == 0) QX%KFLAG = 1
              GO TO 120
          ELSE IF (ABS(MDAB) < QX%MBASE*QX%MBASE) THEN
              MC%MP(2) = 2
              IF (MDAB < 0) THEN
                  MC%MP(3) = AINT (-MDAB/QX%MBASE)
                  MC%MP(4) = ABS(-MDAB - QX%MBASE*MC%MP(3))
                  MC%MP(1) = -1
              ELSE
                  MC%MP(3) = AINT (MDAB/QX%MBASE)
                  MC%MP(4) = ABS(MDAB - QX%MBASE*MC%MP(3))
                  MC%MP(1) = 1
              ENDIF
              IF (MDA == 0 .OR. MDB == 0) QX%KFLAG = 1
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0 .OR.  &
          MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
          IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
              CALL IMI2M2(0,MC,QX)
              MC%MP(2) = QX%MUNKNO
              MC%MP(3) = 1
              QX%KFLAG = -4
              GO TO 120
          ENDIF
          IF (MA%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1) == MB%MP(1) .OR. MB%MP(3) == 0) THEN
                  MC%MP(1) = MA%MP(1)
                  MC%MP(2) = MA%MP(2)
                  MC%MP(3) = MA%MP(3)
                  MC%MP(4) = MA%MP(4)
                  QX%KFLAG = -5
                  GO TO 120
              ELSE
                  QX%KFLAG = -4
                  QX%NAMEST(QX%NCALL) = 'IMADD'
                  CALL FMWARN(QX)
                  CALL IMI2M2(0,MC,QX)
                  MC%MP(2) = QX%MUNKNO
                  MC%MP(3) = 1
                  GO TO 120
              ENDIF
          ENDIF
          IF (MB%MP(2) == QX%MEXPOV) THEN
              IF (MB%MP(1) == MA%MP(1) .OR. MA%MP(3) == 0) THEN
                  MC%MP(1) = MB%MP(1)
                  MC%MP(2) = MB%MP(2)
                  MC%MP(3) = MB%MP(3)
                  MC%MP(4) = MB%MP(4)
                  QX%KFLAG = -5
                  GO TO 120
              ELSE
                  QX%KFLAG = -4
                  QX%NAMEST(QX%NCALL) = 'IMADD'
                  CALL FMWARN(QX)
                  CALL IMI2M2(0,MC,QX)
                  MC%MP(2) = QX%MUNKNO
                  MC%MP(3) = 1
                  GO TO 120
              ENDIF
          ENDIF
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMADD'
          CALL FMWARN(QX)
          CALL IMI2M2(0,MC,QX)
          MC%MP(2) = QX%MUNKNO
          MC%MP(3) = 1
          GO TO 120
      ENDIF

      CALL IMADD3(MA,MB,MC,QX)

  120 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMADD2

      SUBROUTINE IMADD3(MA,MB,MC,QX)

!  Internal addition routine.  MC = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAS,MBS
      INTEGER :: J,JCOMP,JSIGN,N1
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (MA%MP(3) == 0) THEN
          CALL IMEQ(MB,MC,QX)
          QX%KFLAG = 1
          IF (QX%KSUB == 1) THEN
              IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0)  &
                  MC%MP(1) = -MC%MP(1)
              QX%KFLAG = 0
          ENDIF
          RETURN
      ENDIF
      IF (MB%MP(3) == 0) THEN
          CALL IMEQ(MA,MC,QX)
          QX%KFLAG = 1
          RETURN
      ENDIF

      QX%KFLAG = 0
      N1 = MAX(MA%MP(2),MB%MP(2)) + 1

!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MA%MP(1)
      MBS = MB%MP(1)
      IF (QX%KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MA%MP(2) > MB%MP(2)) THEN
          JCOMP = 1
      ELSE IF (MB%MP(2) > MA%MP(2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MA%MP(J+1) > MB%MP(J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MB%MP(J+1) > MA%MP(J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          IF (MAS*MBS > 0) THEN
              CALL IMADDP(MA,MB,MWA,QX)
          ELSE
              CALL IMADDN(MA,MB,MWA,QX)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          IF (MAS*MBS > 0) THEN
              CALL IMADDP(MB,MA,MWA,QX)
          ELSE
              CALL IMADDN(MB,MA,MWA,QX)
          ENDIF
      ENDIF

!             Transfer to MC and fix the sign of the result.

      QX%NDIG = MWA%MP(2)
      IF (QX%NDIG < 2) QX%NDIG = 2
      CALL FMMOVE(MWA,MC,QX)
      MC%MP(1) = 1
      IF (JSIGN < 0 .AND. MC%MP(3) /= 0) MC%MP(1) = -1

      IF (QX%KFLAG < 0) THEN
          IF (QX%KSUB == 1) THEN
              QX%NAMEST(QX%NCALL) = 'IMSUB'
          ELSE
              QX%NAMEST(QX%NCALL) = 'IMADD'
          ENDIF
          CALL FMWARN(QX)
      ENDIF

      RETURN
      END SUBROUTINE IMADD3

      SUBROUTINE IMADDN(MA,MB,MWA,QX)

!  Internal addition routine.  MWA = MA - MB
!  The arguments are such that MA >= MB >= 0.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      REAL (KIND(1.0D0)) :: MK
      INTEGER :: J,K,KL,KP1,KP2,KPT,KSH,N1,RESULT_SIZE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      RESULT_SIZE = 2*MA%MP(2) + 30
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)

      IF (MA%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -4
          MWA%MP(2) = QX%MUNKNO
          MWA%MP(3) = 1
          MWA%MP(4) = 0
          RETURN
      ENDIF

      N1 = MA%MP(2) + 1
      MK = MA%MP(2) - MB%MP(2)
      K = INT(MK)

!             Subtract MB from MA.

      KP1 = MIN(N1,K+1)
      DO J = 1, KP1
         MWA%MP(J+1) = MA%MP(J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      DO J = KP2+1, N1+1
         MWA%MP(J) = MA%MP(J) - MB%MP(J-K)
      ENDDO
      MWA%MP(1+N1+1) = 0

!             Normalize.  Fix the sign of any negative digit.

      IF (K > 0) THEN
          DO J = N1, KP2, -1
             IF (MWA%MP(J+1) < 0) THEN
                 MWA%MP(J+1) = MWA%MP(J+1) + QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - 1
             ENDIF
          ENDDO
          KPT = KP2 - 1
  110     IF (MWA%MP(KPT+1) < 0 .AND. KPT >= 3) THEN
              MWA%MP(KPT+1) = MWA%MP(KPT+1) + QX%MBASE
              MWA%MP(KPT) = MWA%MP(KPT) - 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
      ELSE
          DO J = N1, 3, -1
             IF (MWA%MP(J+1) < 0) THEN
                 MWA%MP(J+1) = MWA%MP(J+1) + QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - 1
             ENDIF
          ENDDO
      ENDIF

!             Shift left if there are any leading zeros in the mantissa.

      DO J = 2, N1
         IF (MWA%MP(J+1) > 0) THEN
             KSH = J - 2
             GO TO 120
         ENDIF
      ENDDO
      MWA%MP(2) = 0
      MWA%MP(4) = 0
      RETURN

  120 IF (KSH > 0) THEN
          KL = N1 - KSH
          DO J = 2, KL
             MWA%MP(J+1) = MWA%MP(J+KSH+1)
          ENDDO
          DO J = KL+1, N1
             MWA%MP(J+1) = 0
          ENDDO
          MWA%MP(2) = MWA%MP(2) - KSH
      ENDIF

      RETURN
      END SUBROUTINE IMADDN

      SUBROUTINE IMADDP(MA,MB,MWA,QX)

!  Internal addition routine.  MWA = MA + MB
!  The arguments are such that MA >= MB >= 0.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      REAL (KIND(1.0D0)) :: MK
      INTEGER :: J,K,KP2,KPT,N1,RESULT_SIZE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      RESULT_SIZE = 2*(MA%MP(2)+1) + 30
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)

      N1 = MA%MP(2) + 1
      MK = MA%MP(2) - MB%MP(2)
      K = INT(MK)

!             Add MA and MB.

      MWA%MP(2) = MA%MP(2) + 1
      MWA%MP(3) = 0
      DO J = 2, K+1
         MWA%MP(J+2) = MA%MP(J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      DO J = KP2+1, N1+1
         MWA%MP(J+1) = MA%MP(J) + MB%MP(J-K)
      ENDDO
      MWA%MP(N1+3) = 0

!             Normalize.  Fix any digit not less than MBASE.

      IF (K > 0) THEN
          DO J = N1+1, KP2, -1
             IF (MWA%MP(J+1) >= QX%MBASE) THEN
                 MWA%MP(J+1) = MWA%MP(J+1) - QX%MBASE
                 MWA%MP(J) = MWA%MP(J) + 1
             ENDIF
          ENDDO
          KPT = KP2 - 1
  110     IF (MWA%MP(KPT+1) >= QX%MBASE .AND. KPT >= 3) THEN
              MWA%MP(KPT+1) = MWA%MP(KPT+1) - QX%MBASE
              MWA%MP(KPT) = MWA%MP(KPT) + 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
      ELSE
          DO J = N1+1, 3, -1
             IF (MWA%MP(J+1) >= QX%MBASE) THEN
                 MWA%MP(J+1) = MWA%MP(J+1) - QX%MBASE
                 MWA%MP(J) = MWA%MP(J) + 1
             ENDIF
          ENDDO
      ENDIF

      RETURN
      END SUBROUTINE IMADDP

      SUBROUTINE IMARGS(KROUTN,NARGS,MA,MB,QX)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: KROUTN
      TYPE(MULTI) :: MA,MB
      INTEGER :: NARGS
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: J,KWRNSV,LAST
      INTENT (IN) :: KROUTN,NARGS,MA,MB

      QX%KFLAG = -4
      IF (MA%MP(2) == QX%MUNKNO) THEN
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (MB%MP(2) == QX%MUNKNO) THEN
              RETURN
          ENDIF
      ENDIF
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0

!             Check the validity of parameters.

      IF (QX%NCALL > 1 .AND. QX%KDEBUG == 0) THEN
          RETURN
      ENDIF
      QX%NAMEST(QX%NCALL) = KROUTN

!             Check MBASE.

      IF (QX%MBASE < 2 .OR. QX%MBASE > MXBASE) THEN
          QX%KFLAG = -2
          CALL FMWARN(QX)
          MBS = QX%MBASE
          IF (QX%MBASE < 2) QX%MBASE = 2
          IF (QX%MBASE > MXBASE) QX%MBASE = MXBASE
          WRITE (KW,                                                       &
                 "(' MBASE was',I10,'.  It has been changed to',I10,'.')"  &
                ) INT(MBS),INT(QX%MBASE)
          CALL FMCONS(QX)
          RETURN
      ENDIF

!             Check exponent range.

      IF (MA%MP(2) < 0) THEN
          IF (ABS(MA%MP(2)) /= QX%MEXPOV .OR. ABS(MA%MP(3)) /= 1) THEN
              QX%KFLAG = -3
              CALL FMWARN(QX)
              RETURN
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MB%MP(2) < 0) THEN
              IF (ABS(MB%MP(2)) /= QX%MEXPOV .OR. ABS(MB%MP(3)) /= 1) THEN
                  QX%KFLAG = -3
                  CALL FMWARN(QX)
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MA%MP(2)-INT(MA%MP(2))) /= 0) QX%KFLAG = 1
      IF (MA%MP(3) <= (-1) .OR. MA%MP(3) >= QX%MBASE .OR.  &
          ABS(MA%MP(3)-INT(MA%MP(3))) /= 0) QX%KFLAG = 2
      IF (QX%KDEBUG == 0) GO TO 110
      LAST = INT(MA%MP(2)) + 1
      IF (MA%MP(2) > SIZE(MA%MP)-2) LAST = 3
      DO J = 3, LAST
         IF (MA%MP(J+1) < 0 .OR. MA%MP(J+1) >= QX%MBASE .OR.  &
             ABS(MA%MP(J+1)-INT(MA%MP(J+1))) /= 0) THEN
             QX%KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
  110 IF (QX%KFLAG /= 0) THEN
          J = QX%KFLAG
          QX%KFLAG = -4
          KWRNSV = QX%KWARN
          IF (QX%KWARN >= 2) QX%KWARN = 1
          CALL FMWARN(QX)
          QX%KWARN = KWRNSV
          IF (QX%KWARN >= 1) THEN
              WRITE (KW,*) ' First invalid array element:  MA(',J,') = ',MA%MP(J+1)
          ENDIF
          IF (QX%KWARN >= 2) THEN
              STOP
          ENDIF
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MB%MP(2)-INT(MB%MP(2))) /= 0) QX%KFLAG = 1
          IF (MB%MP(3) <= (-1) .OR. MB%MP(3) >= QX%MBASE .OR.  &
              ABS(MB%MP(3)-INT(MB%MP(3))) /= 0) QX%KFLAG = 2
          IF (QX%KDEBUG == 0) GO TO 120
          LAST = INT(MB%MP(2)) + 1
          IF (MB%MP(2) > SIZE(MB%MP)-2) LAST = 3
          DO J = 3, LAST
             IF (MB%MP(J+1) < 0 .OR. MB%MP(J+1) >= QX%MBASE .OR.  &
                 ABS(MB%MP(J+1)-INT(MB%MP(J+1))) /= 0) THEN
                 QX%KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (QX%KFLAG /= 0) THEN
              J = QX%KFLAG
              QX%KFLAG = -4
              KWRNSV = QX%KWARN
              IF (QX%KWARN >= 2) QX%KWARN = 1
              CALL FMWARN(QX)
              QX%KWARN = KWRNSV
              IF (QX%KWARN >= 1) THEN
                  WRITE (KW,*) ' First invalid array element:  MB(',J,') = ',MB%MP(J+1)
              ENDIF
              IF (QX%KWARN >= 2) THEN
                  STOP
              ENDIF
              RETURN
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE IMARGS

      SUBROUTINE IMBIG(MA,QX)

!  MA = A very large IM integer.

!  Before version 1.3 of FM, this routine returned the largest representable IM integer.
!  Starting with version 1.3 the size of IM integers is limited only by the space available
!  in the working array MWK in FMSAVE.f95.
!  But if this routine set MA as large as possible, it would leave no room for other
!  FM/IM/ZM numbers.  So a result of 10**(10**6) is returned here.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: L,RESULT_SIZE
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      L = 1.05D+6*LOG(10.0D0)/LOG(DBLE(QX%MBASE)) + 3
      RESULT_SIZE = L + 3
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'IMBIG'

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      CALL IMI2M(10,MXY(1),QX)
      CALL IMI2M(10**6,MXY(2),QX)
      CALL IMPWR(MXY(1),MXY(2),MA,QX)

      IF (QX%NTRACE /= 0 .AND. QX%NCALL <= QX%LVLTRC) THEN
          WRITE (KW,                                               &
                 "(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)"  &
                ) 'IMBIG',QX%NCALL,INT(QX%MBASE)
          WRITE (KW,*) '       1.0M+1000000'
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMBIG

      SUBROUTINE IMCOMB(MA,MB,MC,QX)

!  Binomial coefficients for integers.  MA, MB, MC, are all multiprecision integers.

!  MC = MA choose MB = MA! / ( MB! * (MA-MB)! )

!  This routine extends this definition to allow negative integer values for MA and/or MB.
!  The standard recurrence comb(n,k) = comb(n-1,k-1) + comb(n-1,k) can be used to define
!  comb(n,k) for all integers n,k starting from the initializing definitions
!  comb(0,k) = 0, for all k except 0,
!  comb(n,0) = 1, for all n.
!  Ex:  n = 1, k = 1 => comb(1,1) = comb(0,0)   +  comb(0,1)
!                    => comb(1,1) =         1   +          0,  so  comb(1,1)   =  1
!       n = 0, k = 0 => comb(0,0) = comb(-1,-1) + comb(-1,0)
!                    =>         1 = comb(-1,-1) +          1,  so  comb(-1,-1) =  0
!       n = 0, k = 1 => comb(0,1) = comb(-1,0)  + comb(-1,1)
!                    =>         0 =          1  + comb(-1,1),  so  comb(-1,1)  = -1

!  This definition agrees with the standard factorial definition when n and k are non-negative
!  integers.  The factorial definition is undefined when n or k is a negative integer, since
!  x! has singularities at negative integers.

!  For negative n or k, this extended definition simplifies to:
!  if k < 0,             comb(n,k) = 0
!  if k >= 0 and n < 0,  comb(n,k) = (-1)**k * comb(-n+k-1,k)

!  These extended definitions are useful in some combinatorial applications.
!  Reference:  Concrete Mathematics - Graham, Knuth, Patashnik, Addison-Wesley, 1989.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(MULTI) :: MXY(3)
      INTEGER :: K,KMOD2,L,N
      TYPE(MULTI) :: MT
      INTEGER :: J
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMCOMB'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      CALL IMM2I(MA,N,QX)
      IF (QX%KFLAG == 0) THEN
          CALL IMM2I(MB,K,QX)
          IF (QX%KFLAG == 0) THEN
              CALL IMCOMBI(N,K,MT,QX)
              CALL IMEQ(MT,MC,QX)
              IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

      IF (MA%MP(1) < 0) THEN
          CALL IMSUB(MB,MA,MXY(1),QX)
          CALL IMI2M(1,MXY(2),QX)
          CALL IMSUB(MXY(1),MXY(2),MXY(3),QX)
      ELSE
          CALL IMEQ(MA,MXY(3),QX)
      ENDIF
      CALL IMSUB(MXY(3),MB,MXY(1),QX)
      CALL IMMIN(MB,MXY(1),MXY(2),QX)
      IF (MXY(2)%MP(1) < 0) THEN
          CALL IMI2M(0,MT,QX)
          GO TO 110
      ELSE IF (MXY(2)%MP(3) == 0) THEN
          CALL IMI2M(1,MT,QX)
          GO TO 110
      ENDIF
      CALL IMM2I(MXY(2),L,QX)

!             If L = min(k,n-k) is too big to represent as a machine integer, return unknown,
!             since the binomial result mc would have over half a billion digits.

      IF (QX%KFLAG /= 0) THEN
          CALL IMST2M('UNKNOWN',MT,QX)
          GO TO 110
      ENDIF
      IF (L == 1) THEN
          CALL IMEQ(MXY(3),MT,QX)
          GO TO 110
      ENDIF
      IF (L > 10) THEN
          CALL IMCOMB2(MXY(3),MXY(2),MT,QX)
          GO TO 110
      ENDIF

!             Compute the binomial coefficient.

      CALL IMEQ(MXY(3),MT,QX)
      CALL IMI2M(1,MXY(1),QX)
      DO J = 2, L
         CALL IMSUB(MXY(3),MXY(1),MXY(2),QX)
         CALL IMEQ(MXY(2),MXY(3),QX)
         CALL IMMPY(MXY(3),MT,MXY(2),QX)
         CALL IMDIVI(MXY(2),J,MT,QX)
      ENDDO

  110 CALL IMMODI(MB,2,KMOD2,QX)
      IF (MA%MP(1) < 0 .AND. KMOD2 == 1 .AND.  &
          MT%MP(2) /= QX%MUNKNO .AND. MT%MP(3) /= 0) THEN
          MT%MP(1) = -MT%MP(1)
      ENDIF
      CALL IMEQ(MT,MC,QX)
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMCOMB

      SUBROUTINE IMCOMB2(MA,MB,MC,QX)

!  Binomial coefficients for integers.  MA, MB, MC, are all multiprecision integers.

!  MC = MA choose MB = MA! / ( MB! * (MA-MB)! )

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(MULTI) :: MXY(3)
      INTEGER :: J,J1,J1FAC,KMOD2,KPT,KPT2,L,R
      TYPE(MULTI), ALLOCATABLE :: TOP(:)
      TYPE(MULTI) :: MT
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMCOMB2'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

      IF (MA%MP(1) < 0) THEN
          CALL IMSUB(MB,MA,MXY(1),QX)
          CALL IMI2M(1,MXY(2),QX)
          CALL IMSUB(MXY(1),MXY(2),MXY(3),QX)
      ELSE
          CALL IMEQ(MA,MXY(3),QX)
      ENDIF
      CALL IMSUB(MXY(3),MB,MXY(1),QX)
      CALL IMMIN(MB,MXY(1),MXY(2),QX)
      IF (MXY(2)%MP(1) < 0) THEN
          CALL IMI2M(0,MT,QX)
          GO TO 110
      ELSE IF (MXY(2)%MP(3) == 0) THEN
          CALL IMI2M(1,MT,QX)
          GO TO 110
      ENDIF
      CALL IMM2I(MXY(2),L,QX)

!             If L = min(k,n-k) is too big to represent as a machine integer, return unknown,
!             since the binomial result mc would have over half a billion digits.

      IF (QX%KFLAG /= 0) THEN
          CALL IMST2M('UNKNOWN',MT,QX)
          GO TO 110
      ENDIF
      IF (L == 1) THEN
          CALL IMEQ(MXY(3),MT,QX)
          GO TO 110
      ENDIF

!             Compute the binomial coefficient by making a list of the numerator terms
!             N, N-1, ..., N-L+1.  Then divide out each of the denominator terms 2, 3, ..., L.


      ALLOCATE(TOP(L),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR
      ENDIF
      CALL IMI2M(1,MXY(1),QX)
      CALL IMEQ(MXY(3),TOP(1),QX)
      DO J = 2, L
         CALL IMSUB(TOP(J-1),MXY(1),TOP(J),QX)
      ENDDO

      DO J = L, 2, -1
         CALL IMMODI(MXY(3),J,R,QX)
         KPT = R + 1
         DO WHILE (KPT <= L)
            CALL IMMODI(TOP(KPT),J,R,QX)
            IF (R == 0) THEN
                CALL IMDIVI(TOP(KPT),J,MXY(2),QX)
                CALL IMEQ(MXY(2),TOP(KPT),QX)
                EXIT
            ENDIF
            KPT = KPT + J
            IF (KPT > L) THEN
                J1 = J
                DO WHILE (J1 > 1)
                   CALL IMCOMB2_FACTOR(J1,J1FAC)
                   CALL IMMODI(MXY(3),J1FAC,R,QX)
                   KPT2 = R + 1
                   DO WHILE (KPT2 <= L)
                      CALL IMMODI(TOP(KPT2),J1FAC,R,QX)
                      IF (R == 0) THEN
                          CALL IMDIVI(TOP(KPT2),J1FAC,MXY(2),QX)
                          CALL IMEQ(MXY(2),TOP(KPT2),QX)
                          EXIT
                      ENDIF
                      KPT2 = KPT2 + J1FAC
                   ENDDO
                ENDDO
            ENDIF
         ENDDO
      ENDDO

!             Form the product of the remaining TOP terms.

      CALL IMEQ(TOP(1),MT,QX)
      DO J = 2, L
         IF (TOP(J)%MP(2) > 1 .OR.  &
            (TOP(J)%MP(2) == 1 .AND. TOP(J)%MP(3) > 1)) THEN
             CALL IMMPY(TOP(J),MT,MXY(2),QX)
             CALL IMEQ(MXY(2),MT,QX)
         ENDIF
      ENDDO

      DEALLOCATE(TOP)

  110 CALL IMI2M(2,MXY(1),QX)
      CALL IMMOD(MB,MXY(1),MXY(2),QX)
      CALL IMM2I(MXY(2),KMOD2,QX)
      IF (MA%MP(1) < 0 .AND. KMOD2 == 1 .AND.  &
          MT%MP(2) /= QX%MUNKNO .AND. MT%MP(3) /= 0) THEN
          MT%MP(1) = -MT%MP(1)
      ENDIF
      CALL IMEQ(MT,MC,QX)
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMCOMB2

      SUBROUTINE IMCOMB2_FACTOR(J1,J1FAC)

!  Return J1FAC as one prime factor of J1, and return J1 with the value J1 / J1FAC

      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: J,J1,J1FAC

      IF (MOD(J1,2) == 0) THEN
          J1FAC = 2
          J1 = J1 / J1FAC
          RETURN
      ENDIF

      IF (MOD(J1,3) == 0) THEN
          J1FAC = 3
          J1 = J1 / J1FAC
          RETURN
      ENDIF

      DO J = 5, INT(SQRT(DBLE(J1)))+1, 6
         J1FAC = J
         IF (MOD(J1,J1FAC) == 0) THEN
             J1 = J1 / J1FAC
             RETURN
         ENDIF
         J1FAC = J + 2
         IF (MOD(J1,J1FAC) == 0) THEN
             J1 = J1 / J1FAC
             RETURN
         ENDIF
      ENDDO

      J1FAC = J1
      J1 = 1

      END SUBROUTINE IMCOMB2_FACTOR

      SUBROUTINE IMCOMBI(N,K,MA,QX)

!  Binomial coefficients for integers.
!  N, K, are machine precision integers, MA is a multiprecision integer.

!  MA = N choose K = N! / ( K! * (N-K)! )

!  See the comments in IMCOMB about results for negative N, etc.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N,K
      TYPE(MULTI) :: MA
      TYPE(MULTI) :: MXY(2)
      INTEGER :: L,N1,NMETHD
      INTEGER :: J,KSTART,KT,LARGE,LARGED,NDIV,NEXTD,NEXTN,NMPY,NTD,NTN,RESULT_SIZE
      DOUBLE PRECISION :: CN,CK,CNK,E,LOGN,LOGK,LOGNK,PI
      INTENT (IN) :: N,K
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

      N1 = N
      IF (N < 0) N1 = -N + K - 1
      CN = MAX(1,N1)
      CK = MAX(1,K)
      CK = MIN(CK,CN)
      CNK = MAX(1,N1-K)
      CNK = MIN(CNK,CN)
      E = EXP(1.0D0)
      PI = ACOS(-1.0D0)
      LOGN = (LOG( 2*PI*CN )/2) + CN*LOG( CN/E ) + LOG( 1 + 1/(12.0D0*CN) )
      LOGK = (LOG( 2*PI*CK )/2) + CK*LOG( CK/E ) + LOG( 1 + 1/(12.0D0*CK) )
      LOGNK = (LOG( 2*PI*CNK )/2) + CNK*LOG( CNK/E ) + LOG( 1 + 1/(12.0D0*CNK) )
      L = MIN(K,N1-K)
      IF (LOGN < 1.0D+10) THEN
          RESULT_SIZE = (LOGN - LOGK - LOGNK) / QX%DLOGMB + 7
      ELSE
          RESULT_SIZE = (L*LOG(CN) - MIN(LOGK,LOGNK)) / QX%DLOGMB + 7
      ENDIF
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      IF (L < 0) THEN
          CALL IMI2M(0,MA,QX)
          GO TO 110
      ELSE IF (L == 0) THEN
          CALL IMI2M(1,MA,QX)
          GO TO 110
      ELSE IF (L == 1) THEN
          CALL IMI2M(N1,MA,QX)
          GO TO 110
      ENDIF

!             Determine which method to use.

      NMETHD = 2
      IF (N1 >= 2100) THEN
          IF (N1 >= 10**7) THEN
              IF (L >= 8) NMETHD = 1
          ELSE
              IF (L > EXP(10.7D0 - 0.53D0*LOG(CN))) NMETHD = 1
          ENDIF
      ENDIF

      IF (NMETHD == 1) THEN
          CALL IMFACT_P(N1-L+1,N1,MXY(1),QX)
          CALL IMFACT_P(2,L,MXY(2),QX)
          CALL IMDIV(MXY(1),MXY(2),MA,QX)
          GO TO 110
      ENDIF

!             Find the largest value for N1 choose J using integers.

      NTN = N1
      NTD = 1
      LARGE = INT(INTMAX/N1)
      DO J = 2, L
         IF (NTN <= LARGE) THEN
             NTN = (NTN*((N1+1)-J))/J
         ELSE
             CALL IMI2M(NTN,MA,QX)
             NTN = (N1+1) - J
             NTD = J
             EXIT
         ENDIF
      ENDDO

      IF (NTD == 1) THEN
          CALL IMI2M(NTN,MA,QX)
          GO TO 110
      ENDIF

      NEXTN = NTN
      NEXTD = NTD
      KSTART = NTD + 1

!             Compute the rest of N1 choose K.

      LARGED = MIN(LARGE,INT(MXBASE))
      DO KT = KSTART, L
         NEXTN = NEXTN - 1
         NEXTD = NEXTD + 1
         IF (NTN >= LARGE .OR. NTD >= LARGED) THEN
             CALL IMMPYI(MA,NTN,MXY(1),QX)
             CALL IMDIVI(MXY(1),NTD,MA,QX)
             NTN = NEXTN
             NTD = NEXTD
             CYCLE
         ENDIF
         NMPY = NTN*NEXTN
         NDIV = NTD*NEXTD
         IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
             NTN = NMPY
             NTD = NDIV
         ELSE
             CALL FMGCDI(NMPY,NDIV)
             IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                 NTN = NMPY
                 NTD = NDIV
             ELSE
                 CALL IMMPYI(MA,NTN,MXY(1),QX)
                 CALL IMDIVI(MXY(1),NTD,MA,QX)
                 NTN = NEXTN
                 NTD = NEXTD
             ENDIF
         ENDIF
      ENDDO
      CALL FMGCDI(NTN,NTD)
      CALL IMMPYI(MA,NTN,MXY(1),QX)
      CALL IMDIVI(MXY(1),NTD,MA,QX)

  110 IF (N < 0 .AND. MOD(K,2) == 1 .AND.  &
          MA%MP(2) /= QX%MUNKNO .AND. MA%MP(3) /= 0) THEN
          MA%MP(1) = -MA%MP(1)
      ENDIF
      RETURN
      END SUBROUTINE IMCOMBI

      FUNCTION IMCOMP(MA,LREL,MB,QX)

!  Logical comparison of FM numbers MA and MB.

!  LREL is a CHARACTER description of the comparison to be done:
!  LREL = 'EQ' returns IMCOMP = .TRUE. if MA == MB
!       = 'NE', 'GE', 'GT', 'LE', 'LT' also work like a logical IF.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      LOGICAL :: IMCOMP
      CHARACTER(*) :: LREL
      CHARACTER(2) :: JREL
      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,JCOMP,NDSAVE,NLAST,NTRSAV
      INTENT (IN) :: MA,LREL,MB

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMCOMP   ',2,MA,MB,QX)
      QX%NAMEST(QX%NCALL) = 'IMCOMP'

      IF (QX%NCALL <= QX%LVLTRC .AND. ABS(QX%NTRACE) >= 2) THEN
          WRITE (KW,"(' Input to IMCOMP')")
          NDSAVE = QX%NDIG
          IF (QX%NTRACE > 0) THEN
              CALL IMPRNT(MA,QX)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL IMPRNT(MB,QX)
          ELSE
              QX%NDIG = MAX(2,INT(MA%MP(2)))
              NTRSAV = QX%NTRACE
              CALL IMNTRJ(MA,QX%NDIG,QX)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              QX%NDIG = MAX(2,INT(MB%MP(2)))
              CALL IMNTRJ(MB,QX%NDIG,QX)
              QX%NTRACE = NTRSAV
          ENDIF
          QX%NDIG = NDSAVE
      ENDIF

!             JCOMP will be 1 if MA > MB
!                           2 if MA == MB
!                           3 if MA < MB

!             Check for special cases.

      JREL = LREL
      IF (LREL /= 'EQ' .AND. LREL /= 'NE' .AND. LREL /= 'LT' .AND.  &
          LREL /= 'GT' .AND. LREL /= 'LE' .AND. LREL /= 'GE') THEN
          IF (LREL == 'eq' .OR. LREL == '==') THEN
              JREL = 'EQ'
          ELSE IF (LREL == 'ne' .OR. LREL == '/=') THEN
              JREL = 'NE'
          ELSE IF (LREL == 'lt' .OR. LREL == '<') THEN
              JREL = 'LT'
          ELSE IF (LREL == 'gt' .OR. LREL == '>') THEN
              JREL = 'GT'
          ELSE IF (LREL == 'le' .OR. LREL == '<=') THEN
              JREL = 'LE'
          ELSE IF (LREL == 'ge' .OR. LREL == '>=') THEN
              JREL = 'GE'
          ELSE
              IMCOMP = .FALSE.
              QX%KFLAG = -4
              IF (QX%NCALL /= 1 .OR. QX%KWARN <= 0) GO TO 120
              IF (QX%KWARN <= 0) GO TO 120
              WRITE (KW,                                                     &
                     "(/' Error of type KFLAG = -4 in FM package in',"   //  &
                     "' routine IMCOMP'//1X,A,' is not one of the six'," //  &
                     "' recognized comparisons.'//' .FALSE. has been',"  //  &
                     "' returned.'/)"                                        &
                    ) LREL
              IF (QX%KWARN >= 2) THEN
                  STOP
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          IMCOMP = .FALSE.
          QX%KFLAG = -4
          GO TO 120
      ENDIF

      IF (ABS(MA%MP(2)) == QX%MEXPOV .AND. MA%MP(2) == MB%MP(2) .AND.  &
          MA%MP(3) == MB%MP(3) .AND. MA%MP(1) == MB%MP(1)) THEN
          IMCOMP = .FALSE.
          QX%KFLAG = -4
          IF (QX%NCALL /= 1 .OR. QX%KWARN <= 0) GO TO 120
          IF (QX%KWARN <= 0) GO TO 120
          WRITE (KW,                                                     &
                 "(/' Error of type KFLAG = -4 in FM package in ',"  //  &
                 "'routine IMCOMP'//' Two numbers in the same ',"    //  &
                 "'overflow category cannot be compared.'//"         //  &
                 "' .FALSE. has been returned.'/)"                       &
                )
          IF (QX%KWARN >= 2) THEN
              STOP
          ENDIF
          GO TO 120
      ENDIF

!             Check for zero.

      QX%KFLAG = 0
      IF (MA%MP(3) == 0) THEN
          JCOMP = 2
          IF (MB%MP(3) == 0) GO TO 110
          IF (MB%MP(1) < 0) JCOMP = 1
          IF (MB%MP(1) > 0) JCOMP = 3
          GO TO 110
      ENDIF
      IF (MB%MP(3) == 0) THEN
          JCOMP = 1
          IF (MA%MP(1) < 0) JCOMP = 3
          GO TO 110
      ENDIF

!             Check for opposite signs.

      IF (MA%MP(1) > 0 .AND. MB%MP(1) < 0) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MB%MP(1) > 0 .AND. MA%MP(1) < 0) THEN
          JCOMP = 3
          GO TO 110
      ENDIF

!             See which one is larger in absolute value.

      IF (MA%MP(2) > MB%MP(2)) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MB%MP(2) > MA%MP(2)) THEN
          JCOMP = 3
          GO TO 110
      ENDIF
      NLAST = INT(MA%MP(2)) + 1

      DO J = 2, NLAST
         IF (ABS(MA%MP(J+1)) > ABS(MB%MP(J+1))) THEN
             JCOMP = 1
             GO TO 110
         ENDIF
         IF (ABS(MB%MP(J+1)) > ABS(MA%MP(J+1))) THEN
             JCOMP = 3
             GO TO 110
         ENDIF
      ENDDO

      JCOMP = 2

!             Now match the JCOMP value to the requested comparison.

  110 IF (JCOMP == 1 .AND. MA%MP(1) < 0) THEN
          JCOMP = 3
      ELSE IF (JCOMP == 3 .AND. MB%MP(1) < 0) THEN
          JCOMP = 1
      ENDIF

      IMCOMP = .FALSE.
      IF (JCOMP == 1 .AND. (JREL == 'GT' .OR. JREL == 'GE' .OR. JREL == 'NE')) IMCOMP = .TRUE.
      IF (JCOMP == 2 .AND. (JREL == 'EQ' .OR. JREL == 'GE' .OR. JREL == 'LE')) IMCOMP = .TRUE.
      IF (JCOMP == 3 .AND. (JREL == 'NE' .OR. JREL == 'LT' .OR. JREL == 'LE')) IMCOMP = .TRUE.

  120 CONTINUE
      IF (QX%NTRACE /= 0) THEN
          IF (QX%NCALL <= QX%LVLTRC .AND. ABS(QX%NTRACE) >= 1) THEN
              IF (QX%KFLAG == 0) THEN
                  WRITE (KW,                                         &
                         "(' IMCOMP',15X,'Call level =',I2,5X,"  //  &
                         "'MBASE =',I10)"                            &
                        ) QX%NCALL,INT(QX%MBASE)
              ELSE
                  WRITE (KW,                                        &
                         "(' IMCOMP',6X,'Call level =',I2,4X,"  //  &
                         "'MBASE =',I10,4X,'KFLAG =',I3)"           &
                        ) QX%NCALL,INT(QX%MBASE),QX%KFLAG
              ENDIF
              IF (IMCOMP) THEN
                  WRITE (KW,"(7X,'.TRUE.')")
              ELSE
                  WRITE (KW,"(7X,'.FALSE.')")
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END FUNCTION IMCOMP

      SUBROUTINE IMDIM(MA,MB,MC,QX)

!  MC = DIM(MA,MB)

!  Positive difference.  MC = MA - MB  if MA >= MB,
!                           = 0        otherwise.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KOVFL,RESULT_SIZE
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      RESULT_SIZE = MAX(MA%MP(2),MB%MP(2)) + 3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMDIM    ',2,MA,MB,QX)
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMDIM'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
          GO TO 110
      ENDIF
      IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMDIM'
          CALL FMWARN(QX)
          CALL IMST2M('UNKNOWN',MC,QX)
          GO TO 110
      ENDIF
      KOVFL = 0
      IF (MA%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPOV) THEN
          KOVFL = 1
          IF (MA%MP(2) == QX%MEXPOV .AND. MB%MP(2) == QX%MEXPOV .AND.  &
              MA%MP(3) == MB%MP(3) .AND. MA%MP(1) == MB%MP(1)) THEN
              QX%KFLAG = -4
              QX%NAMEST(QX%NCALL) = 'IMDIM'
              CALL FMWARN(QX)
              CALL IMST2M('UNKNOWN',MC,QX)
              GO TO 110
          ENDIF
      ENDIF

      IF (IMCOMP(MA,'>=',MB,QX)) THEN
          CALL IMSUB(MA,MB,MC,QX)
          IF (QX%KFLAG == 1) QX%KFLAG = 0
      ELSE
          MC%MP(2) = 0
          MC%MP(3) = 0
          MC%MP(4) = 0
          MC%MP(1) = 1
      ENDIF

      IF (MC%MP(2) >= QX%MEXPOV) THEN
          IF (MC%MP(2) == QX%MUNKNO) THEN
              QX%KFLAG = -4
              QX%NAMEST(QX%NCALL) = 'IMDIM'
              CALL FMWARN(QX)
          ELSE IF (QX%NCALL == 1 .OR. MC%MP(2) >= QX%MEXPOV) THEN
              IF (MC%MP(1) > 0) THEN
                  CALL IMST2M('OVERFLOW',MC,QX)
              ELSE
                  CALL IMST2M('-OVERFLOW',MC,QX)
              ENDIF
              QX%KFLAG = -5
              QX%NAMEST(QX%NCALL) = 'IMDIM'
              IF (KOVFL /= 1) CALL FMWARN(QX)
          ENDIF
      ENDIF

  110 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMDIM

      SUBROUTINE IMDIV(MA,MB,MC,QX)

!  MC = INT(MA/MB)

!  Use IMDIVR if both INT(MA/MB) and MOD(MA,MB) are needed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      IF (MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MA%MP(2) - MB%MP(2) + 6
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMDIV    ',2,MA,MB,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMDIV'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
          GO TO 110
      ENDIF

      QX%KREM = 0
      CALL IMDIVR(MA,MB,MC,MXY(1),QX)
      QX%KREM = 1

      IF (MC%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMDIV'
          CALL FMWARN(QX)
      ENDIF

  110 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMDIV

      SUBROUTINE IMDIVI(MA,IDIV,MB,QX)

!  MB = INT(MA/IDIV)

!  Use IMDVIR if both INT(MA/IDIV) and MOD(MA,IDIV) are needed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IDIV,IREM,NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA,IDIV
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      RESULT_SIZE = MAX(5,INT(MA%MP(2)+3))
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMDIVI   ',1,MA,MA,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMDIVI'
          CALL IMNTR(2,MA,MA,1,QX)
          CALL IMNTRI(2,IDIV,0,QX)
      ENDIF

      IF (MA%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MB,QX)
          QX%KFLAG = -4
          GO TO 110
      ENDIF

      CALL IMDVIR(MA,IDIV,MB,IREM,QX)

      IF (MB%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMDIVI'
          CALL FMWARN(QX)
      ENDIF

  110 IF (MB%MP(2) <= 1) MB%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMDIVI

      SUBROUTINE IMDIVR(MA,MB,MC,MD,QX)

!  MC = INT(MA / MB),    MD = Remainder from the division.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC,MD
      TYPE(WORK_AREA) :: MWA
      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB,MDR
      DOUBLE PRECISION :: XB,XBR,XBASE,XMWA
      REAL (KIND(1.0D0)) :: MAS,MAXMWA,MB1,MBP1,MBS,MCARRY,MKT,MLMAX,MQD
      INTEGER :: J,JB,JL,K,KA,KB,KL,KLTFLG,KPTMWA,LCRRCT,NA1,NB1,ND,NDSAVE,NGUARD,NL,  &
                 NMBWDS,NMETHD,NTRSAV,RESULT_SIZE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE(FM_SETTINGS) :: QX
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC,MD
      TYPE(MULTI) :: MXY(4)

      IF (MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MA%MP(2) - MB%MP(2) + 6
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      RESULT_SIZE = MAX(5,INT(MB%MP(2)+3)) + 2
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = MA%MP(2) + 5
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = 2*MA%MP(2) + 30
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMDIVR   ',2,MA,MB,QX)
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMDIVR'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF
      QX%KFLAG = 0
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)

!             Check for special cases.

      IF (MB%MP(2) == 1 .AND. MA%MP(2) /= QX%MUNKNO) THEN
          IF (MB%MP(1)*MB%MP(3) == 1) THEN
              CALL IMEQ(MA,MC,QX)
              MD%MP(2) = 0
              MD%MP(3) = 0
              MD%MP(4) = 0
              MD%MP(1) = 1
              GO TO 170
          ELSE IF (MB%MP(1)*MB%MP(3) == -1) THEN
              CALL IMEQ(MA,MC,QX)
              IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0)  &
                  MC%MP(1) = -MC%MP(1)
              MD%MP(2) = 0
              MD%MP(3) = 0
              MD%MP(4) = 0
              MD%MP(1) = 1
              GO TO 170
          ENDIF
      ENDIF
      IF (MA%MP(2) < MB%MP(2) .AND. MB%MP(2) /= QX%MUNKNO) GO TO 110
      IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0 .OR. MB%MP(3) == 0 .OR.  &
          MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
          QX%KFLAG = -4
          IF (MA%MP(2) /= QX%MUNKNO .AND. MB%MP(2) /= QX%MUNKNO) THEN
              QX%NAMEST(QX%NCALL) = 'IMDIVR'
              CALL FMWARN(QX)
          ENDIF
          CALL IMST2M('UNKNOWN',MC,QX)
          CALL IMST2M('UNKNOWN',MD,QX)
          GO TO 170
      ENDIF
      IF (MA%MP(2) <= 2) THEN
          IF (MB%MP(2) > 2) GO TO 110
          IF (MB%MP(3) == 0) GO TO 110
          IF (MA%MP(2) <= 1) THEN
              MDA = MA%MP(1) * MA%MP(3)
          ELSE
              MDA = MA%MP(1) * (MA%MP(3)*QX%MBASE + MA%MP(4))
          ENDIF
          IF (MB%MP(2) <= 1) THEN
              MDB = MB%MP(1) * MB%MP(3)
          ELSE
              MDB = MB%MP(1) * (MB%MP(3)*QX%MBASE + MB%MP(4))
          ENDIF
          MDAB = AINT (MDA / MDB)
          MDR = MDA - MDAB*MDB
          IF (ABS(MDAB) < QX%MBASE) THEN
              MC%MP(2) = 1
              IF (MDAB == 0) MC%MP(2) = 0
              IF (MDAB >= 0) THEN
                  MC%MP(3) = MDAB
                  MC%MP(1) = 1
              ELSE
                  MC%MP(3) = -MDAB
                  MC%MP(1) = -1
              ENDIF
              MC%MP(4) = 0
          ELSE IF (ABS(MDAB) < QX%MBASE*QX%MBASE) THEN
              MC%MP(2) = 2
              IF (MDAB >= 0) THEN
                  MC%MP(3) = AINT (MDAB/QX%MBASE)
                  MC%MP(4) = ABS(MDAB - QX%MBASE*MC%MP(3))
                  MC%MP(1) = 1
              ELSE
                  MC%MP(3) = AINT (-MDAB/QX%MBASE)
                  MC%MP(4) = ABS(-MDAB - QX%MBASE*MC%MP(3))
                  MC%MP(1) = -1
              ENDIF
          ELSE
              GO TO 110
          ENDIF
          IF (ABS(MDR) < QX%MBASE) THEN
              MD%MP(2) = 1
              IF (MDR == 0) MD%MP(2) = 0
              IF (MDR >= 0) THEN
                  MD%MP(3) = MDR
                  MD%MP(1) = 1
              ELSE
                  MD%MP(3) = -MDR
                  MD%MP(1) = -1
              ENDIF
              MD%MP(4) = 0
              GO TO 170
          ELSE IF (ABS(MDR) < QX%MBASE*QX%MBASE) THEN
              MD%MP(2) = 2
              IF (MDR >= 0) THEN
                  MD%MP(3) = AINT (MDR/QX%MBASE)
                  MD%MP(4) = ABS(MDR - QX%MBASE*MD%MP(3))
                  MD%MP(1) = 1
              ELSE
                  MD%MP(3) = AINT (-MDR/QX%MBASE)
                  MD%MP(4) = ABS(-MDR - QX%MBASE*MD%MP(3))
                  MD%MP(1) = -1
              ENDIF
              GO TO 170
          ENDIF
      ENDIF

  110 KLTFLG = 0
      MAS = MA%MP(1)
      MBS = MB%MP(1)
      KL = INT(MB%MP(2))
      IF (ABS(KL) >= QX%MEXPOV) KL = 2
      RESULT_SIZE = ABS(MB%MP(2)) + 4
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      DO J = 0, KL+1
         MXY(1)%MP(J+1) = MB%MP(J+1)
      ENDDO
      MXY(1)%MP(1) = 1
      IF (KL == 1) MXY(1)%MP(4) = 0
      IF (MA%MP(2) == MXY(1)%MP(2) .AND.  &
          ABS(MA%MP(3)) <= MXY(1)%MP(3)) THEN
          DO J = 2, KL+1
             IF (MA%MP(J+1) /= MXY(1)%MP(J+1)) GO TO 120
          ENDDO
          KLTFLG = 2
  120     IF (KLTFLG == 0) THEN
              DO J = 2, KL+1
                 IF (MA%MP(J+1) < MXY(1)%MP(J+1)) THEN
                     KLTFLG = 1
                     EXIT
                 ELSE IF (MA%MP(J+1) > MXY(1)%MP(J+1)) THEN
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (MA%MP(2) < MB%MP(2) .OR. KLTFLG >= 1) THEN
          IF (KLTFLG /= 2) THEN
              CALL IMEQ(MA,MD,QX)
              MD%MP(1) = ABS(MD%MP(1))
              CALL IMI2M(0,MC,QX)
          ELSE
              CALL IMI2M(1,MC,QX)
              CALL IMI2M(0,MD,QX)
          ENDIF
          GO TO 160
      ENDIF

      QX%NDIG = INT(MA%MP(2)) + 2
      IF (QX%NDIG < 2) QX%NDIG = 2

!             Check for using an FFT-based method if precision is very high.

      ND = 1000
      IF (INT(MA%MP(2))-INT(MB%MP(2)) >= ND) THEN
          NMETHD = 2
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL IMI2FM(MA,MXY(1),QX)
          MXY(1)%MP(1) = 1
          CALL IMI2FM(MB,MXY(2),QX)
          MXY(2)%MP(1) = 1
          CALL FMDIV(MXY(1),MXY(2),MXY(3),QX)
          CALL IMFM2I(MXY(3),MC,QX)
          IF (QX%KREM /= 1) THEN
              CALL IMI2M(0,MD,QX)
          ELSE
              CALL IMABS(MA,MXY(1),QX)
              CALL IMABS(MB,MXY(2),QX)
              CALL IMMPY(MC,MXY(2),MXY(3),QX)
              CALL IMSUB(MXY(1),MXY(3),MXY(4),QX)
              CALL IMEQ(MXY(4),MD,QX)
              IF (MD%MP(1) == -1) THEN
                  CALL IMI2M(1,MXY(3),QX)
                  CALL IMSUB(MC,MXY(3),MXY(4),QX)
                  CALL IMEQ(MXY(4),MC,QX)
                  CALL IMADD(MD,MXY(2),MXY(4),QX)
                  CALL IMEQ(MXY(4),MD,QX)
              ELSE IF (IMCOMP(MD,'>=',MXY(2),QX)) THEN
                  CALL IMI2M(1,MXY(3),QX)
                  CALL IMADD(MC,MXY(3),MXY(4),QX)
                  CALL IMEQ(MXY(4),MC,QX)
                  CALL IMSUB(MD,MXY(2),MXY(4),QX)
                  CALL IMEQ(MXY(4),MD,QX)
              ENDIF
          ENDIF
          GO TO 160
      ENDIF

!             NGUARD is the number of guard digits used.

      NGUARD = 1
      NA1 = INT(MA%MP(2)) + 1
      NB1 = INT(MB%MP(2)) + 1

!             Copy MA into the working array.

      DO J = 3, NA1
         MWA%MP(J+2) = MA%MP(J+1)
      ENDDO
      MWA%MP(2) = MA%MP(2) - MB%MP(2) + 1
      MWA%MP(3) = 0
      NL = NA1 + NGUARD + 3
      DO J = NA1+2, NL
         MWA%MP(J+1) = 0
      ENDDO

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MA%MP(1)
      MB1 = MB%MP(2)
      MBS = MB%MP(1)
      MWA%MP(4) = MA%MP(3)

!             NMBWDS is the number of words of MB used to compute the estimated quotient digit MQD.

      NMBWDS = 4
      IF (QX%MBASE < 100) NMBWDS = 7

!             XB is an approximation of MB used in estimating the quotient digits.

      XBASE = DBLE(QX%MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= NB1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MB%MP(J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= NB1) THEN
                 XB = XB*XBASE + DBLE(MB%MP(J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= NB1) THEN
          XB = XB + DBLE(MB%MP(JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = QX%MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - QX%MBASE
      MLMAX = MIN(MLMAX,MKT)

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.
!             It is used to determine whether normalization can be postponed.

      MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  130 KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWA%MP(KPTMWA+1))*XBASE + DBLE(MWA%MP(KPTMWA+2)))*XBASE  &
                 + DBLE(MWA%MP(KPTMWA+3)))*XBASE + DBLE(MWA%MP(KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWA%MP(KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = KA + INT(MB1) - 1
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWA%MP(J+1) < 0) THEN
                 MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
                 MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MB from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          DO J = KA+1, KB+1
             MWA%MP(J) = MWA%MP(J) - MQD*MB%MP(J-JB)
          ENDDO
      ENDIF

      MWA%MP(KA+1) = MWA%MP(KA+1) + MWA%MP(KA)*QX%MBASE
      MWA%MP(KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA-2 < MWA%MP(2)) GO TO 130

!             Final normalization.

      KPTMWA = KPTMWA - 1
      DO J = KPTMWA, 3, -1
         IF (MWA%MP(J+1) < 0) THEN
             MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
             MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ENDIF
      ENDDO

      LCRRCT = 0
  140 DO J = KPTMWA+INT(MB1), KPTMWA+2, -1
         IF (MWA%MP(J+1) < 0) THEN
             MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
             MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ENDIF
      ENDDO

!             Due to rounding, the remainder may not be between 0 and ABS(MB) here.
!             Correct if necessary.

      IF (MWA%MP(KA+1) < 0) THEN
          LCRRCT = LCRRCT - 1
          DO J = KA, KB
             MWA%MP(J+1) = MWA%MP(J+1) + MB%MP(J-JB+1)
          ENDDO
          GO TO 140
      ELSE IF (MWA%MP(KA+1) >= QX%MBASE) THEN
          LCRRCT = LCRRCT + 1
          DO J = KA, KB
             MWA%MP(J+1) = MWA%MP(J+1) - MB%MP(J-JB+1)
          ENDDO
          GO TO 140
      ENDIF
      IF (MWA%MP(3) /= 0 .OR. KPTMWA == 2) THEN
          DO J = 1, INT(MWA%MP(2))+1
             MC%MP(J+1) = MWA%MP(J+1)
          ENDDO
      ELSE
          DO J = 3, INT(MWA%MP(2))+1
             MC%MP(J) = MWA%MP(J+1)
          ENDDO
          IF (MC%MP(3) /= 0) THEN
              MC%MP(2) = MWA%MP(2) - 1
          ELSE
              MC%MP(2) = 0
          ENDIF
      ENDIF
      IF (MC%MP(2) <= 1) MC%MP(4) = 0
      MC%MP(1) = 1

      IF (MWA%MP(KPTMWA+2) /= 0) THEN
          DO J = 1, INT(MB1)
             MD%MP(J+2) = MWA%MP(J+KPTMWA+1)
          ENDDO
          MD%MP(2) = MB1
      ELSE
          DO J = 1, INT(MB1)
             IF (MWA%MP(J+KPTMWA+1) /= 0) THEN
                 DO K = J, INT(MB1)
                    MD%MP(K-J+3) = MWA%MP(K+KPTMWA+1)
                 ENDDO
                 MD%MP(2) = MB1 + 1 - J
                 GO TO 150
             ENDIF
          ENDDO
          MD%MP(2) = 0
          MD%MP(3) = 0
      ENDIF
  150 IF (MD%MP(2) <= 1) MD%MP(4) = 0
      MD%MP(1) = 1

!             If the remainder had to be corrected, make the corresponding adjustment in
!             the quotient.

      IF (MD%MP(2) > MXY(1)%MP(2) .OR.    &
         (MD%MP(2) == MXY(1)%MP(2) .AND.  &
          ABS(MD%MP(3)) >= MXY(1)%MP(3))) THEN
          IF (IMCOMP(MD,'>=',MXY(1),QX)) THEN
              CALL IMSUB(MD,MXY(1),MXY(3),QX)
              CALL IMEQ(MXY(3),MD,QX)
              LCRRCT = LCRRCT + 1
          ENDIF
      ENDIF
      IF (LCRRCT /= 0) THEN
          CALL IMI2M(LCRRCT,MXY(2),QX)
          CALL IMADD(MXY(2),MC,MXY(3),QX)
          CALL IMEQ(MXY(3),MC,QX)
      ENDIF

  160 MC%MP(1) = 1
      MD%MP(1) = 1
      IF (MAS < 0 .AND. MBS > 0) THEN
          IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0) MC%MP(1) = -1
          IF (MD%MP(2) /= QX%MUNKNO .AND. MD%MP(3) /= 0) MD%MP(1) = -1
      ELSE IF (MAS > 0 .AND. MBS < 0)  THEN
          IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0) MC%MP(1) = -1
      ELSE IF (MAS < 0 .AND. MBS < 0)  THEN
          IF (MD%MP(2) /= QX%MUNKNO .AND. MD%MP(3) /= 0) MD%MP(1) = -1
      ENDIF

  170 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      IF (MD%MP(2) <= 1) MD%MP(4) = 0
      QX%NTRACE = NTRSAV
      IF (QX%NTRACE /= 0) THEN
          CALL IMNTR(1,MC,MC,1,QX)
          IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  QX%NDIG = MAX(2,INT(MD%MP(2)))
                  NTRSAV = QX%NTRACE
                  CALL IMNTRJ(MD,QX%NDIG,QX)
                  QX%NTRACE = NTRSAV
              ELSE
                  CALL IMPRNT(MD,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMDIVR

      SUBROUTINE IMDVIR(MA,IDIV,MB,IREM,QX)

!  MB = INT(MA / IDIV),    IREM = Remainder from the division.

!  Division by a one word integer.  The remainder is also a one word integer.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX
      REAL (KIND(1.0D0)) :: MAS,MDA,MDAB,MDB,MDR,MKT,MODINT,MVALP
      INTEGER :: IDIV,IREM,J,JDIV,KA,KL,KLTFLG,KPT,N1,NDSAVE,NMVAL,NTRSAV,NV2,RESULT_SIZE
      INTENT (IN) :: MA,IDIV
      INTENT (INOUT) :: MB,IREM
      TYPE(MULTI) :: MXY(3)

      RESULT_SIZE = MAX(5,INT(MA%MP(2)+5))
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5

      RESULT_SIZE = 2*MA%MP(2) + 30
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMDVIR   ',1,MA,MA,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      KLTFLG = 0
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      MKT = ABS(IDIV)
      IF (MKT < QX%MBASE) THEN
          MXY(1)%MP(2) = 1
          MXY(1)%MP(3) = ABS(IDIV)
          MXY(1)%MP(4) = 0
          MXY(1)%MP(1) = 1
          IF (IDIV < 0) MXY(1)%MP(1) = -1
      ELSE IF (MKT < QX%MBASE*QX%MBASE) THEN
          MXY(1)%MP(2) = 2
          MXY(1)%MP(3) = INT(MKT/QX%MBASE)
          MXY(1)%MP(4) = MKT - MXY(1)%MP(3)*QX%MBASE
          MXY(1)%MP(5) = 0
          MXY(1)%MP(1) = 1
          IF (IDIV < 0) MXY(1)%MP(1) = -1
      ELSE
          CALL IMI2M(IDIV,MXY(1),QX)
      ENDIF
      QX%NTRACE = NTRSAV
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMDVIR'
          CALL IMNTR(2,MA,MA,1,QX)
          CALL IMNTRI(2,IDIV,0,QX)
      ENDIF
      JDIV = ABS(IDIV)

!             Check for special cases.

      IF (MA%MP(2) < 0) THEN
          IREM = QX%IUNKNO
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMDVIR'
          CALL FMWARN(QX)
          CALL IMST2M('UNKNOWN',MB,QX)
          GO TO 150
      ENDIF
      IF (JDIV == 1 .AND. MA%MP(2) /= QX%MUNKNO) THEN
          IF (IDIV == 1) THEN
              CALL IMEQ(MA,MB,QX)
              IREM = 0
              GO TO 150
          ELSE
              CALL IMEQ(MA,MB,QX)
              IF (MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0)  &
                  MB%MP(1) = -MB%MP(1)
              IREM = 0
              GO TO 150
          ENDIF
      ENDIF
      IF (MA%MP(2) >= QX%MEXPOV .OR. IDIV == 0) THEN
          QX%KFLAG = -4
          IF (MA%MP(2) /= QX%MUNKNO) THEN
              QX%NAMEST(QX%NCALL) = 'IMDVIR'
              CALL FMWARN(QX)
          ENDIF
          CALL IMST2M('UNKNOWN',MB,QX)
          IREM = QX%IUNKNO
          GO TO 150
      ENDIF
      IF (MA%MP(2) <= 2) THEN
          IF (MA%MP(2) <= 1) THEN
              MDA = MA%MP(1) * MA%MP(3)
          ELSE
              MDA = MA%MP(1) * (MA%MP(3)*QX%MBASE + MA%MP(4))
          ENDIF
          MDB = IDIV
          MDAB = AINT (MDA/MDB)
          MDR = MDA - MDAB*MDB
          IF (ABS(MDAB) < QX%MBASE) THEN
              MB%MP(2) = 1
              IF (MDAB == 0) MB%MP(2) = 0
              IF (MDAB < 0) THEN
                  MB%MP(3) = -MDAB
                  MB%MP(1) = -1
              ELSE
                  MB%MP(3) = MDAB
                  MB%MP(1) = 1
              ENDIF
              MB%MP(4) = 0
          ELSE IF (ABS(MDAB) < QX%MBASE*QX%MBASE) THEN
              MB%MP(2) = 2
              IF (MDAB < 0) THEN
                  MB%MP(3) = AINT (-MDAB/QX%MBASE)
                  MB%MP(4) = ABS(-MDAB - QX%MBASE*MB%MP(3))
                  MB%MP(1) = -1
              ELSE
                  MB%MP(3) = AINT (MDAB/QX%MBASE)
                  MB%MP(4) = ABS(MDAB - QX%MBASE*MB%MP(3))
                  MB%MP(1) = 1
              ENDIF
          ELSE
              GO TO 110
          ENDIF
          IREM = INT(MDR)
          GO TO 150
      ENDIF

  110 MAS = MA%MP(1)
      MXY(1)%MP(1) = 1
      KL = MXY(1)%MP(2)
      IF (MA%MP(2) <= MXY(1)%MP(2)) THEN
          IF (MA%MP(2) == MXY(1)%MP(2) .AND.  &
              ABS(MA%MP(3)) <= MXY(1)%MP(3)) THEN
              DO J = 2, KL+1
                 IF (MA%MP(J+1) /= MXY(1)%MP(J+1)) THEN
                     IF (MA%MP(J+1) < MXY(1)%MP(J+1)) KLTFLG = 1
                     GO TO 120
                 ENDIF
              ENDDO
              KLTFLG = 2
          ENDIF
  120     IF (MA%MP(2) < MXY(1)%MP(2) .OR. KLTFLG >= 1) THEN
              IF (KLTFLG /= 2) THEN
                  CALL IMM2I(MA,IREM,QX)
                  IREM = ABS(IREM)
                  CALL IMI2M(0,MB,QX)
              ELSE
                  CALL IMI2M(1,MB,QX)
                  IREM = 0
              ENDIF
              GO TO 140
          ENDIF
      ENDIF
      QX%NDIG = INT(MA%MP(2))
      IF (QX%NDIG < 2) QX%NDIG = 2
      N1 = INT(MA%MP(2)) + 1

!             If ABS(IDIV) >= MXBASE use IMDIVR.

      MVALP = ABS(IDIV)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IDIV) > MXBASE .OR. NMVAL /= ABS(IDIV) .OR. NV2 /= ABS(IDIV)-1) THEN
          CALL IMI2M(IDIV,MXY(2),QX)
          CALL IMDIVR(MA,MXY(2),MXY(1),MXY(3),QX)
          CALL IMEQ(MXY(1),MB,QX)
          CALL IMEQ(MXY(3),MXY(2),QX)
          CALL IMM2I(MXY(2),IREM,QX)
          GO TO 150
      ENDIF

!             Find the first significant digit of the quotient.

      MKT = MA%MP(3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*QX%MBASE + MA%MP(J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO

      CALL IMM2I(MA,IREM,QX)
      CALL IMI2M(0,MB,QX)
      GO TO 150

!             Do the rest of the division.

  130 KA = KPT + 1
      MWA%MP(2) = MA%MP(2) + 2 - KPT
      MWA%MP(3) = INT (MKT/MVALP)
      MODINT = MKT - MWA%MP(3)*MVALP
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          DO J = KA+1, N1+1
             MKT = MODINT*QX%MBASE + MA%MP(J)
             MWA%MP(KL+J) = INT (MKT/MVALP)
             MODINT = MKT - MWA%MP(KL+J)*MVALP
          ENDDO
      ENDIF

      DO J = 1, INT(MWA%MP(2))+1
         MB%MP(J+1) = MWA%MP(J+1)
      ENDDO
      IREM = INT(MODINT)

  140 MB%MP(1) = 1
      IF (MAS < 0 .AND. IDIV > 0) THEN
          IF (MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0) MB%MP(1) = -1
          IREM = -IREM
      ELSE IF (MAS > 0 .AND. IDIV < 0)  THEN
          IF (MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0) MB%MP(1) = -1
      ELSE IF (MAS < 0 .AND. IDIV < 0)  THEN
          IREM = -IREM
      ENDIF

  150 IF (MB%MP(2) <= 1) MB%MP(4) = 0
      IF (QX%NTRACE /= 0 .AND. QX%NCALL <= QX%LVLTRC) THEN
          CALL IMNTR(1,MB,MB,1,QX)
          CALL IMNTRI(1,IREM,0,QX)
      ENDIF

      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMDVIR

      SUBROUTINE IMEQ(MA,MB,QX)

!  MB = MA

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,KDG
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: RESULT_SIZE

      RESULT_SIZE = MA%MP(2)+3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      KDG = MAX(2,INT(MA%MP(2))) + 2
      IF (KDG > SIZE(MA%MP)) KDG = 4
      DO J = 1, KDG
         MB%MP(J) = MA%MP(J)
      ENDDO
      RETURN
      END SUBROUTINE IMEQ

      SUBROUTINE IMFACT(N,MA,QX)

!  MA = N!   (N factorial)  N is a machine precision integer and MA is an IM number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: N
      INTENT (IN) :: N
      INTENT (INOUT) :: MA
      INTEGER :: J,K,NDSAVE,RESULT_SIZE
      TYPE(FM_SETTINGS) :: QX

      K = MAX(N,2)
      RESULT_SIZE = 10 + (LOG(2.0D0*QX%DPPI*K)/2 + K*LOG(DBLE(K)) - K) / QX%DLOGMB
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMFACT'
          CALL  IMNTRI(2,N,1,QX)
      ENDIF

!             Check for special cases.

      IF (N < 0) THEN
          CALL IMST2M('UNKNOWN',MA,QX)
          QX%KFLAG = -4
          GO TO 110
      ELSE IF (N <= 12) THEN
          K = 1
          DO J = 2, N
             K = K*J
          ENDDO
          CALL IMI2M(K,MA,QX)
          GO TO 110
      ENDIF

      CALL IMFACT_P(2,N,MA,QX)

  110 IF (MA%MP(2) <= 1) MA%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MA,MA,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMFACT

      RECURSIVE SUBROUTINE IMFACT_P(A,B,MP,QX)

!  This routine does the binary splitting for computing N!
!  MP = A * (A+1) * ... * B.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MP
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP
      TYPE(MULTI) :: MXY(2)
      INTEGER :: J,M,RESULT_SIZE
      REAL (KIND(0.0D0)) :: DA,DB,DLA,DLB
      TYPE(FM_SETTINGS) :: QX

      DA = A
      DB = B
      IF ((DB+0.5D0)*LOG(DB+1) > 1.0D+10) THEN
          RESULT_SIZE = (B-A+1)*LOG(DB) / QX%DLOGMB + 7 + QX%NGRD52
      ELSE
          IF (A >= 2) THEN
              DLA = (DA+0.5D0)*LOG(DA) - DA + 1/(12*(DA))
          ELSE
              DLA = 0
          ENDIF
          IF (B >= 2) THEN
              DLB = (DB+0.5D0)*LOG(DB) - DB + 1/(12*(DB))
          ELSE
              DLB = 0
          ENDIF
          RESULT_SIZE = ( DLB - DLA ) / QX%DLOGMB + 7 + QX%NGRD52
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      IF (B-A < 25) THEN
          CALL IMI2M(A,MP,QX)
          DO J = A+1, B-1, 2
             CALL IMMPYI(MP,J,MXY(1),QX)
             CALL IMMPYI(MXY(1),J+1,MP,QX)
          ENDDO
          IF (MOD(B-A,2) == 1) THEN
              CALL IMMPYI(MP,B,MXY(1),QX)
              CALL IMEQ(MXY(1),MP,QX)
          ENDIF
          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL IMFACT_P(A,M,MXY(1),QX)
      CALL IMFACT_P(M+1,B,MXY(2),QX)
      CALL IMMPY(MXY(1),MXY(2),MP,QX)

  110 RETURN
      END SUBROUTINE IMFACT_P

      SUBROUTINE IMFM2I(MA,MB,QX)

!  MB = INT(MA)

!  Convert from real (FM) format to integer (IM) format.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,NTRSAV,NDGSAV,RESULT_SIZE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)

      RESULT_SIZE = MAX(5,INT(MA%MP(2)+4))
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      QX%KFLAG = 0
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      NDGSAV = QX%NDIG
      IF (ABS(MA%MP(2)+3) >= QX%MEXPOV) THEN
          QX%NDIG = 2
          CALL FMEQ(MA,MB,QX)
          QX%NDIG = NDGSAV
      ELSE
          QX%NDIG = MIN(QX%NDIG,RESULT_SIZE-3)
          CALL FMINT(MA,MXY(1),QX)
          CALL FMEQ(MXY(1),MB,QX)
          QX%NDIG = NDGSAV
          DO J = QX%NDIG+2, INT(MA%MP(2))+1
             MB%MP(J+1) = 0
          ENDDO
          IF (MB%MP(2) <= 1) MB%MP(4) = 0
      ENDIF
      QX%NTRACE = NTRSAV
      QX%NCALL = QX%NCALL - 1

      RETURN
      END SUBROUTINE IMFM2I

      SUBROUTINE IMFORM(FORM,MA,STRING,QX)

!  Convert an IM number (MA) to a character string base 10 (STRING) using character string
!  FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: FORM,STRING
      TYPE(MULTI) :: MA
      INTEGER :: NDSAVE
      INTENT (IN) :: FORM,MA
      INTENT (INOUT) :: STRING
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMFORM   ',1,MA,MA,QX)
      QX%KFLAG = 0
      QX%NAMEST(QX%NCALL) = 'IMFORM'
      NDSAVE = QX%NDIG
      QX%NDIG = INT(MA%MP(2))
      IF (QX%NDIG < 2) QX%NDIG = 2
      IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2

      CALL FMFORM(FORM,MA,STRING,QX)

      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMFORM

      SUBROUTINE IMFPRT(FORM,MA,QX)

!  Print an IM number (MA) on unit KW using character string FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      TYPE(MULTI) :: MA
      INTEGER :: NDSAVE
      INTENT (IN) :: FORM,MA
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMFPRT   ',1,MA,MA,QX)
      QX%KFLAG = 0
      QX%NAMEST(QX%NCALL) = 'IMFPRT'
      NDSAVE = QX%NDIG
      QX%NDIG = INT(MA%MP(2))
      IF (QX%NDIG < 2) QX%NDIG = 2
      IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2

      CALL FMFPRT(FORM,MA,QX)

      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMFPRT

      SUBROUTINE IMGCD(MA,MB,MC,QX)

!  Lehmer's GCD algorithm for MC = GCD(MA,MB).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA, MB, MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: J, K
      DOUBLE PRECISION :: ABCD_MAX, DPBASE, A1, B1, C1, D1, Q1A, Q1B, T1, T2, T3, U1, V1
      CHARACTER(25) :: ST
      LOGICAL, EXTERNAL :: IMABS_GREATER_THAN
      TYPE(MULTI) :: MXY(4)
      INTEGER :: NDSAVE,RESULT_SIZE
      TYPE(FM_SETTINGS) :: QX

      RESULT_SIZE = MAX(MA%MP(2),MB%MP(2)) + 3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMGCD    ',2,MA,MB,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMGCD'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

!             Check for special cases.

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
          GO TO 110
      ELSE IF (MB%MP(3) == 0) THEN
          CALL IMABS(MA,MC,QX)
          GO TO 110
      ELSE IF (MA%MP(3) == 0) THEN
          CALL IMABS(MB,MC,QX)
          GO TO 110
      ELSE IF (MB%MP(2) == 1 .AND. ABS(MB%MP(3)) == 1) THEN
          CALL IMI2M(1,MC,QX)
          GO TO 110
      ELSE IF (MA%MP(2) == 1 .AND. ABS(MA%MP(3)) == 1) THEN
          CALL IMI2M(1,MC,QX)
          GO TO 110
      ELSE IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0 .OR.  &
          MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMGCD'
          CALL FMWARN(QX)
          CALL IMST2M('UNKNOWN',MC,QX)
          GO TO 110
      ENDIF

      CALL IMABS(MA,MXY(3),QX)
      CALL IMABS(MB,MXY(4),QX)
      IF (IMABS_GREATER_THAN(MXY(3),MXY(4))) THEN
          CALL IMEQ(MXY(3),MXY(1),QX)
          CALL IMEQ(MXY(4),MXY(2),QX)
      ELSE
          CALL IMEQ(MXY(4),MXY(1),QX)
          CALL IMEQ(MXY(3),MXY(2),QX)
      ENDIF

      IF (QX%MBASE < 1000) THEN
          CALL IMGCD2(MA,MB,MC,QX)
          GO TO 110
      ENDIF

      ABCD_MAX = (MAXINT / QX%MBASE) / 2
      DPBASE = QX%MBASE
      T1 = 1.0D-3 / EPSILON(1.0D0)
      CALL IMI2M(1,MXY(3),QX)
      T2 = DPBASE
      K = 1
      DO WHILE (T2 < T1)
         MXY(3)%MP(2) = MXY(3)%MP(2) + 1
         K = K + 1
         MXY(3)%MP(K+2) = 0
         T2 = T2 * DPBASE
      ENDDO
      MXY(3)%MP(3) = AINT( DPBASE * T1 / T2 )

!             MXY(1) >= MXY(2) > 0 during the algorithm.

      DO WHILE (IMABS_GREATER_THAN(MXY(1),MXY(3)))

         IF (MXY(1)%MP(2) == MXY(2)%MP(2)) THEN
             U1 = MXY(1)%MP(3)
             V1 = MXY(2)%MP(3)
             DO J = 2, INT(MXY(1)%MP(2))
                IF (U1 < MAXINT / (10 * DPBASE)) THEN
                    U1 = U1 * DPBASE + MXY(1)%MP(J+2)
                    V1 = V1 * DPBASE + MXY(2)%MP(J+2)
                ELSE
                    T1 = (MXY(1)%MP(J+2) + 1.0D-2) / DPBASE
                    T2 = (MXY(2)%MP(J+2) + 1.0D-2) / DPBASE
                    DO WHILE (U1 < MAXINT / 100)
                       T1 = T1 * 10
                       K = T1
                       T1 = T1 - K
                       U1 = U1 * 10 + K

                       T2 = T2 * 10
                       K = T2
                       T2 = T2 - K
                       V1 = V1 * 10 + K
                    ENDDO
                    EXIT
                ENDIF
             ENDDO
         ELSE IF (MXY(1)%MP(2) == MXY(2)%MP(2) + 1) THEN
             U1 = MXY(1)%MP(3)
             V1 = 0
             DO J = 2, INT(MXY(1)%MP(2))
                IF (U1 < MAXINT / (10 * DPBASE)) THEN
                    U1 = U1 * DPBASE + MXY(1)%MP(J+2)
                    V1 = V1 * DPBASE + MXY(2)%MP(J+1)
                ELSE
                    T1 = (MXY(1)%MP(J+2)   + 1.0D-2) / DPBASE
                    T2 = (MXY(2)%MP(J+1) + 1.0D-2) / DPBASE
                    DO WHILE (U1 < MAXINT / 100)
                       T1 = T1 * 10
                       K = T1
                       T1 = T1 - K
                       U1 = U1 * 10 + K

                       T2 = T2 * 10
                       K = T2
                       T2 = T2 - K
                       V1 = V1 * 10 + K
                    ENDDO
                    EXIT
                ENDIF
             ENDDO
         ELSE
             U1 = 1
             V1 = 0
         ENDIF

         A1 = 1
         B1 = 0
         C1 = 0
         D1 = 1
         Q1A = 0
         Q1B = 0

         DO WHILE (Q1A == Q1B)
            IF (V1 + C1 /= 0.0D0 .AND. V1 + D1 /= 0.0D0) THEN
                Q1A = AINT( (U1 + A1) / (V1 + C1) )
                Q1B = AINT( (U1 + B1) / (V1 + D1) )
                IF (Q1A == Q1B) THEN
                    T1 = A1 - Q1A*C1
                    T2 = B1 - Q1A*D1
                    T3 = U1 - Q1A*V1
                    IF (ABS(T1) > ABCD_MAX .OR. ABS(T2) > ABCD_MAX) THEN
                        EXIT
                    ELSE
                        A1 = C1
                        C1 = T1
                        B1 = D1
                        D1 = T2
                        U1 = V1
                        V1 = T3
                    ENDIF
                ENDIF
            ELSE
                EXIT
            ENDIF
         ENDDO

         IF (B1 == 0) THEN
             CALL IMMOD(MXY(1),MXY(2),MXY(4),QX)
             CALL IMEQ(MXY(2),MXY(1),QX)
             CALL IMEQ(MXY(4),MXY(2),QX)
             IF (MXY(2)%MP(3) == 0) THEN
                 CALL IMEQ(MXY(1),MC,QX)
                 GO TO 110
             ENDIF
         ELSE
             CALL IMGCD_REDUCE_UV(MXY(1), MXY(2), MXY(4), A1, B1, C1, D1,QX)
         ENDIF
      ENDDO

!             Finish the gcd using double precision.

      IF (MXY(2)%MP(3) == 0) THEN
          CALL IMEQ(MXY(1),MC,QX)
          GO TO 110
      ENDIF
      U1 = 0
      DO J = 1, INT(MXY(1)%MP(2))
         U1 = U1 * DPBASE + MXY(1)%MP(J+2)
      ENDDO
      V1 = 0
      DO J = 1, INT(MXY(2)%MP(2))
         V1 = V1 * DPBASE + MXY(2)%MP(J+2)
      ENDDO
      DO WHILE (V1 > 0)
         T1 = MOD(U1,V1)
         U1 = V1
         V1 = T1
      ENDDO
      IF (U1 < DPBASE) THEN
          MXY(1)%MP(2) = 1
          MXY(1)%MP(3) = U1
          MXY(1)%MP(4) = 0
      ELSE IF (U1 < DPBASE*DPBASE) THEN
          MXY(1)%MP(2) = 2
          MXY(1)%MP(3) = AINT(U1/DPBASE)
          MXY(1)%MP(4) = MOD(U1,DPBASE)
      ELSE
          IF (ABS(U1) < HUGE(1)) THEN
              K = U1
              CALL IMI2M(K,MXY(1),QX)
          ELSE
              WRITE (ST,'(E25.16)') U1
              CALL IMST2M(ST,MXY(1),QX)
          ENDIF
      ENDIF

      CALL IMEQ(MXY(1),MC,QX)

      IF (MC%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMGCD'
          CALL FMWARN(QX)
      ENDIF

  110 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMGCD

      SUBROUTINE IMGCD_REDUCE_UV(MU, MV, MV_SHIFT, A1, B1, C1, D1,QX)

!  Return  MU = A1 * MU + B1 * MV,
!  and     MV = C1 * MU + D1 * MV.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MU, MV, MV_SHIFT
      DOUBLE PRECISION :: A1, B1, C1, D1, U1, V1
      INTENT (INOUT) :: MU, MV
      INTENT (IN) :: A1, B1, C1, D1
      INTEGER :: J, K, N_U, N_V
      TYPE(FM_SETTINGS) :: QX

!             Do the operations.

      N_U = MU%MP(2)
      N_V = MV%MP(2)
      K = N_U - N_V
      IF (K == 0) THEN
          DO J = 3, N_U+2
             U1 = MU%MP(J)
             V1 = MV%MP(J)
             MU%MP(J-1) = A1 * U1 + B1 * V1
             MV%MP(J-1) = C1 * U1 + D1 * V1
          ENDDO
      ELSE
          DO J = 3, K+2
             MV_SHIFT%MP(J) = 0
          ENDDO
          DO J = 3, N_V+2
             MV_SHIFT%MP(J+K) = MV%MP(J)
          ENDDO
          N_V = N_U
          DO J = 3, N_U+2
             U1 = MU%MP(J)
             V1 = MV_SHIFT%MP(J)
             MU%MP(J-1) = A1 * U1 + B1 * V1
             MV%MP(J-1) = C1 * U1 + D1 * V1
          ENDDO
      ENDIF

!             Normalize the digits in MU and MV.

      DO J = N_U+1, 2, -1
         IF (MU%MP(J) < 0) THEN
             K = (-MU%MP(J)-1) / QX%MBASE + 1
             MU%MP(J) = MU%MP(J) + K * QX%MBASE
             MU%MP(J-1) = MU%MP(J-1) - K
         ELSE
             K = MU%MP(J) / QX%MBASE
             MU%MP(J) = MU%MP(J) - K * QX%MBASE
             MU%MP(J-1) = MU%MP(J-1) + K
         ENDIF
      ENDDO

      DO J = N_V+1, 2, -1
         IF (MV%MP(J) < 0) THEN
             K = (-MV%MP(J)-1) / QX%MBASE + 1
             MV%MP(J) = MV%MP(J) + K * QX%MBASE
             MV%MP(J-1) = MV%MP(J-1) - K
         ELSE
             K = MV%MP(J) / QX%MBASE
             MV%MP(J) = MV%MP(J) - K * QX%MBASE
             MV%MP(J-1) = MV%MP(J-1) + K
         ENDIF
      ENDDO

!             Normalize the numbers if there are leading zeros.

      IF (MU%MP(2) == 0) THEN
          MU%MP(2) = N_U - 1
      ELSE
          DO J = N_U+2, 3, -1
             MU%MP(J) = MU%MP(J-1)
          ENDDO
          MU%MP(2) = N_U
      ENDIF
      K = 0
      DO J = 3, N_U+2
         IF (MU%MP(J) == 0) THEN
             K = K + 1
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (K > 0) THEN
          MU%MP(2) = MU%MP(2) - K
          DO J = 3, INT(MU%MP(2))+2
             MU%MP(J) = MU%MP(J+K)
          ENDDO
          DO J = 0, K-1
             MU%MP(2+N_U-J) = 0
          ENDDO
      ENDIF

      IF (MV%MP(2) == 0) THEN
          MV%MP(2) = N_V - 1
      ELSE
          DO J = N_V+2, 3, -1
             MV%MP(J) = MV%MP(J-1)
          ENDDO
          MV%MP(2) = N_V
      ENDIF
      K = 0
      DO J = 3, N_V+2
         IF (MV%MP(J) == 0) THEN
             K = K + 1
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (K > 0) THEN
          MV%MP(2) = MV%MP(2) - K
          DO J = 3, INT(MV%MP(2))+2
             MV%MP(J) = MV%MP(J+K)
          ENDDO
          DO J = 0, K-1
             MV%MP(2+N_V-J) = 0
          ENDDO
      ENDIF

      END SUBROUTINE IMGCD_REDUCE_UV

      SUBROUTINE IMGCD2(MA,MB,MC,QX)

!  MC is returned as the greatest common divisor of MA and MB.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX

      RESULT_SIZE = MAX(MA%MP(2),MB%MP(2)) + 3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMGCD2   ',2,MA,MB,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMGCD2'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

!             Check for special cases.

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
          GO TO 120
      ELSE IF (MB%MP(3) == 0) THEN
          CALL IMABS(MA,MC,QX)
          GO TO 120
      ELSE IF (MA%MP(3) == 0) THEN
          CALL IMABS(MB,MC,QX)
          GO TO 120
      ELSE IF (MB%MP(2) == 1 .AND. ABS(MB%MP(3)) == 1) THEN
          CALL IMI2M(1,MC,QX)
          GO TO 120
      ELSE IF (MA%MP(2) == 1 .AND. ABS(MA%MP(3)) == 1) THEN
          CALL IMI2M(1,MC,QX)
          GO TO 120
      ELSE IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0 .OR.  &
          MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMGCD2'
          CALL FMWARN(QX)
          CALL IMST2M('UNKNOWN',MC,QX)
          GO TO 120
      ENDIF

      CALL IMABS(MA,MXY(3),QX)
      CALL IMABS(MB,MXY(2),QX)
      CALL IMMAX(MXY(3),MXY(2),MXY(1),QX)
      CALL IMMIN(MXY(3),MXY(2),MXY(4),QX)
      CALL IMEQ(MXY(4),MXY(2),QX)
  110 CALL IMDIVR(MXY(1),MXY(2),MXY(4),MXY(3),QX)
      IF (MXY(3)%MP(3) /= 0) THEN
          CALL IMEQ(MXY(2),MXY(1),QX)
          CALL IMEQ(MXY(3),MXY(2),QX)
          GO TO 110
      ENDIF
      CALL IMEQ(MXY(2),MC,QX)

      IF (MC%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMGCD2'
          CALL FMWARN(QX)
      ENDIF

  120 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMGCD2

      SUBROUTINE IMI2FM(MA,MB,QX)

!  MB = MA

!  Convert from integer (IM) format to real (FM) format.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: KDG
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMI2FM   ',1,MA,MA,QX)
      QX%KFLAG = 0
      KDG = MAX(2,INT(MA%MP(2)))
      IF (MA%MP(2) >= QX%MEXPOV) KDG = 2
      CALL FMEQU(MA,MB,KDG,QX%NDIG,QX)
      QX%NCALL = QX%NCALL - 1

      RETURN
      END SUBROUTINE IMI2FM

      SUBROUTINE IMI2M(IVAL,MA,QX)

!  MA = IVAL

!  This routine performs the trace printing.  IMI2M2 is used to do the conversion.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMI2M'
          CALL IMNTRI(2,IVAL,1,QX)

          CALL IMI2M2(IVAL,MA,QX)

          CALL IMNTR(1,MA,MA,1,QX)
      ELSE
          CALL IMI2M2(IVAL,MA,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMI2M

      SUBROUTINE IMI2M2(IVAL,MA,QX)

!  MA = IVAL

!  Convert a one word integer to IM format.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: IVAL
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: NDSAVE,RESULT_SIZE
      DOUBLE PRECISION :: DT
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (IVAL == 0) THEN
          QX%NDIG = 2
      ELSE
          DT = LOG(DBLE(ABS(IVAL)))/QX%DLOGMB + 2
          QX%NDIG = MAX(2,INT(DT))
      ENDIF
      RESULT_SIZE = QX%NDIG + 3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      CALL FMIM(IVAL,MA,QX)
      IF (MA%MP(2) <= 1) MA%MP(4) = 0
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMI2M2

      SUBROUTINE IMINP(LINE,MA,LA,LB,QX)

!  Convert an array of characters to multiple precision integer format.

!  LINE is an A1 character array of length LB to be converted to IM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.
!  LB is a pointer to the last character of the field for that number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: KFSAVE,NDSAVE,LA,LB
      CHARACTER :: LINE(LB)
      TYPE(MULTI) :: MA,MWI
      TYPE(FM_SETTINGS) :: QX
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA


      QX%NCALL = QX%NCALL + 1
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      QX%NAMEST(QX%NCALL) = 'IMINP'

      QX%NDIG = 50
      QX%NCALL = QX%NCALL - 1
      CALL FMINP(LINE,MWI,LA,LB,QX)
      QX%NCALL = QX%NCALL + 1
      IF (MWI%MP(2) > 50 .AND. ABS(MWI%MP(2)) < QX%MEXPOV) THEN
          QX%NDIG = MWI%MP(2) + 1
          QX%NCALL = QX%NCALL - 1
          CALL FMINP(LINE,MWI,LA,LB,QX)
          QX%NCALL = QX%NCALL + 1
      ENDIF
      KFSAVE = QX%KFLAG
      CALL IMFM2I(MWI,MA,QX)
      QX%KFLAG = KFSAVE

      IF (MA%MP(2) <= 1) MA%MP(4) = 0
      QX%NDIG = NDSAVE
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MA,MA,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMINP

      SUBROUTINE IMM2DP(MA,X,QX)

!  X = MA

!  Convert an IM number to double precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's double
!  precision number system, change the definition of DPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      DOUBLE PRECISION :: X
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KRESLT,ND2,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      QX%NCALL = QX%NCALL + 1
      QX%KFLAG = 0
      QX%NAMEST(QX%NCALL) = 'IMM2DP'
      KRESLT = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMARGS('IMM2DP   ',1,MA,MA,KRESLT,QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL IMNTR(2,MA,MA,1,QX)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.  Set X to some value that the user is likely
!             to recognize as wrong.

          X = DBLE(QX%RUNKNO)
          QX%KFLAG = -4
          IF (MA%MP(2) /= QX%MUNKNO) CALL FMWARN(QX)
          IF (QX%NTRACE /= 0) CALL IMNTRR(1,X,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      NDSAVE = QX%NDIG
      QX%NDIG = MAX(2,INT(MA%MP(2)))
      ND2 = 2 - LOG(EPSILON(1.0D0))/QX%DLOGMB
      IF (QX%NDIG >= ND2) QX%NDIG = ND2
      CALL FMMD(MA,X,QX)

      IF (QX%NTRACE /= 0) CALL IMNTRR(1,X,1,QX)
      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMM2DP

      SUBROUTINE IMM2I(MA,IVAL,QX)

!  IVAL = MA

!  Convert an IM number to a one word integer.

!  KFLAG =  0 is returned if the conversion is exact.
!        = -4 is returned if MA is larger than INTMAX in magnitude.  IVAL = IUNKNO is returned as
!             an indication that IVAL could not be computed without integer overflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: IVAL,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMM2I    ',1,MA,MA,QX)
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMM2I'
          CALL IMNTR(2,MA,MA,1,QX)
      ENDIF

      QX%NDIG = INT(MA%MP(2))
      IF (QX%NDIG < 2) QX%NDIG = 2
      IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2
      QX%KFLAG = 0
      CALL FMM2I(MA,IVAL,QX)

      IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
          CALL IMNTRI(1,IVAL,1,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMM2I

      SUBROUTINE IMM2SP(MA,X,QX)

!  X = MA

!  Convert an IM number to single precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's single
!  precision number system, change the definition of SPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      REAL :: X
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: Y
      INTEGER :: KRESLT,ND2,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      QX%NCALL = QX%NCALL + 1
      QX%KFLAG = 0
      QX%NAMEST(QX%NCALL) = 'IMM2SP'
      KRESLT = 0
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMARGS('IMM2SP   ',1,MA,MA,KRESLT,QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL IMNTR(2,MA,MA,1,QX)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.  Set X to some value that the user is likely
!             to recognize as wrong.

          X = QX%RUNKNO
          QX%KFLAG = -4
          IF (MA%MP(2) /= QX%MUNKNO) CALL FMWARN(QX)
          Y = X
          IF (QX%NTRACE /= 0) CALL IMNTRR(1,Y,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      NDSAVE = QX%NDIG
      QX%NDIG = MAX(2,INT(MA%MP(2)))
      ND2 = 2 - LOG(EPSILON(1.0D0))/QX%DLOGMB
      IF (QX%NDIG >= ND2) QX%NDIG = ND2
      CALL FMMD(MA,Y,QX)
      X = Y

      IF (QX%NTRACE /= 0) CALL IMNTRR(1,Y,1,QX)
      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMM2SP

      SUBROUTINE IMMAX(MA,MB,MC,QX)

!  MC = MAX(MA,MB)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMMAX    ',2,MA,MB,QX)
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMMAX'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
      ELSE IF (IMCOMP(MA,'<',MB,QX)) THEN
          CALL IMEQ(MB,MC,QX)
      ELSE
          CALL IMEQ(MA,MC,QX)
      ENDIF

      IF (MC%MP(2) <= 1) MC%MP(4) = 0
      QX%KWARN = KWRNSV
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMMAX

      SUBROUTINE IMMIN(MA,MB,MC,QX)

!  MC = MIN(MA,MB)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMMIN    ',2,MA,MB,QX)
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMMIN'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
      ELSE IF (IMCOMP(MA,'>',MB,QX)) THEN
          CALL IMEQ(MB,MC,QX)
      ELSE
          CALL IMEQ(MA,MC,QX)
      ENDIF

      IF (MC%MP(2) <= 1) MC%MP(4) = 0
      QX%KWARN = KWRNSV
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMMIN

      SUBROUTINE IMMOD(MA,MB,MC,QX)

!  MC = MOD(MA,MB)

!  Use IMDIVR if both INT(MA/MB) and MOD(MA,MB) are needed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      RESULT_SIZE = MIN(MA%MP(2),MB%MP(2)) + 3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMMOD    ',2,MA,MB,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMMOD'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
          GO TO 110
      ENDIF

      CALL IMDIVR(MA,MB,MXY(1),MXY(2),QX)
      CALL IMEQ(MXY(2),MC,QX)

      IF (MC%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMMOD'
          CALL FMWARN(QX)
      ENDIF

  110 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMMOD

      SUBROUTINE IMMODI(MA,IMOD,IREM,QX)

!  Internal routine to return integer IREM = mod( MA , IMOD ).
!  ABS(IMOD) should be less than MAXINT/MBASE for faster mod calculation.

!  MA is a multiple precision IM integer.
!  IMOD and IREM are one-word integers.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,T1,T2
      INTEGER :: IMOD,IREM,J,N
      TYPE(FM_SETTINGS) :: QX
      REAL (KIND(1.0D0)) :: MMOD, MREM

      MMOD = ABS(IMOD)
      N = MA%MP(2)

!             If abs(imod) is more than than MAXINT/MBASE, do it the hard way, since the
!             MBASE*MREM in the fast method could be too big to represent exactly in d.p.

      IF (MMOD >= MAXINT/QX%MBASE) THEN
          CALL IMI2M(ABS(IMOD),T1,QX)
          CALL IMMOD(MA,T1,T2,QX)
          CALL IMM2I(T2,IREM,QX)
      ELSE
          MREM = 0
          DO J = 3, N+2
             MREM = MOD( QX%MBASE*MREM + MA%MP(J) , MMOD )
          ENDDO
      ENDIF

      IREM = MREM
      IF (MA%MP(1) < 0) IREM = -IREM

      END SUBROUTINE IMMODI

      SUBROUTINE IMMPY(MA,MB,MC,QX)

!  MC = MA * MB

!  This routine performs the trace printing.  IMMPY2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMMPY'
          CALL IMNTR(2,MA,MB,2,QX)

          CALL IMMPY2(MA,MB,MC,QX)

          CALL IMNTR(1,MC,MC,1,QX)
      ELSE
          CALL IMMPY2(MA,MB,MC,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMMPY

      SUBROUTINE IMMPY2(MA,MB,MC,QX)

!  MC = MA * MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MDAB
      INTEGER :: NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      IF (MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MA%MP(2) + MB%MP(2) + 4
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      IF (QX%KDEBUG == 1) CALL IMARGS('IMMPY    ',2,MA,MB,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG

      IF (MA%MP(2) <= 1) THEN
          IF (MB%MP(2) > 1) GO TO 110
          MDAB = MA%MP(1) * MA%MP(3) * MB%MP(1) * MB%MP(3)
          IF (ABS(MDAB) < QX%MBASE) THEN
              MC%MP(2) = 1
              IF (MDAB == 0) MC%MP(2) = 0
              IF (MDAB >= 0) THEN
                  MC%MP(3) = MDAB
                  MC%MP(1) = 1
              ELSE
                  MC%MP(3) = -MDAB
                  MC%MP(1) = -1
              ENDIF
              MC%MP(4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < QX%MBASE*QX%MBASE) THEN
              MC%MP(2) = 2
              IF (MDAB >= 0) THEN
                  MC%MP(3) = AINT (MDAB/QX%MBASE)
                  MC%MP(4) = ABS(MDAB - QX%MBASE*MC%MP(3))
                  MC%MP(1) = 1
              ELSE
                  MC%MP(3) = AINT (-MDAB/QX%MBASE)
                  MC%MP(4) = ABS(-MDAB - QX%MBASE*MC%MP(3))
                  MC%MP(1) = -1
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          CALL IMI2M2(0,MC,QX)
          MC%MP(2) = QX%MUNKNO
          MC%MP(3) = 1
          GO TO 120
      ENDIF
      IF (MA%MP(3) == 0 .OR. MB%MP(3) == 0) THEN
          MC%MP(1) = 1
          MC%MP(2) = 0
          MC%MP(3) = 0
          MC%MP(4) = 0
          GO TO 120
      ENDIF
      IF (MA%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
          IF (MA%MP(1)*MB%MP(1) < 0) THEN
              CALL IMI2M2(-1,MC,QX)
              MC%MP(2) = QX%MEXPOV
              MC%MP(3) = 1
          ELSE
              CALL IMI2M2(1,MC,QX)
              MC%MP(2) = QX%MEXPOV
              MC%MP(3) = 1
          ENDIF
          GO TO 120
      ENDIF
      IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMMPY'
          CALL FMWARN(QX)
          CALL IMI2M2(0,MC,QX)
          MC%MP(2) = QX%MUNKNO
          MC%MP(3) = 1
          GO TO 120
      ENDIF
      IF (MB%MP(2) == 1 .AND. MB%MP(3) == 1 .AND. MB%MP(1) == 1) THEN
          CALL IMEQ(MA,MC,QX)
          GO TO 120
      ELSE IF (MB%MP(2) == 1 .AND. MB%MP(3) == 1 .AND. MB%MP(1) == -1) THEN
          CALL IMEQ(MA,MC,QX)
          IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0)  &
              MC%MP(1) = -MC%MP(1)
          GO TO 120
      ELSE IF (MA%MP(2) == 1 .AND. MA%MP(3) == 1 .AND. MA%MP(1) == 1) THEN
          CALL IMEQ(MB,MC,QX)
          GO TO 120
      ELSE IF (MA%MP(2) == 1 .AND. MA%MP(3) == 1 .AND. MA%MP(1) == -1) THEN
          CALL IMEQ(MB,MC,QX)
          IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0)  &
              MC%MP(1) = -MC%MP(1)
          GO TO 120
      ENDIF
      QX%NDIG = INT(MA%MP(2) + MB%MP(2))

      IF (QX%NDIG < 2) QX%NDIG = 2
      CALL IMMPY3(MA,MB,MWA,QX)

!             Transfer to MC and fix the sign of the result.

      QX%NDIG = MWA%MP(2)
      IF (QX%NDIG < 2) QX%NDIG = 2
      IF (MA%MP(1)*MB%MP(1) < 0) THEN
          CALL FMMOVE(MWA,MC,QX)
          MC%MP(1) = -1
      ELSE
          CALL FMMOVE(MWA,MC,QX)
          MC%MP(1) = 1
      ENDIF

  120 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMMPY2

      SUBROUTINE IMMPY3(MA,MB,MWA,QX)

!  Internal multiplication of MA*MB.  The result is returned in MWA.  Both MA and MB are positive.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAXMWA,MBJ,MBP1,MKT,MMAX
      INTEGER :: J,JM1,K,KB,KL,KLMA,KLMB,N1,ND,NMETHD,NZDA,NZDB,RESULT_SIZE
      TYPE(MULTI) :: MXY(2)
      INTENT (IN) :: MA,MB

      RESULT_SIZE = 2*(MA%MP(2)+MB%MP(2)) + 30
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)

      N1 = QX%NDIG + 1
      MWA%MP(2) = MA%MP(2) + MB%MP(2)
      MWA%MP(N1+2) = 0

!             Check for using an FFT-based method if precision is very high.

      ND = MAX(MA%MP(2),MB%MP(2))
      IF (LOG(7.0D0*ND/3.0D0) < LOG(7.0D3/3.0D0)*MIN(MA%MP(2),MB%MP(2))/1.0D3) THEN
          NZDA = INT(MA%MP(2))
          NZDB = INT(MB%MP(2))
          DO J = 2, INT(MB%MP(2))
             IF (MB%MP(J+2) == 0) NZDB = NZDB - 1
          ENDDO
          IF (REAL(NZDA)*NZDB < 65.0*ND*LOG(REAL(ND))) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          ND = QX%NDIG
          QX%NDIG = MAX(MA%MP(2),MB%MP(2))
          CALL IMI2FM(MA,MXY(1),QX)
          CALL IMI2FM(MB,MXY(2),QX)
          CALL FMMPYFFT(MXY(1),MXY(2),MWA,QX)
          QX%NDIG = ND
          RETURN
      ENDIF

!             The multiplication loop begins here.

!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = QX%MBASE + 1
      MMAX = INTMAX - QX%MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      MBJ = MB%MP(3)
      MWA%MP(3) = 0
      KLMA = INT(MA%MP(2))
      DO K = KLMA+3, N1
         MWA%MP(K+1) = 0
      ENDDO

!             (Inner Loop)

      DO K = 3, KLMA+2
         MWA%MP(K+1) = MA%MP(K)*MBJ
      ENDDO
      MAXMWA = MBJ
      IF (MAXMWA > MMAX) THEN
          MAXMWA = 0
          KL = KLMA + 1
          DO KB = KL+1, 3, -1
             MKT = INT (MWA%MP(KB+1)/QX%MBASE)
             MWA%MP(KB) = MWA%MP(KB) + MKT
             MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
          ENDDO
      ENDIF
      KLMB = INT(MB%MP(2))
      DO J = 3, KLMB+1
         MBJ = MB%MP(J+1)
         IF (MBJ /= 0) THEN
             MAXMWA = MAXMWA + MBJ
             JM1 = J - 1
             KL = KLMA + 1

!                       Major (Inner Loop)

             DO K = J+2, J+KLMA+1
                MWA%MP(K) = MWA%MP(K) + MA%MP(K-JM1)*MBJ
             ENDDO
         ENDIF

         IF (MAXMWA > MMAX) THEN
             MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

             DO KB = JM1+KL, JM1+2, -1
                MKT = INT (MWA%MP(KB+1)/QX%MBASE)
                MWA%MP(KB) = MWA%MP(KB) + MKT
                MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
             ENDDO
         ENDIF
      ENDDO

!             Perform the final normalization.  (Inner Loop)

      DO KB = N1+1, 4, -1
         MKT = INT (MWA%MP(KB)/QX%MBASE)
         MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
         MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
      ENDDO

      RETURN
      END SUBROUTINE IMMPY3

      SUBROUTINE IMMPYI(MA,IVAL,MB,QX)

!  MB = MA * IVAL

!  This routine performs the trace printing.  IMMPYI2 is used to do the arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMMPYI'
          CALL IMNTR(2,MA,MA,1,QX)
          CALL IMNTRI(2,IVAL,0,QX)

          CALL IMMPYI2(MA,IVAL,MB,QX)

          CALL IMNTR(1,MB,MB,1,QX)
      ELSE
          CALL IMMPYI2(MA,IVAL,MB,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMMPYI

      SUBROUTINE IMMPYI2(MA,IVAL,MB,QX)

!  MB = MA * IVAL

!  Multiplication by a one word integer.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MDAB,MKT,MVAL
      DOUBLE PRECISION :: DT
      INTEGER :: IVAL,J,KA,KB,KC,KSHIFT,N1,NDSAVE,NMVAL,NV2,RESULT_SIZE
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2)
      TYPE(FM_SETTINGS) :: QX

      DT = LOG(DBLE(ABS(IVAL)+1))/QX%DLOGMB + 1
      RESULT_SIZE = MA%MP(2) + DT + 4
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      RESULT_SIZE = 2*RESULT_SIZE + 30
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (QX%KDEBUG == 1) CALL IMARGS('IMMPYI   ',1,MA,MA,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      MAS = MA%MP(1)

      IF (MA%MP(2) <= 1) THEN
          MDAB = MA%MP(1) * MA%MP(3) * IVAL
          IF (ABS(MDAB) < QX%MBASE) THEN
              MB%MP(2) = 1
              IF (MDAB == 0) MB%MP(2) = 0
              MB%MP(1) = 1
              IF (MDAB < 0) MB%MP(1) = -1
              MB%MP(3) = ABS(MDAB)
              MB%MP(4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < QX%MBASE*QX%MBASE) THEN
              MB%MP(2) = 2
              MB%MP(1) = 1
              IF (MDAB < 0) MB%MP(1) = -1
              MDAB = ABS(MDAB)
              MB%MP(3) = AINT (MDAB/QX%MBASE)
              MB%MP(4) = MDAB - QX%MBASE*MB%MP(3)
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

      IF (MA%MP(2) < 0) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMMPYI'
          CALL FMWARN(QX)
          CALL IMI2M2(0,MB,QX)
          MB%MP(2) = QX%MUNKNO
          MB%MP(3) = 1
          GO TO 120
      ENDIF
      IF (MA%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          CALL IMI2M2(0,MB,QX)
          MB%MP(2) = QX%MUNKNO
          MB%MP(3) = 1
          GO TO 120
      ELSE IF (IVAL == 0) THEN
          CALL IMI2M2(0,MB,QX)
          GO TO 120
      ELSE IF (IVAL == 1) THEN
          CALL IMEQ(MA,MB,QX)
          GO TO 120
      ELSE IF (IVAL == -1) THEN
          CALL IMEQ(MA,MB,QX)
          IF (MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0)  &
              MB%MP(1) = -MB%MP(1)
          GO TO 120
      ELSE IF (MA%MP(2) == 1 .AND. MA%MP(3)*MA%MP(1) == 1) THEN
          CALL IMI2M2(IVAL,MB,QX)
          GO TO 120
      ELSE IF (MA%MP(2) == 1 .AND. MA%MP(3)*MA%MP(1) == -1) THEN
          CALL IMI2M2(IVAL,MB,QX)
          IF (MB%MP(2) /= QX%MUNKNO .AND. MB%MP(3) /= 0)  &
              MB%MP(1) = -MB%MP(1)
          GO TO 120
      ELSE IF (MA%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
          CALL IMI2M2(1,MB,QX)
          MB%MP(2) = QX%MEXPOV
          MB%MP(3) = 1
          GO TO 110
      ENDIF

!             Work with positive numbers.

      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1
      QX%NDIG = INT(MA%MP(2))
      IF (QX%NDIG < 2) QX%NDIG = 2
      N1 = QX%NDIG + 1

!             To leave room for normalization, shift the product to the right KSHIFT places in MWA.

      KSHIFT = INT((LOG(DBLE(MA%MP(3)+1)*DBLE(MVAL)))/QX%DLOGMB)

!             If IVAL is too big, use IMMPY2.

      IF (KSHIFT > QX%NDIG .OR. MVAL > MAXINT/QX%MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL IMI2M2(IVAL,MXY(1),QX)
          CALL IMMPY2(MA,MXY(1),MB,QX)
          GO TO 120
      ENDIF

      MWA%MP(2) = MA%MP(2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = QX%NDIG + 5
      DO J = KB, KC
         MWA%MP(J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MA%MP(J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/QX%MBASE)
         MWA%MP(J+1) = MKT - MCARRY*QX%MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/QX%MBASE)
         MWA%MP(J+1) = MCARRY - MKT*QX%MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWA%MP(3) or MWA%MP(4).

      IF (MWA%MP(3) == 0) THEN
          MB%MP(2) = MWA%MP(2) - 1
          DO J = 3, KB
             MB%MP(J) = MWA%MP(J+1)
          ENDDO
      ELSE
          MB%MP(2) = MWA%MP(2)
          DO J = 2, KB
             MB%MP(J+1) = MWA%MP(J+1)
          ENDDO
      ENDIF

!             Put the sign on the result.

  110 MB%MP(1) = 1
      IF ((IVAL > 0 .AND. MAS < 0) .OR. (IVAL < 0 .AND.MAS > 0)) MB%MP(1) = -1

  120 IF (MB%MP(2) <= 1) MB%MP(4) = 0
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMMPYI2

      SUBROUTINE IMMPYM(MA,MB,MC,MD,QX)

!  MD = MA * MB mod MC

!  This routine is slightly faster than calling IMMPY and IMMOD separately.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC,MD
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX
      REAL (KIND(1.0D0)) :: MAS,MAXMWA,MBP1,MBS,MC1,MCARRY,MDC,MDAB,MKT,MLMAX,MQD
      DOUBLE PRECISION :: XB,XBASE,XBR,XMWA
      INTEGER :: J,JB,JL,K,KA,KB,KL,KLTFLG,KPTMWA,N1,NA1,NC1,NDSAVE,NGUARD,NL,NMCWDS,NTRSAV
      INTEGER :: RESULT_SIZE
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TYPE(MULTI) :: MXY(3)

      RESULT_SIZE = MC%MP(2) + 4
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      RESULT_SIZE = 2*(MA%MP(2)+MB%MP(2)) + 30
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMMPYM   ',2,MA,MB,QX)
      NDSAVE = QX%NDIG
      QX%KFLAG = 0
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMMPYM'
          CALL IMNTR(2,MA,MB,2,QX)
          IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  QX%NDIG = MAX(2,INT(MC%MP(2)))
                  IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2
                  NTRSAV = QX%NTRACE
                  CALL IMNTRJ(MC,QX%NDIG,QX)
                  QX%NTRACE = NTRSAV
                  QX%NDIG = NDSAVE
              ELSE
                  CALL IMPRNT(MC,QX)
              ENDIF
          ENDIF
      ENDIF

      IF (MA%MP(2) <= 1) THEN
          IF (MB%MP(2) > 1) GO TO 110
          IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0) GO TO 110
          MDAB = MA%MP(1) * MA%MP(3) * MB%MP(1) * MB%MP(3)
          IF (MC%MP(2) <= 2) THEN
              IF (MC%MP(3) == 0) GO TO 110
              IF (MC%MP(2) <= 1) THEN
                  MDC = MC%MP(1) * MC%MP(3)
              ELSE
                  MDC = MC%MP(1) * (MC%MP(3)*QX%MBASE + MC%MP(4))
              ENDIF
              MDAB = MOD(MDAB,MDC)
          ENDIF
          IF (ABS(MDAB) < QX%MBASE) THEN
              MD%MP(2) = 1
              IF (MDAB == 0) MD%MP(2) = 0
              MD%MP(1) = 1
              IF (MDAB < 0) MD%MP(1) = -1
              MD%MP(3) = ABS(MDAB)
              MD%MP(4) = 0
              GO TO 160
          ELSE IF (ABS(MDAB) < QX%MBASE*QX%MBASE) THEN
              MD%MP(2) = 2
              MD%MP(1) = 1
              IF (MDAB < 0) MD%MP(1) = -1
              MDAB = ABS(MDAB)
              MD%MP(3) = AINT (MDAB/QX%MBASE)
              MD%MP(4) = MDAB - QX%MBASE*MD%MP(3)
              GO TO 160
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO .OR.  &
          MC%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          CALL IMST2M('UNKNOWN',MD,QX)
          GO TO 170
      ELSE IF (MC%MP(3) == 0 .OR. MA%MP(2) < 0 .OR. MB%MP(2) < 0 .OR.  &
               MC%MP(2) < 0 .OR. MA%MP(2) >= QX%MEXPOV .OR.            &
               MB%MP(2) >= QX%MEXPOV .OR. MC%MP(2) >= QX%MEXPOV) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMMPYM'
          CALL FMWARN(QX)
          CALL IMST2M('UNKNOWN',MD,QX)
          GO TO 170
      ELSE IF (MA%MP(3) == 0 .OR. MB%MP(3) == 0) THEN
          CALL IMI2M(0,MD,QX)
          GO TO 170
      ELSE IF (MC%MP(2) == 1 .AND. MC%MP(3) == 1) THEN
          CALL IMI2M(0,MD,QX)
          GO TO 170
      ELSE IF (MB%MP(2) == 1 .AND. MB%MP(3) == 1 .AND. MB%MP(1) == 1) THEN
          CALL IMMOD(MA,MC,MD,QX)
          GO TO 160
      ELSE IF (MB%MP(2) == 1 .AND. MB%MP(3) == 1 .AND. MB%MP(1) == -1) THEN
          CALL IMMOD(MA,MC,MD,QX)
          IF (MD%MP(2) /= QX%MUNKNO .AND. MD%MP(3) /= 0)  &
              MD%MP(1) = -MD%MP(1)
          GO TO 160
      ELSE IF (MA%MP(2) == 1 .AND. MA%MP(3) == 1 .AND. MA%MP(1) == 1) THEN
          CALL IMMOD(MB,MC,MD,QX)
          GO TO 160
      ELSE IF (MA%MP(2) == 1 .AND. MA%MP(3) == 1 .AND. MA%MP(1) == -1) THEN
          CALL IMMOD(MB,MC,MD,QX)
          IF (MD%MP(2) /= QX%MUNKNO .AND. MD%MP(3) /= 0)  &
              MD%MP(1) = -MD%MP(1)
          GO TO 160
      ENDIF

      QX%NDIG = INT(MA%MP(2) + MB%MP(2))
      IF (QX%NDIG < 2) QX%NDIG = 2

!             Check for using an FFT-based method if precision is very high.

      IF (QX%NDIG >= 1000) THEN
          CALL IMMPY(MA,MB,MXY(1),QX)
          CALL IMMOD(MXY(1),MC,MXY(2),QX)
          CALL IMEQ(MXY(2),MD,QX)
          GO TO 160
      ENDIF

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MA%MP(1)
      MBS = MB%MP(1)

      N1 = QX%NDIG + 1

!             It is faster if the second argument is the one with fewer digits.

      IF (MA%MP(2) < MB%MP(2)) THEN
          CALL IMMPY3(MB,MA,MWA,QX)
      ELSE
          CALL IMMPY3(MA,MB,MWA,QX)
      ENDIF

!             Now do the division to find MWA mod MC.

      KLTFLG = 0
      IF (MWA%MP(3) == 0) THEN
          MWA%MP(2) = MWA%MP(2) - 1
      ELSE
          DO J = N1, 2, -1
             MWA%MP(J+2) = MWA%MP(J+1)
          ENDDO
          MWA%MP(3) = 0
      ENDIF
      KL = INT(MC%MP(2))
      RESULT_SIZE = MAX(MA%MP(2),MB%MP(2),MC%MP(2)) + 4
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      DO J = 1, KL+2
         MXY(1)%MP(J) = MC%MP(J)
      ENDDO
      MXY(1)%MP(1) = 1
      IF (MWA%MP(2) == MXY(1)%MP(2) .AND.  &
          ABS(MWA%MP(4)) <= MXY(1)%MP(3)) THEN
          DO J = 4, N1+1
             MXY(2)%MP(J) = MWA%MP(J+1)
          ENDDO
          MXY(2)%MP(3) = ABS(MWA%MP(4))
          MXY(2)%MP(2) = MWA%MP(2)
          MXY(2)%MP(1) = 1
          IF (IMCOMP(MXY(2),'==',MXY(1),QX)) THEN
              KLTFLG = 2
          ELSE IF (IMCOMP(MXY(2),'<',MXY(1),QX)) THEN
              KLTFLG = 1
          ENDIF
      ENDIF
      IF (MWA%MP(2) < MC%MP(2) .OR. KLTFLG >= 1) THEN
          IF (KLTFLG /= 2) THEN
              DO J = 3, N1+1
                 MD%MP(J) = MWA%MP(J+1)
              ENDDO
              MD%MP(2) = MWA%MP(2)
          ELSE
              CALL IMI2M(0,MD,QX)
          ENDIF
          GO TO 150
      ENDIF

      QX%NDIG = INT(MWA%MP(2))
      IF (QX%NDIG < 2) QX%NDIG = 2

!             NGUARD is the number of guard digits used.

      NGUARD = 1
      NA1 = INT(MWA%MP(2)) + 1
      NC1 = INT(MC%MP(2)) + 1
      MWA%MP(2) = MWA%MP(2) - MC%MP(2) + 1
      NL = NA1 + NGUARD + 3
      DO J = NA1+2, NL
         MWA%MP(J+1) = 0
      ENDDO

!             Work only with positive numbers.

      MC1 = MC%MP(2)

!             NMCWDS is the number of words of MC used to compute the estimated quotient digit MQD.

      NMCWDS = 4
      IF (QX%MBASE < 100) NMCWDS = 7

!             XB is an approximation of MC used in estimating the quotient digits.

      XBASE = DBLE(QX%MBASE)
      XB = 0
      JL = NMCWDS
      IF (JL <= NC1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MC%MP(J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= NC1) THEN
                 XB = XB*XBASE + DBLE(MC%MP(J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= NC1) THEN
          XB = XB + DBLE(MC%MP(JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBP1 = QX%MBASE + 1
      MLMAX = MAXINT/MBP1
      MKT = INTMAX - QX%MBASE
      MLMAX = MIN(MLMAX,MKT)

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.
!             It is used to determine whether normalization can be postponed.

      MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  120 KL = KPTMWA + NMCWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWA%MP(KPTMWA+1))*XBASE + DBLE(MWA%MP(KPTMWA+2)))*XBASE  &
                 + DBLE(MWA%MP(KPTMWA+3)))*XBASE + DBLE(MWA%MP(KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWA%MP(KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = KA + INT(MC1) - 1
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWA%MP(J+1) < 0) THEN
                 MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
                 MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
                 MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
                 MWA%MP(J) = MWA%MP(J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWA%MP(J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MC from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          DO J = KA+1, KB+1
             MWA%MP(J) = MWA%MP(J) - MQD*MC%MP(J-JB)
          ENDDO
      ENDIF

      MWA%MP(KA+1) = MWA%MP(KA+1) + MWA%MP(KA)*QX%MBASE
      MWA%MP(KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA-2 < MWA%MP(2)) GO TO 120

!             Final normalization.

      KPTMWA = KPTMWA - 1
      DO J = KPTMWA, 3, -1
         IF (MWA%MP(J+1) < 0) THEN
             MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
             MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ENDIF
      ENDDO

  130 DO J = KPTMWA+INT(MC1), KPTMWA+2, -1
         IF (MWA%MP(J+1) < 0) THEN
             MCARRY = INT((-MWA%MP(J+1)-1)/QX%MBASE) + 1
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ELSE IF (MWA%MP(J+1) >= QX%MBASE) THEN
             MCARRY = -INT(MWA%MP(J+1)/QX%MBASE)
             MWA%MP(J+1) = MWA%MP(J+1) + MCARRY*QX%MBASE
             MWA%MP(J) = MWA%MP(J) - MCARRY
         ENDIF
      ENDDO

!             Due to rounding, the remainder may not be between 0 and ABS(MC) here.
!             Correct if necessary.

      IF (MWA%MP(KA+1) < 0) THEN
          DO J = KA, KB
             MWA%MP(J+1) = MWA%MP(J+1) + MC%MP(J-JB+1)
          ENDDO
          GO TO 130
      ELSE IF (MWA%MP(KA+1) >= QX%MBASE) THEN
          DO J = KA, KB
             MWA%MP(J+1) = MWA%MP(J+1) - MC%MP(J-JB+1)
          ENDDO
          GO TO 130
      ENDIF

      IF (MWA%MP(KPTMWA+2) /= 0) THEN
          DO J = 1, INT(MC1)
             MD%MP(J+2) = MWA%MP(J+KPTMWA+1)
          ENDDO
          MD%MP(2) = MC1
      ELSE
          DO J = 1, INT(MC1)
             IF (MWA%MP(J+KPTMWA+1) /= 0) THEN
                 DO K = J, INT(MC1)
                    MD%MP(K-J+3) = MWA%MP(K+KPTMWA+1)
                 ENDDO
                 MD%MP(2) = MC1 + 1 - J
                 GO TO 140
             ENDIF
          ENDDO
          MD%MP(2) = 0
          MD%MP(3) = 0
      ENDIF
  140 IF (MD%MP(2) <= 1) MD%MP(4) = 0

      IF (MD%MP(2) > MXY(1)%MP(2) .OR.    &
         (MD%MP(2) == MXY(1)%MP(2) .AND.  &
          ABS(MD%MP(3)) >= MXY(1)%MP(3))) THEN
          MD%MP(1) = 1
          IF (IMCOMP(MD,'>=',MXY(1),QX)) THEN
              CALL IMSUB(MD,MXY(1),MXY(3),QX)
              CALL IMEQ(MXY(3),MD,QX)
          ENDIF
      ENDIF

  150 MD%MP(1) = 1
      IF (MAS*MBS < 0) THEN
          IF (MD%MP(2) /= QX%MUNKNO .AND. MD%MP(3) /= 0)  &
              MD%MP(1) = -MD%MP(1)
      ENDIF

  160 IF (MD%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMMPYM'
          CALL FMWARN(QX)
      ENDIF

  170 IF (MD%MP(2) <= 1) MD%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MD,MD,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMMPYM

      SUBROUTINE IMNTR(NTR,MA,MB,NARG,QX)

!  Print IM numbers in base 10 format.  This is used for trace output from the IM routines.

!  NTR =  1 if a result of an IM call is to be printed.
!      =  2 to print input argument(s) to an IM call.

!  MA  -  the IM number to be printed.

!  MB  -  an optional second IM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be printed, and NARG = 2 if both
!         MA and MB are to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: NARG,NDSAVE,NTR,NTRSAV
      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MA,MB,NARG
      TYPE(FM_SETTINGS) :: QX

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = QX%NAMEST(QX%NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ELSE
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10)"                                            &
                    ) NAME,QX%NCALL,INT(QX%MBASE)
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%KFLAG
          ENDIF
      ENDIF

      NDSAVE = QX%NDIG
      IF (QX%NTRACE < 0) THEN
          QX%NDIG = MAX(2,INT(MA%MP(2)))
          IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2
          NTRSAV = QX%NTRACE
          CALL IMNTRJ(MA,QX%NDIG,QX)
          IF (NARG == 2) THEN
              QX%NDIG = MAX(2,INT(MB%MP(2)))
              IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2
              CALL IMNTRJ(MB,QX%NDIG,QX)
          ENDIF
          QX%NTRACE = NTRSAV
      ENDIF

      IF (QX%NTRACE > 0) THEN
          CALL IMPRNT(MA,QX)
          IF (NARG == 2) CALL IMPRNT(MB,QX)
      ENDIF

      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMNTR

      SUBROUTINE IMNTRI(NTR,N,KNAM,QX)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,"(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)")  &
                     NAME,QX%NCALL,INT(QX%MBASE)
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I20)") N

      RETURN
      END SUBROUTINE IMNTRI

      SUBROUTINE IMNTRJ(MA,ND,QX)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: ND
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(99) :: FORM
      INTEGER :: J,L,N
      INTENT (IN) :: MA,ND

      L = INT(LOG10(DBLE(QX%MBASE-1))) + 2
      N = (QX%KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,                                                       &
                 "(' (1X,I19,I',I2,',',I3,'I',I2,'/(22X,',I3,'I',I2,')) ')"  &
                ) L+2, N-1, L, N, L
      ENDIF
      IF (INT(MA%MP(2)) >= 2) THEN
          WRITE (KW,*) '            Sign = ',INT(MA%MP(1)),  &
                       '  Exponent = ',INT(MA%MP(2)),'  Digits:'
          WRITE (FORM,*) '(13X,', N, 'I', L, ')'
          WRITE (KW,FORM) (INT(MA%MP(J)),J=3,ND+2)
      ELSE
          WRITE (KW,*) '            Sign = ',INT(MA%MP(1)),  &
                       '  Exponent = ',INT(MA%MP(2)),'  Digits:'
          WRITE (FORM,*) '(13X,', N, 'I', L, ')'
          WRITE (KW,FORM) INT(MA%MP(3)),(0,J=4,ND+2)
      ENDIF

      RETURN
      END SUBROUTINE IMNTRJ

      SUBROUTINE IMNTRR(NTR,X,KNAM,QX)

!  Internal routine for trace output of real variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Double precision value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      DOUBLE PRECISION :: X
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,X,KNAM

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,"(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)") NAME,QX%NCALL,INT(QX%MBASE)
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,D30.20)") X

      RETURN
      END SUBROUTINE IMNTRR

      SUBROUTINE IMOUT(MA,LINE,LB,QX)

!  Convert an integer multiple precision number to a character array for output.

!  MA   is an IM number to be converted to an A1 character array in base 10 format.
!  LINE is the character(1) array in which the result is returned.
!  LB   is the length of LINE.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: JF1SAV,JF2SAV,LB,NDSAVE
      CHARACTER :: LINE(LB)
      TYPE(MULTI) :: MA
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMOUT    ',1,MA,MA,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      QX%NAMEST(QX%NCALL) = 'IMOUT'

      NDSAVE = QX%NDIG
      JF1SAV = QX%JFORM1
      JF2SAV = QX%JFORM2
      QX%JFORM1 = 2
      QX%JFORM2 = 0
      QX%NDIG = MAX(2,INT(MA%MP(2)))
      IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2
      CALL FMOUT(MA,LINE,LB,QX)

      QX%NDIG = NDSAVE
      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMOUT


      SUBROUTINE IMPMOD(MA,MB,MC,MD,QX)

!  MD = MOD(MA**MB,MC)

!  The binary multiplication method used requires an average of 1.5 * LOG2(MB) operations.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC,MD
      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: IREM,KWRNSV,NDSAVE,NTRSAV,RESULT_SIZE
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TYPE(MULTI) :: MXY(6)
      TYPE(FM_SETTINGS) :: QX

      RESULT_SIZE = MC%MP(2) + 3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMPMOD   ',2,MA,MB,QX)
      IF (QX%KDEBUG == 1) CALL IMARGS('IMPMOD   ',1,MC,MC,QX)
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMPMOD'
          CALL IMNTR(2,MA,MB,2,QX)
          IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  QX%NDIG = MAX(2,INT(MC%MP(2)))
                  IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2
                  NTRSAV = QX%NTRACE
                  CALL IMNTRJ(MC,QX%NDIG,QX)
                  QX%NTRACE = NTRSAV
                  QX%NDIG = NDSAVE
              ELSE
                  CALL IMPRNT(MC,QX)
              ENDIF
          ENDIF
      ENDIF
      MBS = MB%MP(1)

!             Check for special cases.

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO .OR.  &
          MC%MP(2) == QX%MUNKNO .OR. MA%MP(2) == QX%MEXPOV .OR.  &
          MB%MP(2) == QX%MEXPOV .OR. MC%MP(2) == QX%MEXPOV .OR.  &
          MA%MP(2) < 0 .OR. MB%MP(2) < 0 .OR. MC%MP(2) < 0 .OR.  &
          (MB%MP(1)*MB%MP(3) <= 0 .AND. MA%MP(3) == 0) .OR.      &
          MC%MP(3) == 0) THEN
          QX%KFLAG = -4
          IF (MA%MP(2) /= QX%MUNKNO .AND. MB%MP(2) /= QX%MUNKNO .AND.  &
              MC%MP(2) /=QX%MUNKNO) THEN
              QX%NAMEST(QX%NCALL) = 'IMPMOD'
              CALL FMWARN(QX)
          ENDIF
          CALL IMST2M('UNKNOWN',MD,QX)
          IF (QX%NTRACE /= 0) CALL IMNTR(1,MD,MD,1,QX)
          QX%NDIG = NDSAVE
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      IF (MB%MP(3) == 0) THEN
          CALL IMI2M(1,MD,QX)
          IF (QX%NTRACE /= 0) CALL IMNTR(1,MD,MD,1,QX)
          QX%NDIG = NDSAVE
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      IF (MB%MP(2) == 1 .AND. ABS(MB%MP(3)) == 1) THEN
          KWRNSV = QX%KWARN
          QX%KWARN = 0
          IF (MB%MP(1) == 1) THEN
              CALL IMMOD(MA,MC,MXY(6),QX)
          ELSE
              CALL IMI2M(1,MXY(2),QX)
              CALL IMDIVR(MXY(2),MA,MXY(1),MXY(3),QX)
              CALL IMMOD(MXY(1),MC,MXY(6),QX)
          ENDIF
          CALL IMEQ(MXY(6),MD,QX)
          IF (QX%NTRACE /= 0) CALL IMNTR(1,MD,MD,1,QX)
          QX%NDIG = NDSAVE
          QX%NCALL = QX%NCALL - 1
          QX%KWARN = KWRNSV
          RETURN
      ENDIF

      IF (MA%MP(3) == 0) THEN
          CALL IMI2M(0,MD,QX)
          IF (QX%NTRACE /= 0) CALL IMNTR(1,MD,MD,1,QX)
          QX%NDIG = NDSAVE
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

!             Initialize.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL IMABS(MB,MXY(3),QX)
      CALL IMDIVR(MA,MC,MXY(1),MXY(2),QX)
      CALL IMEQ(MC,MXY(1),QX)
      CALL IMDVIR(MXY(3),2,MXY(6),IREM,QX)
      IF (IREM == 0) THEN
          CALL IMI2M(1,MXY(6),QX)
      ELSE
          CALL IMEQ(MXY(2),MXY(6),QX)
      ENDIF
      CALL IMDVIR(MXY(3),2,MXY(4),IREM,QX)
      CALL IMEQ(MXY(4),MXY(3),QX)

!             This is the multiplication loop.

  110 CALL IMDVIR(MXY(3),2,MXY(4),IREM,QX)
      CALL IMEQ(MXY(4),MXY(3),QX)
      CALL IMMPYM(MXY(2),MXY(2),MXY(1),MXY(5),QX)
      CALL IMEQ(MXY(5),MXY(2),QX)
      IF (IREM == 1) THEN
          CALL IMMPYM(MXY(2),MXY(6),MXY(1),MXY(5),QX)
          CALL IMEQ(MXY(5),MXY(6),QX)
      ENDIF
      IF (MXY(3)%MP(3) > 0 .AND. MXY(6)%MP(3) /= 0) GO TO 110

      IF (MBS < 0) THEN
          CALL IMI2M(1,MXY(2),QX)
          QX%KREM = 0
          CALL IMDIVR(MXY(2),MXY(6),MXY(4),MXY(3),QX)
          QX%KREM = 1
          CALL IMEQ(MXY(4),MXY(6),QX)
      ENDIF
      QX%KWARN = KWRNSV
      CALL IMEQ(MXY(6),MD,QX)
      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMPMOD'
          CALL FMWARN(QX)
      ENDIF
      IF (MD%MP(2) <= 1) MD%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MD,MD,1,QX)
      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMPMOD

      SUBROUTINE IMPRNT(MA,QX)

!  Print MA in base 10 format.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: JF1SAV,JF2SAV,NDSAVE
      INTENT (IN) :: MA

      NDSAVE = QX%NDIG
      JF1SAV = QX%JFORM1
      JF2SAV = QX%JFORM2
      QX%JFORM1 = 2
      QX%JFORM2 = 0
      QX%NDIG = MAX(2,INT(MA%MP(2)))
      IF (ABS(MA%MP(2)) >= QX%MEXPOV) QX%NDIG = 2
      CALL FMPRNT(MA,QX)
      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMPRNT

      SUBROUTINE IMPWR(MA,MB,MC,QX)

!  MC = MA ** MB

!  The binary multiplication method used requires an average of 1.5 * LOG2(MB) multiplications.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MAS,MBS
      DOUBLE PRECISION :: DA,DB
      INTEGER :: IREM,IREMB,JSIGN,KOVFL,KWRNSV,RESULT_SIZE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(5)
      TYPE(FM_SETTINGS) :: QX

      IF ((MA%MP(2) == 1 .AND. MA%MP(3) == 1) .OR.  &
          MA%MP(3) == 0 .OR. MB%MP(3) == 0) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = 5
          KOVFL = 1
          KWRNSV = QX%KWARN
          QX%KWARN = 0
          CALL IMM2DP(MA,DA,QX)
          IF (QX%KFLAG == 0) THEN
              CALL IMM2DP(MB,DB,QX)
              IF (QX%KFLAG == 0) THEN
                  RESULT_SIZE = ABS(DB)*LOG(ABS(DA)+1)/QX%DLOGMB + 5
                  KOVFL = 0
                  IF (ABS(RESULT_SIZE) >= QX%MEXPOV) THEN
                      RESULT_SIZE = 5
                      KOVFL = 1
                  ENDIF
              ENDIF
          ELSE
              CALL IMM2DP(MB,DB,QX)
              IF (QX%KFLAG == 0) THEN
                  RESULT_SIZE = MIN(HUGE(1)/10.0D0,ABS(DB)*(ABS(MA%MP(2))+1) + 5)
                  KOVFL = 0
                  IF (ABS(RESULT_SIZE) >= QX%MEXPOV .OR. ABS(MA%MP(2)) >= QX%MEXPOV) THEN
                      RESULT_SIZE = 5
                      KOVFL = 1
                  ENDIF
              ENDIF
          ENDIF
          QX%KWARN = KWRNSV
      ENDIF
      IF (MB%MP(1) < 0 .AND. MA%MP(3) /= 0) THEN
          RESULT_SIZE = 5
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMPWR    ',2,MA,MB,QX)
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMPWR'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF
      MAS = MA%MP(1)
      MBS = MB%MP(1)
      KWRNSV = QX%KWARN

!             Check for special cases.

      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO .OR.    &
          MA%MP(2) < 0 .OR. MB%MP(2) < 0 .OR. ((MB%MP(1) < 0 .OR.  &
          MB%MP(3) == 0) .AND. MA%MP(3) == 0)) THEN
          QX%KFLAG = -4
          IF (MA%MP(2) /= QX%MUNKNO .AND. MB%MP(2) /= QX%MUNKNO) THEN
              QX%KWARN = KWRNSV
              QX%NAMEST(QX%NCALL) = 'IMPWR'
              CALL FMWARN(QX)
          ENDIF
          CALL IMST2M('UNKNOWN',MC,QX)
          GO TO 130
      ENDIF

      IF (MB%MP(3) == 0) THEN
          CALL IMI2M(1,MC,QX)
          GO TO 130
      ENDIF

      IF (MA%MP(2) == 1 .AND. MA%MP(3) == 1) THEN
          QX%KWARN = 0
          IF (MAS == 1) THEN
              CALL IMI2M(1,MC,QX)
          ELSE
              CALL IMI2M(2,MXY(1),QX)
              CALL IMDIVR(MB,MXY(1),MXY(4),MXY(2),QX)
              CALL IMEQ(MXY(4),MXY(1),QX)
              IF (MXY(2)%MP(2) == QX%MUNKNO) THEN
                  QX%KFLAG = -4
                  QX%KWARN = KWRNSV
                  QX%NAMEST(QX%NCALL) = 'IMPWR'
                  CALL FMWARN(QX)
                  CALL IMST2M('UNKNOWN',MC,QX)
              ELSE IF (MXY(2)%MP(3) == 0) THEN
                  CALL IMI2M(1,MC,QX)
              ELSE
                  CALL IMI2M(-1,MC,QX)
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

      IF (MB%MP(2) == 1 .AND. MB%MP(3) == 1) THEN
          QX%KWARN = 0
          IF (MBS == 1) THEN
              CALL IMEQ(MA,MC,QX)
          ELSE
              CALL IMI2M(1,MXY(1),QX)
              QX%KREM = 0
              CALL IMDIVR(MXY(1),MA,MXY(3),MXY(2),QX)
              CALL IMEQ(MXY(3),MC,QX)
              QX%KREM = 1
          ENDIF
          GO TO 130
      ENDIF

      IF (MA%MP(3) == 0) THEN
          CALL IMI2M(0,MC,QX)
          GO TO 130
      ENDIF

      IF (MB%MP(1) < 0) THEN
          CALL IMI2M(0,MC,QX)
          GO TO 130
      ENDIF

      IF (MB%MP(2) == QX%MEXPOV) THEN
          IF (MBS < 0) THEN
              CALL IMI2M(0,MC,QX)
          ELSE IF (MAS > 0) THEN
              CALL IMST2M('OVERFLOW',MC,QX)
              QX%KFLAG = -5
          ELSE
              QX%KFLAG = -4
              QX%KWARN = KWRNSV
              QX%NAMEST(QX%NCALL) = 'IMPWR'
              CALL FMWARN(QX)
              CALL IMST2M('UNKNOWN',MC,QX)
          ENDIF
          GO TO 130
      ENDIF

      IF (MA%MP(2) == QX%MEXPOV) THEN
          JSIGN = 1
          IF (MA%MP(1) < 0) JSIGN = -1
          IF (MBS > 0) THEN
              CALL IMDVIR(MB,2,MXY(1),IREM,QX)
              CALL IMST2M('OVERFLOW',MC,QX)
              MC%MP(1) = JSIGN**IREM
              QX%KFLAG = -5
          ELSE
              CALL IMI2M(0,MC,QX)
          ENDIF
          GO TO 130
      ENDIF

      IF (KOVFL == 1) THEN
          IF (MBS <= 0) THEN
              CALL IMI2M(0,MC,QX)
          ELSE IF (MA%MP(1) >= 0) THEN
              CALL IMST2M('OVERFLOW',MC,QX)
              QX%KFLAG = -5
              QX%KWARN = KWRNSV
              QX%NAMEST(QX%NCALL) = 'IMPWR'
              CALL FMWARN(QX)
          ELSE
              CALL IMDVIR(MB,2,MXY(1),IREM,QX)
              CALL IMST2M('OVERFLOW',MC,QX)
              MC%MP(1) = (-1)**IREM
              QX%KFLAG = -5
              QX%KWARN = KWRNSV
              QX%NAMEST(QX%NCALL) = 'IMPWR'
              CALL FMWARN(QX)
          ENDIF
          GO TO 130
      ENDIF

!             Initialize.

      QX%KWARN = 0
      CALL IMABS(MB,MXY(2),QX)

      CALL IMEQ(MA,MXY(1),QX)

      CALL IMDVIR(MB,2,MXY(4),IREMB,QX)
      CALL IMEQ(MXY(4),MC,QX)
      IF (IREMB == 0) THEN
          CALL IMI2M(1,MC,QX)
      ELSE
          CALL IMEQ(MXY(1),MC,QX)
      ENDIF
      CALL IMDVIR(MXY(2),2,MXY(4),IREM,QX)
      CALL IMEQ(MXY(4),MXY(2),QX)

!             This is the multiplication loop.

  110 CALL IMDVIR(MXY(2),2,MXY(4),IREM,QX)
      CALL IMEQ(MXY(4),MXY(2),QX)
      CALL IMSQR(MXY(1),MXY(5),QX)
      CALL IMEQ(MXY(5),MXY(1),QX)
      IF (IREM == 1) THEN
          CALL IMMPY(MXY(1),MC,MXY(3),QX)
          CALL IMEQ(MXY(3),MC,QX)
      ENDIF
      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL IMEQ(MXY(1),MC,QX)
          IF (MAS < 0 .AND. IREMB == 1) MC%MP(1) = -1
          GO TO 120
      ENDIF
      IF (MXY(2)%MP(3) > 0) GO TO 110

  120 IF (MBS < 0) THEN
          CALL IMI2M(1,MXY(1),QX)
          QX%KREM = 0
          CALL IMDIVR(MXY(1),MC,MXY(4),MXY(2),QX)
          QX%KREM = 1
          CALL IMEQ(MXY(4),MC,QX)
      ENDIF

      IF (MC%MP(2) >= QX%MEXPOV) THEN
          IF (QX%NCALL == 1 .OR. MC%MP(2) >= QX%MEXPOV) THEN
              IF (MC%MP(1) > 0) THEN
                  CALL IMST2M('OVERFLOW',MC,QX)
              ELSE
                  CALL IMST2M('-OVERFLOW',MC,QX)
              ENDIF
              QX%KFLAG = -5
              QX%KWARN = KWRNSV
              QX%NAMEST(QX%NCALL) = 'IMPWR'
              CALL FMWARN(QX)
          ENDIF
      ENDIF

  130 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      QX%KWARN = KWRNSV
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMPWR'
          CALL IMNTR(1,MC,MC,1,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMPWR

      SUBROUTINE IMREAD(KREAD,MA,QX)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      INTEGER :: KREAD
      CHARACTER :: CMBUFF(LMBUFF)
      TYPE(FM_SETTINGS) :: QX

      CHARACTER :: LINE(132)
      INTEGER :: J,LB
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'IMREAD'
      LB = 0

  110 READ (KREAD,"(132A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 132
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFF) THEN
                 WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                     '  Raise its size or change the format being used.'
                 STOP
             ENDIF
             CMBUFF(LB) = LINE(J)
         ENDIF
      ENDDO

      CALL IMINP(CMBUFF,MA,1,LB,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN

!             If there is an error, return UNKNOWN.

  120 QX%KFLAG = -4
      CALL FMWARN(QX)
      CALL FMST2M('UNKNOWN',MA,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMREAD

      SUBROUTINE IMSIGN(MA,MB,MC,QX)

!  MC = SIGN(MA,MB)

!  MC is set to ABS(MA) if MB is positive or zero, or -ABS(MA) if MB is negative.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KWRNSV,NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      RESULT_SIZE = MA%MP(2) + 3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMSIGN   ',2,MA,MB,QX)
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMSIGN'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      QX%NDIG = INT(MA%MP(2))
      IF (QX%NDIG < 2) QX%NDIG = 2
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC,QX)
          QX%KFLAG = -4
      ELSE IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMSIGN'
          CALL FMWARN(QX)
          CALL IMST2M('UNKNOWN',MC,QX)
      ELSE IF (MB%MP(1) >= 0) THEN
          CALL IMEQ(MA,MC,QX)
          MC%MP(1) = 1
      ELSE
          CALL IMEQ(MA,MC,QX)
          IF (MC%MP(2) /= QX%MUNKNO .AND. MC%MP(3) /= 0) MC%MP(1) = -1
      ENDIF

      IF (MC%MP(2) <= 1) MC%MP(4) = 0
      QX%KWARN = KWRNSV
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMSIGN

      SUBROUTINE IMSQR(MA,MB,QX)

!  MB = MA * MA

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MDAB
      INTEGER :: NDSAVE,RESULT_SIZE
      RESULT_SIZE = 2*MA%MP(2) + 4
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMSQR    ',1,MA,MA,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMSQR'
          CALL IMNTR(2,MA,MA,1,QX)
      ENDIF

      IF (MA%MP(2) <= 1) THEN
          IF (MA%MP(2) < 0) GO TO 110
          MDAB = MA%MP(3) * MA%MP(3)
          IF (ABS(MDAB) < QX%MBASE) THEN
              MB%MP(2) = 1
              IF (MDAB == 0) MB%MP(2) = 0
              MB%MP(3) = MDAB
              MB%MP(4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < QX%MBASE*QX%MBASE) THEN
              MB%MP(2) = 2
              MB%MP(3) = AINT (MDAB/QX%MBASE)
              MB%MP(4) = MDAB - QX%MBASE*MB%MP(3)
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MA%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          CALL IMST2M('UNKNOWN',MB,QX)
          GO TO 120
      ENDIF
      IF (MA%MP(3) == 0) THEN
          MB%MP(1) = 1
          MB%MP(2) = 0
          MB%MP(3) = 0
          MB%MP(4) = 0
          GO TO 120
      ENDIF
      IF (MA%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
          CALL IMST2M('OVERFLOW',MB,QX)
          GO TO 120
      ENDIF
      IF (MA%MP(2) == 1 .AND. ABS(MA%MP(3)) == 1) THEN
          CALL IMI2M(1,MB,QX)
          GO TO 120
      ELSE IF (MA%MP(2) < 0) THEN
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMSQR'
          CALL FMWARN(QX)
          CALL IMST2M('UNKNOWN',MB,QX)
          GO TO 120
      ENDIF

      QX%NDIG = INT(MA%MP(2) + MA%MP(2))

      IF (QX%NDIG < 2) QX%NDIG = 2

      CALL IMSQR2(MA,MB,QX)

  120 IF (MB%MP(2) <= 1) MB%MP(4) = 0
      MB%MP(1) = 1
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMSQR

      SUBROUTINE IMSQR2(MA,MB,QX)

!  MB = MA*MA.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(WORK_AREA) :: MWA
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAXMAX,MAXMWA,MBJ,MBKJ,MBNORM,MBP1,MK,MKA,MKT,MMAX,MT
      INTEGER :: J,JM1,K,KB,KI,KJ,KL,KNZ,KOVUN,KWA,L,N1,ND,NMETHD,NZDA,RESULT_SIZE
      TYPE(MULTI) :: MXY(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      RESULT_SIZE = 2*MA%MP(2) + 30
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)

!             KSQR is used to tell FMMPYFFT that only one input fft is needed.

      QX%KSQR = 1
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (QX%KDEBUG == 1 .OR. QX%MBASE*QX%MBASE <= MXBASE/(4*QX%MBASE)) THEN
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          IF (MA%MP(2) == QX%MUNKNO) KOVUN = 2
          QX%NCALL = QX%NCALL + 1
          CALL IMMPY(MA,MA,MB,QX)
          QX%NCALL = QX%NCALL - 1
          IF ((QX%KFLAG < 0 .AND. KOVUN == 0) .OR. (QX%KFLAG == -4 .AND. KOVUN == 1)) THEN
              QX%NAMEST(QX%NCALL) = 'IMSQR'
              CALL FMWARN(QX)
          ENDIF
          GO TO 130
      ELSE IF (MA%MP(3) == 0) THEN
          CALL IMEQ(MA,MB,QX)
          GO TO 130
      ENDIF
      QX%KFLAG = 0
      MAXMAX = 0
      N1 = INT(MA%MP(2)) + 1
      MWA%MP(2) = MA%MP(2) + MA%MP(2)

!             Check for using an FFT-based method if precision is very high.

      ND = 1000
      IF (QX%NDIG >= ND) THEN
          NZDA = 0
          DO J = 2, INT(MA%MP(2))
             IF (MA%MP(J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (MA%MP(2)-NZDA < 50 .OR. REAL(NZDA)/MA%MP(2) > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          ND = QX%NDIG
          QX%NDIG = MA%MP(2)
          CALL IMI2FM(MA,MXY(1),QX)
          CALL IMI2FM(MA,MXY(2),QX)
          CALL FMMPYFFT(MXY(1),MXY(2),MWA,QX)
          QX%NDIG = ND
          GO TO 120
      ENDIF

      L = N1 + INT(MA%MP(2))
      MWA%MP(L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBP1 = QX%MBASE + 1
      MBNORM = (MAXINT/(MBP1*MBP1))
      MMAX = INTMAX - QX%MBASE
      MMAX = MIN((MAXINT/MBP1 - MBP1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MA%MP(3)

!             Count the trailing zeros in MA.

          IF (MA%MP(N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = INT(MA%MP(2)), 2, -1
                 IF (MA%MP(J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWA%MP(3) = 0
          MWA%MP(4) = 0
          DO K = N1+1, L
             MWA%MP(K+1) = 0
          ENDDO

!             (Inner Loop)

          DO K = 4, N1+1
             MWA%MP(K+1) = MA%MP(K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, N1
             MBJ = MA%MP(J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 DO K = 2*J+1, JM1+KL+1
                    MWA%MP(K) = MWA%MP(K) + MA%MP(K-JM1)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWA%MP(KB+1)/QX%MBASE)
                    MWA%MP(KB) = MWA%MP(KB) + MKT
                    MWA%MP(KB+1) = MWA%MP(KB+1) - MKT*QX%MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          IF (2*MAX(MAXMAX,MAXMWA)+QX%MBASE > MMAX) THEN
              DO KB = L+1, 5, -1
                 MKT = INT (MWA%MP(KB)/QX%MBASE)
                 MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
                 MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
              ENDDO
          ENDIF

          DO J = 4, L, 2
             IF (J/2 <= N1) THEN
                 MKA = MA%MP(1+J/2)
                 MWA%MP(J) = 2*MWA%MP(J) + MKA*MKA
                 MWA%MP(J+1) = 2*MWA%MP(J+1)
             ELSE
                 MWA%MP(J) = 2*MWA%MP(J)
                 MWA%MP(J+1) = 2*MWA%MP(J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MA%MP(1+(L+1)/2)
                  MWA%MP(L+1) = 2*MWA%MP(L+1) + MKA*MKA
              ELSE
                  MWA%MP(L+1) = 2*MWA%MP(L+1)
              ENDIF
          ENDIF

          DO KB = L+1, 4, -1
             MKT = INT (MWA%MP(KB)/QX%MBASE)
             MWA%MP(KB-1) = MWA%MP(KB-1) + MKT
             MWA%MP(KB) = MWA%MP(KB) - MKT*QX%MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize
!             as the digits are multiplied.

          DO J = 2, L
             MWA%MP(J+1) = 0
          ENDDO
          KJ = MA%MP(2) + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MA%MP(KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MA%MP(KI-K+1)*MBKJ + MWA%MP(KWA-K+1) + MK
                MK = INT (MT/QX%MBASE)
                MWA%MP(KWA-K+1) = MT - QX%MBASE*MK
             ENDDO
             MWA%MP(KWA-KL) = MK
          ENDDO

      ENDIF

!             The multiplication is complete.

  120 QX%NDIG = MWA%MP(2)
      IF (QX%NDIG < 2) QX%NDIG = 2
      CALL FMMOVE(MWA,MB,QX)

      IF (QX%KFLAG < 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMSQR'
          CALL FMWARN(QX)
      ENDIF

  130 MB%MP(1) = 1
      QX%KSQR = 0
      RETURN
      END SUBROUTINE IMSQR2

      SUBROUTINE IMST2M(STRING,MA,QX)

!  MA = STRING

!  Convert a character string to IM format.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFF(LMBUFF)
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'IMST2M'
      LB = LEN(STRING)
      IF (LB > LMBUFF) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF
      KFSAVE = QX%KFLAG

      DO J = 1, LB
         CMBUFF(J) = STRING(J:J)
      ENDDO

      CALL IMINP(CMBUFF,MA,1,LB,QX)

      IF (MA%MP(2) <= 1) MA%MP(4) = 0
      IF (KFSAVE /= 0) QX%KFLAG = KFSAVE
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMST2M

      SUBROUTINE IMSUB(MA,MB,MC,QX)

!  MC = MA - MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB
      INTEGER :: NDSAVE,RESULT_SIZE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      RESULT_SIZE = MAX(MA%MP(2),MB%MP(2)) + 4
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMSUB    ',2,MA,MB,QX)
      QX%KFLAG = 0
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          QX%NAMEST(QX%NCALL) = 'IMSUB'
          CALL IMNTR(2,MA,MB,2,QX)
      ENDIF

      IF (MA%MP(2) <= 2) THEN
          IF (MB%MP(2) > 2 .OR. MA%MP(2) < 0 .OR. MB%MP(2) < 0) GO TO 110
          IF (MA%MP(2) <= 1) THEN
              MDA = MA%MP(1) * MA%MP(3)
          ELSE
              MDA = MA%MP(1) * (MA%MP(3)*QX%MBASE + MA%MP(4))
          ENDIF
          IF (MB%MP(2) <= 1) THEN
              MDB = MB%MP(1) * MB%MP(3)
          ELSE
              MDB = MB%MP(1) * (MB%MP(3)*QX%MBASE + MB%MP(4))
          ENDIF
          MDAB = MDA - MDB
          IF (ABS(MDAB) < QX%MBASE) THEN
              MC%MP(2) = 1
              IF (MDAB == 0) MC%MP(2) = 0
              MC%MP(1) = 1
              IF (MDAB < 0) MC%MP(1) = -1
              MC%MP(3) = ABS(MDAB)
              MC%MP(4) = 0
              IF (MDA == 0 .OR. MDB == 0) QX%KFLAG = 1
              GO TO 120
          ELSE IF (ABS(MDAB) < QX%MBASE*QX%MBASE) THEN
              MC%MP(2) = 2
              MC%MP(1) = 1
              IF (MDAB < 0) MC%MP(1) = -1
              MDAB = ABS(MDAB)
              MC%MP(3) = AINT (MDAB/QX%MBASE)
              MC%MP(4) = MDAB - QX%MBASE*MC%MP(3)
              IF (MDA == 0 .OR. MDB == 0) QX%KFLAG = 1
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MA%MP(2) < 0 .OR. MB%MP(2) < 0 .OR.  &
          MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
          IF (MA%MP(2) == QX%MUNKNO .OR. MB%MP(2) == QX%MUNKNO) THEN
              CALL IMST2M('UNKNOWN',MC,QX)
              QX%KFLAG = -4
              GO TO 120
          ENDIF
          IF (MA%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1) == -MB%MP(1) .OR. MB%MP(3) == 0) THEN
                  MC%MP(1) = MA%MP(1)
                  MC%MP(2) = MA%MP(2)
                  MC%MP(3) = MA%MP(3)
                  MC%MP(4) = MA%MP(4)
                  QX%KFLAG = -5
                  GO TO 120
              ELSE
                  QX%KFLAG = -4
                  QX%NAMEST(QX%NCALL) = 'IMSUB'
                  CALL FMWARN(QX)
                  CALL IMST2M('UNKNOWN',MC,QX)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MB%MP(2) == QX%MEXPOV) THEN
              IF (-MB%MP(1) == MA%MP(1) .OR. MA%MP(3) == 0) THEN
                  MC%MP(1) = -MB%MP(1)
                  MC%MP(2) = MB%MP(2)
                  MC%MP(3) = MB%MP(3)
                  MC%MP(4) = MB%MP(4)
                  QX%KFLAG = -5
                  GO TO 120
              ELSE
                  QX%KFLAG = -4
                  QX%NAMEST(QX%NCALL) = 'IMSUB'
                  CALL FMWARN(QX)
                  CALL IMST2M('UNKNOWN',MC,QX)
                  GO TO 120
              ENDIF
          ENDIF
          QX%KFLAG = -4
          QX%NAMEST(QX%NCALL) = 'IMSUB'
          CALL FMWARN(QX)
          CALL IMST2M('UNKNOWN',MC,QX)
          GO TO 120
      ENDIF

!             IMADD3 will negate MB and add.

      QX%KSUB = 1
      CALL IMADD3(MA,MB,MC,QX)
      QX%KSUB = 0

  120 IF (MC%MP(2) <= 1) MC%MP(4) = 0
      IF (QX%NTRACE /= 0) CALL IMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMSUB

      SUBROUTINE IMUNPK(MP,MA,QX)

!  MP is unpacked and the value returned in MA.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MP
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,KP,KMA1,RESULT_SIZE
      INTENT (IN) :: MP
      INTENT (INOUT) :: MA

      RESULT_SIZE = MP%MP(2) + 3
      IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)

      KMA1 = INT(MP%MP(2))
      IF (KMA1 <= 2) KMA1 = 2
      IF (ABS(KMA1) >= QX%MEXPOV) KMA1 = 2
      KP = 2
      MA%MP(2) = MP%MP(2)
      MA%MP(3) = AINT (ABS(MP%MP(3))/QX%MBASE)
      MA%MP(4) = ABS(MP%MP(3)) - MA%MP(3)*QX%MBASE
      MA%MP(1) = 1
      IF (MP%MP(1) < 0) MA%MP(1) = -1
      IF (KMA1 >= 4) THEN
          DO J = 4, KMA1, 2
             KP = KP + 1
             MA%MP(J+1) = AINT (MP%MP(KP+1)/QX%MBASE)
             MA%MP(J+2) = MP%MP(KP+1) - MA%MP(J+1)*QX%MBASE
          ENDDO
      ENDIF
      IF (MOD(KMA1,2) == 1) MA%MP(KMA1+2) = AINT (MP%MP(KP+2)/QX%MBASE)
      RETURN
      END SUBROUTINE IMUNPK

      SUBROUTINE IMWRIT(KWRITE,MA,QX)

!  Write MA on unit KWRITE.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using IMREAD.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: KWRITE
      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFF(LMBUFF)
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,K,KSAVE,L,LAST,LB,ND,NDSAVE,NEXP
      INTENT (IN) :: KWRITE,MA

      QX%NCALL = QX%NCALL + 1
      IF (QX%KDEBUG == 1) CALL IMARGS('IMWRIT   ',1,MA,MA,QX)
      QX%NAMEST(QX%NCALL) = 'IMWRIT'
      NDSAVE = QX%NDIG
      QX%NDIG = MAX(2,INT(MA%MP(2)))
      IF (MA%MP(2) >= QX%MEXPOV) QX%NDIG = 2

      KSAVE = QX%KFLAG
      ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = ND + NEXP
      IF (LB > LMBUFF) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF

      CALL IMOUT(MA,CMBUFF,LB,QX)

      QX%KFLAG = KSAVE
      QX%NDIG = NDSAVE
      LAST = LB + 1
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L)
             ELSE
                 IF (L > 73) WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFF(K),K=L-72,L)
             ENDIF
             QX%NCALL = QX%NCALL - 1
             RETURN
         ENDIF
      ENDDO
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE IMWRIT

      SUBROUTINE IM_OR_FM_ADD(MA,MB,MC,QX)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: M1,M2
      INTEGER :: RESULT_SIZE
      TYPE(FM_SETTINGS) :: QX

      IF (MAX(MA%MP(2),MB%MP(2)) > QX%NDIG) THEN
      ELSE
          RESULT_SIZE = MAX(MA%MP(2),MB%MP(2)) + 4
          IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
          RESULT_SIZE = MAX(5,RESULT_SIZE)
      ENDIF

      IF (MAX(MA%MP(2),MB%MP(2)) > QX%NDIG) THEN
          IF (MA%MP(2) >= QX%NDIG .AND. MB%MP(2) >= QX%NDIG) THEN
              CALL FMADD(MA,MB,MC,QX)
          ELSE IF (MA%MP(2) >= QX%NDIG .AND. MB%MP(2) < QX%NDIG) THEN
              CALL IMI2FM(MB,M2,QX)
              CALL FMADD(MA,M2,MC,QX)
          ELSE IF (MA%MP(2) < QX%NDIG .AND. MB%MP(2) >= QX%NDIG) THEN
              CALL IMI2FM(MA,M1,QX)
              CALL FMADD(M1,MB,MC,QX)
          ELSE IF (MA%MP(2) < QX%NDIG .AND. MB%MP(2) < QX%NDIG) THEN
              CALL IMI2FM(MA,M1,QX)
              CALL IMI2FM(MB,M2,QX)
              CALL FMADD(M1,M2,MC,QX)
          ENDIF
      ELSE
          CALL IMADD(MA,MB,MC,QX)
      ENDIF

      RETURN
      END SUBROUTINE IM_OR_FM_ADD

      SUBROUTINE IM_OR_FM_EQ(MA,MB,QX)

!  Internal routine used by binary splitting algorithms.
!  MA is an integer, but if it gets bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      IF (MA%MP(2) >= QX%NDIG) THEN
          CALL FMEQ(MA,MB,QX)
      ELSE
          CALL IMEQ(MA,MB,QX)
      ENDIF
      RETURN
      END SUBROUTINE IM_OR_FM_EQ

      SUBROUTINE IM_OR_FM_MPY(MA,MB,MC,QX)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: M1,M2
      INTEGER :: RESULT_SIZE
      TYPE(FM_SETTINGS) :: QX

      IF (MA%MP(2)+MB%MP(2) > QX%NDIG) THEN
      ELSE
          IF (MA%MP(2) >= QX%MEXPOV .OR. MB%MP(2) >= QX%MEXPOV) THEN
              RESULT_SIZE = 5
          ELSE
              RESULT_SIZE = MA%MP(2) + MB%MP(2) + 4
          ENDIF
          RESULT_SIZE = MAX(5,RESULT_SIZE)
      ENDIF

      IF (MA%MP(2)+MB%MP(2) > QX%NDIG) THEN
          IF (MA%MP(2) >= QX%NDIG .AND. MB%MP(2) >= QX%NDIG) THEN
              CALL FMMPY(MA,MB,MC,QX)
          ELSE IF (MA%MP(2) >= QX%NDIG .AND. MB%MP(2) < QX%NDIG) THEN
              CALL IMI2FM(MB,M2,QX)
              CALL FMMPY(MA,M2,MC,QX)
          ELSE IF (MA%MP(2) < QX%NDIG .AND. MB%MP(2) >= QX%NDIG) THEN
              CALL IMI2FM(MA,M1,QX)
              CALL FMMPY(M1,MB,MC,QX)
          ELSE IF (MA%MP(2) < QX%NDIG .AND. MB%MP(2) < QX%NDIG) THEN
              CALL IMI2FM(MA,M1,QX)
              CALL IMI2FM(MB,M2,QX)
              CALL FMMPY(M1,M2,MC,QX)
          ENDIF
      ELSE
          CALL IMMPY(MA,MB,MC,QX)
      ENDIF

      RETURN
      END SUBROUTINE IM_OR_FM_MPY

      SUBROUTINE IM_OR_FM_SQR(MA,MB,QX)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: M1
      INTEGER :: RESULT_SIZE
      TYPE(FM_SETTINGS) :: QX

      IF (2*MA%MP(2) > QX%NDIG) THEN
      ELSE
          RESULT_SIZE = 2*MA%MP(2) + 4
          IF (ABS(RESULT_SIZE) >= QX%MEXPOV) RESULT_SIZE = 5
          RESULT_SIZE = MAX(5,RESULT_SIZE)
      ENDIF

      IF (2*MA%MP(2) > QX%NDIG) THEN
          IF (MA%MP(2) >= QX%NDIG) THEN
              CALL FMSQR(MA,MB,QX)
          ELSE
              CALL IMI2FM(MA,M1,QX)
              CALL FMSQR(M1,MB,QX)
          ENDIF
      ELSE
          CALL IMSQR(MA,MB,QX)
      ENDIF

      RETURN
      END SUBROUTINE IM_OR_FM_SQR




!  The ZM routines perform complex multiple-precision arithmetic.

      SUBROUTINE ZMSET(NPREC,QX)

!  Set precision to at least NPREC significant digits for using ZM arithmetic.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NPREC
      INTENT (IN) :: NPREC
      TYPE(FM_SETTINGS) :: QX

!             Set JFORMZ to ' 1.23 + 4.56 i ' format.

      QX%JFORMZ = 1

!             Set JPRNTZ to print real and imaginary parts on one line whenever possible.

      QX%JPRNTZ = 1

!             Use FMSET to initialize the other variables.

      CALL FMSET(NPREC,QX)

      RETURN
      END SUBROUTINE ZMSET

      SUBROUTINE ZMABS(MA,MBFM,QX)

!  MBFM = ABS(MA)

!  Complex absolute value.  The result is a real FM number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MBFM
      REAL (KIND(1.0D0)) :: MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TYPE(MULTI) :: MXY(3),MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      NTRSAV = QX%NTRACE
      IF (QX%NTRACE /= 0) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'ZMABS'
          CALL ZMNTR(2,MA,MA,1,QX)
          QX%NCALL = QX%NCALL - 1
      ENDIF
      QX%NTRACE = 0
      CALL ZMENTR('ZMABS    ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      QX%NTRACE = NTRSAV
      IF (KRESLT /= 0) THEN
          CALL FMEQ(MZ01(1),MBFM,QX)
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      MXEXP1 = INT(QX%MXEXP2/2.01D0)
      IF (MA(1)%MP(3) == 0) THEN
          CALL FMABS(MZ02(2),MXY(3),QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMABS(MZ02(1),MXY(3),QX)
          GO TO 120
      ELSE IF (MA(1)%MP(2) == QX%MEXPOV .OR. MA(2)%MP(2) == QX%MEXPOV) THEN
          CALL FMI2M(1,MXY(3),QX)
          MXY(3)%MP(2) = MAX(MZ02(1)%MP(2),MZ02(2)%MP(2))
          GO TO 120
      ELSE IF (MA(1)%MP(2) == QX%MEXPUN) THEN
          IF (MA(2)%MP(2) > -MXEXP1+QX%NDIG+1) THEN
              CALL FMABS(MZ02(2),MXY(3),QX)
          ELSE
              CALL FMST2M('UNKNOWN',MXY(3),QX)
              QX%KFLAG = -4
          ENDIF
          GO TO 120
      ELSE IF (MA(2)%MP(2) == QX%MEXPUN) THEN
          IF (MA(1)%MP(2) > -MXEXP1+QX%NDIG+1) THEN
              CALL FMABS(MZ02(1),MXY(3),QX)
          ELSE
              CALL FMST2M('UNKNOWN',MXY(3),QX)
              QX%KFLAG = -4
          ENDIF
          GO TO 120
      ELSE IF (MA(1)%MP(2) /= QX%MUNKNO .AND. MA(2)%MP(2) /= QX%MUNKNO) THEN
          IF (MA(1)%MP(2) > MA(2)%MP(2)+QX%NDIG+1) THEN
              CALL FMABS(MZ02(1),MXY(3),QX)
              GO TO 120
          ELSE IF (MA(2)%MP(2) > MA(1)%MP(2)+QX%NDIG+1) THEN
              CALL FMABS(MZ02(2),MXY(3),QX)
              GO TO 120
          ENDIF
      ENDIF

      CALL FMSQR(MZ02(1),MXY(1),QX)
      CALL FMSQR(MZ02(2),MXY(2),QX)
      CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
      CALL FMSQRT_R1(MXY(3),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXI2(MXY(3),MBFM,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMABS

      SUBROUTINE ZMACOS(MA,MB,QX)

!  MB = ACOS(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMACOS   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL FMPI(MZ01(1),QX)
          CALL FMDIVI_R1(MZ01(1),2,QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          KRSAVE = QX%KRAD
          QX%KRAD = 1
          CALL FMACOS(MZ04(1),MZ01(1),QX)
          QX%KRAD = KRSAVE
          IF (QX%KFLAG == 0) THEN
              CALL FMI2M(0,MZ01(2),QX)
              GO TO 120
          ENDIF
      ENDIF
      IF ((MA(1)%MP(3) == 0 .OR. MA(1)%MP(2)*2 <= -QX%NDIG) .AND.  &
          (MA(2)%MP(3) == 0 .OR. MA(2)%MP(2)*2 <= -QX%NDIG)) THEN
          CALL FMPI(MZ02(1),QX)
          CALL FMDIVI_R1(MZ02(1),2,QX)
          CALL FMI2M(0,MZ02(2),QX)
          CALL ZMSUB(MZ02,MZ04,MZ01,QX)
          GO TO 120
      ENDIF

      CALL ZMI2M(0,MZ01,QX)
      CALL ZMI2M(1,MZ03,QX)
      CALL ZMSUB(MZ03,MZ04,MZ02,QX)
      CALL ZMADD(MZ03,MZ04,MZ05,QX)
      CALL ZMMPY(MZ02,MZ05,MZ03,QX)
      CALL ZMSQRT(MZ03,MZ02,QX)
      DO J = 1, QX%NDIG+2
         MZ03(1)%MP(J) = MZ02(2)%MP(J)
         MZ03(2)%MP(J) = MZ02(1)%MP(J)
      ENDDO
      IF (MZ03(1)%MP(2) /= QX%MUNKNO .AND. MZ03(1)%MP(3) /= 0)  &
          MZ03(1)%MP(1) = -MZ03(1)%MP(1)

      IF ((MA(1)%MP(3) /= 0 .AND. MZ03(1)%MP(2) == MA(1)%MP(2) .AND.  &
          MZ03(1)%MP(1)*MZ03(1)%MP(3) == MA(1)%MP(1)*MA(1)%MP(3))     &
          .OR. (MA(2)%MP(3) /= 0 .AND. MZ03(2)%MP(2) == MA(2)%MP(2)   &
          .AND. MZ03(2)%MP(1)*MZ03(2)%MP(3) ==                        &
          MA(2)%MP(1)*MA(2)%MP(3)) ) THEN
          CALL ZMADD(MZ04,MZ03,MZ05,QX)
          CALL FMSQR(MZ05(1),MXY(2),QX)
          CALL FMSQR(MZ05(2),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(4),QX)
          CALL FMI2M(1,MXY(1),QX)
          CALL FMSUB_R2(MXY(4),MXY(1),QX)
          IF (MXY(1)%MP(2) < 0) THEN
              QX%NDIG = QX%NDIG - INT(MXY(1)%MP(2))
              CALL ZMEQU_R1(MZ04,NDSAVE,QX%NDIG,QX)
              CALL ZMI2M(0,MZ01,QX)
              CALL ZMI2M(1,MZ03,QX)
              CALL ZMSUB(MZ03,MZ04,MZ02,QX)
              CALL ZMADD(MZ03,MZ04,MZ05,QX)
              CALL ZMMPY(MZ02,MZ05,MZ03,QX)
              CALL ZMSQRT(MZ03,MZ02,QX)
              DO J = 1, QX%NDIG+2
                 MZ03(1)%MP(J) = MZ02(2)%MP(J)
                 MZ03(2)%MP(J) = MZ02(1)%MP(J)
              ENDDO
              IF (MZ03(1)%MP(2) /= QX%MUNKNO .AND. MZ03(1)%MP(3) /= 0)  &
                  MZ03(1)%MP(1) = -MZ03(1)%MP(1)
              CALL ZMADD(MZ04,MZ03,MZ05,QX)
          ENDIF

          CALL ZMLN(MZ05,MZ03,QX)
          DO J = 1, QX%NDIG+2
             MZ01(1)%MP(J) = MZ03(2)%MP(J)
             MZ01(2)%MP(J) = MZ03(1)%MP(J)
          ENDDO
          IF (MZ01(2)%MP(2) /= QX%MUNKNO .AND. MZ01(2)%MP(3) /= 0)  &
              MZ01(2)%MP(1) = -MZ01(2)%MP(1)
      ELSE
          CALL ZMSUB(MZ04,MZ03,MZ05,QX)
          CALL FMSQR(MZ05(1),MXY(2),QX)
          CALL FMSQR(MZ05(2),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(4),QX)
          CALL FMI2M(1,MXY(1),QX)
          CALL FMSUB_R2(MXY(4),MXY(1),QX)
          IF (MXY(1)%MP(2) < 0) THEN
              QX%NDIG = QX%NDIG - INT(MXY(1)%MP(2))
              CALL ZMEQU_R1(MZ04,NDSAVE,QX%NDIG,QX)
              CALL ZMI2M(0,MZ01,QX)
              CALL ZMI2M(1,MZ03,QX)
              CALL ZMSUB(MZ03,MZ04,MZ02,QX)
              CALL ZMADD(MZ03,MZ04,MZ05,QX)
              CALL ZMMPY(MZ02,MZ05,MZ03,QX)
              CALL ZMSQRT(MZ03,MZ02,QX)
              DO J = 1, QX%NDIG+2
                 MZ03(1)%MP(J) = MZ02(2)%MP(J)
                 MZ03(2)%MP(J) = MZ02(1)%MP(J)
              ENDDO
              IF (MZ03(1)%MP(2) /= QX%MUNKNO .AND. MZ03(1)%MP(3) /= 0)  &
                  MZ03(1)%MP(1) = -MZ03(1)%MP(1)
              CALL ZMSUB(MZ04,MZ03,MZ05,QX)
          ENDIF

          CALL ZMLN(MZ05,MZ03,QX)
          DO J = 1, QX%NDIG+2
             MZ01(1)%MP(J) = MZ03(2)%MP(J)
             MZ01(2)%MP(J) = MZ03(1)%MP(J)
          ENDDO
          IF (MZ01(1)%MP(2) /= QX%MUNKNO .AND. MZ01(1)%MP(3) /= 0)  &
              MZ01(1)%MP(1) = -MZ01(1)%MP(1)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMACOS

      SUBROUTINE ZMACOSH(MA,MB,QX)

!  MB = ACOSH(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2)


      CALL ZMENTR('ZMACOSH  ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)

      IF ((MA(1)%MP(3) == 0 .OR. MA(1)%MP(2)*4 <= -QX%NDIG) .AND.  &
          (MA(2)%MP(3) == 0 .OR. MA(2)%MP(2)*4 <= -QX%NDIG)) THEN
          CALL FMPI(MZ02(1),QX)
          CALL FMDIVI_R1(MZ02(1),2,QX)
          CALL FMI2M(0,MZ02(2),QX)
          CALL ZMSUB(MZ02,MZ04,MZ03,QX)
          IF (MZ04(2)%MP(2) /= QX%MEXPUN) THEN
              CALL ZMIPWR(MZ04,3,MZ02,QX)
              CALL ZMDIVI(MZ02,6,MZ01,QX)
              CALL ZMSUB(MZ03,MZ01,MZ02,QX)
              CALL FMEQ(MZ02(1),MZ01(2),QX)
              CALL FMMPYI(MZ02(2),-1,MZ01(1),QX)
          ELSE
              CALL FMIPWR(MZ04(1),3,MZ02(1),QX)
              CALL FMDIVI(MZ02(1),6,MZ01(1),QX)
              CALL FMSUB(MZ03(1),MZ01(1),MZ01(2),QX)
              CALL FMMPYI(MZ03(2),-1,MZ01(1),QX)
          ENDIF
          IF (MZ04(2)%MP(1) < 0) THEN
              MZ01(2)%MP(1) = -1
              IF (MZ01(1)%MP(2) /= QX%MUNKNO .AND. MZ01(1)%MP(3) /= 0)  &
                  MZ01(1)%MP(1) = -MZ01(1)%MP(1)
          ENDIF
          GO TO 120
      ENDIF

      CALL ZMI2M(1,MZ03,QX)
      CALL ZMADD(MZ04,MZ03,MZ05,QX)
      CALL ZMSQRT(MZ05,MZ02,QX)
      CALL ZMSUB(MZ04,MZ03,MZ05,QX)
      CALL ZMSQRT(MZ05,MZ01,QX)
      CALL ZMMPY(MZ01,MZ02,MZ05,QX)
      CALL ZMADD(MZ04,MZ05,MZ02,QX)
      CALL ZMLN(MZ02,MZ01,QX)

  120 IF (MA(2)%MP(3) == 0 .AND. MA(1)%MP(2) <= 0) THEN
          CALL FMI2M(0,MZ01(1),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMACOSH

      SUBROUTINE ZMADD(MA,MB,MC,QX)

!  MC = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      TYPE(FM_SETTINGS) :: QX
      INTEGER :: KF1,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MAR,MAI,MBR,MBI,MXSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC


      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          ABS(MB(1)%MP(2)) > QX%MEXPAB .OR. ABS(MB(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          CALL ZMENTR('ZMADD    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
          QX%NDIG = NDSAVE
          QX%MXEXP = MXSAVE
          NTRSAV = QX%NTRACE
          QX%NTRACE = 0
      ELSE
          QX%NCALL = QX%NCALL + 1
          NTRSAV = QX%NTRACE
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMADD'
              CALL ZMNTR(2,MA,MB,2,QX)
              QX%NTRACE = 0
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMADD to use more guard digits for user calls.

      QX%NCALL = QX%NCALL - 1

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      MAR = MA(1)%MP(2)
      IF (MA(1)%MP(3) == 0) MAR = QX%MEXPUN - 1
      MAI = MA(2)%MP(2)
      IF (MA(2)%MP(3) == 0) MAI = QX%MEXPUN - 1
      MBR = MB(1)%MP(2)
      IF (MB(1)%MP(3) == 0) MBR = QX%MEXPUN - 1
      MBI = MB(2)%MP(2)
      IF (MB(2)%MP(3) == 0) MBI = QX%MEXPUN - 1

      CALL FMADD(MA(1),MB(1),MC(1),QX)
      KF1 = QX%KFLAG
      CALL FMADD(MA(2),MB(2),MC(2),QX)

      QX%NCALL = QX%NCALL + 1
      IF (NTRSAV /= 0) THEN
          QX%NTRACE = NTRSAV
          QX%NAMEST(QX%NCALL) = 'ZMADD'
      ENDIF
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 1) QX%KFLAG = KF1
      IF (QX%KFLAG == 1) THEN
          QX%KFLAG = 0
          IF (MAR <= MBR .AND. MAI <= MBI) QX%KFLAG = 1
          IF (MAR >= MBR .AND. MAI >= MBI) QX%KFLAG = 1
      ENDIF

      IF (MC(1)%MP(2) == QX%MUNKNO .OR. MC(2)%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
      ELSE IF (MC(1)%MP(2) == QX%MEXPOV .OR. MC(2)%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
      ELSE IF (MC(1)%MP(2) == QX%MEXPUN .OR. MC(2)%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -6
      ENDIF
      IF ((MC(1)%MP(2) == QX%MUNKNO) .OR. (MC(2)%MP(2) == QX%MUNKNO)  &
         .OR. (MC(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MC(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MC(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
         .OR. (MC(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
          QX%NAMEST(QX%NCALL) = 'ZMADD'
          CALL ZMWARN(QX)
      ENDIF
      IF (QX%NTRACE /= 0) THEN
          CALL ZMNTR(1,MC,MC,1,QX)
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMADD

      SUBROUTINE ZMADD_R1(MA,MB,QX)

!  MA = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMADD(MA,MB,MXY,QX)
      CALL ZMEQ(MXY,MA,QX)


      END SUBROUTINE ZMADD_R1

      SUBROUTINE ZMADD_R2(MA,MB,QX)

!  MB = MA + MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMADD(MA,MB,MXY,QX)
      CALL ZMEQ(MXY,MB,QX)


      END SUBROUTINE ZMADD_R2

      SUBROUTINE ZMADDI(MA,INTEG,QX)

!  MA = MA + INTEG        Increment by one-word (real) integer.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      INTEGER :: INTEG
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (INOUT) :: MA
      INTENT (IN) :: INTEG
      TYPE(MULTI) :: MZ01(2)


      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          NTRSAV = QX%NTRACE
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'ZMADDI'
              CALL ZMNTR(2,MA,MA,1,QX)
              CALL FMNTRI(2,INTEG,0,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          QX%NTRACE = 0
          CALL ZMENTR('ZMADDI   ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          QX%NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              CALL FMEQ(MZ01(1),MA(1),QX)
              QX%NCALL = QX%NCALL + 1
              IF (QX%NTRACE /= 0) CALL ZMNTR(1,MA,MA,1,QX)
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
          QX%NDIG = NDSAVE
          QX%MXEXP = MXSAVE
          NTRSAV = QX%NTRACE
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMADDI'
              CALL ZMNTR(2,MA,MA,1,QX)
              CALL FMNTRI(2,INTEG,0,QX)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMADDI to use more guard digits for user calls.

      QX%NCALL = QX%NCALL - 1
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0

      CALL FMADDI(MA(1),INTEG,QX)

      QX%NTRACE = NTRSAV
      QX%KWARN = KWRNSV
      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) QX%NAMEST(QX%NCALL) = 'ZMADDI'
      IF (MA(1)%MP(2) == QX%MUNKNO .OR. MA(2)%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
      ELSE IF (MA(1)%MP(2) == QX%MEXPOV .OR. MA(2)%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
      ELSE IF (MA(1)%MP(2) == QX%MEXPUN .OR. MA(2)%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -6
      ENDIF
      IF ((MA(1)%MP(2) == QX%MUNKNO) .OR. (MA(2)%MP(2) == QX%MUNKNO)  &
         .OR. (MA(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MA(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MA(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
         .OR. (MA(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
          QX%NAMEST(QX%NCALL) = 'ZMADDI'
          CALL ZMWARN(QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MA,MA,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMADDI

      SUBROUTINE ZMARG(MA,MBFM,QX)

!  MBFM = ARG(MA)

!  Complex argument.  The result is a real FM number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MBFM
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TYPE(MULTI) :: MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      NTRSAV = QX%NTRACE
      IF (QX%NTRACE /= 0) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'ZMARG'
          CALL ZMNTR(2,MA,MA,1,QX)
          QX%NCALL = QX%NCALL - 1
      ENDIF
      QX%NTRACE = 0
      CALL ZMENTR('ZMARG    ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      QX%NTRACE = NTRSAV
      IF (KRESLT /= 0) THEN
          CALL FMEQ(MZ01(1),MBFM,QX)
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

      CALL FMATN2(MZ02(2),MZ02(1),MZ01(1),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXI2(MZ01(1),MBFM,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMARG

      SUBROUTINE ZMASIN(MA,MB,QX)

!  MB = ASIN(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMASIN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ01,QX)
          GO TO 120
      ELSE IF ((MA(1)%MP(3) == 0 .OR. MA(1)%MP(2)*2 <= -QX%NDIG) .AND.  &
               (MA(2)%MP(3) == 0 .OR. MA(2)%MP(2)*2 <= -QX%NDIG)) THEN
          CALL ZMEQ(MZ04,MZ01,QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          KRSAVE = QX%KRAD
          QX%KRAD = 1
          CALL FMASIN(MZ04(1),MZ01(1),QX)
          QX%KRAD = KRSAVE
          IF (QX%KFLAG == 0) THEN
              CALL FMI2M(0,MZ01(2),QX)
              GO TO 120
          ENDIF
      ENDIF

      CALL ZMI2M(0,MZ01,QX)
      CALL ZMI2M(1,MZ03,QX)
      CALL ZMSUB(MZ03,MZ04,MZ02,QX)
      CALL ZMADD(MZ03,MZ04,MZ05,QX)
      CALL ZMMPY(MZ02,MZ05,MZ03,QX)
      CALL ZMSQRT(MZ03,MZ02,QX)
      DO J = 1, QX%NDIG+2
         MZ03(1)%MP(J) = MZ04(2)%MP(J)
         MZ03(2)%MP(J) = MZ04(1)%MP(J)
      ENDDO
      IF (MZ03(1)%MP(2) /= QX%MUNKNO .AND. MZ03(1)%MP(3) /= 0)  &
          MZ03(1)%MP(1) = -MZ03(1)%MP(1)

      IF ((MZ02(1)%MP(3) /= 0 .AND. MZ03(1)%MP(2) == MZ02(1)%MP(2)  &
          .AND. MZ03(1)%MP(1)*MZ03(1)%MP(3) ==                      &
                MZ02(1)%MP(1)*MZ02(1)%MP(3)) .OR.                   &
          (MZ02(2)%MP(3) /= 0 .AND. MZ03(2)%MP(2) == MZ02(2)%MP(2)  &
          .AND.  MZ03(2)%MP(1)*MZ03(2)%MP(3) ==                     &
                 MZ02(2)%MP(1)*MZ02(2)%MP(3)) ) THEN
          CALL ZMADD(MZ02,MZ03,MZ05,QX)
          CALL FMSQR(MZ05(1),MXY(2),QX)
          CALL FMSQR(MZ05(2),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(4),QX)
          CALL FMI2M(1,MXY(1),QX)
          CALL FMSUB_R2(MXY(4),MXY(1),QX)
          IF (MXY(1)%MP(2) < 0) THEN
              QX%NDIG = QX%NDIG - INT(MXY(1)%MP(2))
              CALL ZMEQU_R1(MZ04,NDSAVE,QX%NDIG,QX)
              CALL ZMI2M(0,MZ01,QX)
              CALL ZMI2M(1,MZ03,QX)
              CALL ZMSUB(MZ03,MZ04,MZ02,QX)
              CALL ZMADD(MZ03,MZ04,MZ05,QX)
              CALL ZMMPY(MZ02,MZ05,MZ03,QX)
              CALL ZMSQRT(MZ03,MZ02,QX)
              DO J = 1, QX%NDIG+2
                 MZ03(1)%MP(J) = MZ04(2)%MP(J)
                 MZ03(2)%MP(J) = MZ04(1)%MP(J)
              ENDDO
              IF (MZ03(1)%MP(2) /= QX%MUNKNO .AND. MZ03(1)%MP(3) /= 0)  &
                  MZ03(1)%MP(1) = -MZ03(1)%MP(1)
              CALL ZMADD(MZ02,MZ03,MZ05,QX)
          ENDIF

          CALL ZMLN(MZ05,MZ03,QX)
          DO J = 1, QX%NDIG+2
             MZ01(1)%MP(J) = MZ03(2)%MP(J)
             MZ01(2)%MP(J) = MZ03(1)%MP(J)
          ENDDO
          IF (MZ01(2)%MP(2) /= QX%MUNKNO .AND. MZ01(2)%MP(3) /= 0)  &
              MZ01(2)%MP(1) = -MZ01(2)%MP(1)
      ELSE
          CALL ZMSUB(MZ02,MZ03,MZ05,QX)
          CALL FMSQR(MZ05(1),MXY(2),QX)
          CALL FMSQR(MZ05(2),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(4),QX)
          CALL FMI2M(1,MXY(1),QX)
          CALL FMSUB_R2(MXY(4),MXY(1),QX)
          IF (MXY(1)%MP(2) < 0) THEN
              QX%NDIG = QX%NDIG - INT(MXY(1)%MP(2))
              CALL ZMEQU_R1(MZ04,NDSAVE,QX%NDIG,QX)
              CALL ZMI2M(0,MZ01,QX)
              CALL ZMI2M(1,MZ03,QX)
              CALL ZMSUB(MZ03,MZ04,MZ02,QX)
              CALL ZMADD(MZ03,MZ04,MZ05,QX)
              CALL ZMMPY(MZ02,MZ05,MZ03,QX)
              CALL ZMSQRT(MZ03,MZ02,QX)
              DO J = 1, QX%NDIG+2
                 MZ03(1)%MP(J) = MZ04(2)%MP(J)
                 MZ03(2)%MP(J) = MZ04(1)%MP(J)
              ENDDO
              IF (MZ03(1)%MP(2) /= QX%MUNKNO .AND. MZ03(1)%MP(3) /= 0)  &
                  MZ03(1)%MP(1) = -MZ03(1)%MP(1)
              CALL ZMSUB(MZ02,MZ03,MZ05,QX)
          ENDIF
          CALL ZMLN(MZ05,MZ03,QX)
          DO J = 1, QX%NDIG+2
             MZ01(1)%MP(J) = MZ03(2)%MP(J)
             MZ01(2)%MP(J) = MZ03(1)%MP(J)
          ENDDO
          IF (MZ01(1)%MP(2) /= QX%MUNKNO .AND. MZ01(1)%MP(3) /= 0)  &
              MZ01(1)%MP(1) = -MZ01(1)%MP(1)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMASIN

      SUBROUTINE ZMASINH(MA,MB,QX)

!  MB = ASINH(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2)


      CALL ZMENTR('ZMASINH  ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ01,QX)
          GO TO 120
      ELSE IF ((MA(1)%MP(3) == 0 .OR. MA(1)%MP(2)*2 <= -QX%NDIG) .AND.  &
               (MA(2)%MP(3) == 0 .OR. MA(2)%MP(2)*2 <= -QX%NDIG)) THEN
          IF (QX%KROUND == 1) THEN
              CALL ZMEQ(MZ04,MZ01,QX)
          ELSE
              CALL ZMIPWR(MZ04,3,MZ03,QX)
              CALL ZMDIVI(MZ03,6,MZ02,QX)
              CALL ZMSUB(MZ04,MZ02,MZ01,QX)
              KR_RETRY = 2
          ENDIF
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMASINH(MZ04(1),MZ01(1),QX)
          IF (QX%KFLAG == 0) THEN
              CALL FMI2M(0,MZ01(2),QX)
              GO TO 120
          ENDIF
      ENDIF

      CALL ZMI2M(1,MZ03,QX)
      CALL ZMSQR(MZ04,MZ02,QX)
      CALL ZMADD(MZ03,MZ02,MZ05,QX)
      CALL ZMSQRT(MZ05,MZ02,QX)

      IF (MZ04(1)%MP(1) > 0) THEN
          CALL ZMADD(MZ02,MZ04,MZ05,QX)
          CALL ZMLN(MZ05,MZ01,QX)
      ELSE
          CALL ZMSUB(MZ02,MZ04,MZ05,QX)
          CALL ZMLN(MZ05,MZ01,QX)
          IF (MZ01(1)%MP(2) /= QX%MUNKNO .AND. MZ01(1)%MP(3) /= 0)  &
              MZ01(1)%MP(1) = -MZ01(1)%MP(1)
          IF (MZ01(2)%MP(2) /= QX%MUNKNO .AND. MZ01(2)%MP(3) /= 0)  &
              MZ01(2)%MP(1) = -MZ01(2)%MP(1)
      ENDIF

  120 IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(2) <= 0) THEN
          CALL FMI2M(0,MZ01(1),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMASINH

      SUBROUTINE ZMATAN(MA,MB,QX)

!  MB = ATAN(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JTERM,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMATAN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ03,QX)
          GO TO 130
      ELSE IF ((MA(1)%MP(3) == 0 .OR. MA(1)%MP(2)*2 <= -QX%NDIG) .AND.  &
               (MA(2)%MP(3) == 0 .OR. MA(2)%MP(2)*2 <= -QX%NDIG)) THEN
          CALL ZMEQ(MZ04,MZ03,QX)
          GO TO 130
      ELSE IF (MA(2)%MP(3) == 0) THEN
          KRSAVE = QX%KRAD
          QX%KRAD = 1
          CALL FMATAN(MZ04(1),MZ03(1),QX)
          QX%KRAD = KRSAVE
          IF (QX%KFLAG == 0) THEN
              CALL FMI2M(0,MZ03(2),QX)
              GO TO 130
          ENDIF
      ENDIF

      X = 1.0E+5
      CALL FMDPM(DBLE(X),MXY(1),QX)
      CALL FMABS(MZ04(1),MXY(2),QX)
      CALL FMABS(MZ04(2),MXY(3),QX)
      CALL FMADD_R2(MXY(2),MXY(3),QX)

      IF (FMCOMP(MXY(3),'>=',MXY(1),QX)) THEN
          CALL ZMI2M(0,MZ03,QX)
          CALL FMPI(MZ03(1),QX)
          CALL FMDIVI_R1(MZ03(1),2,QX)
          IF (MA(1)%MP(1) < 0 .AND. MZ03(1)%MP(2) /= QX%MUNKNO .AND.  &
              MZ03(1)%MP(3) /= 0) MZ03(1)%MP(1) = -MZ03(1)%MP(1)
          CALL ZMI2M(1,MZ01,QX)
          CALL ZMDIV(MZ01,MZ04,MZ05,QX)
          CALL ZMEQ(MZ05,MZ02,QX)
          CALL ZMSUB(MZ03,MZ05,MZ01,QX)
          CALL ZMEQ(MZ01,MZ03,QX)
          IF (MA(1)%MP(2) > QX%NDIG .OR. MA(2)%MP(2) > QX%NDIG) GO TO 130
          CALL ZMSQR(MZ05,MZ01,QX)
          JTERM = 1
  120     CALL ZMMPY(MZ02,MZ01,MZ05,QX)
          CALL ZMEQ(MZ05,MZ02,QX)
          JTERM = JTERM + 2
          CALL FMEQ(MZ02(1),MXY(4),QX)
          CALL FMEQ(MZ02(2),MXY(5),QX)
          CALL ZMDIVI(MZ02,JTERM,MZ05,QX)
          CALL ZMEQ(MZ05,MZ02,QX)
          CALL ZMADD(MZ03,MZ02,MZ05,QX)
          CALL ZMEQ(MZ05,MZ03,QX)
          IF (QX%KFLAG /= 0) GO TO 130
          CALL FMEQ(MXY(4),MZ02(1),QX)
          CALL FMEQ(MXY(5),MZ02(2),QX)
          CALL ZMMPY(MZ02,MZ01,MZ05,QX)
          CALL ZMEQ(MZ05,MZ02,QX)
          JTERM = JTERM + 2
          CALL FMEQ(MZ02(1),MXY(4),QX)
          CALL FMEQ(MZ02(2),MXY(5),QX)
          CALL ZMDIVI(MZ02,JTERM,MZ05,QX)
          CALL ZMEQ(MZ05,MZ02,QX)
          CALL ZMSUB(MZ03,MZ02,MZ05,QX)
          CALL ZMEQ(MZ05,MZ03,QX)
          IF (QX%KFLAG /= 0) GO TO 130
          CALL FMEQ(MXY(4),MZ02(1),QX)
          CALL FMEQ(MXY(5),MZ02(2),QX)
          GO TO 120
      ELSE
          CALL ZM2I2M(0,1,MZ01,QX)
          CALL ZMSUB(MZ01,MZ04,MZ03,QX)
          CALL ZMADD(MZ01,MZ04,MZ05,QX)
          CALL ZMDIV(MZ05,MZ03,MZ02,QX)
          CALL FMSQR(MZ02(1),MXY(3),QX)
          CALL FMSQR(MZ02(2),MXY(4),QX)
          CALL FMADD(MXY(3),MXY(4),MXY(5),QX)
          CALL FMI2M(1,MXY(2),QX)
          CALL FMSUB_R2(MXY(5),MXY(2),QX)
          IF (MXY(2)%MP(2) < 0) THEN
              QX%NDIG = QX%NDIG - INT(MXY(2)%MP(2))
              CALL ZMEQU_R1(MZ04,NDSAVE,QX%NDIG,QX)
              CALL ZM2I2M(0,1,MZ01,QX)
              CALL ZMSUB(MZ01,MZ04,MZ03,QX)
              CALL ZMADD(MZ01,MZ04,MZ05,QX)
              CALL ZMDIV(MZ05,MZ03,MZ02,QX)
          ENDIF
          CALL ZMLN(MZ02,MZ05,QX)
          CALL ZMDIVI(MZ05,2,MZ02,QX)
          DO J = 1, QX%NDIG+2
             MZ03(1)%MP(J) = MZ02(2)%MP(J)
             MZ03(2)%MP(J) = MZ02(1)%MP(J)
          ENDDO
          IF (MZ03(1)%MP(2) /= QX%MUNKNO .AND. MZ03(1)%MP(3) /= 0)  &
              MZ03(1)%MP(1) = -MZ03(1)%MP(1)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ03(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ03(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ03,MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMATAN

      SUBROUTINE ZMATANH(MA,MB,QX)

!  MB = ATANH(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JTERM,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),MZ06(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMATANH  ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ03,QX)
          GO TO 130
      ELSE IF ((MA(1)%MP(3) == 0 .OR. MA(1)%MP(2)*2 <= -QX%NDIG) .AND.  &
               (MA(2)%MP(3) == 0 .OR. MA(2)%MP(2)*2 <= -QX%NDIG)) THEN
          CALL ZMEQ(MZ04,MZ03,QX)
          GO TO 130
      ELSE IF (MA(2)%MP(3) == 0 .AND. MA(2)%MP(2) <= 0) THEN
          CALL FMATANH(MZ04(1),MZ03(1),QX)
          IF (QX%KFLAG == 0) THEN
              CALL FMI2M(0,MZ03(2),QX)
              GO TO 130
          ENDIF
      ENDIF

      CALL FMDPM(1.0D+5,MXY(1),QX)
      CALL FMABS(MZ04(1),MXY(2),QX)
      CALL FMABS(MZ04(2),MXY(3),QX)
      CALL FMADD_R2(MXY(2),MXY(3),QX)

      IF (FMCOMP(MXY(3),'>=',MXY(1),QX)) THEN
          CALL ZMI2M(0,MZ03,QX)
          CALL FMPI(MZ03(2),QX)
          IF (MA(2)%MP(1) > 0) THEN
              CALL FMDIVI_R1(MZ03(2),2,QX)
          ELSE
              CALL FMDIVI_R1(MZ03(2),-2,QX)
          ENDIF
          IF (MA(1)%MP(1) < 0 .AND. MZ03(1)%MP(2) /= QX%MUNKNO .AND.  &
              MZ03(1)%MP(3) /= 0) MZ03(1)%MP(1) = -MZ03(1)%MP(1)
          CALL ZMI2M(1,MZ01,QX)
          CALL ZMDIV(MZ01,MZ04,MZ05,QX)
          CALL ZMEQ(MZ05,MZ02,QX)
          CALL ZMADD(MZ03,MZ05,MZ01,QX)
          CALL ZMEQ(MZ01,MZ03,QX)
          IF (MA(1)%MP(2) > QX%NDIG .OR. MA(2)%MP(2) > QX%NDIG) GO TO 130
          CALL ZMSQR(MZ05,MZ01,QX)
          JTERM = 1
  120     CALL ZMMPY(MZ02,MZ01,MZ05,QX)
          CALL ZMEQ(MZ05,MZ02,QX)
          JTERM = JTERM + 2
          CALL ZMDIVI(MZ02,JTERM,MZ06,QX)
          CALL ZMADD(MZ03,MZ06,MZ05,QX)
          CALL ZMEQ(MZ05,MZ03,QX)
          IF (QX%KFLAG /= 0) GO TO 130
          GO TO 120
      ELSE
          CALL ZMI2M(0,MZ03,QX)
          CALL ZMI2M(1,MZ01,QX)
          CALL ZMSUB(MZ01,MZ04,MZ02,QX)
          CALL ZMADD(MZ01,MZ04,MZ05,QX)
          CALL ZMDIV(MZ05,MZ02,MZ03,QX)
          CALL FMSQR(MZ03(1),MXY(3),QX)
          CALL FMSQR(MZ03(2),MXY(4),QX)
          CALL FMADD(MXY(3),MXY(4),MXY(5),QX)
          CALL FMI2M(1,MXY(2),QX)
          CALL FMSUB_R2(MXY(5),MXY(2),QX)
          IF (MXY(2)%MP(2) < 0) THEN
              QX%NDIG = QX%NDIG - INT(MXY(2)%MP(2))
              CALL ZMEQU_R1(MZ04,NDSAVE,QX%NDIG,QX)
              CALL ZMI2M(1,MZ01,QX)
              CALL ZMSUB(MZ01,MZ04,MZ02,QX)
              CALL ZMADD(MZ01,MZ04,MZ05,QX)
              CALL ZMDIV(MZ05,MZ02,MZ03,QX)
          ENDIF
          CALL ZMLN(MZ03,MZ05,QX)
          CALL ZMDIVI(MZ05,2,MZ03,QX)
      ENDIF

  130 IF (MA(2)%MP(3) == 0 .AND. MA(1)%MP(2) >= 1) THEN
          MZ03(2)%MP(1) = -MA(1)%MP(1)
      ENDIF
      IF (MA(1)%MP(3) == 0) THEN
          CALL FMI2M(0,MZ03(1),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ03(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ03(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ03,MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMATANH

      SUBROUTINE ZMCHSH(MA,MB,MC,QX)

!  MB = COSH(MA),    MC = SINH(MA).

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  ZMCOSH and ZMSINH.

!  MB and MC must be distinct arrays.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(MULTI) :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2)
      TYPE(FM_SETTINGS) :: QX


      NCSAVE = QX%NCALL
      CALL ZMENTR('ZMCHSH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      QX%NCALL = NCSAVE + 1
      IF (KRESLT /= 0) THEN
          CALL ZMEQ(MB,MC,QX)
          IF (QX%NTRACE /= 0) THEN
              CALL ZMNTR(1,MB,MB,1,QX)
              IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
                  IF (QX%NTRACE < 0) THEN
                      CALL ZMNTRJ(MC,QX%NDIG,QX)
                  ELSE
                      CALL ZMPRNT(MC,QX)
                  ENDIF
              ENDIF
          ENDIF
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(1,MZ01,QX)
          CALL ZMI2M(0,MZ05,QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMCHSH(MZ04(1),MZ01(1),MZ05(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          CALL FMI2M(0,MZ05(2),QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMCSSN(MZ04(2),MZ01(1),MZ05(2),QX)
          CALL FMI2M(0,MZ01(2),QX)
          CALL FMI2M(0,MZ05(1),QX)
          GO TO 120
      ENDIF

!             Find SINH(REAL(MA)) and COSH(REAL(MA)).

      CALL FMCHSH(MZ04(1),MZ02(1),MZ02(2),QX)

!             Find SIN(IMAG(MA)) and COS(IMAG(MA)).

      CALL FMCSSN(MZ04(2),MZ03(1),MZ03(2),QX)

!             COSH(MA) =  COSH(REAL(MA))*COS(IMAG(MA)) + SINH(REAL(MA))*SIN(IMAG(MA)) i

      CALL FMMPY(MZ02(1),MZ03(1),MZ01(1),QX)
      CALL FMMPY(MZ02(2),MZ03(2),MZ01(2),QX)

!             SINH(MA) =  SINH(REAL(MA))*COS(IMAG(MA)) + COSH(REAL(MA))*SIN(IMAG(MA)) i

      CALL FMMPY(MZ02(2),MZ03(1),MZ05(1),QX)
      CALL FMMPY(MZ02(1),MZ03(2),MZ05(2),QX)

      IF (MZ05(1)%MP(2) == QX%MUNKNO .OR. MZ05(2)%MP(2) == QX%MUNKNO) THEN
          CALL ZMCOSH(MZ04,MZ01,QX)
          CALL ZMSINH(MZ04,MZ05,QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ05(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ05(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEQU(MZ05,MC,QX%NDIG,NDSAVE,QX)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      IF (QX%NTRACE /= 0) THEN
          IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL+1 <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL ZMNTRJ(MC,QX%NDIG,QX)
              ELSE
                  CALL ZMPRNT(MC,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMCHSH

      SUBROUTINE ZMCMPX(MAFM,MBFM,MC,QX)

!  MC = COMPLEX( MAFM , MBFM )

!  MAFM and MBFM are real FM numbers, MC is a complex ZM number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MAFM,MBFM,MC(2)
      INTENT (IN) :: MAFM,MBFM
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX


      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMCMPX'
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MAFM,MBFM,2,1,QX)

      CALL FMEQ(MAFM,MC(1),QX)
      CALL FMEQ(MBFM,MC(2),QX)

      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMCMPX

      SUBROUTINE ZMCONJ(MA,MB,QX)

!  MB = CONJG(MA)

!  Complex conjugate.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMCONJ'
      IF (QX%NTRACE /= 0) CALL ZMNTR(2,MA,MA,1,QX)

      CALL FMEQ(MA(1),MB(1),QX)
      CALL FMEQ(MA(2),MB(2),QX)
      IF (MB(2)%MP(2) /= QX%MUNKNO .AND. MB(2)%MP(3) /= 0)  &
          MB(2)%MP(1) = -MB(2)%MP(1)

      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMCONJ

      SUBROUTINE ZMCOS(MA,MB,QX)

!  MB = COS(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5),MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMCOS    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(1,MZ01,QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMCOS(MZ02(1),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMCOSH(MZ02(2),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ENDIF

!             Find COS(REAL(MA)) and SIN(REAL(MA)).

      CALL FMCSSN(MZ02(1),MZ01(1),MZ01(2),QX)

!             Find COSH(IMAG(MA)) and SINH(IMAG(MA)).

      CALL FMCHSH(MZ02(2),MXY(1),MXY(2),QX)

!             COS(MA) =  COS(REAL(MA))*COSH(IMAG(MA)) - SIN(REAL(MA))*SINH(IMAG(MA)) i

      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMABS(MZ01(1),MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMABS(MZ02(2),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(5),QX)
          CALL FMEXP(MXY(5),MXY(4),QX)
          IF (MZ01(1)%MP(1) < 0) CALL FMMPYI_R1(MXY(4),-1,QX)

          CALL FMABS(MZ01(2),MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(1),QX)
          CALL FMEXP(MXY(1),MXY(5),QX)
          IF (MZ02(2)%MP(1) > 0) CALL FMMPYI_R1(MXY(5),-1,QX)
          IF (MZ01(2)%MP(1) < 0) CALL FMMPYI_R1(MXY(5),-1,QX)

          CALL FMEQ(MXY(4),MZ01(1),QX)
          CALL FMEQ(MXY(5),MZ01(2),QX)
      ELSE
          CALL FMMPY_R1(MZ01(1),MXY(1),QX)
          IF (MXY(2)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(3) /= 0)  &
              MXY(2)%MP(1) = -MXY(2)%MP(1)
          CALL FMMPY_R1(MZ01(2),MXY(2),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMCOS

      SUBROUTINE ZMCOSH(MA,MB,QX)

!  MB = COSH(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5),MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMCOSH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(1,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMCOS(MZ02(2),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMCOSH(MZ02(1),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ENDIF

!             Find COS(IMAG(MA)) and SIN(IMAG(MA)).

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2),QX)

!             Find COSH(REAL(MA)) and SINH(REAL(MA)).

      CALL FMCHSH(MZ02(1),MXY(1),MXY(2),QX)

!             COSH(MA) =  COSH(REAL(MA))*COS(IMAG(MA)) + SINH(REAL(MA))*SIN(IMAG(MA)) i

      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMABS(MZ01(1),MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMABS(MZ02(1),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(5),QX)
          CALL FMEXP(MXY(5),MXY(4),QX)
          IF (MZ01(1)%MP(1) < 0) CALL FMMPYI_R1(MXY(4),-1,QX)

          CALL FMABS(MZ01(2),MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(1),QX)
          CALL FMEXP(MXY(1),MXY(5),QX)
          IF (MZ02(1)%MP(1) < 0) CALL FMMPYI_R1(MXY(5),-1,QX)
          IF (MZ01(2)%MP(1) < 0) CALL FMMPYI_R1(MXY(5),-1,QX)

          CALL FMEQ(MXY(4),MZ01(1),QX)
          CALL FMEQ(MXY(5),MZ01(2),QX)
      ELSE
          CALL FMMPY_R1(MZ01(1),MXY(1),QX)
          CALL FMMPY_R1(MZ01(2),MXY(2),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMCOSH

      SUBROUTINE ZMCSSN(MA,MB,MC,QX)

!  MB = COS(MA),    MC = SIN(MA).

!  If both the sine and cosine are needed, this routine is faster than calling both ZMCOS and ZMSIN.

!  MB and MC must be distinct arrays.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(MULTI) :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2)
      TYPE(FM_SETTINGS) :: QX


      NCSAVE = QX%NCALL
      CALL ZMENTR('ZMCSSN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      QX%NCALL = NCSAVE + 1
      IF (KRESLT /= 0) THEN
          CALL ZMEQ(MB,MC,QX)
          IF (QX%NTRACE /= 0) THEN
              CALL ZMNTR(1,MB,MB,1,QX)
              IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL <= QX%LVLTRC) THEN
                  IF (QX%NTRACE < 0) THEN
                      CALL ZMNTRJ(MC,QX%NDIG,QX)
                  ELSE
                      CALL ZMPRNT(MC,QX)
                  ENDIF
              ENDIF
          ENDIF
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(1,MZ01,QX)
          CALL ZMI2M(0,MZ05,QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMCSSN(MZ04(1),MZ01(1),MZ05(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          CALL FMI2M(0,MZ05(2),QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMCHSH(MZ04(2),MZ01(1),MZ05(2),QX)
          CALL FMI2M(0,MZ01(2),QX)
          CALL FMI2M(0,MZ05(1),QX)
          GO TO 120
      ENDIF

!             Find SIN(REAL(MA)) and COS(REAL(MA)).

      CALL FMCSSN(MZ04(1),MZ02(1),MZ02(2),QX)

!             Find SINH(IMAG(MA)) and COSH(IMAG(MA)).

      CALL FMCHSH(MZ04(2),MZ03(1),MZ03(2),QX)

!             COS(MA) =  COS(REAL(MA))*COSH(IMAG(MA)) - SIN(REAL(MA))*SINH(IMAG(MA)) i

      CALL FMMPY(MZ02(1),MZ03(1),MZ01(1),QX)
      CALL FMMPY(MZ02(2),MZ03(2),MZ01(2),QX)
      IF (MZ01(2)%MP(2) /= QX%MUNKNO .AND. MZ01(2)%MP(3) /= 0)  &
          MZ01(2)%MP(1) = -MZ01(2)%MP(1)

!             SIN(MA) =  SIN(REAL(MA))*COSH(IMAG(MA)) + COS(REAL(MA))*SINH(IMAG(MA)) i

      CALL FMMPY(MZ02(2),MZ03(1),MZ05(1),QX)
      CALL FMMPY(MZ02(1),MZ03(2),MZ05(2),QX)

      IF (MZ05(1)%MP(2) == QX%MUNKNO .OR. MZ05(2)%MP(2) == QX%MUNKNO) THEN
          CALL ZMCOS(MZ04,MZ01,QX)
          CALL ZMSIN(MZ04,MZ05,QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ05(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ05(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEQU(MZ05,MC,QX%NDIG,NDSAVE,QX)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      IF (QX%NTRACE /= 0) THEN
          IF (ABS(QX%NTRACE) >= 1 .AND. QX%NCALL+1 <= QX%LVLTRC) THEN
              IF (QX%NTRACE < 0) THEN
                  CALL ZMNTRJ(MC,QX%NDIG,QX)
              ELSE
                  CALL ZMPRNT(MC,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMCSSN

      SUBROUTINE ZMDIV(MA,MB,MC,QX)

!  MC = MA / MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MAXEXP,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NTRSAV
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(8),MZ01(2),MZ02(2)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX


      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          ABS(MB(1)%MP(2)) > QX%MEXPAB .OR. ABS(MB(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          CALL ZMENTR('ZMDIV    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMDIV'
              CALL ZMNTR(2,MA,MB,2,QX)
          ENDIF
          NDSAVE = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+QX%NGRD52,2)
          IF (QX%MBASE >= 100*ABS(MA(1)%MP(3)) .OR. QX%MBASE >= 100*ABS(MA(2)%MP(3))) THEN
              QX%NDIG = QX%NDIG + 1
          ELSE IF (QX%MBASE >= 100*ABS(MB(1)%MP(3)) .OR.  &
              QX%MBASE >= 100*ABS(MB(2)%MP(3))) THEN
              QX%NDIG = QX%NDIG + 1
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
          KOVUN = 0
      ENDIF

      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      KR_RETRY = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA(1),MXY(5),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MA(2),MXY(6),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB(1),MXY(7),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB(2),MXY(8),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(2) == MB(1)%MP(2) .AND.  &
          MA(1)%MP(3) == MB(1)%MP(3) .AND.  &
          MA(1)%MP(1) == MB(1)%MP(1)) THEN
          IF (MA(2)%MP(2) == MB(2)%MP(2) .AND.  &
              MA(2)%MP(3) == MB(2)%MP(3) .AND.  &
              MA(2)%MP(1) == MB(2)%MP(1)) THEN
              DO J = 3, NDSAVE+1
                 IF (MA(1)%MP(J+1) /= MB(1)%MP(J+1)) GO TO 120
                 IF (MA(2)%MP(J+1) /= MB(2)%MP(J+1)) GO TO 120
              ENDDO
              IF (ABS(MA(1)%MP(2)) < QX%MEXPOV .AND. ABS(MA(2)%MP(2)) < QX%MEXPOV  &
                  .AND. ABS(MB(1)%MP(2)) < QX%MEXPOV .AND.                         &
                  ABS(MB(2)%MP(2)) < QX%MEXPOV) THEN
                  CALL ZMI2M(1,MZ01,QX)
                  GO TO 140
              ENDIF
          ENDIF
      ENDIF
      IF (MA(1)%MP(2) == MB(1)%MP(2) .AND.  &
          MA(1)%MP(3) == MB(1)%MP(3) .AND.  &
          (-MA(1)%MP(1)) == MB(1)%MP(1)) THEN
          IF (MA(2)%MP(2) == MB(2)%MP(2) .AND.  &
              MA(2)%MP(3) == MB(2)%MP(3) .AND.  &
              (-MA(2)%MP(1)) == MB(2)%MP(1)) THEN
              DO J = 3, NDSAVE+1
                 IF (MA(1)%MP(J+1) /= MB(1)%MP(J+1)) GO TO 120
                 IF (MA(2)%MP(J+1) /= MB(2)%MP(J+1)) GO TO 120
              ENDDO
              IF (ABS(MA(1)%MP(2)) < QX%MEXPOV .AND. ABS(MA(2)%MP(2)) < QX%MEXPOV  &
                  .AND. ABS(MB(1)%MP(2)) < QX%MEXPOV .AND.                         &
                  ABS(MB(2)%MP(2)) < QX%MEXPOV) THEN
                  CALL ZMI2M(-1,MZ01,QX)
                  GO TO 140
              ENDIF
          ENDIF
      ENDIF
  120 IF (MXY(5)%MP(2) == QX%MEXPUN .OR. MXY(6)%MP(2) == QX%MEXPUN .OR.  &
          MXY(7)%MP(2) == QX%MEXPUN .OR. MXY(8)%MP(2) == QX%MEXPUN .OR.  &
          MXY(5)%MP(2) == QX%MEXPOV .OR. MXY(6)%MP(2) == QX%MEXPOV .OR.  &
          MXY(7)%MP(2) == QX%MEXPOV .OR. MXY(8)%MP(2) == QX%MEXPOV ) THEN
          CALL ZMI2M(0,MZ01,QX)
          CALL ZMDIV_UNOV(MXY(5),MXY(6),MXY(7),MXY(8),MZ01,QX)
          GO TO 140
      ENDIF

!             Method for  ( a + b i ) / ( c + d i ):

!             If  abs(c) <= abs(d)  Then

!                 P = c / d
!                 result = ( a*P + b )/( c*P + d ) + ( b*P - a )/( c*P + d ) i

!             Else

!                 P = d / c
!                 result = ( b*P + a )/( d*P + c ) + ( b - a*P )/( d*P + c ) i


      IF (MXY(7)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(4),QX)
          J = 1
      ELSE IF (MXY(8)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(4),QX)
          J = 2
      ELSE IF (MXY(7)%MP(2) < MXY(8)%MP(2)) THEN
          CALL FMDIV(MXY(7),MXY(8),MXY(4),QX)
          J = 1
      ELSE IF (MXY(8)%MP(2) < MXY(7)%MP(2)) THEN
          CALL FMDIV(MXY(8),MXY(7),MXY(4),QX)
          J = 2
      ELSE IF (MXY(7)%MP(3) < MXY(8)%MP(3)) THEN
          CALL FMDIV(MXY(7),MXY(8),MXY(4),QX)
          J = 1
      ELSE IF (MXY(8)%MP(3) < MXY(7)%MP(3)) THEN
          CALL FMDIV(MXY(8),MXY(7),MXY(4),QX)
          J = 2
      ELSE IF (MXY(7)%MP(4) < MXY(8)%MP(4)) THEN
          CALL FMDIV(MXY(7),MXY(8),MXY(4),QX)
          J = 1
      ELSE IF (MXY(8)%MP(4) < MXY(7)%MP(4)) THEN
          CALL FMDIV(MXY(8),MXY(7),MXY(4),QX)
          J = 2
      ELSE IF (FMCOMP(MXY(7),'<=',MXY(8),QX)) THEN
          CALL FMDIV(MXY(7),MXY(8),MXY(4),QX)
          J = 1
      ELSE
          CALL FMDIV(MXY(8),MXY(7),MXY(4),QX)
          J = 2
      ENDIF

      IF (J == 1) THEN
          CALL FMDIV(MXY(7),MXY(8),MXY(4),QX)
          CALL FMMPYE(MXY(4),MXY(5),MXY(6),MXY(7),MZ01(1),MZ01(2),MXY(3),QX)
          CALL FMADD_R1(MXY(3),MXY(8),QX)
          MAXEXP = MAX(MXY(6)%MP(2),MZ01(1)%MP(2))
          CALL FMADD_R2(MXY(6),MZ01(1),QX)
          IF (MZ01(1)%MP(2) < MAXEXP) GO TO 130
          MAXEXP = MAX(MZ01(2)%MP(2),MXY(5)%MP(2))
          CALL FMSUB_R1(MZ01(2),MXY(5),QX)
          IF (MZ01(2)%MP(2) < MAXEXP) GO TO 130
          CALL FMDIVD(MZ01(1),MZ01(2),MXY(3),MZ02(1),MZ02(2),QX)
          CALL ZMEQ(MZ02,MZ01,QX)
          GO TO 140
      ELSE
          CALL FMDIV(MXY(8),MXY(7),MXY(4),QX)
          CALL FMMPYE(MXY(4),MXY(6),MXY(5),MXY(8), MZ01(1),MZ01(2),MXY(3),QX)
          CALL FMADD_R1(MXY(3),MXY(7),QX)
          MAXEXP = MAX(MXY(5)%MP(2),MZ01(1)%MP(2))
          CALL FMADD_R2(MXY(5),MZ01(1),QX)
          IF (MZ01(1)%MP(2) < MAXEXP) GO TO 130
          MAXEXP = MAX(MZ01(2)%MP(2),MXY(6)%MP(2))
          CALL FMSUB_R2(MXY(6),MZ01(2),QX)
          IF (MZ01(2)%MP(2) < MAXEXP) GO TO 130
          CALL FMDIVD(MZ01(1),MZ01(2),MXY(3),MZ02(1),MZ02(2),QX)
          CALL ZMEQ(MZ02,MZ01,QX)
          GO TO 140
      ENDIF

!             When there was cancellation error above, raise precision and use
!             the more stable formula.
!             ( a*c + b*d ) / ( c*c + d*d ) + ( b*c - a*d ) / ( c*c + d*d ) i

  130 IF (2*QX%NDIG <= NDIG_MAX) THEN
          CALL FMEQU_R1(MXY(5),QX%NDIG,2*QX%NDIG,QX)
          CALL FMEQU_R1(MXY(6),QX%NDIG,2*QX%NDIG,QX)
          CALL FMEQU_R1(MXY(7),QX%NDIG,2*QX%NDIG,QX)
          CALL FMEQU_R1(MXY(8),QX%NDIG,2*QX%NDIG,QX)
          QX%NDIG = 2*QX%NDIG
      ENDIF
      CALL FMMPYE(MXY(7),MXY(5),MXY(6),MXY(7), MZ01(1),MZ01(2),MXY(3),QX)
      CALL FMMPYE(MXY(8),MXY(6),MXY(5),MXY(8), MXY(1),MXY(2),MXY(4),QX)
      CALL FMADD_R2(MXY(3),MXY(4),QX)
      CALL FMADD_R1(MZ01(1),MXY(1),QX)
      CALL FMSUB_R1(MZ01(2),MXY(2),QX)
      CALL FMDIVD(MZ01(1),MZ01(2),MXY(4),MZ02(1),MZ02(2),QX)
      CALL ZMEQ(MZ02,MZ01,QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  140 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      QX%MXEXP = MXSAVE
      QX%NTRACE = NTRSAV
      NDGSV2 = QX%NDIG
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      CALL ZMEQU(MZ01,MC,NDGSV2,NDSAVE,QX)
      IF (MC(1)%MP(2) >= QX%MEXPOV .OR. MC(1)%MP(2) <= -QX%MEXPOV .OR.  &
          MC(2)%MP(2) >= QX%MEXPOV .OR. MC(2)%MP(2) <= -QX%MEXPOV) THEN
          IF (MC(1)%MP(2) == QX%MUNKNO .OR. MC(2)%MP(2) == QX%MUNKNO) THEN
              QX%KFLAG = -4
          ELSE IF (MC(1)%MP(2) == QX%MEXPOV .OR. MC(2)%MP(2) == QX%MEXPOV) THEN
              QX%KFLAG = -5
          ELSE IF (MC(1)%MP(2) == QX%MEXPUN .OR. MC(2)%MP(2) == QX%MEXPUN) THEN
              QX%KFLAG = -6
          ENDIF
          IF ((MC(1)%MP(2) == QX%MUNKNO) .OR. (MC(2)%MP(2) == QX%MUNKNO)  &
             .OR. (MC(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
             .OR. (MC(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
             .OR. (MC(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
             .OR. (MC(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
                  QX%NAMEST(QX%NCALL) = 'ZMDIV'
                  CALL ZMWARN(QX)
          ENDIF
      ENDIF
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMDIV

      SUBROUTINE ZMDIV_UNOV(MA,MB,MC,MD,MZ,QX)

!  Check special cases where at least one of MA, MB, MC, MD is underflow or overflow.

!  Return MZ as the result.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC,MD,MZ(2)
      INTENT (INOUT) :: MZ
      INTENT (IN) :: MA,MB,MC,MD
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(12), MZ01(2)
      INTEGER :: K_EPS, KS, N_OV
      REAL (KIND(1.0D0)) :: M_EXPUN, M_EXPOV, M_L1, M_L2, M_R1, M_R2
      LOGICAL, EXTERNAL :: FMCOMP

      M_EXPUN = -AINT( MAX_EXPONENT / 2.01D0 + 0.5D0 ) - 1
      M_EXPOV = AINT( MAX_EXPONENT / 2.01D0 + 0.5D0 ) + 2
      N_OV = 0
      IF (MA%MP(2) == QX%MEXPOV) THEN
          N_OV = 1
          IF (MB%MP(2) >= M_EXPOV-QX%NDIG) THEN
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
              GO TO 110
          ENDIF
      ENDIF
      IF (MB%MP(2) == QX%MEXPOV) THEN
          IF (N_OV == 0) THEN
              N_OV = 2
              IF (MA%MP(2) >= M_EXPOV-QX%NDIG) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
          ELSE
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
              GO TO 110
          ENDIF
      ENDIF
      IF (MC%MP(2) == QX%MEXPOV) THEN
          IF (N_OV == 0) THEN
              N_OV = 3
              IF (MD%MP(2) >= M_EXPOV-QX%NDIG) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
          ELSE
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
              GO TO 110
          ENDIF
      ENDIF
      IF (MD%MP(2) == QX%MEXPOV) THEN
          IF (N_OV == 0) THEN
              N_OV = 4
              IF (MC%MP(2) >= M_EXPOV-QX%NDIG) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
          ELSE
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
              GO TO 110
          ENDIF
      ENDIF
      IF (N_OV > 0) THEN
          IF (N_OV <= 2) THEN
              CALL FMST2M('OVERFLOW',MXY(2),QX)
              CALL FMSQR(MC,MXY(4),QX)
              CALL FMSQR(MD,MXY(5),QX)
              CALL FMADD(MXY(4),MXY(5),MXY(6),QX)
              CALL FMSQRT(MXY(6),MXY(3),QX)
          ELSE
              CALL FMST2M('OVERFLOW',MXY(3),QX)
              CALL FMSQR(MA,MXY(4),QX)
              CALL FMSQR(MB,MXY(5),QX)
              CALL FMADD(MXY(4),MXY(5),MXY(6),QX)
              CALL FMSQRT(MXY(6),MXY(2),QX)
          ENDIF
          CALL FMDIV(MXY(2),MXY(3),MXY(1),QX)
          IF (MXY(1)%MP(2) == QX%MUNKNO) THEN
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
              GO TO 110
          ENDIF
          IF (N_OV <= 2) THEN
              IF (N_OV == 1) THEN
                  IF (MA%MP(1) == 1) THEN
                      CALL FMI2M(0,MXY(3),QX)
                      IF (MB%MP(1) ==  1) K_EPS =  1
                      IF (MB%MP(1) == -1) K_EPS = -1
                      IF (MB%MP(3) == 0) K_EPS = 0
                  ELSE
                      CALL FMI2M(180,MXY(3),QX)
                      IF (MB%MP(1) ==  1) K_EPS = -1
                      IF (MB%MP(1) == -1) K_EPS =  1
                      IF (MB%MP(3) == 0) K_EPS = 0
                  ENDIF
              ELSE
                  IF (MB%MP(1) == 1) THEN
                      CALL FMI2M(90,MXY(3),QX)
                      IF (MA%MP(1) ==  1) K_EPS = -1
                      IF (MA%MP(1) == -1) K_EPS =  1
                      IF (MA%MP(3) == 0) K_EPS = 0
                  ELSE
                      CALL FMI2M(-90,MXY(3),QX)
                      IF (MA%MP(1) ==  1) K_EPS =  1
                      IF (MA%MP(1) == -1) K_EPS = -1
                      IF (MA%MP(3) == 0) K_EPS = 0
                  ENDIF
              ENDIF
              CALL FMEQ(MC,MZ01(1),QX)
              CALL FMEQ(MD,MZ01(2),QX)
              KS = QX%KRAD
              QX%KRAD = 0
              CALL ZMARG(MZ01,MXY(4),QX)
              QX%KRAD = KS
              CALL FMSUB(MXY(3),MXY(4),MXY(2),QX)
          ELSE
              IF (N_OV == 3) THEN
                  IF (MC%MP(1) == 1) THEN
                      CALL FMI2M(0,MXY(4),QX)
                      IF (MD%MP(1) ==  1) K_EPS = -1
                      IF (MD%MP(1) == -1) K_EPS =  1
                      IF (MD%MP(3) == 0) K_EPS = 0
                  ELSE
                      CALL FMI2M(180,MXY(4),QX)
                      IF (MD%MP(1) ==  1) K_EPS =  1
                      IF (MD%MP(1) == -1) K_EPS = -1
                      IF (MD%MP(3) == 0) K_EPS = 0
                  ENDIF
              ELSE
                  IF (MB%MP(1) == 1) THEN
                      CALL FMI2M(90,MXY(4),QX)
                      IF (MC%MP(1) ==  1) K_EPS =  1
                      IF (MC%MP(1) == -1) K_EPS = -1
                      IF (MC%MP(3) == 0) K_EPS = 0
                  ELSE
                      CALL FMI2M(-90,MXY(4),QX)
                      IF (MC%MP(1) ==  1) K_EPS = -1
                      IF (MC%MP(1) == -1) K_EPS =  1
                      IF (MC%MP(3) == 0) K_EPS = 0
                  ENDIF
              ENDIF
              CALL FMEQ(MA,MZ01(1),QX)
              CALL FMEQ(MB,MZ01(2),QX)
              KS = QX%KRAD
              QX%KRAD = 0
              CALL ZMARG(MZ01,MXY(3),QX)
              QX%KRAD = KS
              CALL FMSUB(MXY(3),MXY(4),MXY(2),QX)
          ENDIF
          IF (MXY(2)%MP(1) < 0) THEN
              CALL FMI2M(360,MXY(5),QX)
              CALL FMADD_R1(MXY(2),MXY(5),QX)
          ENDIF
          CALL FMI2M(0,MXY(5),QX)
          IF (FMCOMP(MXY(2),'==',MXY(5),QX)) THEN
              IF (K_EPS == -1) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('OVERFLOW-OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('UNDERFLOW-UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
              IF (K_EPS == 0) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('OVERFLOW',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('UNDERFLOW',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
              IF (K_EPS == 1) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('OVERFLOW+OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('UNDERFLOW+UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
          CALL FMI2M(90,MXY(5),QX)
          IF (FMCOMP(MXY(2),'==',MXY(5),QX)) THEN
              IF (K_EPS == -1) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('OVERFLOW+OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('UNDERFLOW+UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
              IF (K_EPS == 0) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('0.0+OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('0.0+UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
              IF (K_EPS == 1) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('-OVERFLOW+OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('-UNDERFLOW+UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
          CALL FMI2M(180,MXY(5),QX)
          IF (FMCOMP(MXY(2),'==',MXY(5),QX)) THEN
              IF (K_EPS == -1) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('-OVERFLOW+OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('-UNDERFLOW+UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
              IF (K_EPS == 0) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('-OVERFLOW',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('-UNDERFLOW',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
              IF (K_EPS == 1) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('-OVERFLOW-OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('-UNDERFLOW-UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
          CALL FMI2M(270,MXY(5),QX)
          IF (FMCOMP(MXY(2),'==',MXY(5),QX)) THEN
              IF (K_EPS == -1) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('-OVERFLOW-OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('-UNDERFLOW-UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
              IF (K_EPS == 0) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('0.0-OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('0.0-UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
              IF (K_EPS == 1) THEN
                  IF (N_OV <= 2) THEN
                      CALL ZMST2M('OVERFLOW-OVERFLOW*i',MZ,QX)
                      GO TO 110
                  ELSE
                      CALL ZMST2M('UNDERFLOW-UNDERFLOW*i',MZ,QX)
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
          CALL FMI2M(90,MXY(5),QX)
          IF (FMCOMP(MXY(2),'<=',MXY(5),QX)) THEN
              IF (N_OV <= 2) THEN
                  CALL ZMST2M('OVERFLOW+OVERFLOW*i',MZ,QX)
                  GO TO 110
              ELSE
                  CALL ZMST2M('UNDERFLOW+UNDERFLOW*i',MZ,QX)
                  GO TO 110
              ENDIF
          ENDIF
          CALL FMI2M(90,MXY(5),QX)
          IF (FMCOMP(MXY(2),'<=',MXY(5),QX)) THEN
              IF (N_OV <= 2) THEN
                  CALL ZMST2M('OVERFLOW+OVERFLOW*i',MZ,QX)
                  GO TO 110
              ELSE
                  CALL ZMST2M('UNDERFLOW+UNDERFLOW*i',MZ,QX)
                  GO TO 110
              ENDIF
          ENDIF
          CALL FMI2M(90,MXY(5),QX)
          IF (FMCOMP(MXY(2),'<=',MXY(5),QX)) THEN
              IF (N_OV <= 2) THEN
                  CALL ZMST2M('OVERFLOW+OVERFLOW*i',MZ,QX)
                  GO TO 110
              ELSE
                  CALL ZMST2M('UNDERFLOW+UNDERFLOW*i',MZ,QX)
                  GO TO 110
              ENDIF
          ENDIF
      ENDIF
      CALL FMSQR(MC,MXY(1),QX)
      CALL FMSQR(MD,MXY(2),QX)
      CALL FMMPY(MA,MC,MXY(3),QX)
      CALL FMMPY(MB,MD,MXY(4),QX)
      CALL FMMPY(MB,MC,MXY(5),QX)
      CALL FMMPY(MA,MD,MXY(6),QX)
      CALL FMMPYI_R1(MXY(6),-1,QX)
      CALL FMADD(MXY(1),MXY(2),MXY(7),QX)
      IF (MXY(7)%MP(2) == QX%MUNKNO) THEN
          CALL FMST2M('UNDERFLOW',MXY(7),QX)
      ENDIF

      CALL FMADD(MXY(3),MXY(4),MXY(8),QX)
      IF (MXY(8)%MP(2) == QX%MUNKNO .AND. MXY(3)%MP(3) /= 0 .AND.  &
          MXY(4)%MP(3) /= 0) THEN
          IF (MXY(3)%MP(2) == QX%MUNKNO) THEN
              IF (MA%MP(2) == QX%MEXPUN .AND. MC%MP(2) == QX%MEXPOV) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
              IF (MA%MP(2) == QX%MEXPOV .AND. MC%MP(2) == QX%MEXPUN) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
          ENDIF
          IF (MXY(3)%MP(2) == QX%MUNKNO) THEN
              IF (MB%MP(2) == QX%MEXPUN .AND. MD%MP(2) == QX%MEXPOV) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
              IF (MB%MP(2) == QX%MEXPOV .AND. MD%MP(2) == QX%MEXPUN) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
          ENDIF
          M_L1 = MAX( MIN( MA%MP(2) , M_EXPOV) , M_EXPUN )
          M_L2 = MAX( MIN( MC%MP(2) , M_EXPOV) , M_EXPUN )
          M_R1 = MAX( MIN( MB%MP(2) , M_EXPOV) , M_EXPUN )
          M_R2 = MAX( MIN( MD%MP(2) , M_EXPOV) , M_EXPUN )
          IF (M_L1+M_L2+QX%NDIG < M_R1+M_R2) THEN
              CALL FMEQ(MXY(4),MXY(8),QX)
          ELSE IF (M_R1+M_R2+QX%NDIG < M_L1+M_L2) THEN
              CALL FMEQ(MXY(3),MXY(8),QX)
          ELSE
              IF (MA%MP(1)*MC%MP(1) == MB%MP(1)*MD%MP(1)) THEN
                  IF ( (MA%MP(2) == QX%MEXPOV .OR. MC%MP(2) == QX%MEXPOV) .AND.  &
                       (MB%MP(2) == QX%MEXPOV .OR. MD%MP(2) == QX%MEXPOV) ) THEN
                      IF (MA%MP(2) == QX%MEXPOV) THEN
                          CALL FMABS(MC,MXY(10),QX)
                      ELSE
                          CALL FMABS(MA,MXY(10),QX)
                      ENDIF
                      IF (MB%MP(2) == QX%MEXPOV) THEN
                          CALL FMABS(MD,MXY(11),QX)
                      ELSE
                          CALL FMABS(MB,MXY(11),QX)
                      ENDIF
                      CALL FMADD(MXY(10),MXY(11),MXY(12),QX)
                      IF (MXY(12)%MP(2) >= 1) THEN
                          CALL FMST2M('OVERFLOW',MXY(8),QX)
                          MXY(8)%MP(1) = MA%MP(1)*MC%MP(1)
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

      CALL FMADD(MXY(5),MXY(6),MXY(9),QX)
      IF (MXY(9)%MP(2) == QX%MUNKNO .AND. MXY(5)%MP(3) /= 0 .AND.  &
          MXY(6)%MP(3) /= 0) THEN
          IF (MXY(5)%MP(2) == QX%MUNKNO) THEN
              IF (MB%MP(2) == QX%MEXPUN .AND. MC%MP(2) == QX%MEXPOV) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
              IF (MB%MP(2) == QX%MEXPOV .AND. MC%MP(2) == QX%MEXPUN) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
          ENDIF
          IF (MXY(5)%MP(2) == QX%MUNKNO) THEN
              IF (MA%MP(2) == QX%MEXPUN .AND. MD%MP(2) == QX%MEXPOV) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
              IF (MA%MP(2) == QX%MEXPOV .AND. MD%MP(2) == QX%MEXPUN) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ,QX)
                  GO TO 110
              ENDIF
          ENDIF
          M_L1 = MAX( MIN( MB%MP(2) , M_EXPOV) , M_EXPUN )
          M_L2 = MAX( MIN( MC%MP(2) , M_EXPOV) , M_EXPUN )
          M_R1 = MAX( MIN( MA%MP(2) , M_EXPOV) , M_EXPUN )
          M_R2 = MAX( MIN( MD%MP(2) , M_EXPOV) , M_EXPUN )
          IF (M_L1+M_L2+QX%NDIG < M_R1+M_R2) THEN
              CALL FMEQ(MXY(6),MXY(9),QX)
          ELSE IF (M_R1+M_R2+QX%NDIG < M_L1+M_L2) THEN
              CALL FMEQ(MXY(5),MXY(9),QX)
          ELSE
              IF (MB%MP(1)*MC%MP(1) == -MA%MP(1)*MD%MP(1)) THEN
                  IF ( (MB%MP(2) == QX%MEXPOV .OR. MC%MP(2) == QX%MEXPOV) .AND.  &
                       (MA%MP(2) == QX%MEXPOV .OR. MD%MP(2) == QX%MEXPOV) ) THEN
                      IF (MB%MP(2) == QX%MEXPOV) THEN
                          CALL FMABS(MC,MXY(10),QX)
                      ELSE
                          CALL FMABS(MB,MXY(10),QX)
                      ENDIF
                      IF (MA%MP(2) == QX%MEXPOV) THEN
                          CALL FMABS(MD,MXY(11),QX)
                      ELSE
                          CALL FMABS(MA,MXY(11),QX)
                      ENDIF
                      CALL FMADD(MXY(10),MXY(11),MXY(12),QX)
                      IF (MXY(12)%MP(2) >= 1) THEN
                          CALL FMST2M('OVERFLOW',MXY(9),QX)
                          MXY(9)%MP(1) = MB%MP(1)*MC%MP(1)
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

      CALL FMDIV(MXY(8),MXY(7),MZ(1),QX)
      CALL FMDIV(MXY(9),MXY(7),MZ(2),QX)

  110 RETURN
      END SUBROUTINE ZMDIV_UNOV

      SUBROUTINE ZMDIV_R1(MA,MB,QX)

!  MA = MA / MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMDIV(MA,MB,MXY,QX)
      CALL ZMEQ(MXY,MA,QX)


      END SUBROUTINE ZMDIV_R1

      SUBROUTINE ZMDIV_R2(MA,MB,QX)

!  MB = MA / MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMDIV(MA,MB,MXY,QX)
      CALL ZMEQ(MXY,MB,QX)


      END SUBROUTINE ZMDIV_R2

      SUBROUTINE ZMDIVI(MA,INTEG,MB,QX)

!  MB = MA / INTEG        Divide by one-word (real) integer.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTEGER :: INTEG
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB


      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          NTRSAV = QX%NTRACE
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'ZMDIVI'
              CALL ZMNTR(2,MA,MA,1,QX)
              CALL FMNTRI(2,INTEG,0,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          QX%NTRACE = 0
          CALL ZMENTR('ZMDIVI   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          QX%NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
          QX%NDIG = NDSAVE
          QX%MXEXP = MXSAVE
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMDIVI'
              CALL ZMNTR(2,MA,MA,1,QX)
              CALL FMNTRI(2,INTEG,0,QX)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMDIVI to use more guard digits for user calls.

      QX%NCALL = QX%NCALL - 1
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0

      CALL FMDIVI(MA(1),INTEG,MB(1),QX)
      CALL FMDIVI(MA(2),INTEG,MB(2),QX)

      QX%NTRACE = NTRSAV
      QX%KWARN = KWRNSV
      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) QX%NAMEST(QX%NCALL) = 'ZMDIVI'
      IF (MB(1)%MP(2) == QX%MUNKNO .OR. MB(2)%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
      ELSE IF (MB(1)%MP(2) == QX%MEXPOV .OR. MB(2)%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
      ELSE IF (MB(1)%MP(2) == QX%MEXPUN .OR. MB(2)%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -6
      ENDIF
      IF ((MB(1)%MP(2) == QX%MUNKNO) .OR. (MB(2)%MP(2) == QX%MUNKNO)  &
         .OR. (MB(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MB(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MB(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
         .OR. (MB(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
          QX%NAMEST(QX%NCALL) = 'ZMDIVI'
          CALL ZMWARN(QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMDIVI

      SUBROUTINE ZMDIVI_R1(MA,IVAL,QX)

!  MA = MA / IVAL

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMDIVI(MA,IVAL,MXY,QX)
      CALL ZMEQ(MXY,MA,QX)


      END SUBROUTINE ZMDIVI_R1

      SUBROUTINE ZMENTR(NROUTN,MA,MB,NARGS,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)

!  Do the argument checking and increasing of precision, overflow threshold, etc., upon entry to
!  a ZM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result immediately
!           (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow or underflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NARGS,KRESLT,NDSAVE,KOVUN
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: J,KWRNSV,NDS
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      KRESLT = 0
      QX%NCALL = QX%NCALL + 1
      QX%KFLAG = 0
      QX%NAMEST(QX%NCALL) = NROUTN
      IF (QX%NTRACE /= 0) CALL ZMNTR(2,MA,MB,NARGS,QX)

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      KOVUN = 0
      IF (MA(1)%MP(2) == QX%MEXPOV .OR. MA(1)%MP(2) == QX%MEXPUN .OR.  &
          MA(2)%MP(2) == QX%MEXPOV .OR. MA(2)%MP(2) == QX%MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MB(1)%MP(2) == QX%MEXPOV .OR. MB(1)%MP(2) == QX%MEXPUN .OR.  &
          MB(2)%MP(2) == QX%MEXPOV .OR. MB(2)%MP(2) == QX%MEXPUN) KOVUN = 1
      ENDIF
      MXSAVE = QX%MXEXP

!             Check the validity of parameters if this is a user call.

      IF (QX%NCALL > 1 .AND. QX%KDEBUG == 0) GO TO 130

!             Check NDIG.

      IF (QX%NDIG < 2) THEN
          QX%KFLAG = -1
          CALL ZMWARN(QX)
          NDS = QX%NDIG
          IF (QX%NDIG < 2) QX%NDIG = 2
          WRITE (KW,                                                      &
                 "(' NDIG was',I10,'.  It has been changed to',I10,'.')"  &
                ) NDS,QX%NDIG
          KRESLT = 12
          GO TO 130
      ENDIF

!             Check MBASE.

      IF (QX%MBASE < 2 .OR. QX%MBASE > MXBASE) THEN
          QX%KFLAG = -2
          CALL ZMWARN(QX)
          MBS = QX%MBASE
          IF (QX%MBASE < 2) QX%MBASE = 2
          IF (QX%MBASE > MXBASE) QX%MBASE = MXBASE
          WRITE (KW,                                                       &
                 "(' MBASE was',I10,'.  It has been changed to',I10,'.')"  &
                ) INT(MBS),INT(QX%MBASE)
          CALL FMCONS(QX)
          KRESLT = 12
          GO TO 130
      ENDIF

!             Check exponent range.

      IF (MA(1)%MP(2) > QX%MXEXP+1 .OR. MA(1)%MP(2) < -QX%MXEXP) THEN
          IF ((ABS(MA(1)%MP(2)) /= QX%MEXPOV .AND. ABS(MA(1)%MP(2)) /= QX%MUNKNO) .OR.  &
              ABS(MA(1)%MP(3)) /= 1) THEN
              QX%KFLAG = -3
              CALL ZMWARN(QX)
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF
      IF (MA(2)%MP(2) > QX%MXEXP+1 .OR. MA(2)%MP(2) < -QX%MXEXP) THEN
          IF ((ABS(MA(2)%MP(2)) /= QX%MEXPOV .AND. ABS(MA(2)%MP(2)) /= QX%MUNKNO) .OR.  &
              ABS(MA(2)%MP(3)) /= 1) THEN
              QX%KFLAG = -3
              CALL ZMWARN(QX)
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MB(1)%MP(2) > QX%MXEXP+1 .OR. MB(1)%MP(2) < -QX%MXEXP) THEN
              IF ((ABS(MB(1)%MP(2)) /= QX%MEXPOV .AND.  &
                   ABS(MB(1)%MP(2)) /= QX%MUNKNO) .OR. ABS(MB(1)%MP(3)) /= 1) THEN
                  QX%KFLAG = -3
                  CALL ZMWARN(QX)
                  KRESLT = 12
                  GO TO 130
              ENDIF
          ENDIF
          IF (MB(2)%MP(2) > QX%MXEXP+1 .OR. MB(2)%MP(2) < -QX%MXEXP) THEN
              IF ((ABS(MB(2)%MP(2)) /= QX%MEXPOV .AND.  &
                   ABS(MB(2)%MP(2)) /= QX%MUNKNO) .OR. ABS(MB(2)%MP(3)) /= 1) THEN
                  QX%KFLAG = -3
                  CALL ZMWARN(QX)
                  KRESLT = 12
                  GO TO 130
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MA(1)%MP(2)-INT(MA(1)%MP(2))) /= 0) QX%KFLAG = 1
      IF (ABS(MA(2)%MP(2)-INT(MA(2)%MP(2))) /= 0) QX%KFLAG = 1 + QX%NDIG + 1
      IF (MA(1)%MP(3) <= (-1) .OR. MA(1)%MP(3) >= QX%MBASE .OR.  &
          ABS(MA(1)%MP(3)-INT(MA(1)%MP(3))) /= 0) QX%KFLAG = 2
      IF (MA(2)%MP(3) <= (-1) .OR. MA(2)%MP(3) >= QX%MBASE .OR.  &
          ABS(MA(2)%MP(3)-INT(MA(2)%MP(3))) /= 0) QX%KFLAG = 2 + QX%NDIG + 1
      IF (QX%KDEBUG == 0) GO TO 110
      DO J = 3, QX%NDIG+1
         IF (MA(1)%MP(J+1) < 0 .OR. MA(1)%MP(J+1) >= QX%MBASE .OR.  &
             ABS(MA(1)%MP(J+1)-INT(MA(1)%MP(J+1))) /= 0) THEN
             QX%KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
      DO J = 3, QX%NDIG+1
         IF (MA(2)%MP(J+1) < 0 .OR. MA(2)%MP(J+1) >= QX%MBASE .OR.  &
             ABS(MA(2)%MP(J+1)-INT(MA(2)%MP(J+1))) /= 0) THEN
             QX%KFLAG = J + QX%NDIG + 1
             GO TO 110
         ENDIF
      ENDDO
  110 IF (QX%KFLAG /= 0) THEN
          J = QX%KFLAG
          QX%KFLAG = -4
          KWRNSV = QX%KWARN
          IF (QX%KWARN >= 2) QX%KWARN = 1
          CALL ZMWARN(QX)
          QX%KWARN = KWRNSV
          IF (QX%KWARN >= 1) THEN
              IF (J < QX%NDIG+1) THEN
                  WRITE (KW,*) ' First invalid array element:  MA(',  &
                               J,',1) = ',MA(1)%MP(J+1)
              ELSE
                  WRITE (KW,*) ' First invalid array element:  MA(',  &
                               J-QX%NDIG-1,',2) = ',MA(2)%MP(J+1)
              ENDIF
          ENDIF
          IF (QX%KWARN >= 2) THEN
              STOP
          ENDIF
          KRESLT = 12
          GO TO 130
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MB(1)%MP(2)-INT(MB(1)%MP(2))) /= 0) QX%KFLAG = 1
          IF (ABS(MB(2)%MP(2)-INT(MB(2)%MP(2))) /= 0) QX%KFLAG = 1 + QX%NDIG + 1
          IF (MB(1)%MP(3) <= (-1) .OR. MB(1)%MP(3) >= QX%MBASE .OR.  &
              ABS(MB(1)%MP(3)-INT(MB(1)%MP(3))) /= 0) QX%KFLAG = 2
          IF (MB(2)%MP(3) <= (-1) .OR. MB(2)%MP(3) >= QX%MBASE .OR.  &
              ABS(MB(2)%MP(3)-INT(MB(2)%MP(3))) /= 0) QX%KFLAG = 2 + QX%NDIG + 1
          IF (QX%KDEBUG == 0) GO TO 120
          DO J = 3, QX%NDIG+1
             IF (MB(1)%MP(J+1) < 0 .OR. MB(1)%MP(J+1) >= QX%MBASE .OR.  &
                 ABS(MB(1)%MP(J+1)-INT(MB(1)%MP(J+1))) /= 0) THEN
                 QX%KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
          DO J = 3, QX%NDIG+1
             IF (MB(2)%MP(J+1) < 0 .OR. MB(2)%MP(J+1) >= QX%MBASE .OR.  &
                 ABS(MB(2)%MP(J+1)-INT(MB(2)%MP(J+1))) /= 0) THEN
                 QX%KFLAG = J + QX%NDIG + 1
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (QX%KFLAG /= 0) THEN
              J = QX%KFLAG
              QX%KFLAG = -4
              KWRNSV = QX%KWARN
              IF (QX%KWARN >= 2) QX%KWARN = 1
              CALL ZMWARN(QX)
              QX%KWARN = KWRNSV
              IF (QX%KWARN >= 1) THEN
                  IF (J < QX%NDIG+1) THEN
                      WRITE (KW,*) ' First invalid array element:  MB(',  &
                                   J,',1) = ',MB(1)%MP(J+1)
                  ELSE
                      WRITE (KW,*) ' First invalid array element:  MB(',  &
                                   J-QX%NDIG-1,',2) = ',MB(2)%MP(J+1)
                  ENDIF
              ENDIF
              IF (QX%KWARN >= 2) THEN
                  STOP
              ENDIF
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF

!             Increase the working precision.

  130 NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          QX%NDIG = MAX(QX%NDIG+QX%NGRD52,2)
          IF (QX%MBASE >= 100*ABS(MA(1)%MP(3)) .OR. QX%MBASE >= 100*ABS(MA(2)%MP(3))) THEN
              QX%NDIG = QX%NDIG + 1
          ELSE IF (NARGS == 2 .AND. (QX%MBASE >= 100*ABS(MB(1)%MP(3)) .OR.  &
              QX%MBASE >= 100*ABS(MB(2)%MP(3)))) THEN
              QX%NDIG = QX%NDIG + 1
          ENDIF
      ENDIF
      IF ((MA(1)%MP(2) == QX%MUNKNO .AND. MA(2)%MP(2) == QX%MUNKNO) .OR.  &
          (MB(1)%MP(2) == QX%MUNKNO .AND. MB(2)%MP(2) == QX%MUNKNO)) THEN
          QX%KFLAG = -4
          KRESLT = 12
      ENDIF
      IF (KRESLT /= 0) THEN
          QX%NDIG = NDSAVE
          CALL ZMRSLT(MC,KRESLT,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MC,MC,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

!             Extend the overflow/underflow threshold.

      QX%MXEXP = QX%MXEXP2
      RETURN
      END SUBROUTINE ZMENTR

      SUBROUTINE ZMEQ(MA,MB,QX)

!  MB = MA

!  This is the standard form of equality, where MA and MB both have precision NDIG.
!  Use ZMEQU for assignments that also change precision.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      CALL FMEQ(MA(1),MB(1),QX)
      CALL FMEQ(MA(2),MB(2),QX)
      RETURN
      END SUBROUTINE ZMEQ

      SUBROUTINE ZMEQU(MA,MB,NDA,NDB,QX)

!  Set MB (having NDB digits) equal to MA (having NDA digits).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      CALL FMEQU(MA(1),MB(1),NDA,NDB,QX)
      CALL FMEQU(MA(2),MB(2),NDA,NDB,QX)
      RETURN
      END SUBROUTINE ZMEQU

      SUBROUTINE ZMEQU_R1(MA,NDA,NDB,QX)

!  Change precision of MA from NDA digits on input to NDB digits on output.

!  If NDB is less than NDA the result is rounded to NDB digits.

!  If NDB is greater than NDA the result has zero digits padded on the right.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      CALL FMEQU_R1(MA(1),NDA,NDB,QX)
      CALL FMEQU_R1(MA(2),NDA,NDB,QX)
      RETURN
      END SUBROUTINE ZMEQU_R1

      SUBROUTINE ZMEXIT(MT,MC,NDSAVE,MXSAVE,KOVUN,QX)

!  Upon exit from an ZM routine the result MT (having precision NDIG) is rounded and returned in
!  MC (having precision NDSAVE).
!  The values of NDIG, MXEXP, and KACCSW are restored to the values NDSAVE,MXSAVE.
!  KOVUN is nonzero if one of the routine's input arguments was overflow or underflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MT(2),MC(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KOVUN
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT
      INTENT (INOUT) :: MC,NDSAVE,MXSAVE,KOVUN

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      QX%MXEXP = MXSAVE
      KFSAVE = QX%KFLAG
      CALL ZMEQU(MT,MC,QX%NDIG,NDSAVE,QX)
      IF (QX%KFLAG /= -5 .AND. QX%KFLAG /= -6) QX%KFLAG = KFSAVE
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      IF (MC(1)%MP(2) == QX%MEXPUN .OR. MC(2)%MP(2) == QX%MEXPUN) QX%KFLAG = -6
      IF (MC(1)%MP(2) == QX%MEXPOV .OR. MC(2)%MP(2) == QX%MEXPOV) QX%KFLAG = -5
      IF (MC(1)%MP(2) == QX%MUNKNO .OR. MC(2)%MP(2) == QX%MUNKNO) THEN
          IF (QX%KFLAG /= -9) QX%KFLAG = -4
      ENDIF
      IF ((MC(1)%MP(2) == QX%MUNKNO .AND. QX%KFLAG /= -9) .OR.  &
          (MC(2)%MP(2) == QX%MUNKNO .AND. QX%KFLAG /= -9) .OR.  &
          (MC(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)  .OR.     &
          (MC(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)  .OR.     &
          (MC(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)  .OR.     &
          (MC(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) CALL ZMWARN(QX)
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMEXIT

      SUBROUTINE ZMEXI2(MXFM,MYFM,NDSAVE,MXSAVE,KOVUN,QX)

!  This routine is used upon exit for complex functions that return real FM results.
!  Round MXFM and return the result in MYFM.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MXFM,MYFM
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KOVUN
      INTENT (IN) :: MXFM
      INTENT (INOUT) :: MYFM,NDSAVE,MXSAVE,KOVUN
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFSAVE,KWRNSV

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      QX%MXEXP = MXSAVE
      KFSAVE = QX%KFLAG
      CALL FMEQU(MXFM,MYFM,QX%NDIG,NDSAVE,QX)
      IF (QX%KFLAG /= -5 .AND. QX%KFLAG /= -6) QX%KFLAG = KFSAVE
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      IF (MYFM%MP(2) == QX%MUNKNO) THEN
          IF (QX%KFLAG >= 0) QX%KFLAG = -4
      ELSE IF (MYFM%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
      ELSE IF (MYFM%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -6
      ENDIF
      IF ((MYFM%MP(2) == QX%MUNKNO .AND. QX%KFLAG /= -9)  &
         .OR. (MYFM%MP(2) == QX%MEXPUN .AND. KOVUN == 0)  &
         .OR. (MYFM%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) CALL ZMWARN(QX)
      IF (QX%NTRACE /= 0) CALL ZMNTR2(1,MYFM,MYFM,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMEXI2

      SUBROUTINE ZMEXP(MA,MB,QX)

!  MB = EXP(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,KWRNSV,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2),MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMEXP    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(1,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMI2M(1,MXY(1),QX)
      ELSE
          CALL FMEXP(MZ02(1),MXY(1),QX)
          IF (MA(2)%MP(3) == 0) THEN
              CALL FMEQ(MXY(1),MZ01(1),QX)
              CALL FMI2M(0,MZ01(2),QX)
              GO TO 120
          ENDIF
      ENDIF

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2),QX)

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMEQ(MZ02(1),MZ02(2),QX)
          CALL FMABS(MZ01(1),MXY(1),QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMADD_R2(MZ02(2),MXY(2),QX)
          CALL FMEXP(MXY(2),MZ02(1),QX)
          IF (MZ01(1)%MP(1) < 0) CALL FMMPYI_R1(MZ02(1),-1,QX)

          CALL FMABS(MZ01(2),MXY(1),QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMADD_R2(MZ02(2),MXY(2),QX)
          CALL FMEXP(MXY(2),MZ02(2),QX)
          IF (MZ01(2)%MP(1) < 0) CALL FMMPYI_R1(MZ02(2),-1,QX)
      ELSE
          CALL FMMPYD(MXY(1),MZ01(1),MZ01(2),MZ02(1),MZ02(2),QX)
      ENDIF
      CALL ZMEQ(MZ02,MZ01,QX)
      QX%KWARN = KWRNSV

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMEXP

      SUBROUTINE ZMFORM(FORM1,FORM2,MA,STRING,QX)

!  Convert MA to STRING using FORM1 format for the real part and FORM2 format for the
!  imaginary part.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: FORM1,FORM2,STRING
      TYPE(MULTI) :: MA(2)
      CHARACTER :: CMBUFF(LMBUFF)
      CHARACTER :: CMBUFZ(LMBUFZ)
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,KWIDIM,KWIDRE,LAST,LSIGN
      INTENT (IN) :: MA,FORM1,FORM2
      INTENT (INOUT) :: STRING
      TYPE(MULTI) :: MXY(2)


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMFORM'
      STRING = ' '
      CALL ZMFPCZ(FORM1,MA(1),KWIDRE,CMBUFZ,QX)
      CALL FMEQ(MA(2),MXY(1),QX)
      IF (MXY(1)%MP(1) > 0) THEN
          LSIGN = 1
      ELSE
          LSIGN = -1
          IF (MXY(1)%MP(2) /= QX%MUNKNO .AND. MXY(1)%MP(3) /= 0)  &
              MXY(1)%MP(1) = -MXY(1)%MP(1)
      ENDIF
      CALL ZMFPCM(FORM2,MXY(1),KWIDIM,CMBUFF,QX)

      IF (KWIDRE+KWIDIM+50 > LMBUFZ) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF

      CMBUFZ(KWIDRE+1) = ' '
      IF (LSIGN == 1) THEN
          CMBUFZ(KWIDRE+2) = '+'
      ELSE
          CMBUFZ(KWIDRE+2) = '-'
      ENDIF
      CMBUFZ(KWIDRE+3) = ' '
      DO J = 1, KWIDIM
         CMBUFZ(KWIDRE+3+J) = CMBUFF(J)
      ENDDO
      CMBUFZ(KWIDRE+4+KWIDIM) = ' '
      CMBUFZ(KWIDRE+5+KWIDIM) = 'i'
      IF (QX%JFORMZ == 2) CMBUFZ(KWIDRE+5+KWIDIM) = 'I'
      LAST = KWIDRE + KWIDIM + 5

      IF (MXY(1)%MP(2) == QX%MEXPOV .OR. MXY(1)%MP(2) == QX%MEXPUN) THEN
          DO J = KWIDRE+3, LAST
             IF (CMBUFZ(J) == 'O' .OR. CMBUFZ(J) == 'U') THEN
                 CMBUFZ(J-2) = ' '
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (LAST <= LEN(STRING)) THEN
          DO J = 1, LAST
             STRING(J:J) = CMBUFZ(J)
          ENDDO
      ELSE
          DO J = 1, LAST
             STRING(J:J) = '*'
          ENDDO
      ENDIF
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMFORM

      SUBROUTINE ZMFPCM(FORM,MA,KWI,CMBUFF,QX)

!  Internal routine to convert MA to base 10 using FORM format. The result is returned in CMBUFF and
!  the field width is KWI.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFF(LMBUFF)
      INTEGER :: KWI
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KWD,KSAVE,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: KWI
      TYPE(MULTI) :: MXY(2)


      KSAVE = QX%KFLAG
      JF1SAV = QX%JFORM1
      JF2SAV = QX%JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40
      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          KWI = MAX(1,KWI)
          QX%JFORM1 = 2
          QX%JFORM2 = 0
          KWD = KWI + 11
          IF (KWD+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMNINT(MA,MXY(1),QX)
          IF (MXY(1)%MP(3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD,QX)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 2
          QX%JFORM2 = KD
          ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(QX%JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD,QX)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid
!             showing no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(MA%MP(2))+1)*LOG10(DBLE(QX%MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  QX%JFORM1 = 0
                  QX%JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                          '  Raise its size or change the format being used.'
                      STOP
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI,QX)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 1
          QX%JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI,QX)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 0
          QX%JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFF is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI,QX)
      ELSE
          GO TO 110
      ENDIF

      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      QX%KFLAG = KSAVE
      RETURN

!             Error condition.

  110 QX%KFLAG = -8
      DO J = 1, KWI
         CMBUFF(J) = '*'
      ENDDO
      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      QX%KFLAG = KSAVE
      RETURN
      END SUBROUTINE ZMFPCM

      SUBROUTINE ZMFPCZ(FORM,MA,KWI,CMBUFZ,QX)

!  Internal routine to convert MA to base 10 using FORM format. The result is returned in CMBUFZ and
!  the field width is KWI.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MA
      CHARACTER :: CMBUFZ(LMBUFZ)
      INTEGER :: KWI
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KWD,KSAVE,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: KWI
      TYPE(MULTI) :: MXY(2)


      KSAVE = QX%KFLAG
      JF1SAV = QX%JFORM1
      JF2SAV = QX%JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40
      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          KWI = MAX(1,KWI)
          QX%JFORM1 = 2
          QX%JFORM2 = 0
          KWD = KWI + 11
          IF (KWD+50 > LMBUFZ) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMNINT(MA,MXY(1),QX)
          IF (MXY(1)%MP(3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFZ,KWD,QX)
          ELSE
              DO J = 1, KWD
                 CMBUFZ(J) = ' '
              ENDDO
              CMBUFZ(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFZ(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFZ(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFZ(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 2
          QX%JFORM2 = KD
          ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(QX%JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFZ) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWD,QX)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFZ(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFZ(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid
!             showing no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(MA%MP(2))+1)*LOG10(DBLE(QX%MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  QX%JFORM1 = 0
                  QX%JFORM2 = ND
                  IF (KWI+50 > LMBUFZ) THEN
                      WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                                          '  Raise its size or change the format being used.'
                      STOP
                  ENDIF
                  CALL FMOUT(MA,CMBUFZ,KWI,QX)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFZ(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFZ(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFZ(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 1
          QX%JFORM2 = KD + 1
          IF (KWI+50 > LMBUFZ) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWI,QX)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL,QX)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL,QX)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          QX%JFORM1 = 0
          QX%JFORM2 = KD
          IF (KWI+50 > LMBUFZ) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWI,QX)
      ELSE
          GO TO 110
      ENDIF

      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      QX%KFLAG = KSAVE
      RETURN

!             Error condition.

  110 QX%KFLAG = -8
      DO J = 1, KWI
         CMBUFZ(J) = '*'
      ENDDO
      QX%JFORM1 = JF1SAV
      QX%JFORM2 = JF2SAV
      QX%KFLAG = KSAVE
      RETURN
      END SUBROUTINE ZMFPCZ

      SUBROUTINE ZMFPRT(FORM1,FORM2,MA,QX)

!  Print MA in base 10 using FORM1 format for the real part and FORM2 format for the imaginary part.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: FORM1,FORM2
      TYPE(MULTI) :: MA(2)
      CHARACTER :: CMBUFF(LMBUFF)
      CHARACTER :: CMBUFZ(LMBUFZ)
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(20) :: FORM
      INTEGER :: J,K,KWIDIM,KWIDRE,LAST,LSIGN
      INTENT (IN) :: MA,FORM1,FORM2
      TYPE(MULTI) :: MXY(2)


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMFPRT'

      CALL ZMFPCZ(FORM1,MA(1),KWIDRE,CMBUFZ,QX)
      CALL FMEQ(MA(2),MXY(1),QX)
      IF (MXY(1)%MP(1) >= 0) THEN
          LSIGN = 1
      ELSE
          LSIGN = -1
          IF (MXY(1)%MP(2) /= QX%MUNKNO .AND. MXY(1)%MP(3) /= 0)  &
              MXY(1)%MP(1) = -MXY(1)%MP(1)
      ENDIF
      CALL ZMFPCM(FORM2,MXY(1),KWIDIM,CMBUFF,QX)

      IF (KWIDRE+KWIDIM+50 > LMBUFZ) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF

      CMBUFZ(KWIDRE+1) = ' '
      IF (LSIGN == 1) THEN
          CMBUFZ(KWIDRE+2) = '+'
      ELSE
          CMBUFZ(KWIDRE+2) = '-'
      ENDIF
      CMBUFZ(KWIDRE+3) = ' '
      DO J = 1, KWIDIM
         CMBUFZ(KWIDRE+3+J) = CMBUFF(J)
      ENDDO
      CMBUFZ(KWIDRE+4+KWIDIM) = ' '
      CMBUFZ(KWIDRE+5+KWIDIM) = 'i'
      IF (QX%JFORMZ == 2) CMBUFZ(KWIDRE+5+KWIDIM) = 'I'
      LAST = KWIDRE + KWIDIM + 5

      IF (MXY(1)%MP(2) == QX%MEXPOV .OR. MXY(1)%MP(2) == QX%MEXPUN) THEN
          DO J = KWIDRE+3, LAST
             IF (CMBUFZ(J) == 'O' .OR. CMBUFZ(J) == 'U') THEN
                 CMBUFZ(J-2) = ' '
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      WRITE (FORM,"(' (6X,',I3,'A1) ')") QX%KSWIDE-7
      WRITE (KW,FORM) (CMBUFZ(K),K=1,LAST)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMFPRT

      SUBROUTINE ZMI2M(INTEG,MA,QX)

!  MA = INTEG

!  The real part of MA is set to the one word integer value INTEG.
!  The imaginary part is set to zero.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: INTEG
      TYPE(MULTI) :: MA(2)
      INTENT (IN) :: INTEG
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMI2M'
      IF (QX%NTRACE /= 0) CALL ZMNTRI(2,INTEG,1,QX)

      CALL FMI2M(INTEG,MA(1),QX)
      CALL FMI2M(0,MA(2),QX)

      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MA,MA,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMI2M

      SUBROUTINE ZM2I2M(INTEG1,INTEG2,MA,QX)

!  MA = INTEG1 + INTEG2 i

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: INTEG1,INTEG2
      TYPE(MULTI) :: MA(2)
      INTENT (IN) :: INTEG1,INTEG2
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZM2I2M'
      IF (QX%NTRACE /= 0) THEN
          CALL ZMNTRI(2,INTEG1,1,QX)
          CALL ZMNTRI(2,INTEG2,0,QX)
      ENDIF

      CALL FMI2M(INTEG1,MA(1),QX)
      CALL FMI2M(INTEG2,MA(2),QX)

      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MA,MA,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZM2I2M

      SUBROUTINE ZMIMAG(MA,MBFM,QX)

!  MBFM = IMAG(MA)        imaginary part of MA

!  MA is a complex ZM number, MBFM is a real FM number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TYPE(FM_SETTINGS) :: QX

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMIMAG'
      IF (QX%NTRACE /= 0) CALL ZMNTR(2,MA,MA,1,QX)

      CALL FMEQ(MA(2),MBFM,QX)

      IF (QX%NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMIMAG

      SUBROUTINE ZMINP(LINE,MA,LA,LB,QX)

!  Convert an A1 character string to floating point multiple precision complex format.

!  LINE is an A1 character array of length LB to be converted to ZM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.  This allows more
!     than one number to be stored in an array and converted in place.
!  LB is a pointer to the last character of the field for that number.

!  The input numbers may be in integer or any real format.
!  In exponential format the 'E' may also be 'D', 'Q', or 'M'.

!  The following are all valid input strings:

!  1.23 + 4.56 I
!  1.23 + 4.56*I
!  2 + i
!  -i
!  1.23
!  4.56i
!  ( 1.23 , 4.56 )

!  So that ZMINP will convert any output from ZMOUT, LINE is tested to see if the input contains any
!  of the special symbols +OVERFLOW, -OVERFLOW, +UNDERFLOW, -UNDERFLOW, or UNKNOWN.
!  For user input the abbreviations OVFL, UNFL, UNKN may be used.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      TYPE(MULTI) :: MA(2)
      TYPE(FM_SETTINGS) :: QX
      INTEGER :: J,JSTATE,K,KDIGFL,KFLAG1,KIFLAG,KPT,KRSAVE,KSIGN,KSTART,KSTOP,KSTOPI,  &
                 KSTOPR,KSTRTI,KSTRTR,KTYPE,KVAL,NDSAVE,NTRSAV

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States 2-8 refer to the real part, states 10-16 refer to the imaginary part.
!  States of the machine:

!   1.  Initial entry to the subroutine
!   2.  Sign of the number
!   3.  Scanning digits before a decimal point
!   4.  Decimal point
!   5.  Scanning digits after a decimal point
!   6.  E, D, Q, or M - precision indicator before the exponent
!   7.  Sign of the exponent
!   8.  Scanning exponent
!   9.  Comma between the real and imaginary part
!  10.  Sign of the number
!  11.  Scanning digits before a decimal point
!  12.  Decimal point
!  13.  Scanning digits after a decimal point
!  14.  E, D, Q, or M - precision indicator before the exponent
!  15.  Sign of the exponent
!  16.  Scanning exponent
!  17.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (E,D,Q,M)
!  5.  Illegal character for number
!  6.  Comma (,)
!  7.  Character to be ignored   ' '    '('    ')'    '*'

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state JSTATE and a character of type JTYPE is encountered the new state of the
!  machine is given by JTRANS(JSTATE,JTYPE).

!  State  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16

      INTEGER :: JTRANS(16,4) = RESHAPE(  (/                                  &
          2, 17, 10, 10, 10,  7, 17, 10, 10, 17, 17, 17, 17, 15, 17, 17,      &
          3,  3,  3,  5,  5,  8,  8,  8, 11, 11, 11, 13, 13, 16, 16, 16,      &
          4,  4,  4, 17, 17, 17, 17, 17, 12, 12, 12, 17, 17, 17, 17, 17,      &
          6,  6,  6,  6,  6,  8, 17, 17, 14, 14, 14, 14, 14, 16, 17, 17   /)  &
        , (/ 16,4 /) )
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(2)


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMINP'
      NDSAVE = QX%NDIG
      KRSAVE = QX%KROUND
      QX%KROUND = 1
      QX%KFLAG = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (QX%LHASH == 0) CALL FMHTBL(QX)

!             Since arithmetic tracing is not usually desired during I/O conversion, disable
!             tracing during this routine.

      NTRSAV = QX%NTRACE
      QX%NTRACE = 0

!             Increase the working precision.

      IF (QX%NCALL <= 2) THEN
          K = QX%NGRD52
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF
      KSTART = LA
      KSTOP = LB
      JSTATE = 1
      KSTRTR = 0
      KSTOPR = 0
      KSTRTI = 0
      KSTOPI = 0
      KDIGFL = 0
      KIFLAG = 0
      KSIGN = 1

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == ' ' .OR. LINE(J) == '(' .OR. LINE(J) == ')'  &
             .OR. LINE(J) == '*') CYCLE
         IF (LINE(J) == 'I' .OR. LINE(J) == 'i') THEN
             KIFLAG = 1
             IF (KSTRTI == 0) THEN
                 KSTRTI = KSTRTR
                 KSTOPI = KSTOPR
                 KSTRTR = 0
                 KSTOPR = 0
             ENDIF
             CYCLE
         ENDIF

         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,                                                       &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = QX%KHASHT(KPT)
             KVAL  = QX%KHASHV(KPT)
         ENDIF
         IF (KTYPE == 2 .OR. KTYPE == 5) KDIGFL = 1
         IF (LINE(J) == ',') THEN
             IF (JSTATE < 9) THEN
                 JSTATE = 9
             ELSE
                 GO TO 110
             ENDIF
         ELSE
             IF (KTYPE >= 5) KTYPE = 2
             IF (JSTATE < 17) JSTATE = JTRANS(JSTATE,KTYPE)
         ENDIF
         IF (JSTATE == 9 .OR. JSTATE == 10) KDIGFL = 0
         IF (JSTATE == 2 .OR. JSTATE == 10) KSIGN = KVAL

         IF (JSTATE >= 2 .AND. JSTATE <= 8) THEN
             IF (KSTRTR == 0) KSTRTR = J
             KSTOPR = J
         ENDIF
         IF (JSTATE >= 10 .AND. JSTATE <= 16) THEN
             IF (KSTRTI == 0) KSTRTI = J
             KSTOPI = J
         ENDIF

      ENDDO

!             Form the number and return.

      IF (KSTRTR > 0) THEN
          QX%NCALL = QX%NCALL - 1
          CALL FMINP(LINE,MXY(1),KSTRTR,KSTOPR,QX)
          QX%NCALL = QX%NCALL + 1
      ELSE
          CALL FMIM(0,MXY(1),QX)
      ENDIF
      KFLAG1 = QX%KFLAG

      IF (KSTRTI > 0) THEN
          IF (KIFLAG == 1 .AND. KDIGFL == 0) THEN
              CALL FMIM(KSIGN,MXY(2),QX)
          ELSE
              QX%NCALL = QX%NCALL - 1
              CALL FMINP(LINE,MXY(2),KSTRTI,KSTOPI,QX)
              QX%NCALL = QX%NCALL + 1
          ENDIF
      ELSE IF (KIFLAG == 1) THEN
          CALL FMIM(1,MXY(2),QX)
      ELSE
          CALL FMIM(0,MXY(2),QX)
      ENDIF

      IF (KFLAG1 /= 0 .OR. QX%KFLAG /= 0 .OR. JSTATE == 17) GO TO 110
      CALL FMEQU(MXY(1),MA(1),QX%NDIG,NDSAVE,QX)
      CALL FMEQU(MXY(2),MA(2),QX%NDIG,NDSAVE,QX)
      GO TO 120

!             Error in converting the number.

  110 QX%KFLAG = -7
      CALL ZMWARN(QX)
      MA(1)%MP(1) = 1
      MA(1)%MP(2) = QX%MUNKNO
      MA(1)%MP(3) = 1
      MA(2)%MP(1) = 1
      MA(2)%MP(2) = QX%MUNKNO
      MA(2)%MP(3) = 1
      DO J = 2, NDSAVE
         MA(1)%MP(J+2) = 0
         MA(2)%MP(J+2) = 0
      ENDDO

  120 QX%NDIG = NDSAVE
      QX%NTRACE = NTRSAV
      QX%KROUND = KRSAVE
      IF (QX%KFLAG /= -7) QX%KFLAG = 0
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMINP

      SUBROUTINE ZMINT(MA,MB,QX)

!  MB = INT(MA)

!  The integer parts of both real and imaginary values are returned.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMINT'
      IF (QX%NTRACE /= 0) CALL ZMNTR(2,MA,MA,1,QX)

      CALL FMINT(MA(1),MB(1),QX)
      CALL FMINT(MA(2),MB(2),QX)

      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMINT

      SUBROUTINE ZMIPWR(MA,IVAL,MB,QX)

!  MB = MA ** IVAL

!  Raise a ZM number to an integer power.
!  The binary multiplication method used requires an average of 1.5 * LOG2(IVAL) multiplications.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: IVAL
      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MA2,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: I2N,J,K,KL,KOVUN,KR_RETRY,KWRNSV,LVLSAV,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MZ02(2),MZ03(2),MZ04(2),MZ05(2)
      TYPE(FM_SETTINGS) :: QX


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMIPWR'
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          CALL ZMNTR(2,MA,MA,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)
      ENDIF
      KOVUN = 0
      KR_RETRY = 0
      IF (MA(1)%MP(2) == QX%MEXPOV .OR. MA(1)%MP(2) == QX%MEXPUN .OR.  &
          MA(2)%MP(2) == QX%MEXPOV .OR. MA(2)%MP(2) == QX%MEXPUN) KOVUN = 1

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2

!             Check for special cases.

      IF (IVAL == 1) THEN
          QX%NCALL = QX%NCALL - 1
          J = QX%NTRACE
          QX%NTRACE = 0
          CALL ZMEQ(MA,MZ05,QX)
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'ZMIPWR'
          QX%NTRACE = J
          GO TO 140
      ELSE IF (IVAL == 2) THEN
          QX%NCALL = QX%NCALL - 1
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL ZMSQR(MA,MZ05,QX)
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'ZMIPWR'
          QX%NTRACE = J
          QX%KWARN = K
          GO TO 140
      ENDIF
      IF (MA(1)%MP(2) == QX%MUNKNO .OR. MA(2)%MP(2) == QX%MUNKNO .OR.  &
          (IVAL <= 0 .AND. MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0)) THEN
          MA2 = MA(1)%MP(3)
          QX%KFLAG = -4
          IF (IVAL <= 0 .AND. MA2 == 0) CALL ZMWARN(QX)
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
          QX%NCALL = QX%NCALL - 1
          QX%MXEXP = MXSAVE
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL ZMI2M(1,MB,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
          QX%NCALL = QX%NCALL - 1
          QX%MXEXP = MXSAVE
          RETURN
      ENDIF

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MB,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
          QX%NCALL = QX%NCALL - 1
          QX%MXEXP = MXSAVE
          RETURN
      ENDIF

      IF (MA(2)%MP(3) == 0) THEN
          QX%NCALL = QX%NCALL - 1
          LVLSAV = QX%LVLTRC
          QX%LVLTRC = QX%LVLTRC - 1
          CALL FMIPWR(MA(1),IVAL,MB(1),QX)
          CALL FMIM(0,MB(2),QX)
          QX%NCALL = QX%NCALL + 1
          QX%LVLTRC = LVLSAV
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMIPWR'
              CALL ZMNTR(1,MB,MB,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%MXEXP = MXSAVE
          RETURN
      ENDIF

      IF (MA(1)%MP(3) == 0) THEN
          QX%NCALL = QX%NCALL - 1
          LVLSAV = QX%LVLTRC
          QX%LVLTRC = QX%LVLTRC - 1
          IF (IVAL >= 0) THEN
              I2N = MOD(IVAL,4)
          ELSE
              I2N = MOD(4 - MOD(ABS(IVAL),4),4)
          ENDIF
          IF (I2N == 0) THEN
              CALL FMIPWR(MA(2),IVAL,MB(1),QX)
              CALL FMIM(0,MB(2),QX)
          ELSE IF (I2N == 1) THEN
              CALL FMIPWR(MA(2),IVAL,MB(2),QX)
              CALL FMIM(0,MB(1),QX)
          ELSE IF (I2N == 2) THEN
              CALL FMIPWR(MA(2),IVAL,MB(1),QX)
              CALL FMIM(0,MB(2),QX)
              IF (MB(1)%MP(2) /= QX%MUNKNO .AND. MB(1)%MP(3) /= 0)  &
                  MB(1)%MP(1) = -MB(1)%MP(1)
          ELSE IF (I2N == 3) THEN
              CALL FMIPWR(MA(2),IVAL,MB(2),QX)
              CALL FMIM(0,MB(1),QX)
              IF (MB(2)%MP(2) /= QX%MUNKNO .AND. MB(2)%MP(3) /= 0)  &
                  MB(2)%MP(1) = -MB(2)%MP(1)
          ENDIF
          QX%NCALL = QX%NCALL + 1
          QX%LVLTRC = LVLSAV
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMIPWR'
              CALL ZMNTR(1,MB,MB,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          QX%MXEXP = MXSAVE
          RETURN
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(2*QX%NDIG,2*NDSAVE+10)
      ENDIF
      IF (ABS(IVAL) == 1) THEN
          KWRNSV = QX%KWARN
          QX%KWARN = 0
          IF (IVAL == 1) THEN
              CALL ZMEQ(MA,MZ05,QX)
          ELSE
              K = INT((5.0D0*QX%DLOGTN)/QX%DLOGMB + 2.0D0)
              QX%NDIG = MAX(QX%NDIG+K,2)
              CALL ZMI2M(1,MZ02,QX)
              CALL ZMEQU(MA,MZ03,NDSAVE,QX%NDIG,QX)
              CALL ZMDIV(MZ02,MZ03,MZ05,QX)
          ENDIF
          QX%KWARN = KWRNSV
          GO TO 130
      ENDIF

!             Increase the working precision.

      IF (QX%NCALL == 1) THEN
          XVAL = ABS(IVAL) + 1
          K = INT((5.0*REAL(QX%DLOGTN) + 2.5*LOG(XVAL))/QX%ALOGMB + 3.0)
          IF (QX%MBASE <= 1000) K = 2*K
          QX%NDIG = MAX(QX%NDIG+K,2)
      ELSE
          XVAL = ABS(IVAL) + 1
          K = INT(LOG(XVAL)/QX%ALOGMB + 1.0)
          QX%NDIG = QX%NDIG + K
      ENDIF

!             Initialize.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      K = ABS(IVAL)

      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

      IF (MOD(K,2) == 0) THEN
          CALL ZMI2M(1,MZ05,QX)
      ELSE
          CALL ZMEQ(MZ02,MZ05,QX)
      ENDIF

!             This is the multiplication loop.

  120 K = K/2
      CALL ZMSQR(MZ02,MZ04,QX)
      CALL ZMEQ(MZ04,MZ02,QX)
      IF (MOD(K,2) == 1) THEN
          CALL ZMMPY(MZ02,MZ05,MZ04,QX)
          CALL ZMEQ(MZ04,MZ05,QX)
      ENDIF
      IF (K > 1) GO TO 120

!             Invert if the exponent is negative.

      IF (IVAL < 0) THEN
          CALL ZMI2M(1,MZ02,QX)
          CALL ZMDIV(MZ02,MZ05,MZ04,QX)
          CALL ZMEQ(MZ04,MZ05,QX)
      ENDIF
      QX%KWARN = KWRNSV

!             Round the result and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ05(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ05(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
  140 CALL ZMEXIT(MZ05,MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMIPWR

      SUBROUTINE ZMLG10(MA,MB,QX)

!  MB = LOG10(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      TYPE(MULTI) :: MLN2,MLN3,MLN5,MLN7
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2),MZ01(2),MZ02(2),MZ03(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMLG10   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ03,NDSAVE,QX%NDIG,QX)
      CALL ZMLN(MZ03,MZ02,QX)
      CALL FMLNI(10,MXY(1),MLN2,MLN3,MLN5,MLN7,QX)
      CALL FMDIVD(MZ02(1),MZ02(2),MXY(1),MZ01(1),MZ01(2),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMLG10

      SUBROUTINE ZMLN(MA,MB,QX)

!  MB = LN(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KF1,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(4),MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMLN     ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          QX%KFLAG = -4
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ01,QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          IF (MA(1)%MP(1) < 0) THEN
              CALL FMEQ(MZ02(1),MZ01(1),QX)
              IF (MZ01(1)%MP(2) /= QX%MUNKNO .AND. MZ01(1)%MP(3) /= 0)  &
                  MZ01(1)%MP(1) = -MZ01(1)%MP(1)
              CALL FMLN(MZ01(1),MXY(4),QX)
              CALL FMEQ(MXY(4),MZ01(1),QX)
              CALL FMPI(MZ01(2),QX)
          ELSE
              CALL FMLN(MZ02(1),MZ01(1),QX)
              CALL FMI2M(0,MZ01(2),QX)
          ENDIF
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          IF (MA(2)%MP(1) < 0) THEN
              CALL FMEQ(MZ02(2),MZ01(1),QX)
              IF (MZ01(1)%MP(2) /= QX%MUNKNO .AND. MZ01(1)%MP(3) /= 0)  &
                  MZ01(1)%MP(1) = -MZ01(1)%MP(1)
              CALL FMLN(MZ01(1),MXY(4),QX)
              CALL FMEQ(MXY(4),MZ01(1),QX)
              CALL FMPI(MZ01(2),QX)
              CALL FMDIVI_R1(MZ01(2),-2,QX)
          ELSE
              CALL FMLN(MZ02(2),MZ01(1),QX)
              CALL FMPI(MZ01(2),QX)
              CALL FMDIVI_R1(MZ01(2),2,QX)
          ENDIF
          GO TO 120
      ENDIF

!             Ln(a + b i) = Ln(Abs(a + b i)) + Arg(a + b i) i.

      CALL FMABS(MZ02(1),MXY(1),QX)
      CALL FMABS(MZ02(2),MXY(2),QX)

!             Check for cancellation in Ln(x).

      CALL FMI2M(1,MXY(3),QX)
      KF1 = 0
      IF (FMCOMP(MXY(1),'==',MXY(3),QX) .AND. MXY(2)%MP(2) <= (-QX%NDIG)) KF1 = 1
      IF (FMCOMP(MXY(2),'==',MXY(3),QX) .AND. MXY(1)%MP(2) <= (-QX%NDIG)) KF1 = 1

      IF (FMCOMP(MXY(1),'>=',MXY(2),QX)) THEN
          CALL FMSUB(MZ02(1),MXY(3),MXY(1),QX)
          CALL FMADD(MZ02(1),MXY(3),MXY(2),QX)
          CALL FMMPY_R1(MXY(1),MXY(2),QX)
          CALL FMSQR(MZ02(2),MXY(2),QX)
          CALL FMADD_R2(MXY(1),MXY(2),QX)
      ELSE
          CALL FMSUB(MZ02(2),MXY(3),MXY(1),QX)
          CALL FMADD(MZ02(2),MXY(3),MXY(2),QX)
          CALL FMMPY_R1(MXY(1),MXY(2),QX)
          CALL FMSQR(MZ02(1),MXY(2),QX)
          CALL FMADD_R2(MXY(1),MXY(2),QX)
      ENDIF
      CALL ZMABS(MZ02,MZ01(1),QX)
      CALL FMADD(MZ01(1),MXY(3),MXY(1),QX)
      CALL FMDIV_R2(MXY(2),MXY(1),QX)
      IF (KF1 == 1) THEN
          CALL FMEQ(MXY(1),MZ01(1),QX)
          CALL FMATN2(MZ02(2),MZ02(1),MZ01(2),QX)
          GO TO 120
      ELSE IF (MXY(1)%MP(2) < 0) THEN
          QX%NDIG = QX%NDIG - INT(MXY(1)%MP(2))
          CALL ZMEQU_R1(MZ02,NDSAVE,QX%NDIG,QX)
          CALL ZMABS(MZ02,MZ01(1),QX)
      ENDIF

      CALL FMLN(MZ01(1),MXY(4),QX)
      CALL FMEQ(MXY(4),MZ01(1),QX)
      CALL FMATN2(MZ02(2),MZ02(1),MZ01(2),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMLN

      SUBROUTINE ZMM2I(MA,INTEG,QX)

!  INTEG = MA

!  INTEG is set to the integer value of the real part of MA

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA
      INTENT (INOUT) :: INTEG
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMM2I'
      IF (QX%NTRACE /= 0) CALL ZMNTR(2,MA,MA,1,QX)

      CALL FMM2I(MA(1),INTEG,QX)

      IF (QX%NTRACE /= 0) CALL ZMNTRI(1,INTEG,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMM2I

      SUBROUTINE ZMM2Z(MA,ZVAL,QX)

!  ZVAL = MA

!  Complex variable ZVAL is set to MA.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      COMPLEX :: ZVAL
      TYPE(FM_SETTINGS) :: QX

      REAL :: DI,DR
      INTENT (IN) :: MA
      INTENT (INOUT) :: ZVAL

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMM2Z'
      IF (QX%NTRACE /= 0) CALL ZMNTR(2,MA,MA,1,QX)

      CALL FMM2SP(MA(1),DR,QX)
      CALL FMM2SP(MA(2),DI,QX)
      ZVAL = CMPLX(DR,DI)

      IF (QX%NTRACE /= 0) CALL ZMNTRZ(1,ZVAL,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMM2Z

      SUBROUTINE ZMMPY(MA,MB,MC,QX)

!  MC = MA * MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MAXEXP,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KMETHD,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NTRSAV
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(7),MZ01(2)
      TYPE(FM_SETTINGS) :: QX


      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          ABS(MB(1)%MP(2)) > QX%MEXPAB .OR. ABS(MB(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          CALL ZMENTR('ZMMPY    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMMPY'
              CALL ZMNTR(2,MA,MB,2,QX)
          ENDIF
          NDSAVE = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+QX%NGRD52,2)
          IF (QX%MBASE >= 100*ABS(MA(1)%MP(3)) .OR. QX%MBASE >= 100*ABS(MA(2)%MP(3))) THEN
              QX%NDIG = QX%NDIG + 1
          ELSE IF (QX%MBASE >= 100*ABS(MB(1)%MP(3)) .OR.  &
              QX%MBASE >= 100*ABS(MB(2)%MP(3))) THEN
              QX%NDIG = QX%NDIG + 1
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
          KOVUN = 0
      ENDIF

      KR_RETRY = 0
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA(1),MXY(4),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MA(2),MXY(5),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB(1),MXY(6),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB(2),MXY(7),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      KMETHD = 1

!             If precision is low or a retry is being done due to cancellation,
!             use a slower but more stable form of the multiplication formula.

      IF (QX%NDIG >= 35) KMETHD = 2

      IF (MXY(4)%MP(2) == QX%MEXPUN .OR. MXY(5)%MP(2) == QX%MEXPUN .OR.  &
          MXY(6)%MP(2) == QX%MEXPUN .OR. MXY(7)%MP(2) == QX%MEXPUN .OR.  &
          MXY(4)%MP(2) == QX%MEXPOV .OR. MXY(5)%MP(2) == QX%MEXPOV .OR.  &
          MXY(6)%MP(2) == QX%MEXPOV .OR. MXY(7)%MP(2) == QX%MEXPOV ) THEN
          CALL ZMI2M(0,MZ01,QX)
          CALL ZMMPY_UNOV(MXY(4),MXY(5),MXY(6),MXY(7),MZ01,QX)
          GO TO 140
      ELSE IF (KMETHD == 1) THEN

!             Method 1 for  ( a + b i ) * ( c + d i )

!             result = a*c - b*d + ( a*d + b*c ) i

          CALL FMMPYD(MXY(4),MXY(6),MXY(7),MZ01(1),MZ01(2),QX)
          CALL FMMPYD(MXY(5),MXY(7),MXY(6),MXY(1),MXY(2),QX)
          MAXEXP = MAX(MZ01(1)%MP(2),MXY(1)%MP(2))
          CALL FMSUB_R1(MZ01(1),MXY(1),QX)
          IF (MZ01(1)%MP(2) < MAXEXP) GO TO 120
          MAXEXP = MAX(MZ01(2)%MP(2),MXY(2)%MP(2))
          CALL FMADD_R1(MZ01(2),MXY(2),QX)
          IF (MZ01(2)%MP(2) < MAXEXP) GO TO 120
          GO TO 130
      ELSE

!             Method 2 for  ( a + b i ) * ( c + d i )

!             P = ( a + b )*( c + d )
!             result = a*c - b*d + ( P - a*c - b*d ) i

          CALL FMADD(MXY(4),MXY(5),MXY(1),QX)
          CALL FMADD(MXY(6),MXY(7),MXY(2),QX)
          CALL FMMPY_R1(MXY(1),MXY(2),QX)

          CALL FMMPY(MXY(4),MXY(6),MXY(2),QX)
          CALL FMMPY(MXY(5),MXY(7),MXY(3),QX)

          MAXEXP = MAX(MXY(2)%MP(2),MXY(3)%MP(2))
          CALL FMSUB(MXY(2),MXY(3),MZ01(1),QX)
          IF (MZ01(1)%MP(2) < MAXEXP) GO TO 120
          MAXEXP = MAX(MXY(1)%MP(2),MXY(2)%MP(2),MXY(3)%MP(2))
          CALL FMSUB(MXY(1),MXY(2),MZ01(2),QX)
          CALL FMSUB_R1(MZ01(2),MXY(3),QX)
          IF (MZ01(2)%MP(2) < MAXEXP) GO TO 120
          GO TO 130
      ENDIF

  120 J = QX%NDIG
      IF (2*QX%NDIG <= NDIG_MAX) THEN
          QX%NDIG = 2*QX%NDIG
      ENDIF
      CALL FMEQU(MA(1),MXY(4),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MA(2),MXY(5),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB(1),MXY(6),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB(2),MXY(7),NDSAVE,QX%NDIG,QX)
      CALL FMMPYD(MXY(4),MXY(6),MXY(7),MZ01(1),MZ01(2),QX)
      CALL FMMPYD(MXY(5),MXY(7),MXY(6),MXY(1),MXY(2),QX)
      CALL FMSUB_R1(MZ01(1),MXY(1),QX)
      CALL FMADD_R1(MZ01(2),MXY(2),QX)
      QX%NDIG = J
      GO TO 140

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

  140 QX%MXEXP = MXSAVE
      QX%NTRACE = NTRSAV
      NDGSV2 = QX%NDIG
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      CALL ZMEQU(MZ01,MC,NDGSV2,NDSAVE,QX)
      IF (MC(1)%MP(2) >= QX%MEXPOV .OR. MC(1)%MP(2) <= -QX%MEXPOV .OR.  &
          MC(2)%MP(2) >= QX%MEXPOV .OR. MC(2)%MP(2) <= -QX%MEXPOV) THEN
          IF (MC(1)%MP(2) == QX%MUNKNO .OR. MC(2)%MP(2) == QX%MUNKNO) THEN
              QX%KFLAG = -4
          ELSE IF (MC(1)%MP(2) == QX%MEXPOV .OR. MC(2)%MP(2) == QX%MEXPOV) THEN
              QX%KFLAG = -5
          ELSE IF (MC(1)%MP(2) == QX%MEXPUN .OR. MC(2)%MP(2) == QX%MEXPUN) THEN
              QX%KFLAG = -6
          ENDIF
          IF ((MC(1)%MP(2) == QX%MUNKNO) .OR. (MC(2)%MP(2) == QX%MUNKNO)  &
             .OR. (MC(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
             .OR. (MC(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
             .OR. (MC(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
             .OR. (MC(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
              QX%NAMEST(QX%NCALL) = 'ZMMPY'
              CALL ZMWARN(QX)
          ENDIF
      ENDIF
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMMPY

      SUBROUTINE ZMMPY_UNOV(MA,MB,MC,MD,MZ,QX)

!  Check special cases where at least one of MA, MB, MC, MD is underflow or overflow.

!  Return MZ as the result.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC,MD,MZ(2)
      INTENT (INOUT) :: MZ
      INTENT (IN) :: MA,MB,MC,MD
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(7)
      REAL (KIND(1.0D0)) :: M_EXPUN, M_EXPOV, M_L1, M_L2, M_R1, M_R2


      M_EXPUN = -AINT( MAX_EXPONENT / 2.01D0 + 0.5D0 ) - 1
      M_EXPOV = AINT( MAX_EXPONENT / 2.01D0 + 0.5D0 ) + 2

      CALL FMMPY(MA,MC,MXY(1),QX)
      CALL FMMPY(MB,MD,MXY(2),QX)
      CALL FMMPY(MA,MD,MXY(3),QX)
      CALL FMMPY(MB,MC,MXY(4),QX)
      IF (MXY(1)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(4)%MP(2) /= QX%MUNKNO) THEN
          CALL FMSUB(MXY(1),MXY(2),MZ(1),QX)
          CALL FMADD(MXY(3),MXY(4),MZ(2),QX)
          GO TO 120
      ENDIF

      IF (MXY(1)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(2) /= QX%MUNKNO) THEN
          CALL FMSUB(MXY(1),MXY(2),MZ(1),QX)
      ELSE
          IF (MXY(1)%MP(2) == QX%MUNKNO .AND. MXY(2)%MP(2) /= QX%MUNKNO .AND.  &
              (MA%MP(2) == QX%MEXPOV .OR. MC%MP(2) == QX%MEXPOV)) THEN
              CALL FMST2M('UNKNOWN',MZ(1),QX)
              GO TO 110
          ENDIF
          IF (MXY(2)%MP(2) == QX%MUNKNO .AND. MXY(1)%MP(2) /= QX%MUNKNO .AND.  &
              (MB%MP(2) == QX%MEXPOV .OR. MD%MP(2) == QX%MEXPOV)) THEN
              CALL FMST2M('UNKNOWN',MZ(1),QX)
              GO TO 110
          ENDIF
          IF (MA%MP(2) == QX%MEXPOV .AND. MB%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1)*MC%MP(1) == -MB%MP(1)*MD%MP(1)) THEN
                  CALL FMEQ(MC,MXY(6),QX)
                  MXY(6)%MP(1) = MA%MP(1)*MC%MP(1)
                  CALL FMEQ(MD,MXY(7),QX)
                  MXY(7)%MP(1) = MB%MP(1)*MD%MP(1)
                  CALL FMSUB(MXY(6),MXY(7),MXY(5),QX)
                  CALL FMST2M('OVERFLOW',MXY(6),QX)
                  CALL FMMPY(MXY(5),MXY(6),MZ(1),QX)
                  GO TO 110
              ELSE
                  CALL FMST2M('UNKNOWN',MZ(1),QX)
                  GO TO 110
              ENDIF
          ENDIF
          IF (MA%MP(2) == QX%MEXPOV .AND. MD%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1)*MC%MP(1) == -MB%MP(1)*MD%MP(1)) THEN
                  CALL FMEQ(MC,MXY(6),QX)
                  MXY(6)%MP(1) = MA%MP(1)*MC%MP(1)
                  CALL FMEQ(MB,MXY(7),QX)
                  MXY(7)%MP(1) = MB%MP(1)*MD%MP(1)
                  CALL FMSUB(MXY(6),MXY(7),MXY(5),QX)
                  CALL FMST2M('OVERFLOW',MXY(6),QX)
                  CALL FMMPY(MXY(5),MXY(6),MZ(1),QX)
                  GO TO 110
              ELSE
                  CALL FMST2M('UNKNOWN',MZ(1),QX)
                  GO TO 110
              ENDIF
          ENDIF
          IF (MC%MP(2) == QX%MEXPOV .AND. MB%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1)*MC%MP(1) == -MB%MP(1)*MD%MP(1)) THEN
                  CALL FMEQ(MA,MXY(6),QX)
                  MXY(6)%MP(1) = MA%MP(1)*MC%MP(1)
                  CALL FMEQ(MD,MXY(7),QX)
                  MXY(7)%MP(1) = MB%MP(1)*MD%MP(1)
                  CALL FMSUB(MXY(6),MXY(7),MXY(5),QX)
                  CALL FMST2M('OVERFLOW',MXY(6),QX)
                  CALL FMMPY(MXY(5),MXY(6),MZ(1),QX)
                  GO TO 110
              ELSE
                  CALL FMST2M('UNKNOWN',MZ(1),QX)
                  GO TO 110
              ENDIF
          ENDIF
          IF (MC%MP(2) == QX%MEXPOV .AND. MD%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1)*MC%MP(1) == -MB%MP(1)*MD%MP(1)) THEN
                  CALL FMEQ(MA,MXY(6),QX)
                  MXY(6)%MP(1) = MA%MP(1)*MC%MP(1)
                  CALL FMEQ(MB,MXY(7),QX)
                  MXY(7)%MP(1) = MB%MP(1)*MD%MP(1)
                  CALL FMSUB(MXY(6),MXY(7),MXY(5),QX)
                  CALL FMST2M('OVERFLOW',MXY(6),QX)
                  CALL FMMPY(MXY(5),MXY(6),MZ(1),QX)
                  GO TO 110
              ELSE
                  CALL FMST2M('UNKNOWN',MZ(1),QX)
                  GO TO 110
              ENDIF
          ENDIF
          M_L1 = MAX( MIN( MA%MP(2) , M_EXPOV) , M_EXPUN )
          M_L2 = MAX( MIN( MC%MP(2) , M_EXPOV) , M_EXPUN )
          M_R1 = MAX( MIN( MB%MP(2) , M_EXPOV) , M_EXPUN )
          M_R2 = MAX( MIN( MD%MP(2) , M_EXPOV) , M_EXPUN )
          IF (M_L1+M_L2+QX%NDIG < M_R1+M_R2 .AND. MXY(2)%MP(3) /= 0) THEN
              CALL FMMPYI(MXY(2),-1,MZ(1),QX)
              GO TO 110
          ELSE IF (M_R1+M_R2+QX%NDIG < M_L1+M_L2 .AND. MXY(1)%MP(3) /= 0) THEN
              CALL FMEQ(MXY(1),MZ(1),QX)
              GO TO 110
          ENDIF
          CALL FMSUB(MXY(1),MXY(2),MZ(1),QX)
      ENDIF

  110 IF (MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(4)%MP(2) /= QX%MUNKNO) THEN
          CALL FMSUB(MXY(3),MXY(4),MZ(2),QX)
      ELSE
          IF (MXY(3)%MP(2) == QX%MUNKNO .AND. MXY(4)%MP(2) /= QX%MUNKNO .AND.  &
              (MA%MP(2) == QX%MEXPOV .OR. MD%MP(2) == QX%MEXPOV)) THEN
              CALL FMST2M('UNKNOWN',MZ(2),QX)
              GO TO 120
          ENDIF
          IF (MXY(4)%MP(2) == QX%MUNKNO .AND. MXY(3)%MP(2) /= QX%MUNKNO .AND.  &
              (MB%MP(2) == QX%MEXPOV .OR. MC%MP(2) == QX%MEXPOV)) THEN
              CALL FMST2M('UNKNOWN',MZ(2),QX)
              GO TO 120
          ENDIF
          IF (MA%MP(2) == QX%MEXPOV .AND. MB%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1)*MD%MP(1) == MB%MP(1)*MC%MP(1)) THEN
                  CALL FMEQ(MD,MXY(6),QX)
                  MXY(6)%MP(1) = MA%MP(1)*MD%MP(1)
                  CALL FMEQ(MC,MXY(7),QX)
                  MXY(7)%MP(1) = MB%MP(1)*MC%MP(1)
                  CALL FMSUB(MXY(6),MXY(7),MXY(5),QX)
                  CALL FMST2M('OVERFLOW',MXY(6),QX)
                  CALL FMMPY(MXY(5),MXY(6),MZ(2),QX)
                  GO TO 120
              ELSE
                  CALL FMST2M('UNKNOWN',MZ(2),QX)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MA%MP(2) == QX%MEXPOV .AND. MC%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1)*MD%MP(1) == MB%MP(1)*MC%MP(1)) THEN
                  CALL FMEQ(MD,MXY(6),QX)
                  MXY(6)%MP(1) = MA%MP(1)*MD%MP(1)
                  CALL FMEQ(MB,MXY(7),QX)
                  MXY(7)%MP(1) = MB%MP(1)*MC%MP(1)
                  CALL FMSUB(MXY(6),MXY(7),MXY(5),QX)
                  CALL FMST2M('OVERFLOW',MXY(6),QX)
                  CALL FMMPY(MXY(5),MXY(6),MZ(2),QX)
                  GO TO 120
              ELSE
                  CALL FMST2M('UNKNOWN',MZ(2),QX)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MD%MP(2) == QX%MEXPOV .AND. MB%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1)*MD%MP(1) == MB%MP(1)*MC%MP(1)) THEN
                  CALL FMEQ(MA,MXY(6),QX)
                  MXY(6)%MP(1) = MA%MP(1)*MD%MP(1)
                  CALL FMEQ(MC,MXY(7),QX)
                  MXY(7)%MP(1) = MB%MP(1)*MC%MP(1)
                  CALL FMSUB(MXY(6),MXY(7),MXY(5),QX)
                  CALL FMST2M('OVERFLOW',MXY(6),QX)
                  CALL FMMPY(MXY(5),MXY(6),MZ(2),QX)
                  GO TO 120
              ELSE
                  CALL FMST2M('UNKNOWN',MZ(2),QX)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MD%MP(2) == QX%MEXPOV .AND. MC%MP(2) == QX%MEXPOV) THEN
              IF (MA%MP(1)*MD%MP(1) == MB%MP(1)*MC%MP(1)) THEN
                  CALL FMEQ(MA,MXY(6),QX)
                  MXY(6)%MP(1) = MA%MP(1)*MD%MP(1)
                  CALL FMEQ(MB,MXY(7),QX)
                  MXY(7)%MP(1) = MB%MP(1)*MC%MP(1)
                  CALL FMSUB(MXY(6),MXY(7),MXY(5),QX)
                  CALL FMST2M('OVERFLOW',MXY(6),QX)
                  CALL FMMPY(MXY(5),MXY(6),MZ(2),QX)
                  GO TO 120
              ELSE
                  CALL FMST2M('UNKNOWN',MZ(2),QX)
                  GO TO 120
              ENDIF
          ENDIF
          M_L1 = MAX( MIN( MA%MP(2) , M_EXPOV) , M_EXPUN )
          M_L2 = MAX( MIN( MD%MP(2) , M_EXPOV) , M_EXPUN )
          M_R1 = MAX( MIN( MB%MP(2) , M_EXPOV) , M_EXPUN )
          M_R2 = MAX( MIN( MC%MP(2) , M_EXPOV) , M_EXPUN )
          IF (M_L1+M_L2+QX%NDIG < M_R1+M_R2 .AND. MXY(4)%MP(3) /= 0) THEN
              CALL FMEQ(MXY(4),MZ(2),QX)
              GO TO 120
          ELSE IF (M_R1+M_R2+QX%NDIG < M_L1+M_L2 .AND. MXY(3)%MP(3) /= 0) THEN
              CALL FMEQ(MXY(3),MZ(2),QX)
              GO TO 120
          ENDIF
          CALL FMSUB(MXY(3),MXY(4),MZ(2),QX)
      ENDIF

  120 RETURN
      END SUBROUTINE ZMMPY_UNOV

      SUBROUTINE ZMMPY_R1(MA,MB,QX)

!  MA = MA * MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMMPY(MA,MB,MXY,QX)
      CALL ZMEQ(MXY,MA,QX)


      END SUBROUTINE ZMMPY_R1

      SUBROUTINE ZMMPY_R2(MA,MB,QX)

!  MB = MA * MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMMPY(MA,MB,MXY,QX)
      CALL ZMEQ(MXY,MB,QX)


      END SUBROUTINE ZMMPY_R2

      SUBROUTINE ZMMPYI(MA,INTEG,MB,QX)

!  MB = MA * INTEG        Multiply by one-word (real) integer.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTEGER :: INTEG
      TYPE(FM_SETTINGS) :: QX
      INTEGER :: KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB

      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          NTRSAV = QX%NTRACE
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'ZMMPYI'
              CALL ZMNTR(2,MA,MA,1,QX)
              CALL FMNTRI(2,INTEG,0,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          QX%NTRACE = 0
          CALL ZMENTR('ZMMPYI   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          QX%NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF
          QX%NDIG = NDSAVE
          QX%MXEXP = MXSAVE
          NTRSAV = QX%NTRACE
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMMPYI'
              CALL ZMNTR(2,MA,MA,1,QX)
              CALL FMNTRI(2,INTEG,0,QX)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMMPYI to use more guard digits for user calls.

      QX%NCALL = QX%NCALL - 1
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0

      CALL FMMPYI(MA(1),INTEG,MB(1),QX)
      CALL FMMPYI(MA(2),INTEG,MB(2),QX)

      QX%NTRACE = NTRSAV
      QX%KWARN = KWRNSV
      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) QX%NAMEST(QX%NCALL) = 'ZMMPYI'
      IF (MB(1)%MP(2) == QX%MUNKNO .OR. MB(2)%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
      ELSE IF (MB(1)%MP(2) == QX%MEXPOV .OR. MB(2)%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
      ELSE IF (MB(1)%MP(2) == QX%MEXPUN .OR. MB(2)%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -6
      ENDIF
      IF ((MB(1)%MP(2) == QX%MUNKNO) .OR. (MB(2)%MP(2) == QX%MUNKNO)  &
         .OR. (MB(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MB(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MB(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
         .OR. (MB(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
          QX%NAMEST(QX%NCALL) = 'ZMMPYI'
          CALL ZMWARN(QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMMPYI

      SUBROUTINE ZMMPYI_R1(MA,IVAL,QX)

!  MA = MA / IVAL

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMMPYI(MA,IVAL,MXY,QX)
      CALL ZMEQ(MXY,MA,QX)


      END SUBROUTINE ZMMPYI_R1

      SUBROUTINE ZMNINT(MA,MB,QX)

!  MB = NINT(MA)

!  The nearest integers to both real and imaginary parts are returned.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMNINT'
      IF (QX%NTRACE /= 0) CALL ZMNTR(2,MA,MA,1,QX)

      CALL FMNINT(MA(1),MB(1),QX)
      CALL FMNINT(MA(2),MB(2),QX)

      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMNINT

      SUBROUTINE ZMNTR(NTR,MA,MB,NARG,QX)

!  Print ZM numbers in base 10 format using ZMOUT for conversion.
!  This is used for trace output from the ZM routines.

!  NTR =  1 if a result of an ZM call is to be printed.
!      =  2 to print input argument(s) to an ZM call.

!  MA  -  the ZM number to be printed.

!  MB  -  an optional second ZM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be
!         printed, and NARG = 2 if both MA and MB are to be printed.


!  NTRACE and LVLTRC (in module FMVALS_PARALLEL) control trace printout.

!  NTRACE = 0        No printout except warnings and errors.

!  NTRACE = 1        The result of each call to one of the routines
!                    is printed in base 10, using ZMOUT.

!  NTRACE = -1       The result of each call to one of the routines
!                    is printed in internal base MBASE format.

!  NTRACE = 2        The input arguments and result of each call to one
!                    of the routines is printed in base 10, using ZMOUT.

!  NTRACE = -2       The input arguments and result of each call to one
!                    of the routines is printed in base MBASE format.

!  LVLTRC defines the call level to which the trace is done.  LVLTRC = 1 means only FM routines
!         called directly by the user are traced, LVLTRC = K prints traces for ZM or FM routines
!         with call levels up to and including level K.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTEGER :: NTR,NARG
      CHARACTER(9) :: NAME
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (QX%KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (QX%KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (QX%KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ELSE
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG,QX%KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (QX%NTRACE < 0) THEN
          CALL ZMNTRJ(MA,QX%NDIG,QX)
          IF (NARG == 2) CALL ZMNTRJ(MB,QX%NDIG,QX)
      ENDIF

!             Check for base 10 trace using ZMOUT.

      IF (QX%NTRACE > 0) THEN
          CALL ZMPRNT(MA,QX)

          IF (NARG == 2) THEN
              CALL ZMPRNT(MB,QX)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE ZMNTR

      SUBROUTINE ZMNTR2(NTR,MAFM,MBFM,NARG,QX)

!  Print real FM numbers in base 10 format using FMOUT for conversion.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MAFM,MBFM
      INTEGER :: NTR,NARG
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MAFM,MBFM,NARG

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (QX%KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (QX%KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (QX%KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ELSE
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG,QX%KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (QX%NTRACE < 0) THEN
          CALL FMNTRJ(MAFM,QX%NDIG,QX)
          IF (NARG == 2) CALL FMNTRJ(MBFM,QX%NDIG,QX)
      ENDIF

!             Check for base 10 trace using FMOUT.

      IF (QX%NTRACE > 0) THEN
          CALL FMPRNT(MAFM,QX)
          IF (NARG == 2) THEN
              CALL FMPRNT(MBFM,QX)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE ZMNTR2

      SUBROUTINE ZMNTRI(NTR,N,KNAM,QX)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (QX%KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (QX%KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (QX%KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG,QX%KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I20)") N

      RETURN
      END SUBROUTINE ZMNTRI

      SUBROUTINE ZMNTRJ(MA,ND,QX)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      INTEGER :: ND
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(99) :: FORM
      CHARACTER(40), EXTERNAL :: FMFI
      CHARACTER(40) :: ST1,ST2
      INTEGER :: J,L,N
      INTENT (IN) :: MA,ND

      L = INT(LOG10(DBLE(QX%MBASE-1))) + 2
      N = (QX%KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,                                  &
                 "(' (1X,I19,I',I2,',',I3,'I',I2,"  //  &
                 "'/(22X,',I3,'I',I2,')) ')"            &
                ) L+2, N-1, L, N, L
      ENDIF
      ST1 = FMFI(INT(MA(1)%MP(1)))
      ST2 = FMFI(INT(MA(1)%MP(2)))
      WRITE (KW,"(A,A,A,A,A)") '            Sign = ',TRIM(ST1),  &
                                   '   Exponent = ',TRIM(ST2),'   Digits of real part:'
      WRITE (FORM,*) '(13X,', N, 'I', L, ')'
      WRITE (KW,FORM) (INT(MA(1)%MP(J)),J=3,ND+2)

      ST1 = FMFI(INT(MA(2)%MP(1)))
      ST2 = FMFI(INT(MA(2)%MP(2)))
      WRITE (KW,"(A,A,A,A,A,A,A)") '            Sign = ',TRIM(ST1),  &
                                   '   Exponent = ',TRIM(ST2),'   Digits of imaginary part:'
      WRITE (KW,FORM) (INT(MA(2)%MP(J)),J=3,ND+2)

      RETURN
      END SUBROUTINE ZMNTRJ

      SUBROUTINE ZMNTRZ(NTR,X,KNAM,QX)

!  Internal routine for trace output of complex variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Complex value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      COMPLEX :: X
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(9) :: NAME
      DOUBLE PRECISION :: XREAL,XIMAG
      INTENT (IN) :: NTR,X,KNAM

      IF (QX%NTRACE == 0) RETURN
      IF (QX%NCALL > QX%LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(QX%NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (QX%KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (QX%KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (QX%KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          IF (QX%KFLAG == 0) THEN
              WRITE (KW,                                               &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG
          ELSE
              WRITE (KW,                                              &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,QX%NCALL,INT(QX%MBASE),QX%NDIG,QX%KFLAG
          ENDIF
      ENDIF

      XREAL = DBLE(X)
      XIMAG = DBLE(AIMAG(X))
      IF (XIMAG >= 0.0D0) THEN
          WRITE (KW,"(1X,D30.20,' +',D30.20,' i')") XREAL,XIMAG
      ELSE
          WRITE (KW,"(1X,D30.20,' -',D30.20,' i')") XREAL,ABS(XIMAG)
      ENDIF

      RETURN
      END SUBROUTINE ZMNTRZ

      SUBROUTINE ZMOUT(MA,LINE,LB,LAST1,LAST2,QX)

!  Convert a floating multiple precision number to a character array for output.

!  MA    is an ZM number to be converted to an A1 character array in base 10 format
!  LINE  is the character(1) array in which the result is returned.
!  LB    is the length of LINE.
!  LAST1 is returned as the position of the last nonblank character of the real part of the
!        number in LINE.
!  LAST2 is returned as the position of the last nonblank character of the imaginary part of
!        the number in LINE.

!  JFORM1 and JFORM2 determine the format of the two FM numbers making up the complex value MA.
!  See FMOUT for details.

!  JFORMZ determines the format of the real and imaginary parts.

!  JFORMZ = 1  normal setting :       1.23 - 4.56 i
!         = 2  use capital I  :       1.23 - 4.56 I
!         = 3  parenthesis format   ( 1.23 , -4.56 )

!  LINE should be dimensioned at least 4*(LOG10(MBASE)*NDIG + 15) on a 32-bit machine to allow
!  for up to 10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit
!  integers, etc.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      INTEGER :: LB,LAST1,LAST2
      CHARACTER :: LINE(LB)
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MAIMS
      INTEGER :: J,KPT,LB2,ND,NEXP
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE,LAST1,LAST2
      TYPE(MULTI) :: MXY(2)


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMOUT'
      DO J = 1, LB
         LINE(J) = ' '
      ENDDO
      ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      KPT = 1
      IF (QX%JFORMZ == 3) KPT = 3
      LB2 = MAX(QX%JFORM2+NEXP,ND+NEXP)
      LB2 = MIN(LB+1-KPT,LB2)
      CALL FMOUT(MA(1),LINE(KPT),LB2,QX)

      IF (QX%JFORMZ == 3) LINE(1) = '('
      LAST1 = 1
      DO J = LB2, 1, -1
         IF (LINE(J) /= ' ') THEN
             LAST1 = J
             GO TO 110
         ENDIF
      ENDDO

  110 MAIMS = MA(2)%MP(1)
      CALL FMI2M(0,MXY(1),QX)
      DO J = 1, QX%NDIG+2
         MXY(1)%MP(J) = MA(2)%MP(J)
      ENDDO
      LINE(LAST1+1) = ' '
      IF (QX%JFORMZ == 3) THEN
          LINE(LAST1+2) = ','
      ELSE
          IF (MAIMS < 0) THEN
              MXY(1)%MP(1) = 1
              LINE(LAST1+2) = '-'
          ELSE
              LINE(LAST1+2) = '+'
          ENDIF
      ENDIF

      KPT = LAST1 + 3
      LB2 = MAX(QX%JFORM2+NEXP,ND+NEXP)
      LB2 = MIN(LB+1-KPT,LB2+2)
      CALL FMOUT(MXY(1),LINE(KPT),LB2,QX)
      LAST1 = KPT
      DO J = LB2+KPT-1, KPT, -1
         IF (LINE(J) /= ' ') THEN
             LAST2 = J
             GO TO 120
         ENDIF
      ENDDO

  120 LAST2 = LAST2 + 2
      LINE(LAST2) = 'i'
      IF (QX%JFORMZ == 2) LINE(LAST2) = 'I'
      IF (QX%JFORMZ == 3) LINE(LAST2) = ')'

      IF (LINE(KPT) == ' ' .AND. LINE(KPT+1) == '+') THEN
          DO J = KPT+2, LAST2
             LINE(J-2) = LINE(J)
          ENDDO
          LINE(LAST2-1) = ' '
          LINE(LAST2) = ' '
          LAST2 = LAST2 - 2
      ENDIF

      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMOUT

      SUBROUTINE ZMPRNT(MA,QX)

!  Print MA in base 10 format.

!  ZMPRNT can be called directly by the user for easy output in M format.
!  MA is converted using ZMOUT and printed.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2)
      CHARACTER :: CMBUFZ(LMBUFZ)
      TYPE(FM_SETTINGS) :: QX

      CHARACTER(20) :: FORM
      INTEGER :: K,KSAVE,LAST1,LAST2,LB,LBZ,ND,NEXP
      INTENT (IN) :: MA

      KSAVE = QX%KFLAG
      ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = MAX(QX%JFORM2+NEXP,ND+NEXP)

      IF (QX%JPRNTZ == 1) THEN
          LBZ = 2*LB + 7
          IF (LBZ > LMBUFZ) THEN
              WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                                  '  Raise its size or change the format being used.'
              STOP
          ENDIF
          CALL ZMOUT(MA,CMBUFZ,LBZ,LAST1,LAST2,QX)
          WRITE (FORM,"(' (6X,',I3,'A1) ')") QX%KSWIDE-7
          WRITE (KW,FORM) (CMBUFZ(K),K=1,LAST2)
      ELSE
          CALL FMPRNT(MA(1),QX)
          CALL FMPRNT(MA(2),QX)
      ENDIF
      QX%KFLAG = KSAVE
      RETURN
      END SUBROUTINE ZMPRNT

      SUBROUTINE ZMPWR(MA,MB,MC,QX)

!  MC = MA ** MB.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      TYPE(FM_SETTINGS) :: QX

      REAL (KIND(1.0D0)) :: MXSAVE,MTEMP
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTMB,J,JSIN,JCOS,JSWAP,K,KL,KOVUN,KR_RETRY,KRADSV,  &
                 KRESLT,KWRNSV,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: XVAL
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(5),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),MZ06(2)


      CALL ZMENTR('ZMPWR    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      K = MAX(MB(1)%MP(2),MB(2)%MP(2))
      IF (K < 25000) THEN
          QX%NDIG = QX%NDIG + MAX(K,0) + 1
      ELSE
          QX%NDIG = QX%NDIG + 1
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,QX%NDIG,QX)
      CALL ZMEQU(MB,MZ05,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          IF (MB(1)%MP(1) > 0 .AND. MB(2)%MP(3) == 0) THEN
              CALL ZMI2M(0,MZ02,QX)
              GO TO 130
          ELSE
              QX%KFLAG = -4
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ02,QX)
              GO TO 130
          ENDIF
      ENDIF
      IF (MB(2)%MP(3) == 0) THEN
          KWRNSV = QX%KWARN
          QX%KWARN = 0
          CALL FMMI(MZ05(1),INTMB,QX)
          QX%KWARN = KWRNSV
          IF (QX%KFLAG == 0) THEN
              IF (QX%NCALL == 1) THEN
                  XVAL = ABS(INTMB) + 1
                  K = INT((1.5*LOG(XVAL))/QX%ALOGMB + 2.0)
                  QX%NDIG = MAX(QX%NDIG+K,2)
                  IF (QX%MBASE >= 100*ABS(MA(1)%MP(3)) .OR.  &
                      QX%MBASE >= 100*ABS(MA(2)%MP(3))) THEN
                      QX%NDIG = QX%NDIG + 1
                  ENDIF
              ENDIF
              CALL ZMEQU_R1(MZ04,NDSAVE,QX%NDIG,QX)
              CALL ZMIPWR(MZ04,INTMB,MZ03,QX)
              CALL ZMEQ(MZ03,MZ02,QX)
              GO TO 120
          ENDIF
      ENDIF

!             Check for cases where ABS(MA) is very close to 1, and avoid cancellation.

      CALL FMABS(MZ04(1),MXY(1),QX)
      CALL FMABS(MZ04(2),MXY(2),QX)
      CALL FMI2M(1,MXY(3),QX)
      IF (FMCOMP(MXY(1),'==',MXY(3),QX) .AND.  &
          (MXY(2)%MP(2) <= (-QX%NDIG).OR.MXY(2)%MP(3) == 0)) THEN
          IF (MA(1)%MP(1) > 0) THEN

!                 (1+c)**b = 1 + b*c + ...

              CALL ZMI2M(1,MZ02,QX)
              CALL ZMSUB(MZ04,MZ02,MZ06,QX)
              CALL ZMMPY(MZ05,MZ06,MZ02,QX)
              CALL FMADD_R1(MZ02(1),MXY(3),QX)
          ELSE

!                 (-1+c)**b = (-1)**b * (1 - b*c + ... )

              CALL ZMI2M(-1,MZ02,QX)
              CALL ZMSUB(MZ04,MZ02,MZ01,QX)
              CALL ZMMPY(MZ05,MZ01,MZ06,QX)
              CALL ZMMPYI(MZ06,-1,MZ02,QX)
              CALL FMADD_R1(MZ02(1),MXY(3),QX)
              KRADSV = QX%KRAD
              QX%KRAD = 0
              IF (MA(2)%MP(1) >= 0) THEN
                  CALL FMMPYI(MZ05(1),180,MXY(4),QX)
              ELSE
                  CALL FMMPYI(MZ05(1),-180,MXY(4),QX)
              ENDIF
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2),QX)
              QX%KRAD = KRADSV
              CALL FMPI(MXY(3),QX)
              CALL FMMPY_R1(MXY(3),MZ05(2),QX)
              IF (MA(2)%MP(1) >= 0) CALL FMMPYI_R1(MXY(3),-1,QX)
              CALL FMEXP(MXY(3),MXY(5),QX)
              CALL FMEQ(MXY(5),MXY(3),QX)
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2),QX)
              CALL ZMMPY(MZ02,MZ06,MZ01,QX)
              CALL ZMEQ(MZ01,MZ02,QX)
          ENDIF
          GO TO 120
      ENDIF
      IF (FMCOMP(MXY(2),'==',MXY(3),QX) .AND.  &
          (MXY(1)%MP(2) <= (-QX%NDIG).OR.MXY(1)%MP(3) == 0)) THEN
          IF (MA(2)%MP(1) > 0) THEN

!                 (i+c)**b = i**b * (1 - b*c*i - ... )

              CALL ZM2I2M(0,1,MZ02,QX)
              CALL ZMSUB(MZ04,MZ02,MZ06,QX)
              CALL ZMMPY(MZ05,MZ06,MZ02,QX)
              DO J = 1, QX%NDIG+2
                 MTEMP = MZ02(1)%MP(J)
                 MZ02(1)%MP(J) = MZ02(2)%MP(J)
                 MZ02(2)%MP(J) = MTEMP
              ENDDO
              IF (MZ02(2)%MP(2) /= QX%MUNKNO .AND. MZ02(2)%MP(3) /= 0)  &
                  MZ02(2)%MP(1) = -MZ02(2)%MP(1)
              CALL FMADD_R1(MZ02(1),MXY(3),QX)
              KRADSV = QX%KRAD
              QX%KRAD = 0
              CALL FMMPYI(MZ05(1),90,MXY(4),QX)
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2),QX)
              QX%KRAD = KRADSV
              CALL FMPI(MXY(3),QX)
              CALL FMMPY_R1(MXY(3),MZ05(2),QX)
              CALL FMDIVI_R1(MXY(3),-2,QX)
              CALL FMEXP(MXY(3),MXY(5),QX)
              CALL FMEQ(MXY(5),MXY(3),QX)
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2),QX)
              CALL ZMMPY(MZ02,MZ06,MZ01,QX)
              CALL ZMEQ(MZ01,MZ02,QX)
          ELSE

!                 (-i+c)**b = (-i)**b * (1 + b*c*i - ... )

              CALL ZM2I2M(0,-1,MZ02,QX)
              CALL ZMSUB(MZ04,MZ02,MZ06,QX)
              CALL ZMMPY(MZ05,MZ06,MZ02,QX)
              DO J = 1, QX%NDIG+2
                 MTEMP = MZ02(1)%MP(J)
                 MZ02(1)%MP(J) = MZ02(2)%MP(J)
                 MZ02(2)%MP(J) = MTEMP
              ENDDO
              IF (MZ02(1)%MP(2) /= QX%MUNKNO .AND. MZ02(1)%MP(3) /= 0)  &
                  MZ02(1)%MP(1) = -MZ02(1)%MP(1)
              CALL FMADD_R1(MZ02(1),MXY(3),QX)
              KRADSV = QX%KRAD
              QX%KRAD = 0
              CALL FMMPYI(MZ05(1),-90,MXY(4),QX)
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2),QX)
              QX%KRAD = KRADSV
              CALL FMPI(MXY(3),QX)
              CALL FMMPY_R1(MXY(3),MZ05(2),QX)
              CALL FMDIVI_R1(MXY(3),2,QX)
              CALL FMEXP(MXY(3),MXY(5),QX)
              CALL FMEQ(MXY(5),MXY(3),QX)
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2),QX)
              CALL ZMMPY(MZ02,MZ06,MZ01,QX)
              CALL ZMEQ(MZ01,MZ02,QX)
          ENDIF
          GO TO 120
      ENDIF

      CALL ZMLN(MZ04,MZ06,QX)
      CALL ZMMPY(MZ05,MZ06,MZ02,QX)
      CALL FMEQ(MZ02(2),MZ01(1),QX)
      IF (MZ01(1)%MP(2) > 25000) THEN
          QX%KFLAG = -4
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ02,QX)
          GO TO 130
      ENDIF
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMRDC(MZ01(1),JSIN,JCOS,JSWAP,QX)
      QX%KWARN = KWRNSV
      IEXTRA = INT(MZ02(2)%MP(2) - MZ01(1)%MP(2))
      IF (QX%NDIG >= NDSAVE+QX%NGRD52+MAX(0,IEXTRA)) IEXTRA = 0
      IF (IEXTRA > 1) THEN
          QX%NDIG = QX%NDIG + IEXTRA
          CALL ZMEQU_R1(MZ04,NDSAVE,QX%NDIG,QX)
          CALL ZMEQU_R1(MZ05,NDSAVE,QX%NDIG,QX)
          CALL ZMLN(MZ04,MZ06,QX)
          CALL ZMMPY(MZ05,MZ06,MZ02,QX)
      ENDIF

      CALL ZMEXP(MZ02,MZ04,QX)
      CALL ZMEQ(MZ04,MZ02,QX)


!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ02(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ02(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
  130 CALL ZMEXIT(MZ02,MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMPWR

      SUBROUTINE ZMREAD(KREAD,MA,QX)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: KREAD
      TYPE(MULTI) :: MA(2)
      CHARACTER :: CMBUFZ(LMBUFZ)
      TYPE(FM_SETTINGS) :: QX

      CHARACTER :: LINE(80)
      INTEGER :: J,LB
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMREAD'
      LB = 0

  110 READ (KREAD,"(80A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 80
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFZ) THEN
                 WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                                     '  Raise its size or change the format being used.'
                 STOP
             ENDIF
             CMBUFZ(LB) = LINE(J)
          ENDIF
      ENDDO

      QX%NCALL = QX%NCALL - 1
      CALL ZMINP(CMBUFZ,MA,1,LB,QX)

      RETURN

!             If there is an error, return UNKNOWN.

  120 QX%KFLAG = -4
      CALL ZMWARN(QX)
      CALL ZMST2M('UNKNOWN+UNKNOWN*i',MA,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMREAD

      SUBROUTINE ZMREAL(MA,MBFM,QX)

!  MBFM = REAL(MA)

!  MA is a complex ZM number, MBFM is a real FM number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TYPE(FM_SETTINGS) :: QX

      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMREAL'
      IF (QX%NTRACE /= 0) CALL ZMNTR(2,MA,MA,1,QX)

      CALL FMEQ(MA(1),MBFM,QX)

      IF (QX%NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMREAL

      SUBROUTINE ZMRPWR(MA,IVAL,JVAL,MB,QX)

!  MB = MA ** (IVAL/JVAL)

!  Raise a ZM number to a rational power.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      REAL (KIND(1.0D0)) :: MA2,MR1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IJSIGN,INVERT,IVAL2,J,JVAL2,K,KL,KOVUN,KR_RETRY,KST,L,LVAL,NDSAVE
      REAL :: XVAL
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: AR,BR,F,THETA,X
      INTEGER :: NSTACK(49)
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2),MZ01(2),MZ02(2),MZ03(2),MZ04(2)


      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMRPWR'
      NDSAVE = QX%NDIG
      IF (QX%NTRACE /= 0) THEN
          CALL ZMNTR(2,MA,MA,1,QX)
          CALL FMNTRI(2,IVAL,0,QX)
          CALL FMNTRI(2,JVAL,0,QX)
      ENDIF
      KR_RETRY = 0
      KOVUN = 0
      IF (MA(1)%MP(2) == QX%MEXPOV .OR. MA(1)%MP(2) == QX%MEXPUN .OR.  &
          MA(2)%MP(2) == QX%MEXPOV .OR. MA(2)%MP(2) == QX%MEXPUN) KOVUN = 1

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      IJSIGN = 1
      IVAL2 = ABS(IVAL)
      JVAL2 = ABS(JVAL)
      IF (IVAL > 0 .AND. JVAL < 0) IJSIGN = -1
      IF (IVAL < 0 .AND. JVAL > 0) IJSIGN = -1
      IF (IVAL2 > 0 .AND. JVAL2 > 0) CALL FMGCDI(IVAL2,JVAL2)

!             Check for special cases.

      IF (MA(1)%MP(2) == QX%MUNKNO .OR. MA(2)%MP(2) == QX%MUNKNO .OR.       &
          (IJSIGN <= 0 .AND. MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) .OR.  &
          JVAL == 0) THEN
          MA2 = MA(1)%MP(3)
          QX%KFLAG = -4
          IF (IVAL <= 0 .AND. MA2 == 0) CALL ZMWARN(QX)
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL ZMI2M(1,MB,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2

!             Increase the working precision.

  110 IF (QX%NCALL == 1) THEN
          XVAL = MAX(ABS(IVAL),ABS(JVAL)) + 1
          K = INT((5.0*REAL(QX%DLOGTN) + LOG(XVAL))/QX%ALOGMB + 2.0)
          QX%NDIG = MAX(QX%NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = MAX(ABS(IVAL),ABS(JVAL)) + 1
          K = INT(LOG(XVAL)/QX%ALOGMB + 1.0)
          QX%NDIG = QX%NDIG + K
      ENDIF
      IF (QX%MBASE >= 100*ABS(MA(1)%MP(3)) .OR.  &
          QX%MBASE >= 100*ABS(MA(2)%MP(3))) THEN
          QX%NDIG = QX%NDIG + 1
      ENDIF

      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)
      IF (IVAL2 == 1 .AND. JVAL2 == 2) THEN
          CALL ZMSQRT(MZ02,MZ04,QX)
          IF (IJSIGN < 0) THEN
              CALL ZMI2M(1,MZ01,QX)
              CALL ZMDIV(MZ01,MZ04,MZ02,QX)
              CALL ZMEQ(MZ02,MZ04,QX)
          ENDIF
          GO TO 120
      ENDIF

!             Generate the first approximation to MA**(1/JVAL2).

      CALL ZMI2M(0,MZ04,QX)
      CALL FMDIG(NSTACK,KST,QX)
      QX%NDIG = NSTACK(1)
      CALL FMSQR(MZ02(1),MZ01(1),QX)
      CALL FMSQR(MZ02(2),MXY(1),QX)
      CALL FMADD_R1(MZ01(1),MXY(1),QX)
      CALL FMSQRT_R1(MZ01(1),QX)
      IF (MZ01(1)%MP(2) >= QX%MEXPOV) THEN
          QX%KFLAG = -4
          CALL ZMWARN(QX)
          QX%MXEXP = MXSAVE
          QX%NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

!             Invert MA if ABS(MA) >= 1 and IVAL or JVAL is large.

      INVERT = 0
      IF (IVAL > 5 .OR. JVAL > 5) THEN
          IF (MZ01(1)%MP(2) > 0 .AND. (MZ02(2)%MP(3) /= 0 .OR.  &
              MZ02(1)%MP(1) > 0)) THEN
              INVERT = 1
              QX%NDIG = NSTACK(KST)
              CALL ZMI2M(1,MZ04,QX)
              CALL ZMDIV(MZ04,MZ02,MZ03,QX)
              CALL ZMEQ(MZ03,MZ02,QX)
              QX%NDIG = NSTACK(1)
              CALL FMDIV_R2(MZ04(1),MZ01(1),QX)
          ENDIF
      ENDIF

      CALL FMDIV(MZ02(1),MZ01(1),MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          CALL ZMWARN(QX)
          QX%MXEXP = MXSAVE
          QX%NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      CALL FMM2DP(MXY(1),AR,QX)
      CALL FMDIV(MZ02(2),MZ01(1),MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
          CALL ZMWARN(QX)
          QX%MXEXP = MXSAVE
          QX%NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB,QX)
          IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF
      CALL FMM2DP(MXY(1),BR,QX)
      MR1 = MZ01(1)%MP(2)
      MZ01(1)%MP(2) = 0
      CALL FMM2DP(MZ01(1),X,QX)
      L = INT(MR1/JVAL2)
      F = MR1/DBLE(JVAL2) - L
      X = X**(1.0D0/JVAL2) * DBLE(QX%MBASE)**F
      CALL FMDPM(X,MXY(1),QX)
      MXY(1)%MP(2) = MXY(1)%MP(2) + L

      THETA = ATAN2(BR,AR)
      X = COS(THETA/JVAL2)
      CALL FMDPM(X,MZ04(1),QX)
      X = SIN(THETA/JVAL2)
      CALL FMDPM(X,MZ04(2),QX)
      CALL FMMPY_R2(MXY(1),MZ04(1),QX)
      CALL FMMPY_R2(MXY(1),MZ04(2),QX)

!             Newton iteration.

      DO J = 1, KST
         QX%NDIG = NSTACK(J)
         IF (J < KST) QX%NDIG = QX%NDIG + 1
         LVAL = JVAL2 - 1
         CALL ZMIPWR(MZ04,LVAL,MZ01,QX)
         CALL ZMDIV(MZ02,MZ01,MZ03,QX)
         CALL ZMMPYI(MZ04,LVAL,MZ01,QX)
         CALL ZMADD(MZ01,MZ03,MZ04,QX)
         CALL ZMDIVI(MZ04,JVAL2,MZ03,QX)
         CALL ZMEQ(MZ03,MZ04,QX)
      ENDDO

      CALL ZMIPWR(MZ03,IJSIGN*IVAL2,MZ04,QX)
      IF (INVERT == 1) THEN
          CALL ZMI2M(1,MZ01,QX)
          CALL ZMDIV(MZ01,MZ04,MZ03,QX)
          CALL ZMEQ(MZ03,MZ04,QX)
      ENDIF

!             Round the result and return.

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ04(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ04(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ04,MB,NDSAVE,MXSAVE,KOVUN,QX)
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      RETURN
      END SUBROUTINE ZMRPWR

      SUBROUTINE ZMRSLT(MC,KRESLT,QX)

!  Handle results that are special cases, such as overflow, underflow, and unknown.

!  MC is the result that is returned

!  KRESLT is the result code.  Result codes handled here:

!   0 - Perform the normal operation
!  12 - The result is 'UNKNOWN'

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MC(2)
      INTEGER :: KRESLT
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFSAVE
      INTENT (IN) :: KRESLT
      INTENT (INOUT) :: MC

      KFSAVE = QX%KFLAG

      IF (KRESLT == 12 .OR. KRESLT < 0 .OR. KRESLT > 15) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MC,QX)
          QX%KFLAG = KFSAVE
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE ZMRSLT

      SUBROUTINE ZMSIN(MA,MB,QX)

!  MB = SIN(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5),MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMSIN    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(2) < (-QX%NDIG) .AND. MA(2)%MP(2) < (-QX%NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01,QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMSIN(MZ02(1),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMSINH(MZ02(2),MZ01(2),QX)
          CALL FMI2M(0,MZ01(1),QX)
          GO TO 120
      ENDIF

!             Find COS(REAL(MA)) and SIN(REAL(MA)).

      CALL FMCSSN(MZ02(1),MZ01(2),MZ01(1),QX)

!             Find COSH(IMAG(MA)) and SINH(IMAG(MA)).

      CALL FMCHSH(MZ02(2),MXY(1),MXY(2),QX)

!             SIN(MA) =  SIN(REAL(MA))*COSH(IMAG(MA)) + COS(REAL(MA))*SINH(IMAG(MA)) i

      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMABS(MZ01(1),MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMABS(MZ02(2),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(5),QX)
          CALL FMEXP(MXY(5),MXY(4),QX)
          IF (MZ01(1)%MP(1) < 0) CALL FMMPYI_R1(MXY(4),-1,QX)

          CALL FMABS(MZ01(2),MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(1),QX)
          CALL FMEXP(MXY(1),MXY(5),QX)
          IF (MZ02(2)%MP(1) < 0) CALL FMMPYI_R1(MXY(5),-1,QX)
          IF (MZ01(2)%MP(1) < 0) CALL FMMPYI_R1(MXY(5),-1,QX)

          CALL FMEQ(MXY(4),MZ01(1),QX)
          CALL FMEQ(MXY(5),MZ01(2),QX)
      ELSE
          CALL FMMPY_R1(MZ01(1),MXY(1),QX)
          CALL FMMPY_R1(MZ01(2),MXY(2),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMSIN

      SUBROUTINE ZMSINH(MA,MB,QX)

!  MB = SINH(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5),MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMSINH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(2) < (-QX%NDIG) .AND. MA(2)%MP(2) < (-QX%NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMSIN(MZ02(2),MZ01(2),QX)
          CALL FMI2M(0,MZ01(1),QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMSINH(MZ02(1),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ENDIF

!             Find SIN(IMAG(MA)) and COS(IMAG(MA)).

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2),QX)

!             Find SINH(REAL(MA)) and COSH(REAL(MA)).

      CALL FMCHSH(MZ02(1),MXY(1),MXY(2),QX)

!             SINH(MA) =  SINH(REAL(MA))*COS(IMAG(MA)) + COSH(REAL(MA))*SIN(IMAG(MA)) i

      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMABS(MZ01(1),MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMABS(MZ02(1),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(5),QX)
          CALL FMEXP(MXY(5),MXY(4),QX)
          IF (MZ01(1)%MP(1) < 0) CALL FMMPYI_R1(MXY(4),-1,QX)
          IF (MZ02(1)%MP(1) < 0) CALL FMMPYI_R1(MXY(4),-1,QX)

          CALL FMABS(MZ01(2),MXY(1),QX)
          CALL FMDIVI_R1(MXY(1),2,QX)
          CALL FMLN(MXY(1),MXY(2),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(1),QX)
          CALL FMEXP(MXY(1),MXY(5),QX)
          IF (MZ01(2)%MP(1) < 0) CALL FMMPYI_R1(MXY(5),-1,QX)

          CALL FMEQ(MXY(4),MZ01(1),QX)
          CALL FMEQ(MXY(5),MZ01(2),QX)
      ELSE
          CALL FMMPY_R1(MZ01(1),MXY(2),QX)
          CALL FMMPY_R1(MZ01(2),MXY(1),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMSINH

      SUBROUTINE ZMSQR(MA,MB,QX)

!  MB = MA * MA

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(2),MZ01(2),MZ02(2)
      TYPE(FM_SETTINGS) :: QX


      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSQR    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMSQR'
              CALL ZMNTR(2,MA,MA,1,QX)
          ENDIF
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              QX%NDIG = MAX(QX%NDIG+QX%NGRD52,2)
              IF (QX%MBASE >= 100*ABS(MA(1)%MP(3)) .OR.  &
                  QX%MBASE >= 100*ABS(MA(2)%MP(3))) THEN
                  QX%NDIG = QX%NDIG + 1
              ENDIF
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
          KOVUN = 0
      ENDIF

      KR_RETRY = 0
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(2)%MP(3) == 0) THEN
          CALL FMSQR(MZ02(1),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMSQR(MZ02(2),MZ01(1),QX)
          IF (MZ01(1)%MP(2) /= QX%MUNKNO .AND. MZ01(1)%MP(3) /= 0)  &
              MZ01(1)%MP(1) = -MZ01(1)%MP(1)
          CALL FMI2M(0,MZ01(2),QX)
      ELSE
          CALL FMADD(MZ02(1),MZ02(2),MXY(1),QX)
          CALL FMSUB(MZ02(1),MZ02(2),MXY(2),QX)
          CALL FMMPY(MXY(1),MXY(2),MZ01(1),QX)
          CALL FMMPY(MZ02(1),MZ02(2),MXY(2),QX)
          CALL FMADD(MXY(2),MXY(2),MZ01(2),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      QX%MXEXP = MXSAVE
      QX%NTRACE = NTRSAV
      NDGSV2 = QX%NDIG
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      CALL ZMEQU(MZ01,MB,NDGSV2,NDSAVE,QX)
      IF (MB(1)%MP(2) >= QX%MEXPOV .OR. MB(1)%MP(2) <= -QX%MEXPOV .OR.  &
          MB(2)%MP(2) >= QX%MEXPOV .OR. MB(2)%MP(2) <= -QX%MEXPOV) THEN
          IF (MB(1)%MP(2) == QX%MUNKNO .OR. MB(2)%MP(2) == QX%MUNKNO) THEN
              QX%KFLAG = -4
          ELSE IF (MB(1)%MP(2) == QX%MEXPOV .OR. MB(2)%MP(2) == QX%MEXPOV) THEN
              QX%KFLAG = -5
          ELSE IF (MB(1)%MP(2) == QX%MEXPUN .OR. MB(2)%MP(2) == QX%MEXPUN) THEN
              QX%KFLAG = -6
          ENDIF
          IF ((MB(1)%MP(2) == QX%MUNKNO) .OR. (MB(2)%MP(2) == QX%MUNKNO)  &
             .OR. (MB(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
             .OR. (MB(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
             .OR. (MB(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
             .OR. (MB(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
              QX%NAMEST(QX%NCALL) = 'ZMSQR'
              CALL ZMWARN(QX)
          ENDIF
      ENDIF
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMSQR

      SUBROUTINE ZMSQRT(MA,MB,QX)

!  MB = SQRT(MA).  Principal Square Root.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NTRSAV
      TYPE(FM_SETTINGS) :: QX

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3),MZ01(2),MZ02(2)

      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSQRT   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMSQRT'
              CALL ZMNTR(2,MA,MA,1,QX)
          ENDIF
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              QX%NDIG = MAX(QX%NDIG+QX%NGRD52,2)
              IF (QX%MBASE >= 100*ABS(MA(1)%MP(3)) .OR.  &
                  QX%MBASE >= 100*ABS(MA(2)%MP(3))) THEN
                  QX%NDIG = QX%NDIG + 1
              ENDIF
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
          KOVUN = 0
      ENDIF

      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      MXEXP1 = INT(QX%MXEXP2/2.01D0)
      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMABS(MZ02(2),MXY(1),QX)
          CALL FMDIVI(MXY(1),2,MXY(3),QX)
          CALL FMSQRT_R1(MXY(3),QX)
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMABS(MZ02(1),MXY(3),QX)
          CALL FMSQRT_R1(MXY(3),QX)
      ELSE IF (MA(1)%MP(2) == QX%MEXPUN) THEN
          IF (MA(2)%MP(2) <= -MXEXP1+QX%NDIG+1) THEN
              CALL ZMST2M('UNKNOWN + UNKNOWN i',MZ01,QX)
              GO TO 120
          ENDIF
      ELSE IF (MA(2)%MP(2) == QX%MEXPUN) THEN
          IF (MA(1)%MP(2) <= -MXEXP1+QX%NDIG+1) THEN
              CALL ZMST2M('UNKNOWN + UNKNOWN i',MZ01,QX)
              GO TO 120
          ENDIF
          CALL FMSQR(MZ02(1),MXY(1),QX)
          CALL FMSQR(MZ02(2),MXY(2),QX)
          CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
          CALL FMSQRT_R1(MXY(3),QX)
          IF (MXY(3)%MP(2) == QX%MUNKNO) THEN
              CALL FMABS(MZ02(1),MXY(1),QX)
              CALL FMABS(MZ02(2),MXY(2),QX)
              CALL FMMAX(MXY(1),MXY(2),MZ01(1),QX)
              CALL FMMIN(MXY(1),MXY(2),MZ01(2),QX)
              CALL FMDIV(MZ01(2),MZ01(1),MXY(3),QX)
              CALL FMI2M(1,MXY(1),QX)
              CALL FMADD(MXY(1),MXY(3),MXY(2),QX)
              CALL FMSQRT_R1(MXY(2),QX)
              CALL FMMPY(MZ01(1),MXY(2),MXY(3),QX)
          ENDIF
          CALL FMABS(MZ02(1),MXY(2),QX)
          CALL FMADD_R2(MXY(2),MXY(3),QX)
          CALL FMDIVI_R1(MXY(3),2,QX)
          CALL FMSQRT_R1(MXY(3),QX)
      ELSE
          CALL FMSQR(MZ02(1),MXY(1),QX)
          CALL FMSQR(MZ02(2),MXY(2),QX)
          CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
          CALL FMSQRT_R1(MXY(3),QX)
          IF (MXY(3)%MP(2) == QX%MUNKNO) THEN
              CALL FMABS(MZ02(1),MXY(1),QX)
              CALL FMABS(MZ02(2),MXY(2),QX)
              CALL FMMAX(MXY(1),MXY(2),MZ01(1),QX)
              CALL FMMIN(MXY(1),MXY(2),MZ01(2),QX)
              CALL FMDIV(MZ01(2),MZ01(1),MXY(3),QX)
              CALL FMI2M(1,MXY(1),QX)
              CALL FMADD(MXY(1),MXY(3),MXY(2),QX)
              CALL FMSQRT_R1(MXY(2),QX)
              CALL FMMPY(MZ01(1),MXY(2),MXY(3),QX)
          ENDIF
          CALL FMABS(MZ02(1),MXY(2),QX)
          CALL FMADD_R2(MXY(2),MXY(3),QX)
          CALL FMDIVI_R1(MXY(3),2,QX)
          CALL FMSQRT_R1(MXY(3),QX)
      ENDIF

      CALL FMADD(MXY(3),MXY(3),MXY(2),QX)
      IF (MA(1)%MP(1) >= 0) THEN
          CALL FMDIV(MZ02(2),MXY(2),MZ01(2),QX)
          CALL FMEQ(MXY(3),MZ01(1),QX)
      ELSE
          IF (MA(2)%MP(1) >= 0) THEN
              CALL FMDIV(MZ02(2),MXY(2),MZ01(1),QX)
              CALL FMEQ(MXY(3),MZ01(2),QX)
          ELSE
              CALL FMDIV(MZ02(2),MXY(2),MZ01(1),QX)
              CALL FMEQ(MXY(3),MZ01(2),QX)
              IF (MZ01(1)%MP(2) /= QX%MUNKNO .AND. MZ01(1)%MP(3) /= 0)  &
                  MZ01(1)%MP(1) = -MZ01(1)%MP(1)
              IF (MZ01(2)%MP(2) /= QX%MUNKNO .AND. MZ01(2)%MP(3) /= 0)  &
                  MZ01(2)%MP(1) = -MZ01(2)%MP(1)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      QX%MXEXP = MXSAVE
      CALL ZMEQU(MZ01,MB,QX%NDIG,NDSAVE,QX)

      IF (MB(1)%MP(2) == QX%MUNKNO .OR. MB(2)%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
      ELSE IF (MB(1)%MP(2) == QX%MEXPOV .OR. MB(2)%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
      ELSE IF (MB(1)%MP(2) == QX%MEXPUN .OR. MB(2)%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -6
      ENDIF
      QX%NTRACE = NTRSAV
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      IF ((MB(1)%MP(2) == QX%MUNKNO) .OR. (MB(2)%MP(2) == QX%MUNKNO)  &
         .OR. (MB(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MB(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MB(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
         .OR. (MB(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
          QX%NAMEST(QX%NCALL) = 'ZMSQRT'
          CALL ZMWARN(QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MB,MB,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMSQRT

      SUBROUTINE ZMST2M(STRING,MA,QX)

!  MA = STRING

!  Convert a character string to FM format.
!  This is often more convenient than using ZMINP, which converts an array of character(1) values.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      TYPE(MULTI) :: MA(2)
      CHARACTER :: CMBUFZ(LMBUFZ)
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMST2M'
      LB = LEN(STRING)
      KFSAVE = QX%KFLAG

      IF (LB > LMBUFZ) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF
      DO J = 1, LB
         CMBUFZ(J) = STRING(J:J)
      ENDDO

      QX%NCALL = QX%NCALL - 1
      CALL ZMINP(CMBUFZ,MA,1,LB,QX)

      IF (KFSAVE /= 0) QX%KFLAG = KFSAVE
      RETURN
      END SUBROUTINE ZMST2M

      SUBROUTINE ZMSUB(MA,MB,MC,QX)

!  MC = MA - MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      TYPE(FM_SETTINGS) :: QX
      INTEGER :: KF1,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      IF (ABS(MA(1)%MP(2)) > QX%MEXPAB .OR. ABS(MA(2)%MP(2)) > QX%MEXPAB .OR.  &
          ABS(MB(1)%MP(2)) > QX%MEXPAB .OR. ABS(MB(2)%MP(2)) > QX%MEXPAB .OR.  &
          QX%KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSUB    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
          QX%NDIG = NDSAVE
          QX%MXEXP = MXSAVE
      ELSE
          QX%NCALL = QX%NCALL + 1
          IF (QX%NTRACE /= 0) THEN
              QX%NAMEST(QX%NCALL) = 'ZMSUB'
              CALL ZMNTR(2,MA,MB,2,QX)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMSUB to use more guard digits for user calls.

      QX%NCALL = QX%NCALL - 1
      NTRSAV = QX%NTRACE
      QX%NTRACE = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0

      CALL FMSUB(MA(1),MB(1),MC(1),QX)
      KF1 = QX%KFLAG
      CALL FMSUB(MA(2),MB(2),MC(2),QX)

      QX%NTRACE = NTRSAV
      QX%KWARN = KWRNSV
      QX%NCALL = QX%NCALL + 1
      IF (QX%NTRACE /= 0) QX%NAMEST(QX%NCALL) = 'ZMSUB'
      IF (QX%KFLAG == 1) QX%KFLAG = KF1

      IF (MC(1)%MP(2) == QX%MUNKNO .OR. MC(2)%MP(2) == QX%MUNKNO) THEN
          QX%KFLAG = -4
      ELSE IF (MC(1)%MP(2) == QX%MEXPOV .OR. MC(2)%MP(2) == QX%MEXPOV) THEN
          QX%KFLAG = -5
      ELSE IF (MC(1)%MP(2) == QX%MEXPUN .OR. MC(2)%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -6
      ENDIF
      IF ((MC(1)%MP(2) == QX%MUNKNO) .OR. (MC(2)%MP(2) == QX%MUNKNO)  &
         .OR. (MC(1)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MC(2)%MP(2) == QX%MEXPUN .AND. KOVUN == 0)             &
         .OR. (MC(1)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)             &
         .OR. (MC(2)%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) THEN
          QX%NAMEST(QX%NCALL) = 'ZMSUB'
          CALL ZMWARN(QX)
      ENDIF
      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MC,MC,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMSUB

      SUBROUTINE ZMSUB_R1(MA,MB,QX)

!  MA = MA - MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMSUB(MA,MB,MXY,QX)
      CALL ZMEQ(MXY,MA,QX)


      END SUBROUTINE ZMSUB_R1

      SUBROUTINE ZMSUB_R2(MA,MB,QX)

!  MB = MA - MB

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      TYPE(MULTI) :: MXY(2)


      CALL ZMSUB(MA,MB,MXY,QX)
      CALL ZMEQ(MXY,MB,QX)


      END SUBROUTINE ZMSUB_R2

      SUBROUTINE ZMTAN(MA,MB,QX)

!  MB = TAN(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,K,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NGOAL,N_ACC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3),MZ01(2),MZ02(2),MZ03(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMTAN    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(2) < (-QX%NDIG) .AND. MA(2)%MP(2) < (-QX%NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01,QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMTAN(MZ02(1),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMTANH(MZ02(2),MZ01(2),QX)
          CALL FMI2M(0,MZ01(1),QX)
          GO TO 120
      ENDIF

!             Find SIN(2*REAL(MA)) and COS(2*REAL(MA)).

      CALL FMADD(MZ02(1),MZ02(1),MZ01(1),QX)
      CALL FMCSSN(MZ01(1),MZ01(2),MXY(2),QX)
      CALL FMEQ(MXY(2),MZ01(1),QX)

!             Find SINH(2*IMAG(MA)) and COSH(2*IMAG(MA)).

      CALL FMADD(MZ02(2),MZ02(2),MXY(2),QX)
      CALL FMCHSH(MXY(2),MXY(1),MXY(3),QX)
      CALL FMEQ(MXY(3),MXY(2),QX)

!             TAN(MA) =  SIN(2*REAL(MA))  / (COS(2*REAL(MA))+COSH(2*IMAG(MA)) +
!                        SINH(2*IMAG(MA)) / (COS(2*REAL(MA))+COSH(2*IMAG(MA)) i

      CALL FMADD(MZ01(2),MXY(1),MXY(3),QX)
      CALL FMCANCEL(MZ01(2),MXY(1),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(1),QX)
      IF (MXY(1)%MP(3) == 0) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 7
          GO TO 130
      ELSE IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMDIV_R1(MZ01(1),MXY(1),QX)
          CALL FMIM(1,MZ01(2),QX)
          IF (MXY(2)%MP(1) < 0 .AND. MZ01(2)%MP(2) /= QX%MUNKNO .AND.  &
              MZ01(2)%MP(3) /= 0) MZ01(2)%MP(1) = -MZ01(2)%MP(1)
      ELSE
          CALL FMDIVD(MZ01(1),MXY(2),MXY(1),MZ03(1),MZ03(2),QX)
          CALL ZMEQ(MZ03,MZ01,QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 7
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
  130 IF (N_ACC <= NGOAL) THEN
          IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          QX%NDIG = QX%NDIG + IEXTRA
          GO TO 110
      ENDIF

      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMTAN

      SUBROUTINE ZMTANH(MA,MB,QX)

!  MB = TANH(MA).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,K,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NGOAL,N_ACC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3),MZ01(2),MZ02(2),MZ03(2)
      TYPE(FM_SETTINGS) :: QX


      CALL ZMENTR('ZMTANH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KRSAVE = QX%KRAD
      QX%KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,QX%NDIG,QX)
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMI2M(0,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(2) < (-QX%NDIG) .AND. MA(2)%MP(2) < (-QX%NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01,QX)
          GO TO 120
      ELSE IF (MA(1)%MP(3) == 0) THEN
          CALL FMTAN(MZ02(2),MZ01(2),QX)
          CALL FMI2M(0,MZ01(1),QX)
          GO TO 120
      ELSE IF (MA(2)%MP(3) == 0) THEN
          CALL FMTANH(MZ02(1),MZ01(1),QX)
          CALL FMI2M(0,MZ01(2),QX)
          GO TO 120
      ENDIF

!             Find SIN(2*IMAG(MA)) and COS(2*IMAG(MA)).

      CALL FMADD(MZ02(2),MZ02(2),MZ01(1),QX)
      CALL FMCSSN(MZ01(1),MZ01(2),MXY(2),QX)
      CALL FMEQ(MXY(2),MZ01(1),QX)

!             Find SINH(2*REAL(MA)) and COSH(2*REAL(MA)).

      CALL FMADD(MZ02(1),MZ02(1),MXY(2),QX)
      CALL FMCHSH(MXY(2),MXY(1),MXY(3),QX)
      CALL FMEQ(MXY(3),MXY(2),QX)

!             TANH(MA) =  SINH(2*REAL(MA)) / (COS(2*IMAG(MA))+COSH(2*REAL(MA)) +
!                         SIN(2*IMAG(MA))  / (COS(2*IMAG(MA))+COSH(2*REAL(MA)) i

      CALL FMADD(MZ01(2),MXY(1),MXY(3),QX)
      CALL FMCANCEL(MZ01(2),MXY(1),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(1),QX)
      IF (MXY(1)%MP(3) == 0) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 7
          GO TO 130
      ELSE IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMDIV(MZ01(1),MXY(1),MZ01(2),QX)
          CALL FMIM(1,MZ01(1),QX)
          IF (MXY(2)%MP(1) < 0) MZ01(1)%MP(1) = -1
      ELSE
          CALL FMDIVD(MZ01(1),MXY(2),MXY(1),MZ03(2),MZ03(1),QX)
          CALL ZMEQ(MZ03,MZ01,QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(1)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MZ01(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 7
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
  130 IF (N_ACC <= NGOAL) THEN
          IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          QX%NDIG = QX%NDIG + IEXTRA
          GO TO 110
      ENDIF

      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KOVUN,QX)
      QX%KRAD = KRSAVE
      RETURN
      END SUBROUTINE ZMTANH

      SUBROUTINE ZMWARN(QX)

!  Called by one of the ZM routines to print a warning message if any error condition arises in
!  that routine.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: NAME
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: NCS

      IF (QX%KFLAG >= 0 .OR. QX%NCALL /= 1 .OR. QX%KWARN <= 0) RETURN
      NCS = QX%NCALL
      NAME = QX%NAMEST(QX%NCALL)
      WRITE (KW,"(/' Error of type KFLAG =',I3,"   //  &
                "' in FM package in routine ',A/)"     &
            ) QX%KFLAG,TRIM(NAME)

  110 QX%NCALL = QX%NCALL - 1
      IF (QX%NCALL > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (QX%KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (QX%KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (QX%KFLAG == -3) THEN
          WRITE (KW,                                                     &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (QX%KFLAG == -4 .OR. QX%KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (QX%KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (QX%KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (QX%KFLAG == -8 .AND. NAME == 'ZMOUT') THEN
          WRITE (KW,                                                          &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (QX%KFLAG == -8 .AND. NAME == 'ZMREAD') THEN
          WRITE (KW,                                                        &
                 "(' The CMBUFF array is not big enough to hold the',"  //  &
                 "' input character string'/"                           //  &
                 "' UNKNOWN has been returned.'/)"                          &
                )
      ELSE IF (QX%KFLAG == -9) THEN
          WRITE (KW,                                                &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,                                        &
                 "(I23,' digits were requested (NDIG).'/)"  &
                ) QX%NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ENDIF

      QX%NCALL = NCS
      IF (QX%KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE ZMWARN

      SUBROUTINE ZMWRIT(KWRITE,MA,QX)

!  Write MA on unit KWRITE under the current format.  Multi-line numbers will have '&' as the last
!  nonblank character on all but the last line of the real part and the imaginary part.
!  These numbers can then be read easily using ZMREAD.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: KWRITE
      TYPE(MULTI) :: MA(2)
      CHARACTER :: CMBUFZ(LMBUFZ)
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,K,KSAVE,L,LAST,LAST1,LAST2,LB,ND,NEXP
      INTENT (IN) :: MA,KWRITE

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMWRIT'
      KSAVE = QX%KFLAG
      ND = INT(REAL(QX%NDIG)*LOG10(REAL(QX%MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = 2*MAX(QX%JFORM2+NEXP,ND+NEXP) + 3
      IF (LB > LMBUFZ) THEN
          WRITE (*,"(//A//)") ' Output buffer CMBUFZ is not big enough.' //  &
                              '  Raise its size or change the format being used.'
          STOP
      ENDIF
      CALL ZMOUT(MA,CMBUFZ,LB,LAST1,LAST2,QX)
      QX%KFLAG = KSAVE
      LAST = LAST2 + 1
      DO J = 1, LAST2
         IF (CMBUFZ(LAST-J) /= ' ' .OR. J == LAST2) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFZ(K),K=1,L)
             ELSE
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFZ(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFZ(K),K=L-72,L)
             ENDIF
             QX%NCALL = QX%NCALL - 1
             RETURN
         ENDIF
      ENDDO
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMWRIT

      SUBROUTINE ZMZ2M(ZVAL,MA,QX)

!  MA = ZVAL

!  ZVAL is complex and is converted to ZM form.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      COMPLEX :: ZVAL
      TYPE(MULTI) :: MA(2)
      INTENT (IN) :: ZVAL
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'ZMZ2M'
      IF (QX%NTRACE /= 0) CALL ZMNTRZ(2,ZVAL,1,QX)

      CALL FMSP2M(REAL(ZVAL),MA(1),QX)
      CALL FMSP2M(AIMAG(ZVAL),MA(2),QX)

      IF (QX%NTRACE /= 0) CALL ZMNTR(1,MA,MA,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE ZMZ2M




!  These FM routines perform gamma and related functions.

!  FMBERNOULLI(N,MA)    MA = B(N)  Nth Bernoulli number

!  FMBETA(MA,MB,MC)     MC = Beta(MA,MB)

!  FMCOMB(MA,MB,MC)     MC = Combination MA choose MB  (Binomial coeff.)

!  FMEULER(MA)          MA = Euler's constant ( 0.5772156649... )     < old name: FMEULR >

!  FMFACT(MA,MB)        MB = MA Factorial  (Gamma(MA+1))

!  FMGAM(MA,MB)         MB = Gamma(MA)

!  FMIBTA(MX,MA,MB,MC)  MC = Incomplete Beta(MX,MA,MB)

!  FMIGM1(MA,MB,MC)     MC = Incomplete Gamma(MA,MB).  Lower case Gamma(a,x)

!  FMIGM2(MA,MB,MC)     MC = Incomplete Gamma(MA,MB).  Upper case Gamma(a,x)

!  FMLNGM(MA,MB)        MB = Ln(Gamma(MA))

!  FMPGAM(N,MA,MB)      MB = Polygamma(N,MA)  (Nth derivative of Psi)

!  FMPOCH(MA,N,MB)      MB = MA*(MA+1)*(MA+2)*...*(MA+N-1)  (Pochhammer)

!  FMPSI(MA,MB)         MB = Psi(MA)      (Derivative of Ln(Gamma(MA))

!  For each of these routines there is also a version available for which the argument list is the
!  same but all FM numbers are in packed format.  The packed versions have the same names except
!  'FM' is replaced by 'FP' at the start of each name.

! --------------------------------------------------------------------------------------------------

      SUBROUTINE FMARG2(KROUTN,NARGS,MA,MB,KRESLT,QX)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)
!  KRESLT - Result code returned to the calling routine.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: KROUTN
      TYPE(MULTI) :: MA,MB
      INTEGER :: NARGS,KRESLT
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: NCATMA,NCATMB

      INTEGER, PARAMETER ::                                                     &
               KFACT(15) = (/ 12,12, 0,12, 0, 0, 8, 8, 8, 0, 0, 8, 0, 4, 4 /),  &
               KGAM(15)  = (/ 12,12, 0,12, 0, 0, 3,12, 4, 0, 0, 8, 0, 4, 4 /),  &
               KLNGM(15) = (/ 12,12, 0,12,12,12,12,12,12, 0, 0,11, 0, 0, 4 /),  &
               KPSI(15)  = (/ 12,12, 0,12, 0, 0, 4,12, 3, 0, 0, 0, 0, 0,12 /)
      INTENT (IN) :: MA,MB

      CALL FMARGS(KROUTN,NARGS,MA,MB,KRESLT,QX)
      IF (QX%KFLAG /= 0) RETURN

!             Check for special cases.

      CALL FMCAT(MA,NCATMA,QX)
      NCATMB = 0
      IF (NARGS == 2) CALL FMCAT(MB,NCATMB,QX)

      IF (KROUTN == 'FMFACT') THEN
          KRESLT = KFACT(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMGAM') THEN
          KRESLT = KGAM(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMLNGM') THEN
          KRESLT = KLNGM(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMPSI') THEN
          KRESLT = KPSI(NCATMA)
          GO TO 110
      ENDIF

      KRESLT = 0
      RETURN

  110 IF (KRESLT == 12) THEN
          QX%KFLAG = -4
          CALL FMWRN2(QX)
      ENDIF
      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              QX%KFLAG = -5
          ELSE
              QX%KFLAG = -5
              CALL FMWRN2(QX)
          ENDIF
      ENDIF
      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              QX%KFLAG = -6
          ELSE
              QX%KFLAG = -6
              CALL FMWRN2(QX)
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMARG2

      SUBROUTINE FMBERNOULLI(N,MA,QX)

!  MA = B(N)  where B(N) is the Nth Bernoulli number.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N
      TYPE(MULTI) :: MA
      REAL (KIND(1.0D0)) :: MBSBRN
      INTEGER :: NUMBRN
      TYPE(MULTI) :: MBERN(LMBERN)
      INTEGER :: NDBERN(LMBERN)
      TYPE(FM_SETTINGS) :: QX

      DOUBLE PRECISION :: B
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,NDSAVE
      INTENT (IN) :: N
      INTENT (INOUT) :: MA
      TYPE(MULTI) :: MXY(4)


      MBSBRN = 0
      NUMBRN = 0
      NDBERN = 0

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'BERNOULLI'
      IF (QX%NTRACE /= 0) THEN
          CALL FMNTRI(2,N,1,QX)
      ENDIF

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = INT(5.0/QX%ALOGMT + 2.0 + (REAL(QX%NDIG)*QX%ALOGMT)**0.35/QX%ALOGMT)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF
      KOVUN = 0
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      KR_RETRY = 0
      IF ((MOD(N,2) == 1 .AND. N > 2) .OR. N < 0) THEN
          CALL FMI2M(0,MXY(4),QX)
          GO TO 120
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF

!             For functions that sum series using Bernoulli numbers, N will normally be NUMBRN+2
!             here, or possibly 28 when NUMBRN is zero.  Check to see if this N is much larger than
!             NUMBRN and can be computed directly from the zeta(N) series without computing
!             and saving the intermediate Bernoulli numbers, otherwise call FMBERN.

      B = QX%NDIG*LOG(DBLE(QX%MBASE))/6.91
      IF (N > NUMBRN+100 .AND. N > B) THEN
          CALL FMI2M(1,MXY(1),QX)
          DO J = 2, 10000
             CALL FMI2M(J,MXY(2),QX)
             CALL FMIPWR(MXY(2),-N,MXY(3),QX)
             CALL FMCSADD_R1(MXY(1),MXY(3),QX)
             IF (QX%KFLAG == 1) EXIT
          ENDDO
          CALL FMI2M(N,MXY(3),QX)
          CALL FMFACT(MXY(3),MXY(2),QX)
          CALL FMMPY_R1(MXY(1),MXY(2),QX)
          CALL FMMPYI_R1(MXY(1),2*(-1)**(N/2+1),QX)
          CALL FMPI(MXY(2),QX)
          CALL FMMPYI_R1(MXY(2),2,QX)
          CALL FMIPWR(MXY(2),N,MXY(3),QX)
          CALL FMDIV(MXY(1),MXY(3),MXY(4),QX)
      ELSE
          CALL FMI2M(1,MXY(1),QX)
          CALL FMBERN(N,MXY(1),MXY(4),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(4)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

  120 CALL FMEXT2(MXY(4),MA,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMBERNOULLI

      SUBROUTINE FMBERN(N,MA,MB,MBSBRN,NUMBRN,MBERN,NDBERN,QX)

!  MB = MA*B(N)      B(N) is the Nth Bernoulli number.  (Internal routine used by special functions)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N
      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MBSBRN
      INTEGER :: NUMBRN
      TYPE(MULTI) :: MBERN(LMBERN)
      INTEGER :: NDBERN(LMBERN)
      TYPE(FM_SETTINGS) :: QX

!             MBERN is the array used to save Bernoulli numbers so they do not have to be
!                   re-computed on subsequent calls.

!             Only the even-numbered Bernoulli numbers are stored.
!             B(2N) starts in MBERN(N) for 2N >= 28.
!             The first few numbers have small numerators and denominators, and they are done using
!             FMMPYI and FMDIVI, and are not stored in MBERN.

      DOUBLE PRECISION :: U,UJ,X,B
      REAL (KIND(1.0D0)) :: MNEXP,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: INTNDG,J,J2,K,KL,KOVUN,KR_RETRY,KRESLT,L,LARGE,LARGED,N2,NBOT,  &
                 NDIV,NDP,NDSAV1,NDSAV2,NDSAVE,NEXTD,NEXTN,NMPY,NSTART,NTD,NTN,NTOP,NX
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(5)


      IF (QX%NTRACE /= 0) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMBERN'
          CALL FMNTRI(2,N,1,QX)
          QX%NCALL = QX%NCALL - 1
      ENDIF
      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (ABS(MA%MP(2)) > QX%MEXPAB) THEN
          CALL FMENT2('FMBERN   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
          IF (KRESLT /= 0) THEN
              RETURN
          ENDIF
      ELSE
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMBERN'
          IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MA,1,0,QX)
          KOVUN = 0
          IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
          NDSAVE = QX%NDIG
          IF (QX%NCALL == 1) THEN
              K = INT(5.0/QX%ALOGMT + 2.0 + (REAL(QX%NDIG)*QX%ALOGMT)**0.35/QX%ALOGMT)
              QX%NDIG = MAX(QX%NDIG+K,2)
          ENDIF
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(5),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (N >= 2 .AND. N <= 26) THEN
          CALL FMBER2(N,MXY(5),MXY(4),QX)
          GO TO 120
      ELSE IF (N == 0) THEN
          CALL FMEQ(MXY(5),MXY(4),QX)
          GO TO 120
      ELSE IF (N == 1) THEN
          CALL FMDIVI(MXY(5),-2,MXY(4),QX)
          GO TO 120
      ELSE IF (MA%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(4),QX)
          GO TO 120
      ENDIF

      IF (MOD(N,2) == 1 .OR. N < 0) THEN
          CALL FMI2M(0,MXY(4),QX)
          GO TO 120
      ELSE IF (N/2 > LMBERN) THEN
          QX%KFLAG = -11
          CALL FMWRN2(QX)
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Too many Bernoulli numbers were needed in FMBERN.'
          WRITE (KW,*) ' B(',N,') was requested, and the current maximum is B(',LMBERN*2,').'
          WRITE (KW,*) ' '
          QX%MXEXP = MXSAVE
          QX%NDIG = NDSAVE
          CALL FMST2M('UNKNOWN',MB,QX)
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1,QX)
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

!             See if B(N) has already been computed with sufficient precision.

      N2 = N/2
      IF (QX%MBASE == MBSBRN) THEN
          IF (N <= NUMBRN) THEN
              IF (SIZE(MBERN(N2)%MP) >= QX%NDIG+2) THEN
                  IF (NDBERN(N2) >= QX%NDIG) THEN
                      CALL FMMPY(MBERN(N2),MXY(5),MXY(4),QX)
                      GO TO 120
                  ENDIF
              ENDIF
          ENDIF
      ELSE
          DO J = 28, NUMBRN, 2
             NDBERN(J/2) = 0
          ENDDO
          NUMBRN = 0
      ENDIF

!             Compute more Bernoulli numbers.

      X = 1.0D0
      B = DBLE(QX%MBASE)
      NDP = 0
      DO J = 1, 80
         X = X/B
         IF ((1.0D0+X) <= 1.0D0) THEN
             NDP = J-1
             IF (QX%NDIG <= NDP) X = 4.0D0*QX%DPPI*QX%DPPI
             EXIT
         ENDIF
      ENDDO
      INTNDG = INT(QX%ALOGMX/QX%ALOGMB + 1.0)
      NX = INT(DBLE(QX%NDIG)*QX%DLOGMB/QX%DLOGTW + 2.0D0)
      NSTART = 28
      IF (MBSBRN == QX%MBASE .AND. NUMBRN >= 28) THEN
          NSTART = NUMBRN + 2
          DO J = 28, NUMBRN, 2
             IF (SIZE(MBERN(J/2)%MP) < QX%NDIG+3 .OR. NDBERN(J/2) < QX%NDIG) THEN
                 NSTART = J
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      DO J = NSTART, N, 2

!             Check to see if J is large enough so that the formula
!             B(J) = -B(J-2)*(J-1)*J/(2*pi)**2 can be used.

         IF (J >= NX .AND. QX%NDIG <= NDP .AND. J > 28) THEN
             J2 = J/2
             MNEXP = MBERN(J2-1)%MP(2)
             MBERN(J2-1)%MP(2) = 0
             CALL FMM2DP(MBERN(J2-1),U,QX)
             MBERN(J2-1)%MP(2) = MNEXP
             UJ = J
             U = -U*(UJ*UJ-UJ)/X
             NUMBRN = J
             MBSBRN = QX%MBASE
             CALL FMDPM(U,MBERN(J2),QX)
             MBERN(J2)%MP(2) = MBERN(J2)%MP(2) + MNEXP
             NDBERN(J2) = QX%NDIG
             CYCLE
         ENDIF

         IF (J >= NX .AND. J > 28) THEN
             LARGE = INT(INTMAX/J)
             J2 = J/2
             NUMBRN = J
             MBSBRN = QX%MBASE
             CALL FMPI(MXY(2),QX)
             CALL FMSQR_R1(MXY(2),QX)
             IF (MOD(J,4) == 0 .OR. MOD(J,4) == 1) THEN
                 IF (J < LARGE) THEN
                     L = -(J*J-J)/4
                     CALL FMCSMPYI(MBERN(J2-1),L,MXY(3),QX)
                 ELSE
                     CALL FMCSMPYI(MBERN(J2-1),-J,MXY(3),QX)
                     CALL FMCSMPYI_R1(MXY(3),J-1,QX)
                     CALL FMCSDIVI_R1(MXY(3),4,QX)
                 ENDIF
             ELSE
                 IF (J < LARGE) THEN
                     L = -(J*J-J)
                     CALL FMCSMPYI(MBERN(J2-1),L,MXY(3),QX)
                     CALL FMCSDIVI_R1(MXY(3),4,QX)
                 ELSE
                     CALL FMCSMPYI(MBERN(J2-1),-J,MXY(3),QX)
                     CALL FMCSMPYI_R1(MXY(3),J-1,QX)
                     CALL FMCSDIVI_R1(MXY(3),4,QX)
                 ENDIF
             ENDIF
             CALL FMCSDIV(MXY(3),MXY(2),MBERN(J2),QX)
             NDBERN(J2) = QX%NDIG
             CYCLE
         ENDIF

!             Use the recurrence involving a sum of binomial coefficients times previous B's.

         NTOP = J + 3
         NBOT = J - 6
         LARGE = INT(INTMAX/NTOP)
         LARGED = MIN(LARGE,INT(MXBASE))
         CALL FMCMBI(NTOP,NBOT,MXY(2),QX)
         IF (NBOT <= 26) THEN
             CALL FMBER2(NBOT,MXY(2),MXY(3),QX)
         ELSE
             CALL FMMPY(MBERN(NBOT/2),MXY(2),MXY(3),QX)
         ENDIF
         NDSAV1 = QX%NDIG
         DO NBOT = J-12, 0, -6
            NTN = NBOT + 6
            NTD = NTOP - NBOT - 5
            NEXTN = NTN
            NEXTD = NTD
            IF (NBOT >= 6) THEN
                NDSAV2 = QX%NDIG
                DO K = 1, 5
                   NEXTN = NEXTN - 1
                   NEXTD = NEXTD + 1
                   NMPY = NTN*NEXTN
                   NDIV = NTD*NEXTD
                   IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                       NTN = NMPY
                       NTD = NDIV
                   ELSE
                       CALL FMGCDI(NMPY,NDIV)
                       IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                           NTN = NMPY
                           NTD = NDIV
                       ELSE
                           QX%NDIG = MAX(QX%NGRD22,MIN(NDSAV2,INT(MXY(2)%MP(2))+INTNDG))
                           CALL FMCSMPYI_R1(MXY(2),NTN,QX)
                           CALL FMCSDIVI_R1(MXY(2),NTD,QX)
                           NTN = NEXTN
                           NTD = NEXTD
                       ENDIF
                   ENDIF
                ENDDO
                QX%NDIG = MAX(QX%NGRD22,MIN(NDSAV2,INT(MXY(2)%MP(2))+INTNDG))
                CALL FMCSMPYI_R1(MXY(2),NTN,QX)
                CALL FMCSDIVI_R1(MXY(2),NTD,QX)
                QX%NDIG = NDSAV2
            ELSE
                CALL FMCMBI(NTOP,NBOT,MXY(2),QX)
            ENDIF

!             Now MXY(2) is the combination NTOP choose NBOT.

            IF (NBOT <= 26) THEN
                CALL FMBER2(NBOT,MXY(2),MXY(4),QX)
            ELSE
                CALL FMMPY(MBERN(NBOT/2),MXY(2),MXY(4),QX)
            ENDIF
            QX%NDIG = NDSAV1
            CALL FMCSADD_R1(MXY(3),MXY(4),QX)
            QX%NDIG = MAX(QX%NGRD22,NDSAV1-INT(MXY(3)%MP(2)-MXY(4)%MP(2)))
         ENDDO

         QX%NDIG = NDSAV1
         IF (MOD(J,6) == 4) THEN
             CALL FMI2M(NTOP,MXY(1),QX)
             CALL FMCSDIVI(MXY(1),-6,MXY(4),QX)
             CALL FMSUB_R2(MXY(4),MXY(3),QX)
         ELSE
             CALL FMI2M(NTOP,MXY(1),QX)
             CALL FMCSDIVI(MXY(1),3,MXY(4),QX)
             CALL FMSUB_R2(MXY(4),MXY(3),QX)
         ENDIF

         J2 = J/2
         NUMBRN = J
         MBSBRN = QX%MBASE

         CALL FMCSMPYI_R1(MXY(3),6,QX)
         NTN = NTOP*(NTOP-1)
         LARGE = INT(INTMAX/NTOP)
         IF (NTN > MXBASE .OR. NTOP > LARGE) THEN
             CALL FMCSDIVI_R1(MXY(3),NTOP,QX)
             NTN = NTOP - 1
             CALL FMCSDIVI_R1(MXY(3),NTN,QX)
             NTN = NTOP - 2
             CALL FMCSDIVI(MXY(3),NTN,MBERN(J2),QX)
         ELSE IF (NTN > MXBASE/(NTOP-2) .OR. NTN > LARGE) THEN
             CALL FMCSDIVI_R1(MXY(3),NTN,QX)
             NTN = NTOP - 2
             CALL FMCSDIVI(MXY(3),NTN,MBERN(J2),QX)
         ELSE
             NTN = NTN*(NTOP-2)
             CALL FMCSDIVI(MXY(3),NTN,MBERN(J2),QX)
         ENDIF
         NDBERN(J2) = QX%NDIG
      ENDDO

      CALL FMMPY(MBERN(N2),MXY(5),MXY(4),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(4)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      CALL FMEXT2(MXY(4),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMBERN

      SUBROUTINE FMBER2(N,MA,MB,QX)

!  Internal routine for small Bernoulli numbers.

!  MB = MA*B(N) for N an even integer between 2 and 26.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N
      TYPE(MULTI) :: MA,MB
      INTEGER :: N2
      INTEGER :: NBTOP(13) = (/  &
              1,   1,  1,   1,  5, -691, 7, -3617, 43867, -174611, 854513, -236364091, 8553103 /)
      INTEGER :: NBBOT(13) = (/  &
              6, -30, 42, -30, 66, 2730, 6,   510,   798,     330,    138,       2730,       6 /)
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX

      IF (N <= 0) THEN
          CALL FMEQ(MA,MB,QX)
          RETURN
      ELSE IF (N == 1) THEN
          CALL FMDIVI(MA,-2,MB,QX)
          RETURN
      ELSE IF (MOD(N,2) == 1) THEN
          CALL FMI2M(0,MB,QX)
          RETURN
      ENDIF

      N2 = N/2

      IF (N <= 26) THEN
          IF (NBTOP(N2) == 1) THEN
              CALL FMDIVI(MA,NBBOT(N2),MB,QX)
          ELSE
              CALL FMMPYI(MA,NBTOP(N2),MB,QX)
              CALL FMDIVI_R1(MB,NBBOT(N2),QX)
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMBER2

      SUBROUTINE FMBETA(MA,MB,MC,QX)

!  MC = beta(MA,MB).  beta(MA,MB) = gamma(MA) * gamma(MB) / gamma(MA+MB)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE,MZERO
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K10,K11,KB,KC,KFLKB,KFLNKB,KL,KOVUN,KR_RETRY,KRESLT,  &
                 KWRNSV,N,NB,NBOT,NDSAVE,NK,NKB
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(22)
      TYPE(FM_SETTINGS) :: QX

      IEXTRA = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. (MA%MP(2) < -QX%NDIG .OR. MB%MP(2) < -QX%NDIG) .AND.  &
          MA%MP(2) > (-QX%MXEXP) .AND. MB%MP(2) > (-QX%MXEXP)              .AND.     &
          MA%MP(2) /= QX%MUNKNO .AND. MB%MP(2) /= QX%MUNKNO) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          NDSAVE = QX%NDIG
          QX%NDIG = 2*QX%NDIG + QX%NGRD52
          IF (MA%MP(2) <= MB%MP(2)) THEN
              CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
              CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
          ELSE
              CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
              CALL FMEQU(MB,MXY(1),NDSAVE,QX%NDIG,QX)
          ENDIF
          CALL FMABS(MXY(1),MXY(3),QX)
          CALL FMABS(MXY(2),MXY(4),QX)
          CALL FMADD(MXY(3),MXY(4),MXY(7),QX)
          CALL FMSQR(MXY(7),MXY(3),QX)
          IF (MXY(3)%MP(2) <= MXY(7)%MP(2) - NDSAVE) THEN
              CALL FMI2M(1,MXY(3),QX)
              CALL FMDIV(MXY(3),MXY(1),MXY(4),QX)
              CALL FMDIV(MXY(3),MXY(2),MXY(6),QX)
              IF (MXY(4)%MP(2) < QX%MEXPOV) THEN
                  CALL FMADD(MXY(1),MXY(2),MXY(7),QX)
                  CALL FMPI(MXY(8),QX)
                  CALL FMSQR_R1(MXY(8),QX)
                  CALL FMMPY(MXY(7),MXY(8),MXY(9),QX)
                  CALL FMDIVI_R1(MXY(9),6,QX)
                  CALL FMSUB(MXY(6),MXY(9),MXY(10),QX)
                  CALL FMADD_R2(MXY(4),MXY(10),QX)
                  CALL FMEQU(MXY(10),MC,QX%NDIG,NDSAVE,QX)
                  QX%KFLAG = 0
                  QX%NTRACE = J
                  QX%KWARN = K
                  QX%NDIG = NDSAVE
                  IF (MC%MP(2) < (-QX%MXEXP) .OR. MC%MP(2) > QX%MXEXP+1) GO TO 110
                  IF (QX%NTRACE /= 0) THEN
                      QX%NCALL = QX%NCALL + 1
                      QX%NAMEST(QX%NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1,QX)
                      QX%NCALL = QX%NCALL - 1
                  ENDIF
                  IF (QX%NTRACE /= 0) THEN
                      QX%NCALL = QX%NCALL + 1
                      QX%NAMEST(QX%NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1,QX)
                      QX%NCALL = QX%NCALL - 1
                  ENDIF
                  RETURN
              ENDIF
          ELSE
              CALL FMI2M(1,MXY(3),QX)
              CALL FMSUB(MXY(2),MXY(3),MXY(4),QX)
              IF (MXY(4)%MP(3) == 0) THEN
                  QX%NDIG = NDSAVE
                  CALL FMDIV(MXY(3),MXY(1),MC,QX)
                  QX%KFLAG = 0
                  QX%NTRACE = J
                  QX%KWARN = K
                  IF (MC%MP(2) < (-QX%MXEXP) .OR. MC%MP(2) > QX%MXEXP+1) GO TO 110
                  IF (QX%NTRACE /= 0) THEN
                      QX%NCALL = QX%NCALL + 1
                      QX%NAMEST(QX%NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1,QX)
                      QX%NCALL = QX%NCALL - 1
                  ENDIF
                  IF (QX%NTRACE /= 0) THEN
                      QX%NCALL = QX%NCALL + 1
                      QX%NAMEST(QX%NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1,QX)
                      QX%NCALL = QX%NCALL - 1
                  ENDIF
                  RETURN
              ELSE
                  CALL FMDIV(MXY(3),MXY(1),MXY(4),QX)
                  CALL FMEULR(MXY(5),QX)
                  CALL FMPSI(MXY(2),MXY(6),QX)
                  CALL FMADD(MXY(5),MXY(6),MXY(7),QX)
                  CALL FMSUB(MXY(4),MXY(7),MXY(8),QX)
                  CALL FMEQU(MXY(8),MC,QX%NDIG,NDSAVE,QX)
                  QX%KFLAG = 0
                  QX%NTRACE = J
                  QX%KWARN = K
                  QX%NDIG = NDSAVE
                  IF (MC%MP(2) < (-QX%MXEXP) .OR. MC%MP(2) > QX%MXEXP+1) GO TO 110
                  IF (QX%NTRACE /= 0) THEN
                      QX%NCALL = QX%NCALL + 1
                      QX%NAMEST(QX%NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1,QX)
                      QX%NCALL = QX%NCALL - 1
                  ENDIF
                  IF (QX%NTRACE /= 0) THEN
                      QX%NCALL = QX%NCALL + 1
                      QX%NAMEST(QX%NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1,QX)
                      QX%NCALL = QX%NCALL - 1
                  ENDIF
                  RETURN
              ENDIF
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
      ENDIF

  110 CALL FMENT2('FMBETA   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
      CALL FMEQ(MXY(1),MXY(21),QX)

      JR = QX%KROUND
      QX%KROUND = 1
      CALL FMADD(MXY(1),MXY(2),MXY(17),QX)
      QX%KROUND = JR
      IF (MXY(1)%MP(3) == 0 .OR. MXY(2)%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(22),QX)
          QX%KFLAG = -4
          GO TO 140
      ENDIF

!             See if any of the terms are negative integers.

      CALL FMINT(MXY(1),MXY(8),QX)
      IF (MXY(1)%MP(1) < 0) THEN
          IF (FMCOMP(MXY(1),'==',MXY(8),QX)) THEN
              CALL FMST2M('UNKNOWN',MXY(22),QX)
              QX%KFLAG = -4
              GO TO 140
          ENDIF
      ENDIF
      CALL FMINT(MXY(2),MXY(9),QX)
      IF (MXY(2)%MP(1) < 0) THEN
          IF (FMCOMP(MXY(2),'==',MXY(9),QX)) THEN
              CALL FMST2M('UNKNOWN',MXY(22),QX)
              QX%KFLAG = -4
              GO TO 140
          ENDIF
      ENDIF
      IF (FMCOMP(MXY(17),'==',MXY(1),QX)) THEN
          IF (MXY(2)%MP(2) > QX%MEXPAB) THEN
              CALL FMABS(MXY(2),MXY(13),QX)
              CALL FMDPM(QX%DLOGMB,MXY(6),QX)
              CALL FMMPY_R2(MXY(6),MXY(13),QX)
              J = (MXY(1)%MP(2)+1)
              CALL FMMPYI_R1(MXY(13),J,QX)
          ELSE
              CALL FMABS(MXY(2),MXY(13),QX)
          ENDIF
          CALL FMI2M(1,MXY(6),QX)
          CALL FMULP(MXY(6),MXY(7),QX)
          IF (FMCOMP(MXY(13),'<=',MXY(7),QX)) THEN
              CALL FMGAM(MXY(2),MXY(22),QX)
              GO TO 140
          ENDIF
      ENDIF
      IF (FMCOMP(MXY(17),'==',MXY(2),QX)) THEN
          IF (MXY(1)%MP(2) > QX%MEXPAB) THEN
              CALL FMABS(MXY(1),MXY(13),QX)
              CALL FMDPM(QX%DLOGMB,MXY(6),QX)
              CALL FMMPY_R2(MXY(6),MXY(13),QX)
              J = (MXY(2)%MP(2)+1)
              CALL FMMPYI_R1(MXY(13),J,QX)
          ELSE
              CALL FMABS(MXY(1),MXY(13),QX)
          ENDIF
          CALL FMI2M(1,MXY(6),QX)
          CALL FMULP(MXY(6),MXY(7),QX)
          IF (FMCOMP(MXY(13),'<=',MXY(7),QX)) THEN
              CALL FMGAM(MXY(1),MXY(22),QX)
              GO TO 140
          ENDIF
      ENDIF
      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          IF (MXY(1)%MP(1)*MXY(1)%MP(3) > 0 .AND. MXY(2)%MP(1) > 0 .AND.  &
              MXY(2)%MP(2) >= 1) THEN
              CALL FMST2M('UNDERFLOW',MXY(22),QX)
              QX%KFLAG = -6
              GO TO 140
          ENDIF
      ENDIF
      IF (MXY(2)%MP(2) == QX%MEXPOV) THEN
          IF (MXY(2)%MP(1)*MXY(2)%MP(3) > 0 .AND. MXY(1)%MP(1) > 0 .AND.  &
              MXY(1)%MP(2) >= 1) THEN
              CALL FMST2M('UNDERFLOW',MXY(22),QX)
              QX%KFLAG = -6
              GO TO 140
          ENDIF
      ENDIF
      IF (MXY(17)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(22),QX)
          GO TO 130
      ELSE IF (MXY(17)%MP(1) < 0) THEN
          CALL FMSUB(MXY(1),MXY(8),MXY(6),QX)
          CALL FMSUB(MXY(2),MXY(9),MXY(13),QX)
          CALL FMADD_R2(MXY(6),MXY(13),QX)
          CALL FMINT(MXY(13),MXY(14),QX)
          IF (FMCOMP(MXY(13),'==',MXY(14),QX)) THEN
              CALL FMI2M(0,MXY(22),QX)
              GO TO 130
          ENDIF
      ENDIF

!             See if any of the terms are small integers.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(1),N,QX)
      KFLKB = QX%KFLAG
      CALL FMM2I(MXY(2),K,QX)
      KFLNKB = QX%KFLAG
      CALL FMM2I(MXY(17),NK,QX)
      QX%KWARN = KWRNSV
      NB = N + K - 2
      KB = N - 1
      NKB = K - 1

      IF (KFLKB == 0 .AND. KFLNKB == 0) THEN
          IF (MIN(KB,NKB) <= 200) THEN
              CALL FMCMBI(NB,KB,MXY(22),QX)
              CALL FMI2M(N+K-1,MXY(8),QX)
              CALL FMMPY_R1(MXY(22),MXY(8),QX)
              CALL FMI2M(1,MXY(6),QX)
              CALL FMDIV_R2(MXY(6),MXY(22),QX)
              GO TO 130
          ENDIF
      ENDIF
      NBOT = 0
      IF (KFLKB == 0 .AND. N <= 200) THEN
          CALL FMEQ(MXY(2),MXY(20),QX)
          CALL FMPOCH(MXY(20),N,MXY(5),QX)
          CALL FMFCTI(KB,MXY(11),QX)
          CALL FMDIV(MXY(11),MXY(5),MXY(21),QX)
          IF (ABS(MXY(21)%MP(2)) < MXSAVE) THEN
              CALL FMEQ(MXY(21),MXY(22),QX)
              GO TO 140
          ENDIF
          NBOT = 1
      ELSE IF (KFLNKB == 0 .AND. K <= 200) THEN
          CALL FMEQ(MXY(1),MXY(20),QX)
          CALL FMPOCH(MXY(20),K,MXY(5),QX)
          CALL FMFCTI(NKB,MXY(11),QX)
          CALL FMDIV(MXY(11),MXY(5),MXY(21),QX)
          IF (ABS(MXY(21)%MP(2)) < MXSAVE) THEN
              CALL FMEQ(MXY(21),MXY(22),QX)
              GO TO 140
          ENDIF
          NBOT = 1
      ENDIF
      IF (NBOT == 1) THEN
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
          CALL FMEQ(MXY(1),MXY(21),QX)
          CALL FMADD(MXY(1),MXY(2),MXY(17),QX)
      ENDIF

!             General case.  Use FMGAM, unless one of the numbers is too big.  If so, use FMLNGM.

      X = QX%ALOGMB*REAL(QX%MXEXP)
      CALL FMSP2M(X/LOG(X),MXY(7),QX)
      CALL FMABS(MXY(17),MXY(18),QX)
      CALL FMABS(MXY(1),MXY(19),QX)
      CALL FMABS(MXY(2),MXY(3),QX)
      IF (FMCOMP(MXY(18),'>=',MXY(7),QX) .OR. FMCOMP(MXY(19),'>=',MXY(7),QX) .OR.  &
          FMCOMP(MXY(3),'>=',MXY(7),QX)) THEN

!             See if one argument is not very large and the other is
!             much larger.  For many of these cases, Stirling's formula
!             can be used to simplify Beta and avoid cancellation.

          IF (MXY(1)%MP(2) > MXY(2)%MP(2)) THEN
              CALL FMEQ(MXY(1),MXY(10),QX)
              CALL FMEQ(MXY(2),MXY(11),QX)
          ELSE
              CALL FMEQ(MXY(2),MXY(10),QX)
              CALL FMEQ(MXY(1),MXY(11),QX)
          ENDIF
          IF (MXY(10)%MP(2) > QX%NDIG .AND.  &
              MXY(10)%MP(2) >= MXY(11)%MP(2)+QX%NDIG) THEN
              IF (MXY(11)%MP(1) < 0) THEN
                  IF (MXY(11)%MP(2) > QX%NDIG) THEN
                      QX%KFLAG = -9
                      CALL FMWRN2(QX)
                      QX%NDIG = QX%NDIG - IEXTRA
                      CALL FMST2M('UNKNOWN',MXY(22),QX)
                      GO TO 140
                  ELSE
                      CALL FMI2M(2,MXY(18),QX)
                      CALL FMEQ(MXY(11),MXY(19),QX)
                      MXY(19)%MP(1) = -MXY(19)%MP(1)
                      CALL FMINT(MXY(19),MXY(6),QX)
                      CALL FMMOD(MXY(6),MXY(18),MXY(12),QX)
                      IF (MXY(12)%MP(3) == 0) THEN
                          CALL FMADD(MXY(10),MXY(11),MXY(16),QX)
                          CALL FMLN(MXY(16),MXY(6),QX)
                          CALL FMMPY(MXY(11),MXY(6),MXY(16),QX)
                          CALL FMI2M(1,MXY(6),QX)
                          CALL FMADD(MXY(11),MXY(6),MXY(17),QX)
                          CALL FMEQ(MXY(11),MXY(20),QX)
                          CALL FMLNGM(MXY(17),MXY(4),QX)
                          CALL FMSUB(MXY(4),MXY(16),MXY(6),QX)
                          CALL FMEXP(MXY(6),MXY(13),QX)
                          CALL FMDIV_R1(MXY(13),MXY(20),QX)
                          CALL FMEQ(MXY(13),MXY(22),QX)
                          GO TO 130
                      ENDIF
                  ENDIF
              ENDIF
              CALL FMADD(MXY(10),MXY(11),MXY(16),QX)
              CALL FMLN(MXY(16),MXY(6),QX)
              CALL FMMPY(MXY(11),MXY(6),MXY(16),QX)
              CALL FMEQ(MXY(11),MXY(20),QX)
              CALL FMLNGM(MXY(20),MXY(17),QX)
              CALL FMSUB(MXY(17),MXY(16),MXY(6),QX)
              CALL FMEXP(MXY(6),MXY(13),QX)
              CALL FMEQ(MXY(13),MXY(22),QX)
              GO TO 130
          ENDIF

!             See if both arguments are large.  For many of these cases, Stirling's formula can be
!             used to detect cases where the result will underflow.

          CALL FMDPM(1.0D7,MXY(6),QX)
          IF (FMCOMP(MXY(1),'>',MXY(6),QX) .AND. FMCOMP(MXY(2),'>',MXY(6),QX)) THEN
              CALL FMADD(MXY(1),MXY(2),MXY(6),QX)
              CALL FMLN(MXY(6),MXY(15),QX)
              CALL FMMPY_R2(MXY(6),MXY(15),QX)
              IF (MXY(15)%MP(2) /= QX%MUNKNO .AND. MXY(15)%MP(3) /= 0)  &
                  MXY(15)%MP(1) = -MXY(15)%MP(1)
              CALL FMLN(MXY(1),MXY(6),QX)
              CALL FMMPY_R2(MXY(1),MXY(6),QX)
              CALL FMADD_R1(MXY(15),MXY(6),QX)
              CALL FMLN(MXY(2),MXY(6),QX)
              CALL FMMPY_R2(MXY(2),MXY(6),QX)
              CALL FMADD_R1(MXY(15),MXY(6),QX)
              CALL FMEXP(MXY(15),MXY(16),QX)
              IF (MXY(16)%MP(2) == QX%MEXPUN) THEN
                  CALL FMEQ(MXY(16),MXY(22),QX)
                  GO TO 140
              ENDIF
          ENDIF

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          MZERO = 0
          IEXTRA = INT(MAX(MXY(17)%MP(2),MXY(1)%MP(2),MXY(2)%MP(2),MZERO))
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
              CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
          QX%NDIG = QX%NDIG + IEXTRA
          CALL FMADD(MXY(1),MXY(2),MXY(17),QX)
          CALL FMI2M(1,MXY(10),QX)
          CALL FMI2M(2,MXY(11),QX)
          CALL FMEQ(MXY(17),MXY(22),QX)
          K10 = 0
          K11 = 0
          KC = 0
          IF (MXY(1)%MP(1) < 0) THEN
              CALL FMINT(MXY(1),MXY(12),QX)
              CALL FMMOD(MXY(12),MXY(11),MXY(13),QX)
              IF (MXY(13)%MP(3) == 0) THEN
                  K10 = 1
                  CALL FMADD_R1(MXY(1),MXY(10),QX)
              ENDIF
          ENDIF
          IF (MXY(2)%MP(1) < 0) THEN
              CALL FMINT(MXY(2),MXY(12),QX)
              CALL FMMOD(MXY(12),MXY(11),MXY(13),QX)
              IF (MXY(13)%MP(3) == 0) THEN
                  K11 = 1
                  CALL FMADD_R1(MXY(2),MXY(10),QX)
              ENDIF
          ENDIF
          IF (MXY(22)%MP(1) < 0) THEN
              CALL FMINT(MXY(22),MXY(12),QX)
              CALL FMMOD(MXY(12),MXY(11),MXY(13),QX)
              IF (MXY(13)%MP(3) == 0) THEN
                  KC = 1
                  CALL FMADD_R1(MXY(22),MXY(10),QX)
              ENDIF
          ENDIF
          CALL FMLNGM(MXY(1),MXY(17),QX)
          CALL FMLNGM(MXY(2),MXY(20),QX)
          CALL FMADD_R1(MXY(17),MXY(20),QX)
          CALL FMLNGM(MXY(22),MXY(20),QX)
          CALL FMSUB(MXY(17),MXY(20),MXY(6),QX)
          CALL FMEXP(MXY(6),MXY(17),QX)
          IF (K10 == 1 .OR. K11 == 1 .OR. KC == 1) THEN
              CALL FMI2M(1,MXY(10),QX)
              IF (K10 == 1) THEN
                  CALL FMSUB_R1(MXY(1),MXY(10),QX)
                  CALL FMDIV_R1(MXY(17),MXY(1),QX)
              ENDIF
              IF (K11 == 1) THEN
                  CALL FMSUB_R1(MXY(2),MXY(10),QX)
                  CALL FMDIV_R1(MXY(17),MXY(2),QX)
              ENDIF
              IF (KC == 1) THEN
                  CALL FMSUB_R1(MXY(22),MXY(10),QX)
                  CALL FMMPY_R1(MXY(17),MXY(22),QX)
              ENDIF
          ENDIF
          CALL FMEQ(MXY(17),MXY(22),QX)
      ELSE
          CALL FMGAM(MXY(1),MXY(20),QX)
          CALL FMGAM(MXY(2),MXY(1),QX)
          CALL FMGAM(MXY(17),MXY(22),QX)
          CALL FMMPY(MXY(20),MXY(1),MXY(8),QX)
          CALL FMDIV_R2(MXY(8),MXY(22),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(22)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

  140 CALL FMEXT2(MXY(22),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMBETA

      SUBROUTINE FMCMBI(N,K,MA,QX)

!  Internal routine for computing binomial coefficients for integers.

!  MA = N choose K.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N,K
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: INTNDG,J,KSTART,KT,L,LARGE,LARGED,NDIV,NDSAVE,NEXTD,NEXTN,NMPY,NTD,NTN
      INTENT (IN) :: N,K
      INTENT (INOUT) :: MA

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      L = MIN(K,N-K)
      IF (L <= 0) THEN
          CALL FMI2M(1,MA,QX)
          RETURN
      ENDIF
      IF (L <= 1) THEN
          CALL FMI2M(N,MA,QX)
          RETURN
      ENDIF

!             Find the largest value for N choose J using integers.

      NTN = N
      NTD = 1
      LARGE = INT(INTMAX/N)
      DO J = 2, L
         IF (NTN <= LARGE) THEN
             NTN = (NTN*((N+1)-J))/J
         ELSE
             CALL FMI2M(NTN,MA,QX)
             NTN = (N+1) - J
             NTD = J
             GO TO 110
         ENDIF
      ENDDO

  110 IF (NTD == 1) THEN
          CALL FMI2M(NTN,MA,QX)
          RETURN
      ENDIF

      INTNDG = INT(QX%ALOGMX/QX%ALOGMB + 1.0)
      NEXTN = NTN
      NEXTD = NTD
      KSTART = NTD + 1
      NDSAVE = QX%NDIG

!             Compute the rest of N choose K.

      LARGED = MIN(LARGE,INT(MXBASE))
      DO KT = KSTART, L
         NEXTN = NEXTN - 1
         NEXTD = NEXTD + 1
         IF (NTN >= LARGE .OR. NTD >= LARGED) THEN
             QX%NDIG = MAX(2,MIN(NDSAVE,INT(MA%MP(2))+INTNDG))
             CALL FMCSMPYI_R1(MA,NTN,QX)
             CALL FMCSDIVI_R1(MA,NTD,QX)
             NTN = NEXTN
             NTD = NEXTD
             CYCLE
         ENDIF
         NMPY = NTN*NEXTN
         NDIV = NTD*NEXTD
         IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
             NTN = NMPY
             NTD = NDIV
         ELSE
             CALL FMGCDI(NMPY,NDIV)
             IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                 NTN = NMPY
                 NTD = NDIV
             ELSE
                 QX%NDIG = MAX(2,MIN(NDSAVE,INT(MA%MP(2))+INTNDG))
                 CALL FMCSMPYI_R1(MA,NTN,QX)
                 CALL FMCSDIVI_R1(MA,NTD,QX)
                 NTN = NEXTN
                 NTD = NEXTD
             ENDIF
         ENDIF
      ENDDO
      QX%NDIG = MAX(2,MIN(NDSAVE,INT(MA%MP(2))+INTNDG))
      CALL FMGCDI(NTN,NTD)
      CALL FMCSMPYI_R1(MA,NTN,QX)
      CALL FMCSDIVI_R1(MA,NTD,QX)
      QX%NDIG = NDSAVE

      RETURN
      END SUBROUTINE FMCMBI

      SUBROUTINE FMCOMB(MA,MB,MC,QX)

!  MC = MA choose MB.  (Binomial coefficient -- uses gamma for non-integers)

!  MC = (MA)! / ( (MB)! * (MA-MB)! )

!  This routine extends this definition to allow negative integer values for MA and/or MB.
!  The standard recurrence comb(n,k) = comb(n-1,k-1) + comb(n-1,k) can be used to define
!  comb(n,k) for all integers n,k starting from the initializing definitions
!  comb(0,k) = 0, for all k except 0,
!  comb(n,0) = 1, for all n.
!  Ex:  n = 1, k = 1 => comb(1,1) = comb(0,0)   +  comb(0,1)
!                    => comb(1,1) =         1   +          0,  so  comb(1,1)   =  1
!       n = 0, k = 0 => comb(0,0) = comb(-1,-1) + comb(-1,0)
!                    =>         1 = comb(-1,-1) +          1,  so  comb(-1,-1) =  0
!       n = 0, k = 1 => comb(0,1) = comb(-1,0)  + comb(-1,1)
!                    =>         0 =          1  + comb(-1,1),  so  comb(-1,1)  = -1

!  This definition agrees with the standard factorial definition when n and k are non-negative
!  integers.  The factorial definition is undefined when n or k is a negative integer, since
!  x! has singularities at negative integers.

!  For negative n or k, this extended definition simplifies to:
!  if k < 0,             comb(n,k) = 0
!  if k >= 0 and n < 0,  comb(n,k) = (-1)**k * comb(-n+k-1,k)

!  These extended definitions are useful in some combinatorial applications.
!  Reference:  Concrete Mathematics - Graham, Knuth, Patashnik, Addison-Wesley, 1989.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE,MZERO
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K09,K10,K11,KBOT,KC,KFLGK,KFLGNK,KL,KOVUN,KR_RETRY,  &
                 KRESLT,KSIGN,KWRNSV,LARGE,N,NBOT,NDSAVE,NK
      LOGICAL, EXTERNAL :: FMCOMP
      LOGICAL :: LC1,LC2,LC3
      REAL :: X
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(17)
      TYPE(FM_SETTINGS) :: QX

      K = 0
      IF (MA%MP(1) < 0) THEN
          K10 = QX%NTRACE
          QX%NTRACE = 0
          K11 = QX%KWARN
          QX%KWARN = 0
          CALL FMM2I(MA,J,QX)
          IF (QX%KFLAG == 0) K = 1
          QX%NTRACE = K10
          QX%KWARN = K11
      ENDIF

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MB%MP(2) < -QX%NDIG .AND. K == 0) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCOMB'
              CALL FMNTR(2,MA,MB,2,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMTINY(MXY(1),QX)
              MXY(1)%MP(1) = MA%MP(1)
          ELSE
              CALL FMEQ(MA,MXY(1),QX)
          ENDIF
          IF (MB%MP(2) == QX%MEXPUN) THEN
              CALL FMTINY(MXY(2),QX)
              MXY(2)%MP(1) = MB%MP(1)
          ELSE
              CALL FMEQ(MB,MXY(2),QX)
          ENDIF
          CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
          IF (MXY(3)%MP(3) /= 0) THEN
              CALL FMPI(MXY(4),QX)
              CALL FMSQR(MXY(4),MXY(5),QX)
              CALL FMDIVI(MXY(5),6,MXY(4),QX)
              CALL FMI2M(1,MXY(6),QX)
              CALL FMPGAM(2,MXY(6),MXY(5),QX)
              CALL FMMPY_R1(MXY(5),MXY(1),QX)
              CALL FMDIVI_R1(MXY(5),2,QX)
              CALL FMADD_R1(MXY(4),MXY(5),QX)
              CALL FMMPY_R1(MXY(3),MXY(4),QX)
              CALL FMMPY_R1(MXY(3),MXY(2),QX)
              CALL FMADD_R2(MXY(6),MXY(3),QX)
          ELSE
              CALL FMI2M(1,MXY(3),QX)
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          CALL FMEQ(MXY(3),MC,QX)
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMCOMB'
              CALL FMNTR(1,MC,MC,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF

      CALL FMENT2('FMCOMB   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KSIGN = 1
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)

      CALL FMSUB(MXY(1),MXY(2),MXY(15),QX)
      IF (MXY(2)%MP(3) == 0) THEN
          CALL FMI2M(1,MXY(17),QX)
          GO TO 120
      ENDIF
      CALL FMI2M(1,MXY(3),QX)
      CALL FMSUB(MXY(2),MXY(3),MXY(4),QX)
      IF (MXY(4)%MP(3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(17),QX)
          GO TO 120
      ENDIF

!             See if any of the terms are negative integers.

      CALL FMI2M(1,MXY(11),QX)
      K10 = 0
      IF (MXY(1)%MP(1) < 0) THEN
          CALL FMINT(MXY(1),MXY(7),QX)
          IF (FMCOMP(MXY(1),'==',MXY(7),QX)) K10 = -1
          IF (MA%MP(2) == QX%MEXPOV)  K10 = -1
      ENDIF
      K11 = 0
      IF (MXY(2)%MP(1) < 0) THEN
          CALL FMINT(MXY(2),MXY(8),QX)
          IF (FMCOMP(MXY(2),'==',MXY(8),QX)) K11 = -1
          IF (MB%MP(2) == QX%MEXPOV)  K11 = -1
      ENDIF
      K09 = 0
      IF (FMCOMP(MXY(1),'<',MXY(2),QX)) THEN
          CALL FMMOD(MXY(1),MXY(11),MXY(9),QX)
          CALL FMMOD(MXY(2),MXY(11),MXY(10),QX)
          CALL FMSUB_R2(MXY(9),MXY(10),QX)
          CALL FMINT(MXY(10),MXY(9),QX)
          IF (FMCOMP(MXY(10),'==',MXY(9),QX)) K09 = -1
      ENDIF

      CALL FMI2M(2,MXY(10),QX)

      IF (K11 == -1) THEN
          CALL FMI2M(0,MXY(17),QX)
          GO TO 120
      ELSE IF (MXY(15)%MP(3) == 0) THEN
          CALL FMI2M(1,MXY(17),QX)
          GO TO 120
      ELSE IF (K09 == -1 .AND. K10 == 0) THEN
          CALL FMI2M(0,MXY(17),QX)
          GO TO 120
      ELSE IF (K10 == -1 .AND. K09 == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(17),QX)
          QX%KFLAG = -4
          GO TO 130
      ELSE IF (K10 == -1 .AND. K09 == -1) THEN
          JR = QX%KROUND
          QX%KROUND = 1
          CALL FMMOD(MXY(2),MXY(10),MXY(12),QX)
          IF (MXY(12)%MP(3) /= 0) KSIGN = -1
          CALL FMSUB(MXY(2),MXY(1),MXY(12),QX)
          CALL FMSUB(MXY(12),MXY(11),MXY(1),QX)
          CALL FMSUB(MXY(1),MXY(2),MXY(15),QX)
          QX%KROUND = JR
      ENDIF

!             Check for an obviously overflowed result.

      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          IF (MXY(1)%MP(1)*MXY(1)%MP(3) > 0 .AND. MXY(2)%MP(1) > 0 .AND.  &
              MXY(2)%MP(2) >= 1 .AND. MXY(2)%MP(2) < QX%MEXPOV) THEN
              CALL FMST2M('OVERFLOW',MXY(17),QX)
              QX%KFLAG = -5
              GO TO 130
          ENDIF
      ENDIF
      IF (MXY(1)%MP(2) >= 10000) THEN
          CALL FMI2M(1,MXY(5),QX)
          IF (FMCOMP(MXY(2),'>',MXY(5),QX) .AND. FMCOMP(MXY(2),'<',MXY(1),QX)) THEN
              CALL FMSUB(MXY(1),MXY(2),MXY(5),QX)
              CALL FMMIN(MXY(2),MXY(5),MXY(13),QX)
              CALL FMSUB(MXY(1),MXY(13),MXY(5),QX)
              CALL FMADDI(MXY(5),1,QX)
              CALL FMDIV(MXY(5),MXY(13),MXY(12),QX)
              CALL FMLN(MXY(12),MXY(5),QX)
              CALL FMADDI(MXY(5),1,QX)
              CALL FMMPY(MXY(13),MXY(5),MXY(12),QX)
              CALL FMDPM(6.283185D0,MXY(3),QX)
              CALL FMMPY(MXY(3),MXY(13),MXY(5),QX)
              CALL FMLN(MXY(5),MXY(3),QX)
              CALL FMDIVI(MXY(3),2,MXY(5),QX)
              CALL FMSUB_R1(MXY(12),MXY(5),QX)
              CALL FMEXP(MXY(12),MXY(4),QX)
              IF (MXY(4)%MP(2) == QX%MEXPOV) THEN
                  CALL FMST2M('OVERFLOW',MXY(17),QX)
                  QX%KFLAG = -5
                  GO TO 130
              ENDIF
          ENDIF
      ENDIF

!             See if any of the terms are small integers.

      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(1),N,QX)
      CALL FMM2I(MXY(2),K,QX)
      KFLGK = QX%KFLAG
      CALL FMM2I(MXY(15),NK,QX)
      KFLGNK = QX%KFLAG
      QX%KWARN = KWRNSV

      CALL FMI2M(1,MXY(5),QX)
      JR = QX%KROUND
      QX%KROUND = 1
      CALL FMADD(MXY(1),MXY(5),MXY(3),QX)
      CALL FMSUB_R1(MXY(3),MXY(5),QX)
      QX%KROUND = JR
      IF (KFLGK == 0 .AND. MXY(3)%MP(3) == 0) THEN
          CALL FMI2M(2,MXY(17),QX)
          CALL FMMOD(MXY(2),MXY(17),MXY(5),QX)
          CALL FMEQ(MXY(5),MXY(17),QX)
          IF (MXY(17)%MP(3) == 0) THEN
              CALL FMDIV(MXY(1),MXY(2),MXY(17),QX)
              IF (MXY(17)%MP(2) /= QX%MUNKNO .AND. MXY(17)%MP(3) /= 0)  &
                  MXY(17)%MP(1) = -MXY(17)%MP(1)
          ELSE
              CALL FMDIV(MXY(1),MXY(2),MXY(17),QX)
          ENDIF
          GO TO 120
      ENDIF
      IF (KFLGK == 0 .AND. KFLGNK == 0 .AND. N /= 0) THEN
          IF (MIN(K,NK) <= 200) THEN
              CALL FMCMBI(N,K,MXY(17),QX)
              GO TO 120
          ENDIF
      ENDIF
      NBOT = 0
      IF (KFLGK == 0 .AND. K <= 200) NBOT = K
      IF (KFLGNK == 0 .AND. NK <= 200) NBOT = NK
      IF (NBOT > 0) THEN
          LARGE = INT(MXBASE/NBOT)
          KBOT = 1
          CALL FMEQ(MXY(1),MXY(7),QX)
          CALL FMEQ(MXY(1),MXY(8),QX)
          CALL FMI2M(-1,MXY(9),QX)
          DO J = 2, NBOT
             CALL FMADD_R1(MXY(7),MXY(9),QX)
             CALL FMMPY_R2(MXY(7),MXY(8),QX)
             KBOT = KBOT*J
             IF (KBOT >= LARGE) THEN
                 CALL FMDIVI_R1(MXY(8),KBOT,QX)
                 KBOT = 1
             ENDIF
          ENDDO
          CALL FMDIVI(MXY(8),KBOT,MXY(17),QX)
          GO TO 120
      ENDIF

!             General case.  Use FMFACT, unless one of the numbers is too big.  If so, use FMLNGM.

      X = QX%ALOGMB*REAL(QX%MXEXP)
      CALL FMSP2M(X/LOG(X),MXY(6),QX)
      CALL FMABS(MXY(15),MXY(5),QX)
      LC1 = FMCOMP(MXY(5),'>=',MXY(6),QX)
      CALL FMABS(MXY(1),MXY(5),QX)
      LC2 = FMCOMP(MXY(5),'>=',MXY(6),QX)
      CALL FMABS(MXY(2),MXY(5),QX)
      LC3 = FMCOMP(MXY(5),'>=',MXY(6),QX)
      IF (LC1 .OR. LC2 .OR. LC3) THEN

!             See if the second argument is not very large and the first is much larger.
!             For many of these cases, Stirling's formula can be used to simplify Comb
!             and avoid cancellation.

          IF (MXY(1)%MP(2) > MXY(2)%MP(2) .AND. MXY(1)%MP(1) > 0 .AND.  &
              MXY(2)%MP(1) > 0) THEN
              CALL FMEQ(MXY(1),MXY(9),QX)
              CALL FMEQ(MXY(2),MXY(10),QX)
          ELSE
              CALL FMI2M(1,MXY(9),QX)
              CALL FMI2M(1,MXY(10),QX)
          ENDIF
          IF (MXY(9)%MP(2) > QX%NDIG .AND.  &
              MXY(9)%MP(2) >= MXY(10)%MP(2)+QX%NDIG) THEN
              CALL FMI2M(1,MXY(5),QX)
              CALL FMADD(MXY(10),MXY(5),MXY(16),QX)
              CALL FMLN(MXY(9),MXY(5),QX)
              CALL FMADDI(MXY(5),-1,QX)
              CALL FMMPY(MXY(10),MXY(5),MXY(14),QX)
              CALL FMADD_R2(MXY(10),MXY(14),QX)
              CALL FMLNGM(MXY(16),MXY(15),QX)
              CALL FMSUB(MXY(14),MXY(15),MXY(5),QX)
              CALL FMEXP(MXY(5),MXY(12),QX)
              CALL FMEQ(MXY(12),MXY(17),QX)
              GO TO 120
          ENDIF

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          MZERO = 0
          IEXTRA = INT(MAX(MXY(15)%MP(2),MXY(1)%MP(2),MXY(2)%MP(2),MZERO))
          IF (QX%NDIG+IEXTRA > 3*10**5) THEN
              QX%KFLAG = -4
              CALL FMST2M('UNKNOWN',MXY(17),QX)
              GO TO 130
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
              CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
          QX%NDIG = QX%NDIG + IEXTRA
          IF (K10 == -1 .AND. K09 == -1) THEN
              JR = QX%KROUND
              QX%KROUND = 1
              CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
              CALL FMM2I(MXY(1),N,QX)
              CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(2),MXY(1),MXY(12),QX)
              CALL FMI2M(1,MXY(11),QX)
              CALL FMSUB(MXY(12),MXY(11),MXY(1),QX)
              QX%KROUND = JR
          ENDIF

          CALL FMSUB(MXY(1),MXY(2),MXY(15),QX)
          CALL FMI2M(1,MXY(9),QX)
          CALL FMI2M(2,MXY(10),QX)
          CALL FMADD(MXY(15),MXY(9),MXY(17),QX)
          CALL FMADD_R1(MXY(1),MXY(9),QX)
          CALL FMADD_R1(MXY(2),MXY(9),QX)
          K10 = 0
          K11 = 0
          KC = 0
          IF (MXY(1)%MP(1) < 0) THEN
              CALL FMINT(MXY(1),MXY(11),QX)
              CALL FMMOD(MXY(11),MXY(10),MXY(12),QX)
              IF (MXY(12)%MP(3) == 0) THEN
                  K10 = 1
                  CALL FMADD_R1(MXY(1),MXY(9),QX)
              ENDIF
          ENDIF
          IF (MXY(2)%MP(1) < 0) THEN
              CALL FMINT(MXY(2),MXY(11),QX)
              CALL FMMOD(MXY(11),MXY(10),MXY(12),QX)
              IF (MXY(12)%MP(3) == 0) THEN
                  K11 = 1
                  CALL FMADD_R1(MXY(2),MXY(9),QX)
              ENDIF
          ENDIF
          IF (MXY(17)%MP(1) < 0) THEN
              CALL FMINT(MXY(17),MXY(11),QX)
              CALL FMMOD(MXY(11),MXY(10),MXY(12),QX)
              IF (MXY(12)%MP(3) == 0) THEN
                  KC = 1
                  CALL FMADD_R1(MXY(17),MXY(9),QX)
              ENDIF
          ENDIF
          CALL FMLNGM(MXY(1),MXY(15),QX)
          CALL FMLNGM(MXY(2),MXY(16),QX)
          CALL FMSUB_R1(MXY(15),MXY(16),QX)
          CALL FMLNGM(MXY(17),MXY(16),QX)
          CALL FMSUB_R1(MXY(15),MXY(16),QX)
          CALL FMEXP(MXY(15),MXY(4),QX)
          IF (K10 == 1 .OR. K11 == 1 .OR. KC == 1) THEN
              CALL FMI2M(1,MXY(9),QX)
              IF (K10 == 1) THEN
                  CALL FMSUB_R1(MXY(1),MXY(9),QX)
                  CALL FMDIV_R1(MXY(4),MXY(1),QX)
              ENDIF
              IF (K11 == 1) THEN
                  CALL FMSUB_R1(MXY(2),MXY(9),QX)
                  CALL FMMPY_R1(MXY(4),MXY(2),QX)
              ENDIF
              IF (KC == 1) THEN
                  CALL FMSUB_R1(MXY(17),MXY(9),QX)
                  CALL FMMPY_R1(MXY(4),MXY(17),QX)
              ENDIF
          ENDIF
          CALL FMEQ(MXY(4),MXY(17),QX)
      ELSE
          CALL FMFACT(MXY(1),MXY(16),QX)
          CALL FMFACT(MXY(2),MXY(3),QX)
          CALL FMFACT(MXY(15),MXY(17),QX)
          CALL FMMPY(MXY(17),MXY(3),MXY(7),QX)
          CALL FMDIV(MXY(16),MXY(7),MXY(17),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(17)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

  130 MXY(17)%MP(1) = KSIGN*MXY(17)%MP(1)
      CALL FMEXT2(MXY(17),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMCOMB

      FUNCTION FMDPLG(A,QX)

!  Internal routine for computing an approximation to Log(Gamma(A)) using Stirling's formula.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      DOUBLE PRECISION :: FMDPLG,A
      INTENT (IN) :: A
      TYPE(FM_SETTINGS) :: QX

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      IF (A > 0.0D0) THEN
          FMDPLG = -A + (A-0.5D0)*LOG(A) + QX%DLOGTP/2.0D0
      ELSE IF (A < 0.0D0) THEN
          IF (ABS(A) < 1.0D+8) THEN
              FMDPLG = -(A-1.0D0) - (0.5D0-A)*LOG(1.0D0-A) - QX%DLOGTP/2.0D0 -  &
                       LOG(ABS(SIN(QX%DPPI*A))+1.0D-10) + QX%DLOGPI
          ELSE
              FMDPLG = -(A-1.0D0) - (0.5D0-A)*LOG(1.0D0-A) - QX%DLOGTP/2.0D0 + QX%DLOGPI
          ENDIF
      ELSE

!             A = 0 is really an approximation for some value in [-1,1].

          FMDPLG = 0.0D0
      ENDIF
      RETURN
      END FUNCTION FMDPLG

      SUBROUTINE FMENT2(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)

!  Do the argument checking and increasing of precision, overflow threshold, etc., upon entry
!  to an FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result immediately
!           (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow or underflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      TYPE(MULTI) :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KOVUN
      INTEGER :: K
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = NROUTN
      IF (QX%NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM,QX)
      CALL FMARG2(NROUTN,NARGS,MA,MB,KRESLT,QX)

      KOVUN = 0
      IF (MA%MP(2) == QX%MEXPOV .OR. MA%MP(2) == QX%MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = QX%NDIG
      MXSAVE = QX%MXEXP
      IF (QX%NCALL >= 1 .OR. QX%RAISE_NDIG > 0) THEN
          K = INT(QX%NGRD52 + 1 + 0.002*QX%NDIG + (REAL(QX%NDIG)*QX%ALOGMT)**0.35/QX%ALOGMT)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          IF (KRESLT == 9 .OR. KRESLT == 10 .OR. KRESLT >= 13) THEN
              IF (QX%KRAD == 1) THEN
                  CALL FMPI(MC,QX)
              ELSE
                  CALL FMI2M(180,MC,QX)
              ENDIF
              IF (KRESLT <= 10) CALL FMDIVI_R1(MC,2,QX)
              IF (KRESLT >= 14) CALL FMDIVI_R1(MC,4,QX)
              IF (KRESLT == 9 .OR. KRESLT == 14) MC%MP(1) = -1
              CALL FMEQU_R1(MC,QX%NDIG,NDSAVE,QX)
              QX%NDIG = NDSAVE
              IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
              QX%NCALL = QX%NCALL - 1
              RETURN
          ENDIF

          QX%NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT,QX)
          IF (QX%NTRACE /= 0 .AND. NROUTN /= 'FMIBTA') THEN
              CALL FMNTR(1,MC,MC,1,1,QX)
          ENDIF
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

!             Extend the overflow/underflow threshold.

      QX%MXEXP = QX%MXEXP2
      RETURN
      END SUBROUTINE FMENT2

      SUBROUTINE FMEULR(MA,QX)

!  MA = Euler's constant ( 0.5772156649... )

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA
      TYPE(MULTI) :: M_EULER
      CHARACTER(512) :: STRING
      INTEGER :: K,NDMB,NDSAVE,NDSV
      TYPE(MULTI) :: MXY(2)
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX


      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%KFLAG = 0
      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'FMEULR'
      IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
          WRITE (KW,"(' Input to FMEULR')")
      ENDIF

!             Increase the working precision.

      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = INT(5.0/QX%ALOGMT + 2.0 + (REAL(QX%NDIG)*QX%ALOGMT)**0.35/QX%ALOGMT)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF


!             Euler's constant is slower to compute than the other saved constants, so more digits
!             are stored in STRING for quick conversion.

      NDMB = INT(500.0*2.302585/QX%ALOGMB)
      IF (NDMB >= QX%NDIG) THEN
          NDSV = QX%NDIG
          QX%NDIG = NDMB
          STRING = '0.57721566490153286060651209008240243104215933593992359880576723488486'//  &
          '7726777664670936947063291746749514631447249807082480960504014486542836224173997'//  &
          '6449235362535003337429373377376739427925952582470949160087352039481656708532331'//  &
          '5177661152862119950150798479374508570574002992135478614669402960432542151905877'//  &
          '5535267331399254012967420513754139549111685102807984234877587205038431093997361'//  &
          '3725530608893312676001724795378367592713515772261027349291394079843010341777177'//  &
          '8088154957066107501016191663340152279'
          CALL FMST2M(STRING,M_EULER,QX)
          CALL FMEQU(M_EULER,MA,QX%NDIG,NDSAVE,QX)
          QX%NDIG = NDSV
      ELSE
          NDSV = QX%NDIG
          QX%NDIG = QX%NDIG + 2
          CALL FMEULR_B(MXY(1),M_EULER,QX)
          CALL FMEQ(MXY(1),M_EULER,QX)
          CALL FMEQU(M_EULER,MA,QX%NDIG,NDSAVE,QX)
          QX%NDIG = NDSV
      ENDIF

      QX%NDIG = NDSAVE
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMEULR

      SUBROUTINE FMEULR_B(MB,M_EULER,QX)

!  MB = Euler's constant = .577215...

!  Binary splitting version.
!  Called by FMEULR for large NDIG.  Faster and saves memory by not using Bernoulli numbers.

!  Sum f(x) = 1 + x/(1!)^2 + x^2/(2!)^2 + ...
!  and g(x) = H(1)*x/(1!)^2 + H(2)*x^2/(2!)^2 + ...
!  where H(n) = 1 + 1/2 + ... + 1/n.

!  As x --> infinity, g(x)/f(x) - Ln(x)/2 --> Euler's constant.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MB
      TYPE(MULTI) :: MLN2,MLN3,MLN5,MLN7
      TYPE(MULTI) :: M_EULER
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: K,KT,N,NDSAVE,LEVEL_OF_RECURSION
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(7),X
      TYPE(FM_SETTINGS) :: QX

      IF (QX%MBLOGS /= QX%MBASE) CALL FMCONS(QX)
      QX%NCALL = QX%NCALL + 1
      NDSAVE = QX%NDIG
      IF (QX%NCALL == 1) THEN
          K = MAX(QX%NGRD52-1,2)
          QX%NDIG = MAX(QX%NDIG+K,2)
      ENDIF
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2

!             Determine X, variable in the series.

      N = QX%NDIG*QX%DLOGMB/4
      DO
         K = N
         DO
            KT = K/2
            IF (2*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/3
            IF (3*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/5
            IF (5*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/7
            IF (7*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         IF (K == 1) EXIT
         N = N + 1
      ENDDO

      CALL IMI2M(N,MXY(1),QX)
      CALL IMSQR(MXY(1),X,QX)

!             Determine K, the number of terms to sum in the series.

      K = 3.5912D0*N
      LEVEL_OF_RECURSION = 0
      CALL FMEULR_PTDCV(0,K,MXY(1),MXY(2),MXY(3),MXY(4),MXY(5),X,LEVEL_OF_RECURSION,QX)
      IF (MXY(3)%MP(2) >= QX%NDIG) THEN
          CALL FMEQ(MXY(3),MXY(7),QX)
      ELSE
          CALL IMI2FM(MXY(3),MXY(7),QX)
      ENDIF
      CALL FMSQR(MXY(7),MXY(4),QX)
      IF (MXY(2)%MP(2) >= QX%NDIG) THEN
          CALL FMEQ(MXY(2),MXY(1),QX)
      ELSE
          CALL IMI2FM(MXY(2),MXY(1),QX)
      ENDIF
      CALL FMDIV(MXY(1),MXY(4),MXY(6),QX)
      CALL FMADDI(MXY(6),1,QX)

      CALL FMMPY(MXY(7),MXY(4),MXY(1),QX)
      IF (MXY(5)%MP(2) >= QX%NDIG) THEN
          CALL FMEQ(MXY(5),MXY(4),QX)
      ELSE
          CALL IMI2FM(MXY(5),MXY(4),QX)
      ENDIF
      CALL FMDIV(MXY(4),MXY(1),MXY(2),QX)

      CALL FMDIV(MXY(2),MXY(6),MXY(5),QX)
      CALL FMLNI(N,MXY(1),MLN2,MLN3,MLN5,MLN7,QX)
      CALL FMSUB(MXY(5),MXY(1),M_EULER,QX)

!             Round the result and return.

      CALL FMEXIT(M_EULER,MB,NDSAVE,MXSAVE,0,QX)
      RETURN
      END SUBROUTINE FMEULR_B

      RECURSIVE SUBROUTINE FMEULR_PTDCV(A,B,MP,MT,MD,MC,MV,MX,LEVEL_OF_RECURSION,QX)

!  This routine does the binary splitting for computing Euler's constant.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MP,MT,MD,MC,MV,MX
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP,MT,MD,MC,MV,MX
      TYPE(MULTI) :: MXY(10)
      INTEGER :: J,JP,JD,M,RESULT_SIZE,LEVEL_OF_RECURSION
      REAL (KIND(0.0D0)) :: DA,DB
      TYPE(FM_SETTINGS) :: QX

      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*MX%MP(2) ) + 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      RESULT_SIZE = MIN(QX%NDIG+10,RESULT_SIZE)
      JP = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -  &
                    ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 ) / QX%DLOGMB + 10
      RESULT_SIZE = MIN(QX%NDIG+10,RESULT_SIZE)
      JD = RESULT_SIZE
      CALL IMI2M(A,MXY(1),QX)
      IF (MXY(1)%MP(2) > MX%MP(2)) THEN
          RESULT_SIZE = MX%MP(2) + 4*JD
      ELSE
          RESULT_SIZE = JP + 2*JD
      ENDIF
      RESULT_SIZE = MIN(QX%NDIG+10,RESULT_SIZE)
      RESULT_SIZE = RESULT_SIZE + JD
      RESULT_SIZE = MIN(QX%NDIG+10,RESULT_SIZE)
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 12) THEN

          CALL IMI2M(B-A+1,MXY(2),QX)
          CALL IMPWR(MX,MXY(2),MP,QX)

          CALL IMI2M(1,MD,QX)
          DO J = A, B-1, 2
             CALL IMMPYI(MD,J+1,MXY(1),QX)
             CALL IMMPYI(MXY(1),J+2,MD,QX)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MD,B+1,MXY(1),QX)
              CALL IMEQ(MXY(1),MD,QX)
          ENDIF

          CALL IMI2M(0,MC,QX)
          DO J = A, B
             CALL IMDIVI(MD,J+1,MXY(2),QX)
             CALL IMADD(MC,MXY(2),MXY(3),QX)
             CALL IMEQ(MXY(3),MC,QX)
          ENDDO

!             MT is the T sum
!             MXY(1) is the next term
!             MV is the V sum
!             MXY(3) is the harmonic sum in the V terms

          CALL IMI2M(0,MT,QX)
          CALL IMI2M(0,MV,QX)
          CALL IMSQR(MD,MXY(1),QX)
          CALL IMI2M(0,MXY(3),QX)
          DO J = A, B
             CALL IMDIVI(MXY(1),J+1,MXY(2),QX)
             CALL IMDIVI(MXY(2),J+1,MXY(1),QX)
             CALL IMMPY(MXY(1),MX,MXY(2),QX)
             CALL IMEQ(MXY(2),MXY(1),QX)
             CALL IMADD(MT,MXY(1),MXY(2),QX)
             CALL IMEQ(MXY(2),MT,QX)

             CALL IMDIVI(MD,J+1,MXY(4),QX)
             CALL IMADD(MXY(3),MXY(4),MXY(5),QX)
             CALL IMEQ(MXY(5),MXY(3),QX)
             CALL IMMPY(MXY(1),MXY(3),MXY(5),QX)
             CALL IMADD(MV,MXY(5),MXY(2),QX)
             CALL IMEQ(MXY(2),MV,QX)
          ENDDO
          GO TO 110
      ENDIF

      M = A/2 + B/2 + MOD(A,2)*MOD(B,2)
      CALL FMEULR_PTDCV(A,M-1,MXY(1),MXY(2),MXY(3),MXY(4),MXY(5),MX,LEVEL_OF_RECURSION,QX)
      CALL FMEULR_PTDCV(M,B,MXY(6),MXY(7),MXY(8),MXY(9),MXY(10),MX,LEVEL_OF_RECURSION,QX)
      CALL IM_OR_FM_MPY(MXY(1),MXY(7),MT,QX)
      CALL IM_OR_FM_SQR(MXY(8),MP,QX)
      CALL IM_OR_FM_MPY(MXY(4),MXY(8),MD,QX)

!             MP and MC are not needed in FMEULR_B, so their calculations can be skipped at the
!             top level of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(9),MXY(3),MXY(4),QX)
          CALL IM_OR_FM_ADD(MD,MXY(4),MC,QX)
      ELSE
          CALL IMI2M(0,MC,QX)
      ENDIF

      CALL IM_OR_FM_MPY(MD,MT,MXY(4),QX)
      CALL IM_OR_FM_MPY(MP,MXY(8),MV,QX)
      CALL IM_OR_FM_MPY(MV,MXY(5),MXY(9),QX)
      CALL IM_OR_FM_ADD(MXY(9),MXY(4),MV,QX)
      CALL IM_OR_FM_MPY(MXY(3),MXY(1),MXY(4),QX)
      CALL IM_OR_FM_MPY(MXY(4),MXY(10),MXY(9),QX)
      CALL IM_OR_FM_ADD(MV,MXY(9),MXY(4),QX)
      CALL IM_OR_FM_EQ(MXY(4),MV,QX)

      CALL IM_OR_FM_MPY(MXY(3),MXY(8),MD,QX)

      CALL IM_OR_FM_MPY(MP,MXY(2),MXY(3),QX)
      CALL IM_OR_FM_ADD(MXY(3),MT,MXY(8),QX)
      CALL IM_OR_FM_EQ(MXY(8),MT,QX)

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(1),MXY(6),MP,QX)
      ELSE
          CALL IMI2M(0,MP,QX)
      ENDIF

  110 LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMEULR_PTDCV

      SUBROUTINE FMEXT2(MT,MC,NDSAVE,MXSAVE,KOVUN,QX)

!  Upon exit from an FM routine, the result MT (having precision NDIG) is rounded and returned
!  in MC (having precision NDSAVE).  The values of NDIG, MXEXP, and KACCSW are restored.
!  KOVUN is nonzero if one of the routine's input arguments was overflow or underflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MT,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KOVUN
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT
      INTENT (INOUT) :: MC,NDSAVE,MXSAVE,KOVUN
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      QX%MXEXP = MXSAVE
      KFSAVE = QX%KFLAG
      CALL FMEQU(MT,MC,QX%NDIG,NDSAVE,QX)
      IF (QX%KFLAG /= -5 .AND. QX%KFLAG /= -6) QX%KFLAG = KFSAVE
      QX%NDIG = NDSAVE
      QX%KWARN = KWRNSV
      IF (QX%KFLAG == 1) QX%KFLAG = 0
      IF ((MC%MP(2) == QX%MUNKNO .AND. QX%KFLAG /= -9)  &
         .OR. (MC%MP(2) == QX%MEXPUN .AND. KOVUN == 0)  &
         .OR. (MC%MP(2) == QX%MEXPOV .AND. KOVUN == 0)) CALL FMWRN2(QX)
      IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
      QX%NCALL = QX%NCALL - 1
      RETURN
      END SUBROUTINE FMEXT2

      SUBROUTINE FMFACT(MA,MB,QX)

!  MB = MA!  ( = GAMMA(MA+1))

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3)
      TYPE(FM_SETTINGS) :: QX


!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMFACT'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMEULR(MXY(1),QX)
          CALL FMMPY(MXY(1),MA,MXY(3),QX)
          CALL FMI2M(1,MXY(1),QX)
          CALL FMSUB(MXY(1),MXY(3),MB,QX)
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMFACT'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF

      CALL FMENT2('FMFACT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMADDI(MXY(1),1,QX)
      CALL FMGAM(MXY(1),MXY(2),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(2),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMFACT

      SUBROUTINE FMFCTI(NUM,MA,QX)

!  MA = NUM factorial, where NUM is an integer.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: NUM
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: J,JK,K,LARGE
      INTENT (IN) :: NUM
      INTENT (INOUT) :: MA

      CALL FMI2M(1,MA,QX)
      IF (NUM <= 1) THEN
          RETURN
      ENDIF
      J = NUM
      K = 1
      LARGE = INT(INTMAX/J)
      DO JK = 2, J
         K = K*JK
         IF (K > LARGE) THEN
             CALL FMCSMPYI_R1(MA,K,QX)
             K = 1
         ENDIF
      ENDDO
      IF (K > 1) CALL FMMPYI_R1(MA,K,QX)
      RETURN
      END SUBROUTINE FMFCTI

      SUBROUTINE FMGAM(MA,MB,QX)

!  MB = GAMMA(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MPISAV
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR,X,Z
      INTEGER :: IEXTRA,INTA,J,J2,K,K0,K1,K2,KFL,KL,KOVUN,KC_RETRY,KR_RETRY,KRESLT,  &
                 KRFLCT,KRSAVE,KSIGN,KWSAVE,LARGE,LSHIFT,NDSAV1,NDSAV2,NDSAVE,NMETHD,NTERM
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(17),MJSUMS(LJSUMS),C(0:196)
      INTEGER :: NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      TYPE(FM_SETTINGS) :: QX


      NDIG_C = 0
      MBASE_C = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMGAM'
              CALL FMNTR(2,MA,MA,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          CALL FMI2M(1,MXY(1),QX)
          CALL FMDIV(MXY(1),MA,MXY(2),QX)
          CALL FMEULR(MXY(1),QX)
          CALL FMSUB(MXY(2),MXY(1),MB,QX)
          IF (QX%KFLAG > 0) QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          IF (QX%KFLAG == -5 .AND. MA%MP(2) > QX%MEXPUN) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMGAM'
              CALL FMWRN2(QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMGAM'
              CALL FMNTR(1,MB,MB,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF

      CALL FMENT2('FMGAM    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KC_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQ(MXY(1),MXY(15),QX)

!             Near zero Gamma(x) is about 1/x.

      IF (MXY(15)%MP(2) < (-QX%NDIG-3)) THEN
          CALL FMI2M(1,MXY(5),QX)
          CALL FMDIV(MXY(5),MXY(15),MXY(11),QX)
          GO TO 190
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDPM(DBLE(-0.5),MXY(7),QX)
      IF (FMCOMP(MXY(15),'<=',MXY(7),QX)) THEN
          KRFLCT = 1
          KFL = 0
          IF (MXY(1)%MP(2) <= NDSAVE) THEN
              CALL FMINT(MXY(15),MXY(10),QX)
              IF (FMCOMP(MXY(15),'==',MXY(10),QX)) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(11),QX)
              QX%KFLAG = -4
              GO TO 200
          ELSE
              CALL FMI2M(1,MXY(5),QX)
              CALL FMSUB_R2(MXY(5),MXY(15),QX)
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      CALL FMNINT(MXY(15),MXY(2),QX)
      CALL FMSUB(MXY(15),MXY(2),MXY(6),QX)
      CALL FMM2DP(MXY(6),Z,QX)
      Z = MAX(ABS(Z),1.0D-50)
      IF (QX%KFLAG /= 0 .OR. ABS(Z) >= 1) THEN
          NMETHD = 2
      ELSE
          IF (190*LOG(Z) - 77*QX%DLOGTN >= -(QX%NDIG+1)*QX%DLOGMB .OR.  &
              -190*QX%DLOGTN >= -QX%NDIG*QX%DLOGMB) THEN
              NMETHD = 2
          ENDIF
      ENDIF
      CALL FMM2DP(MXY(15),X,QX)
      IF (QX%KFLAG /= 0) THEN
          NMETHD = 2
      ELSE IF (NMETHD == 1) THEN
          IF (X > 145 - (8+QX%NDIG*QX%DLOGMB/(25*QX%DLOGTN))*LOG(Z) .OR. X > 250) NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 170

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      IF (MA%MP(1) > 0 .AND. NDSAVE+QX%NGRD52 < QX%NDIG .AND. KR_RETRY == 0 .AND. KC_RETRY == 0)  &
          QX%NDIG = NDSAVE + QX%NGRD52
      CALL FMM2I(MXY(2),LSHIFT,QX)
      LSHIFT = LSHIFT - 3
      IF (NDIG_C < QX%NDIG .OR. MBASE_C /= QX%MBASE) THEN
          CALL FMGAM_C(NDIG_C,MBASE_C,C,QX)
      ENDIF
      J2 = (0.38*LOG(Z) + 4.1)*(QX%NDIG*QX%DLOGMB/(84*QX%DLOGTN))
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      NDSAV1 = QX%NDIG
      DO J = 1, 2
         CALL FMEQ(C(J-1),MJSUMS(J),QX)
      ENDDO
      CALL FMSQR(MXY(6),MXY(5),QX)
      CALL FMEQ(MXY(5),MXY(17),QX)
      NTERM = 1
  120 IF (NTERM > 1) THEN
          K = QX%NDIG
          QX%NDIG = NDSAV1
          CALL FMCSMPY_R1(MXY(17),MXY(5),QX)
          QX%NDIG = K
      ENDIF
      DO J = 1, 2
         NTERM = NTERM + 1
         CALL FMEQ(MXY(17),MXY(4),QX)
         CALL FMCSMPY_R1(MXY(4),C(NTERM),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0 .OR. NTERM == 13) GO TO 130
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 120
  130 KFL = QX%KFLAG
      QX%KFLAG = 0
      CALL FMCSNSUMS(2,MJSUMS,QX)
      QX%NDIG = NDSAV1
      CALL FMEQ(MJSUMS(2),MXY(16),QX)
      CALL FMEQ(MXY(6),MXY(3),QX)
      CALL FMCSMPY_R1(MXY(16),MXY(3),QX)
      CALL FMCSADD_R1(MXY(16),MJSUMS(1),QX)
      IF (KFL == 0) THEN
          CALL FMCSMPY_R1(MXY(17),MXY(5),QX)
      ELSE
          CALL FMI2M(0,MXY(8),QX)
          GO TO 160
      ENDIF
      CALL FMI2M(1,MXY(4),QX)
      DO J = 14, J2+13
         CALL FMADD(C(J),MXY(4),MJSUMS(J-13),QX)
      ENDDO
      CALL FMIPWR(MXY(6),J2,MXY(5),QX)
      CALL FMEQ(MXY(5),MXY(7),QX)
      NTERM = J2 + 13
  140 IF (NTERM > J2+13) CALL FMCSMPY_R1(MXY(7),MXY(5),QX)
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL FMEQ(MXY(7),MXY(4),QX)
         CALL FMCSMPY_R1(MXY(4),C(NTERM),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0 .OR. NTERM == 196) GO TO 150
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 140
  150 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      QX%NDIG = NDSAV1
      IF (NTERM == 196) THEN
          GO TO 170
      ENDIF
      CALL FMI2M(1,MXY(4),QX)
      CALL FMSUB(MJSUMS(J2),MXY(4),MXY(8),QX)
      CALL FMEQ(MXY(6),MXY(3),QX)
      MXY(3)%MP(1) = -MXY(3)%MP(1)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(8),MXY(3),QX)
         CALL FMSUB_R1(MJSUMS(J2-J+1),MXY(4),QX)
         CALL FMCSADD_R1(MXY(8),MJSUMS(J2-J+1),QX)
      ENDDO

!             Recover from using a shifted argument.

  160 CALL FMCSMPY_R1(MXY(8),MXY(17),QX)
      CALL FMADD(MXY(8),MXY(16),MXY(10),QX)
      IF (LSHIFT < 0) THEN
          CALL FMEQ(MXY(15),MXY(3),QX)
          CALL FMEQ(MXY(15),MXY(14),QX)
          DO J = 2, -LSHIFT
             CALL FMADDI(MXY(14),1,QX)
             CALL FMCSMPY_R1(MXY(3),MXY(14),QX)
          ENDDO
          CALL FMDIV_R1(MXY(10),MXY(3),QX)
      ENDIF
      IF (LSHIFT > 0) THEN
          IF (MOD(LSHIFT,4) == 0) THEN
              CALL FMI2M(1,MXY(3),QX)
              CALL FMEQ(MXY(6),MXY(14),QX)
              CALL FMADDI(MXY(14),3,QX)
          ELSE
              CALL FMEQ(MXY(6),MXY(3),QX)
              CALL FMADDI(MXY(3),3,QX)
              CALL FMEQ(MXY(3),MXY(14),QX)
              DO J = 1, MOD(LSHIFT,4)-1
                 CALL FMADDI(MXY(14),1,QX)
                 CALL FMCSMPY_R1(MXY(3),MXY(14),QX)
              ENDDO
              CALL FMADDI(MXY(14),1,QX)
          ENDIF
          LSHIFT = LSHIFT - MOD(LSHIFT,4)

!             The product Z*(Z+1)*...*(Z+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(14) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

          CALL FMI2M(1,MXY(11),QX)
          IF (LSHIFT > 0) THEN
              CALL FMSQR(MXY(14),MXY(6),QX)
              CALL FMMPY(MXY(14),MXY(6),MXY(7),QX)
              CALL FMSQR(MXY(6),MXY(8),QX)
              CALL FMCSMPYI(MXY(7),6,MXY(12),QX)
              CALL FMCSADD_R1(MXY(8),MXY(12),QX)
              CALL FMCSMPYI(MXY(6),11,MXY(12),QX)
              CALL FMCSADD_R1(MXY(8),MXY(12),QX)
              CALL FMCSMPYI(MXY(14),6,MXY(12),QX)
              CALL FMCSADD_R1(MXY(8),MXY(12),QX)
              CALL FMEQ(MXY(8),MXY(11),QX)
              CALL FMCSMPYI_R1(MXY(7),16,QX)
              DO K = 0, LSHIFT-8, 4
                 CALL FMCSADD_R1(MXY(8),MXY(7),QX)
                 K2 = 24*(2*K + 7)
                 CALL FMCSMPYI(MXY(6),K2,MXY(12),QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                     K1 = 8*(6*K*K + 42*K + 79)
                     CALL FMCSMPYI(MXY(14),K1,MXY(12),QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 ELSE
                     K1 = 48*K
                     CALL FMCSMPYI(MXY(14),K1,MXY(12),QX)
                     CALL FMCSMPYI_R1(MXY(12),K,QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                     K1 = 336*K + 632
                     CALL FMCSMPYI(MXY(14),K1,MXY(12),QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 ENDIF
                 IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                     K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                     CALL FMADDI(MXY(8),K0,QX)
                 ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                     K0 = 8*(2*K + 7)
                     CALL FMI2M(K0,MXY(12),QX)
                     K0 = K*K + 7*K + 15
                     CALL FMCSMPYI_R1(MXY(12),K0,QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 ELSE
                     K0 = 8*(2*K + 7)
                     CALL FMI2M(K0,MXY(12),QX)
                     CALL FMCSMPYI(MXY(12),K,MXY(9),QX)
                     CALL FMCSMPYI_R1(MXY(9),K,QX)
                     CALL FMCSADD_R1(MXY(8),MXY(9),QX)
                     K0 = 7*K + 15
                     CALL FMCSMPYI_R1(MXY(12),K0,QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 ENDIF
                 CALL FMCSMPY_R1(MXY(11),MXY(8),QX)
              ENDDO
          ENDIF
          CALL FMCSMPY_R1(MXY(11),MXY(3),QX)
          CALL FMCSMPY_R1(MXY(10),MXY(11),QX)
      ENDIF
      CALL FMEQ(MXY(10),MXY(11),QX)
      GO TO 180

!             Method 2.  Use the Ln(Gamma(z)) asymptotic series, then use exp.
!                        To speed the asymptotic series calculation,
!                        increase the argument by LSHIFT.

  170 KWSAVE = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(15),INTA,QX)
      QX%KWARN = KWSAVE

      IF (QX%KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(QX%NDIG)*QX%ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)
      IF (QX%KFLAG == 0) THEN
          IF (INTA <= MAX(200,INT(QX%DLOGMB*QX%NDIG))) THEN
              IF (INTA <= 2) THEN
                  CALL FMI2M(1,MXY(11),QX)
                  GO TO 180
              ENDIF
              INTA = INTA - 1
              CALL FMFCTI(INTA,MXY(11),QX)
              GO TO 180
          ENDIF
      ENDIF

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(5),QX)
          CALL FMADD(MXY(15),MXY(5),MXY(14),QX)
      ELSE
          CALL FMEQ(MXY(15),MXY(14),QX)
      ENDIF

!             Get Gamma for the shifted argument.

!             Compute IEXTRA, the number of extra digits required to compensate for cancellation
!             error when the argument is large.

      IEXTRA = MIN(MAX(INT(MXY(14)%MP(2))-1,0),INT(1.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(14),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(15),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      NDSAV2 = QX%NDIG
      QX%NDIG = QX%NDIG + IEXTRA
      CALL FMLNGM(MXY(14),MXY(4),QX)
      CALL FMEXP(MXY(4),MXY(11),QX)

      QX%NDIG = NDSAV2

!             Reverse the shifting.
!             The product MA*(MA+1)*...*(MA+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(6)  is Z
!             MXY(7)  is Z**2
!             MXY(8)  is Z**3
!             MXY(9)  is (Z+K)*...*(Z+K+3)
!             MXY(12) is the current product

      CALL FMEQ(MXY(15),MXY(6),QX)
      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(6),MXY(7),QX)
          CALL FMMPY(MXY(6),MXY(7),MXY(8),QX)
          CALL FMSQR(MXY(7),MXY(9),QX)
          CALL FMCSMPYI(MXY(8),6,MXY(13),QX)
          CALL FMCSADD_R1(MXY(9),MXY(13),QX)
          CALL FMCSMPYI(MXY(7),11,MXY(13),QX)
          CALL FMCSADD_R1(MXY(9),MXY(13),QX)
          CALL FMCSMPYI(MXY(6),6,MXY(13),QX)
          CALL FMCSADD_R1(MXY(9),MXY(13),QX)
          CALL FMEQ(MXY(9),MXY(12),QX)
          CALL FMCSMPYI_R1(MXY(8),16,QX)
          LARGE = INTMAX
          DO K = 0, LSHIFT-8, 4
             CALL FMCSADD_R1(MXY(9),MXY(8),QX)
             K2 = 24*(2*K + 7)
             CALL FMCSMPYI(MXY(7),K2,MXY(13),QX)
             CALL FMCSADD_R1(MXY(9),MXY(13),QX)
             IF (K <= SQRT(REAL(LARGE)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMCSMPYI(MXY(6),K1,MXY(13),QX)
                 CALL FMCSADD_R1(MXY(9),MXY(13),QX)
             ELSE
                 K1 = 48*K
                 CALL FMCSMPYI(MXY(6),K1,MXY(13),QX)
                 CALL FMCSMPYI_R1(MXY(13),K,QX)
                 CALL FMCSADD_R1(MXY(9),MXY(13),QX)
                 K1 = 336*K + 632
                 CALL FMCSMPYI(MXY(6),K1,MXY(13),QX)
                 CALL FMCSADD_R1(MXY(9),MXY(13),QX)
             ENDIF
             IF (K <= (REAL(LARGE)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(9),K0,QX)
             ELSE IF (K <= SQRT(REAL(LARGE)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(13),QX)
                 K0 = K*K + 7*K + 15
                 CALL FMCSMPYI_R1(MXY(13),K0,QX)
                 CALL FMCSADD_R1(MXY(9),MXY(13),QX)
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(13),QX)
                 CALL FMCSMPYI(MXY(13),K,MXY(10),QX)
                 CALL FMCSMPYI_R1(MXY(10),K,QX)
                 CALL FMCSADD_R1(MXY(9),MXY(10),QX)
                 K0 = 7*K + 15
                 CALL FMCSMPYI_R1(MXY(13),K0,QX)
                 CALL FMCSADD_R1(MXY(9),MXY(13),QX)
             ENDIF
             CALL FMCSMPY_R1(MXY(12),MXY(9),QX)
          ENDDO
          CALL FMDIV_R1(MXY(11),MXY(12),QX)
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

  180 IF (KRFLCT == 1) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(15),MXY(7),QX)
          CALL FMDIVI(MXY(7),2,MXY(8),QX)
          CALL FMINT(MXY(8),MXY(2),QX)
          CALL FMMPYI(MXY(2),2,MXY(9),QX)
          KSIGN = -1
          IF (FMCOMP(MXY(7),'==',MXY(9),QX)) KSIGN = 1
          CALL FMSUB(MXY(15),MXY(7),MXY(10),QX)
          CALL FMPI(MXY(12),QX)
          CALL FMMPY_R1(MXY(12),MXY(10),QX)
          KRSAVE = QX%KRAD
          QX%KRAD = 1
          CALL FMSIN(MXY(12),MXY(3),QX)
          MXY(3)%MP(1) = KSIGN*MXY(3)%MP(1)
          QX%KRAD = KRSAVE
          CALL FMPI(MPISAV,QX)
          CALL FMDIV_R2(MPISAV,MXY(3),QX)
          CALL FMDIV_R2(MXY(3),MXY(11),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(11)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

  200 CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMGAM

      SUBROUTINE FMGAM_C(NDIG_C,MBASE_C,C,QX)

!  Initialize the constants used in the gamma polynomial.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: C(0:196)
      INTEGER :: NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      INTENT (INOUT) :: C,NDIG_C,MBASE_C
      INTEGER :: NDSAVE
      CHARACTER(220) :: ST
      TYPE(FM_SETTINGS) :: QX

      NDSAVE = QX%NDIG
      QX%NDIG = MAX(QX%NDIG,NINT(210*QX%DLOGTN/QX%DLOGMB))
      NDIG_C = QX%NDIG
      MBASE_C = QX%MBASE

      ST = " 2 "
      CALL FMST2M(ST,C(0),QX)
      ST = " 1.845568670196934278786975819835195137915681328120152802388465530" //  &
           "230264546444670658126105873416506500970737105500385835038078991971" //  &
           "02691432755165200471015292749299933251412532452465211441480948350581017M+0"
      CALL FMST2M(ST,C(1),QX)
      ST = " 1.246464995951346528971255032754062122751889033636657384469089862" //  &
           "717670083765963530684050979376234434063149542816318341831199882570" //  &
           "54136293454241409125655601075903604372266188019198826399323980756659507M+0"
      CALL FMST2M(ST,C(2),QX)
      ST = " 5.749941689206122275465545297069514629181683280995911506411578080" //  &
           "726118046263102563376406423582057300595042023225863076035376079997" //  &
           "58104823944616583929664137138189407083120305067949277678404599957423943M-1"
      CALL FMST2M(ST,C(3),QX)
      ST = " 2.300749407541140630184757374755110638744965329574536384291172327" //  &
           "224547634301735916779398033223621567106468104559113876289562540922" //  &
           "49810183476230067472728208959273220898874770326648720581128183324434328M-1"
      CALL FMST2M(ST,C(4),QX)
      ST = " 7.371504661602386878317788712652808511825657580343462427360683175" //  &
           "509260544574956944742301697314778437297368730369274995615677873789" //  &
           "35133238331475104267889872993214666032986278826546933416543800481312385M-2"
      CALL FMST2M(ST,C(5),QX)
      ST = " 2.204110936751696733001055930504381988327566876073187686154801967" //  &
           "909973103233273981903764688650115297934327575508639951789708251337" //  &
           "92707722587521058280471694968009955629145006098566559417433720825728363M-2"
      CALL FMST2M(ST,C(6),QX)
      ST = " 5.448754075820309416743506865467445124448139461938118242185774040" //  &
           "091229588005782816224467061542163141883870132680748064163312525326" //  &
           "79285947455982778971828128624591203392889667559929450792010659863151692M-3"
      CALL FMST2M(ST,C(7),QX)
      ST = " 1.355220860239435200782800511692912879531376156061699075016521316" //  &
           "639789508602632933261809843993626303860552687494426922068347662436" //  &
           "50638664308894605216771132545723510121680479395222846647397509645416658M-3"
      CALL FMST2M(ST,C(8),QX)
      ST = " 2.647856630454963762916703027588487719988377646494592862588577877" //  &
           "670108768701128952589855350528375734341831836105261848089596212014" //  &
           "43438318203511988335596380750860411655605437077878364306986421443576571M-4"
      CALL FMST2M(ST,C(9),QX)
      ST = " 6.120306281920072864297933044336079606323020239995311203374612431" //  &
           "474530317806041317622369821667524651305326663533305730887143946711" //  &
           "61266460849960962516510977842732486514289292246744768624817147886489117M-5"
      CALL FMST2M(ST,C(10),QX)
      ST = " 8.505579174881354789674853004022777303159200477826996950880457101" //  &
           "421412876328884015915508261943090083057713903043228932335601231203" //  &
           "40141960454601937991265277526358454689641320642200080030286310049533045M-6"
      CALL FMST2M(ST,C(11),QX)
      ST = " 2.406177240131441866815352548925218907359016756341071832415175589" //  &
           "258269044824185640836078834625474374503849871861065571818953770220" //  &
           "34975008487473056363745663434694457043463856223590513289898353487696130M-6"
      CALL FMST2M(ST,C(12),QX)
      ST = " 8.802390990648096801589149015845004893557805933708362167755975543" //  &
           "372057695537675243732864757390172399681575843089705450975708832670" //  &
           "47894590480007482518734894597525237926945509694423313414680575733951262M-8"
      CALL FMST2M(ST,C(13),QX)
      ST = " 1.142227645342158377586670448383448546854299529797736913759691985" //  &
           "910949533336448816683159056251333466684021985223318722135340801690" //  &
           "72260625981817135095639775689249807942339836246106905787385604364337194M-7"
      CALL FMST2M(ST,C(14),QX)
      ST = " 1.631475210082743727954198968671352602693131133480080900245408554" //  &
           "939316524124591839852475746114674778530360919625180046232777005122" //  &
           "27236317509067632839828070252526276470500723929148927321567689434907911M-8"
      CALL FMST2M(ST,C(15),QX)
      ST = " 8.623497389978272698928826543954910754554854080065660353539135917" //  &
           "773916063595516849273098040739690585246037837539507713246122281847" //  &
           "07020525306666205624027189054003604432165771697650991757066138256773314M-9"
      CALL FMST2M(ST,C(16),QX)
      ST = " 2.441104025235454263800352688428668916552720940475516379601031040" //  &
           "328703631852876301331001731922670655825329213688582617123340479731" //  &
           "30453030855966898642614830460583649086634599347191276139711017402687474M-9"
      CALL FMST2M(ST,C(17),QX)
      ST = " 8.729150638722326041474546798911555513733749137711634358293958504" //  &
           "106518519494766446793260191698472463238634461285021617971659072089" //  &
           "64830740638437222612735276515039966197638188663669442608898762584643632M-10"
      CALL FMST2M(ST,C(18),QX)
      ST = " 2.839029513083401421929170732563229229668325235436226039051054572" //  &
           "783508115759922623716045941336385750870556656615699867502848974601" //  &
           "25690803078266597331301210600902409196080711025610915592408863593987027M-10"
      CALL FMST2M(ST,C(19),QX)
      ST = " 9.560889804988413908509285509380646041154360005479482459192247765" //  &
           "357528992664976535701311631674646910607500850899901331610584447013" //  &
           "61092693917685042900085585432034263673380064316273851782544357969469641M-11"
      CALL FMST2M(ST,C(20),QX)
      ST = " 3.178270013361840262252491679259206811383776452439447460847595023" //  &
           "655033077497304599287176316699672432816255052883697868521388307529" //  &
           "40383229860610241927494715179896090660025570060233690995092455619052433M-11"
      CALL FMST2M(ST,C(21),QX)
      ST = " 1.061093469576602661180070676287816314794459534888083832039943125" //  &
           "106258601567850805437194313637331057164170163808855202657895983163" //  &
           "75070581362231098256864140947088822349901059528755152892715695385840670M-11"
      CALL FMST2M(ST,C(22),QX)
      ST = " 3.536842812699221803341361602631772393030775267007960695600138342" //  &
           "475056171314799106864974683735705965078815702431194850519988946394" //  &
           "60297349449303074734807619318567432754104422976962193319806157373676528M-12"
      CALL FMST2M(ST,C(23),QX)
      ST = " 1.179381890210746859019626609111101179189547278121204798102640669" //  &
           "089589106613555171765287658695791241618592970217136500883583515937" //  &
           "07042245469783966737397377617384891192343427489490590732643362286614565M-12"
      CALL FMST2M(ST,C(24),QX)
      ST = " 3.931867733137363527554885326768660997026944151573526847589071835" //  &
           "861161866217034417877097706264724092166846479646830599648529767479" //  &
           "29972500613317852095515147938660038231478063008302625870299351511379064M-13"
      CALL FMST2M(ST,C(25),QX)
      ST = " 1.310821437225892696503587059884518604419875759028225403332569486" //  &
           "263124550715228960875605764084965585015810053174223154386683364225" //  &
           "82940623880095674287091265178854323811489670635974124477257044106228515M-13"
      CALL FMST2M(ST,C(26),QX)
      ST = " 4.369852680143739417301538884456930730266716017178643408797678607" //  &
           "489727662002478005547544394166113056281405054193512564204527806783" //  &
           "21820023428536694798337606178682340961609542697763176968052664696930530M-14"
      CALL FMST2M(ST,C(27),QX)
      ST = " 1.456734329592486133181460315029414930377211960023817769883504280" //  &
           "093804008390039009055883271224157190963826905955811848380812603165" //  &
           "54224971663883071707665069028985176275185941888330865659033519170133935M-14"
      CALL FMST2M(ST,C(28),QX)
      ST = " 4.856068671580721652825423134564758955030518962120078212851284455" //  &
           "507593020938761405142314134920533228978526051606006790133466381223" //  &
           "50359680218686853748359459683818517509731959413893343189086282950465935M-15"
      CALL FMST2M(ST,C(29),QX)
      ST = " 1.618761872087034547065539210485881034248882944054015543045073210" //  &
           "910330056730122088065602760823181836215863575050044591541254549198" //  &
           "06533155170588574561959173365139660326081560892373137180542173284519690M-15"
      CALL FMST2M(ST,C(30),QX)
      ST = " 5.396053371990928374785154960328771472570021055817837913960904096" //  &
           "760099091618418168792262897777467993922856366402610309885017994638" //  &
           "31375328961628239846054792847689945091796341112338488175505578851091459M-16"
      CALL FMST2M(ST,C(31),QX)
      ST = " 1.798729611660976774380774106560359446517486065245326232319884896" //  &
           "239912275072122853296640979664466879259429595297450987702461004648" //  &
           "40931772056892963070221773391675849856440134420289464625930506084236358M-16"
      CALL FMST2M(ST,C(32),QX)
      ST = " 5.995878246226820269265104853882744953833262677515218945976170565" //  &
           "702779924974464149394857574835844004490020924890860726739848899923" //  &
           "95696324825550829660096649087698612645940055809410964879423696294173532M-17"
      CALL FMST2M(ST,C(33),QX)
      ST = " 1.998654305589399275726998250553254783542933078465976133420153128" //  &
           "272381058668053909214099708471764295907486937756314951544992358421" //  &
           "97144228984621236873733301083447645823872653994272286143235273563570481M-17"
      CALL FMST2M(ST,C(34),QX)
      ST = " 6.662251581403731529306004514600953655139824062623862163440755266" //  &
           "354957947460012639499946309112697689542491881916960750384664086547" //  &
           "74220845245988438400136805239697524619278380861197973816032911820925462M-18"
      CALL FMST2M(ST,C(35),QX)
      ST = " 2.220768169107932862809420803989156159852745026278540490315171027" //  &
           "166630658162840832652660890951304947572979341837638582334903909155" //  &
           "05010378303851983844455677013599258308919578609796169265316664802443791M-18"
      CALL FMST2M(ST,C(36),QX)
      ST = " 7.402604670809900203376581979566914810234491834807160670117173102" //  &
           "679048535794208132168246922357691220447769517665621319685807754668" //  &
           "30524972355162004213858351086934604282899918908012797069231868984875389M-19"
      CALL FMST2M(ST,C(37),QX)
      ST = " 2.467545917514843068413870814987535001534095121397550756283431485" //  &
           "174239672848806618511211094654861620856356668212851618482113031080" //  &
           "96983868763519240779629920703298714890476973363239861006308885857104223M-19"
      CALL FMST2M(ST,C(38),QX)
      ST = " 8.225180627404782368968305939492307217250324537166525666738082095" //  &
           "443986514199471391717760463558674271532612180804614900051667267307" //  &
           "84828422378491452316833093910246472565776447483034439499635086721544230M-20"
      CALL FMST2M(ST,C(39),QX)
      ST = " 2.741733768240659509936720350920901622511204615005846102750077012" //  &
           "225034115334522335690591847723821637675971676287391586929140867246" //  &
           "24157389063680220659693708857804287064240054553450007399411745938008177M-20"
      CALL FMST2M(ST,C(40),QX)
      ST = " 9.139129792265891288417212538920834449088699985871081943229349237" //  &
           "308947859965368326191615768810794304428951588196306949098368574539" //  &
           "28605395142908365050404570472066333401820331325326810443520131888072775M-21"
      CALL FMST2M(ST,C(41),QX)
      ST = " 3.046380905361179933871534873717109530976853470108494529882869084" //  &
           "727927972747326006151030730201866380503024676995328258901563345953" //  &
           "00658838459344187262962809267579300899208726174226364547735769503160384M-21"
      CALL FMST2M(ST,C(42),QX)
      ST = " 1.015461378786517931007333337553073166997854684093926238094172044" //  &
           "744795968432075139196598233114739312125317801492097820991352317417" //  &
           "40293799704807080092075189476011412233026066523677916838565466920346563M-21"
      CALL FMST2M(ST,C(43),QX)
      ST = " 3.384873955149684581869145002322761445395722444488361773402583112" //  &
           "448446196579967067830143563552847474861011075678427137967175986491" //  &
           "77423399240122512958345857834877457342567505386357823149491980041361130M-22"
      CALL FMST2M(ST,C(44),QX)
      ST = " 1.128291991521080392925404045314099582618612165311869719114516335" //  &
           "417518456246100356538652790526704797786336190873078001030469915965" //  &
           "30342451983442856226503526150387619863083398681667798679726159209459487M-22"
      CALL FMST2M(ST,C(45),QX)
      ST = " 3.760974987926624413050052192380026663425879102031305346359345746" //  &
           "935876097802220422384767553022229983969369775506060549782771493660" //  &
           "85309029600033693383948806798756523782518697759939484580588143464857350M-23"
      CALL FMST2M(ST,C(46),QX)
      ST = " 1.253658750025309164633924716897191398251340412647146221607418983" //  &
           "652266605895765756004913716691084072256991264216324248980009909612" //  &
           "59662905496332238803040488263666172235045176892125202448596644986008747M-23"
      CALL FMST2M(ST,C(47),QX)
      ST = " 4.178863551880140415652989937671280452129584936360929800867252116" //  &
           "863675482287565904618697224054245640513684845309376666513701521263" //  &
           "52903495786573790786121590010548700491620543046740323819627331118835276M-24"
      CALL FMST2M(ST,C(48),QX)
      ST = " 1.392954780243262418680115701340497736540387201421965383888625288" //  &
           "310091918535511115914306440504769869531128337443764472227581178596" //  &
           "20874940378776837220110757980964940848165877287239082243508787832464445M-24"
      CALL FMST2M(ST,C(49),QX)
      ST = " 4.643183258187456757363871480237105948494753871341586050997508099" //  &
           "595411224954239240596072142323602079719155358372134330760070497787" //  &
           "55364393549841452404607067507295993200758608506748675165475527877530949M-25"
      CALL FMST2M(ST,C(50),QX)
      ST = " 1.547727917073673030893407669122051522765823276651858723363536117" //  &
           "860559780947473082931957648716608923599799859242924550204192502327" //  &
           "93202961853805884072569165830891801693280119768515402102389811485890830M-25"
      CALL FMST2M(ST,C(51),QX)
      ST = " 5.159093467774295934623929324290510691555682927619718795937537456" //  &
           "443748751641411020603883876314313578961537671360400477911224749990" //  &
           "32619951820624633170971754679797702479266215176809962392844181877752600M-26"
      CALL FMST2M(ST,C(52),QX)
      ST = " 1.719697925307095214819334128534788375205527844306001827485335608" //  &
           "178891188953930792336558066117385344867670787386310361133421997787" //  &
           "32437687430376200145015883834569265381524778650808598371769510961689717M-26"
      CALL FMST2M(ST,C(53),QX)
      ST = " 5.732326674479775700977445632081415478242873164984623088760026987" //  &
           "046479843038489986034336241981077004936330751439598114357862316445" //  &
           "25391747885525449466566054526270451667824579066863518701758860381778789M-27"
      CALL FMST2M(ST,C(54),QX)
      ST = " 1.910775622357349859006177503807224410484768271435458299879734511" //  &
           "091872750666800933837592866045341090057920381872911981841539613531" //  &
           "34532853835424993139130432850991078908443110651776717566117546886621263M-27"
      CALL FMST2M(ST,C(55),QX)
      ST = " 6.369252235018181185695546747418083648737457861666758649658733495" //  &
           "450326624296352111648047112820334535082139732219092514871542197623" //  &
           "45438407830542732130710826023492126216948058010058111121438710893185370M-28"
      CALL FMST2M(ST,C(56),QX)
      ST = " 2.123084118462838161068146373210838937742442106504888126619598244" //  &
           "689122838503449807948835352511168142442994048637204680573237012416" //  &
           "88214862798756633312023510560919642366853351380446601871574640377801289M-28"
      CALL FMST2M(ST,C(57),QX)
      ST = " 7.076947161851452988857602069175395219260001742350326617810798286" //  &
           "412997417428572002897367283988898197215995346896337658412178803828" //  &
           "71600585988840954970771671278144596708302210216220397647874970105717455M-29"
      CALL FMST2M(ST,C(58),QX)
      ST = " 2.358982412360992050118851554506979955647201613693684896233810502" //  &
           "944787306402820374939041591698662853950957584483745174219063623695" //  &
           "13294756585697364356697316138631583855315160276428811116906407698998717M-29"
      CALL FMST2M(ST,C(59),QX)
      ST = " 7.863274770562928683386208182169555716408523732927181605570254642" //  &
           "783489336698077228912261535122643231786047779260925663715692218511" //  &
           "54079525591282153925777222923833127312465613000068227777044732926174616M-30"
      CALL FMST2M(ST,C(60),QX)
      ST = " 2.621091605860885533233898952848549221472883408639509048156174492" //  &
           "952501040386862212314276518084902725209461671925415533723193076219" //  &
           "02166363594957080995260573241730794841247260537467180156250342238881167M-30"
      CALL FMST2M(ST,C(61),QX)
      ST = " 8.736972058719399393773664808053499235464951884789194640368079086" //  &
           "177143026321168823182202095050518931856284116458482040667912530023" //  &
           "17830489701338487555343938051214348611787932621065770035562250631323146M-31"
      CALL FMST2M(ST,C(62),QX)
      ST = " 2.912324029368913239221905377728027928932487827862157086587586846" //  &
           "896450700145411015082377114761533704468584083695734375828642409882" //  &
           "69259984928264053284030731675607849783920249775114691953904644907709015M-31"
      CALL FMST2M(ST,C(63),QX)
      ST = " 9.707746789052497475085146052433896715360382198339051019251763880" //  &
           "518185755627159066562273677244070805548234512751403592056913207327" //  &
           "80251017233714875898746055682870640485635412611964103637495935078818638M-32"
      CALL FMST2M(ST,C(64),QX)
      ST = " 3.235915602473196442669228672981134089711213167383910530833953829" //  &
           "792990006951794162312454635926395818450571401725370707981435503583" //  &
           "55570191731695332982121199537121246583519326445577596987891273510182193M-32"
      CALL FMST2M(ST,C(65),QX)
      ST = " 1.078638535688323258277639294637321095007154872462571028231301143" //  &
           "605467142930516231430752807470673434147256477737840344704980947455" //  &
           "43053554636974298772295627289032328328373036848556849010802235448385016M-32"
      CALL FMST2M(ST,C(66),QX)
      ST = " 3.595461789454222217017444496718864771407199081151484546256978274" //  &
           "929484367469843471052909175769814275173782972424785067903628062172" //  &
           "38267851839020384161912309600523898207350166920811200389438694198073310M-33"
      CALL FMST2M(ST,C(67),QX)
      ST = " 1.198487264108026960553291549779110538131003576080453431007006512" //  &
           "268160233237697351800460921121832519391521815357041008416084888598" //  &
           "27557131190172270346227678454195010189227547853345612460399635783630149M-33"
      CALL FMST2M(ST,C(68),QX)
      ST = " 3.994957549418305520762016700744032876853769637744488924267188269" //  &
           "584393732051483805590060972426573672962844815489806656051668047426" //  &
           "97928538442568628891602616126915832496578665989847126282893366534237083M-34"
      CALL FMST2M(ST,C(69),QX)
      ST = " 1.331652517070655772993246798258154050119486912201311455268437349" //  &
           "114193156345900532664095994600506577877633489606677937802093759650" //  &
           "12137846480275713137733722530126859812615084188357652189387132980702776M-34"
      CALL FMST2M(ST,C(70),QX)
      ST = " 4.438841725063570781178568100283946176488573680079007649477905193" //  &
           "017992386971455066988895758316824569677887493778455225021106826855" //  &
           "29026392300941094435783945574507271437954562521405284456074260144096753M-35"
      CALL FMST2M(ST,C(71),QX)
      ST = " 1.479613908728203152730390143133201780942639054825565044507758917" //  &
           "773304661939287594029105088656760879117520103897129013490206639754" //  &
           "87435121659508261905208347102886094942106298340234319457765604513963509M-35"
      CALL FMST2M(ST,C(72),QX)
      ST = " 4.932046363361542755686335602696750869830288252199443432734105813" //  &
           "943462260083819436478927601708900720110450661448493818380083105762" //  &
           "71590161306544076696091310423964644508740590548145866774529617253109923M-36"
      CALL FMST2M(ST,C(73),QX)
      ST = " 1.644015454687397316689944677831911620211552013511192085616959005" //  &
           "082583370344704494312506871603969621047795163740944612049682148927" //  &
           "59356353337859121253234322350982876222750860528515262326476034089950266M-36"
      CALL FMST2M(ST,C(74),QX)
      ST = " 5.480051516208532057249213551633236335403175178397767120722791995" //  &
           "833335758082301610732726590856354303605009314671070073367443285322" //  &
           "81719944336949977298072286244404059176341969451639495219169668432874625M-37"
      CALL FMST2M(ST,C(75),QX)
      ST = " 1.826683838882145937413050728363254416465068672788666223790911345" //  &
           "427048802205722820790024964162626522627539834294555447603439041292" //  &
           "92403842411688509922659248102884925797066250995812515878053578599537543M-37"
      CALL FMST2M(ST,C(76),QX)
      ST = " 6.088946129972074589720378401074071029218658010685074635511831120" //  &
           "277695386768911269891962771874827650899040106965903278757448364187" //  &
           "28574155937467016044284632565747254397900833533383192879263530571086410M-38"
      CALL FMST2M(ST,C(77),QX)
      ST = " 2.029648710081921896663063938682967174463636477103609117669608797" //  &
           "346033378612490707724833983253281429017993058131396854118481222339" //  &
           "85407951679907254491401107628467015394676060959591476686232563916557226M-38"
      CALL FMST2M(ST,C(78),QX)
      ST = " 6.765495700501148906774995358078228324235325066490434291070320211" //  &
           "666634035845840680799492809322166392640915607858746928019847633868" //  &
           "45020162815858209793574963810268541266706689851018528823213713218014553M-39"
      CALL FMST2M(ST,C(79),QX)
      ST = " 2.255165233557401948601014902186205602789864371948507888958512686" //  &
           "894666882870433310683786297682141353940837232625056953901094633832" //  &
           "03813175465801305121046951268786662654220745685289766957573976902789674M-39"
      CALL FMST2M(ST,C(80),QX)
      ST = " 7.517217445333887278263065941349084170211801907036126548415826613" //  &
           "097540864542220787119574822998915671722740530800746773131556370537" //  &
           "17036257265431709600760536998990725283074006064618438905604324155029841M-40"
      CALL FMST2M(ST,C(81),QX)
      ST = " 2.505739148480265955233204413682186719497131266833487675446538783" //  &
           "092174430438507742800231748635072748340810415087125614579378635688" //  &
           "66151322710496155055815000392267489014427962480151154107924769960320348M-40"
      CALL FMST2M(ST,C(82),QX)
      ST = " 8.352463828356645340468994201986157494921881256993571664141509541" //  &
           "823273109890101870519752598083111861872055684078254288142631302953" //  &
           "90656071678927672118181416754149675034388261080192075026592829943869784M-41"
      CALL FMST2M(ST,C(83),QX)
      ST = " 2.784154609474488152611480955615773344997254762720123569187499710" //  &
           "482501105031142742130099147104245620254144813103304543108707461283" //  &
           "03676294384838274788281739537719423506089439601147338491518140111085245M-41"
      CALL FMST2M(ST,C(84),QX)
      ST = " 9.280515364970643106573953106487348079696240473524263398418948085" //  &
           "686805363427549650077259362814392417398055197835215069289928148824" //  &
           "67963286545183505632254520821084189068903494611293308100453524544737026M-42"
      CALL FMST2M(ST,C(85),QX)
      ST = " 3.093505121670801685004800389514423527223386419080428824653989649" //  &
           "679279518505124420083928960371367692487927529341787666280479065858" //  &
           "20227384416309509890526585569312748427209499872674012860539332555258032M-42"
      CALL FMST2M(ST,C(86),QX)
      ST = " 1.031168373893747390707549843146989045155823157470502623225595250" //  &
           "851710797449759760498072278428597174778192322827019231254514348869" //  &
           "35739852926303601231003771300391351671865972802045601948838060198753437M-42"
      CALL FMST2M(ST,C(87),QX)
      ST = " 3.437227912987858374961865176796344063877564237772445606496240106" //  &
           "757864483254589585823971686699471956766584959383102055399682270269" //  &
           "52352941784639649980429822410674941181991395320188803002740041936488314M-43"
      CALL FMST2M(ST,C(88),QX)
      ST = " 1.145742637664794559805828100464320725242403637362145522388352767" //  &
           "861006812839084798058391247493282342027006725688139044431839514660" //  &
           "53654774876669055000807030176806220727453288403581728457403167939166997M-43"
      CALL FMST2M(ST,C(89),QX)
      ST = " 3.819142125554752953067839505315181594779066795846739238810201522" //  &
           "091877503536260790984284322275300395166507566249167177334314175598" //  &
           "37162971702086753249324866744493897786886912065021929714836592305111972M-44"
      CALL FMST2M(ST,C(90),QX)
      ST = " 1.273047375186277089451795607705259637601635385366665197585993775" //  &
           "074526908019448436164455682411887757929212685231623835262681489558" //  &
           "82648858340071059461127000212205125717165045854603000054982553620290401M-44"
      CALL FMST2M(ST,C(91),QX)
      ST = " 4.243491250624322227579766750508513228093573956231840709615359110" //  &
           "716873987770463557146491514771994072759888669351546219633295358033" //  &
           "66517307409098637643711145428866491214789294814344532842968257523643745M-45"
      CALL FMST2M(ST,C(92),QX)
      ST = " 1.414497083542290391545199323374869916206725399320438141384531327" //  &
           "265477522477777915006882588147304129058542612492747596977199928651" //  &
           "94869243918440516701383178149493577193540062534758351817970713054178365M-45"
      CALL FMST2M(ST,C(93),QX)
      ST = " 4.714990278476425427697520544930204334035129865733446210245204030" //  &
           "355616997118279522525088487975375771703855109208249987771017533193" //  &
           "90291285366875213381956263086437252260808891626942562877561594888642475M-46"
      CALL FMST2M(ST,C(94),QX)
      ST = " 1.571663426159339506535953571864003053494761363991342538284158655" //  &
           "584260596318169435197761794741189000363244392470381778816827538385" //  &
           "70503152182049565811831241089687440405169499752285888183719228270040702M-46"
      CALL FMST2M(ST,C(95),QX)
      ST = " 5.238878087199125931711927428699616143954533668740342266002176483" //  &
           "066317524800888207882487253378527961702366607212427983576029574311" //  &
           "70477008468882187587684440329802260450306316947736342927462019072062451M-47"
      CALL FMST2M(ST,C(96),QX)
      ST = " 1.746292695733373871385356099575152433557917368382321044143123707" //  &
           "125733276511427813036854586467480879063125488695590156424518309858" //  &
           "40776387319594992052236593986791986838450118314507991811649011797951517M-47"
      CALL FMST2M(ST,C(97),QX)
      ST = " 5.820975652445409306654690542379619928753899950100022072575451976" //  &
           "896049502425251330032699117677706811131644722750272961660598812323" //  &
           "95528274546713027672214860795936676307396171912021238503162387066702843M-48"
      CALL FMST2M(ST,C(98),QX)
      ST = " 1.940325217482010536060783297163692278507114464120206717431891734" //  &
           "053010284461713330551549047577932453595163579118201359494986630173" //  &
           "01494093463680448771677875123107012368194613913742739952428603002168229M-48"
      CALL FMST2M(ST,C(99),QX)
      ST = " 6.467750724940553704809014908981646231351194700919134365131054499" //  &
           "044206347270309742459318050095528539735477919872551695967650699099" //  &
           "88953248180134764653841795790617888566272316181621003159336089850848991M-49"
      CALL FMST2M(ST,C(100),QX)
      ST = " 2.155916908313647547754610174771515398662821458991609891428955252" //  &
           "290583442620154212776250181824196267358169201447214242363354724316" //  &
           "89903280067672089810407626181445703141886320049309134936640041251647199M-49"
      CALL FMST2M(ST,C(101),QX)
      ST = " 7.186389694379149274561055379686410434878982979762824712204962808" //  &
           "871607736477144813893452054031932010405337926726732941950536667006" //  &
           "84810252591610140816882396575440916998193275137670082479286587744869582M-50"
      CALL FMST2M(ST,C(102),QX)
      ST = " 2.395463231459797453698442182708267050312141998051092331530640409" //  &
           "893924848764443035384500574394756654315653015364123642221973250880" //  &
           "68362683781580014370472600811020274312157465907532281112816349722673774M-50"
      CALL FMST2M(ST,C(103),QX)
      ST = " 7.984877438199527417773369963127799969498648440970510669498583482" //  &
           "161029591317677710672043612633451504552983943030656888570069226104" //  &
           "04295259910858734307563648182821156659161484763549481645932818220413101M-51"
      CALL FMST2M(ST,C(104),QX)
      ST = " 2.661625812733226448952431335647978161413961687446878335164533806" //  &
           "702910875419295287094135193138742564146281522194125689011703047524" //  &
           "45739306220536816835347815852152246454806822705745730784267021864361647M-51"
      CALL FMST2M(ST,C(105),QX)
      ST = " 8.872086042444214770744709174167341653906439941556420653788154173" //  &
           "929048445735834186760727780453829909511846845819831435241835442504" //  &
           "04079891107632829549289090071219101574622546793854950277712602194795534M-52"
      CALL FMST2M(ST,C(106),QX)
      ST = " 2.957362014148103242140721175656428119533141966179427551155676500" //  &
           "671725653671481845278656623962048055150306031384279834386038577295" //  &
           "72584556615286334177021422182622284915641930082182710316087748100105028M-52"
      CALL FMST2M(ST,C(107),QX)
      ST = " 9.857873380493756603533616420387300817360969314828251071875082336" //  &
           "698703611411040709238371719721287012785465953801003782742219530827" //  &
           "73983924014324680294547858829752678323087789357138505841177563631130388M-53"
      CALL FMST2M(ST,C(108),QX)
      ST = " 3.285957793497938650277342040351753052374376933619786220663421040" //  &
           "427587332321480401454840426545683394351958951963755749546928108005" //  &
           "75979757809361423163013264428850345811205867029087095522459004260861910M-53"
      CALL FMST2M(ST,C(109),QX)
      ST = " 1.095319264499317829033981510140817754508285369349556399833223737" //  &
           "174998151312514038433336840462205568158214000003108865975414472963" //  &
           "70581756862795260586373374661842883378795511151785344346238350698780645M-53"
      CALL FMST2M(ST,C(110),QX)
      ST = " 3.651064214997738460800440485464116453512465873766107387248343452" //  &
           "458997203837952291715916094766655886246438013372552836368973829605" //  &
           "29202550932685485563387565304843167421189066345923958359568125707813957M-54"
      CALL FMST2M(ST,C(111),QX)
      ST = " 1.217021404999249244605272366723881223583838603878543320302210671" //  &
           "409056933719216026722268770996716099812270381542447122348883231949" //  &
           "38922656964910194439295935941196896773701049861546343314133034224282491M-54"
      CALL FMST2M(ST,C(112),QX)
      ST = " 4.056738016664171876197055085310199605151026698635243534713457892" //  &
           "107296169062875134691895441571499550130093746425411512549327123228" //  &
           "16601740468340561446321921103466463550189353682758076018331072415996381M-55"
      CALL FMST2M(ST,C(113),QX)
      ST = " 1.352246005554725890610555164289246652995273648088741088360045973" //  &
           "623667364361191345555088170702142598112873445326035312084757222791" //  &
           "25547996491724650392650447881135472685838861374568021340343847835638534M-55"
      CALL FMST2M(ST,C(114),QX)
      ST = " 4.507486685182424465064025894185168278371602793396197455600512532" //  &
           "406474418197117862785333707359281266142995363043310398030388775224" //  &
           "96855355439438225180328883970301863313369556592379689501165566142115306M-56"
      CALL FMST2M(ST,C(115),QX)
      ST = " 1.502495561727476029111885802751588446409759610042467877987373043" //  &
           "860038180719787874668067312469292183193912200682893897594757683194" //  &
           "08099696091579813882633694420046951596146901116935629924246701724845131M-56"
      CALL FMST2M(ST,C(116),QX)
      ST = " 5.008318539091589782265978940332517362043223441916201948536518072" //  &
           "099322344676502315123489826715051040283829780783100995910094849108" //  &
           "65034584595413084839701258466960248343166395950551930374997082566708225M-57"
      CALL FMST2M(ST,C(117),QX)
      ST = " 1.669439513030530682061916213454823087218137831151025299167070973" //  &
           "190879095582514009353872307284741332656640434042133116166845579709" //  &
           "81635243531150493888288323800171093455101171326873303863260272601517849M-57"
      CALL FMST2M(ST,C(118),QX)
      ST = " 5.564798376768437493472862129317060203208340292866327711857634512" //  &
           "795204118217070748492626708664751935590615442683377362519336018325" //  &
           "51004856969881087903485123401331518636537459253893877449123506707146950M-58"
      CALL FMST2M(ST,C(119),QX)
      ST = " 1.854932792256146302807572731110803878429090610101994543365419672" //  &
           "049548214027388780306433203424820289079873088082231836000918687537" //  &
           "23334792833523598579662177790912527794946886117189075782702240392408839M-58"
      CALL FMST2M(ST,C(120),QX)
      ST = " 6.183109307520488855150122490825215119994140805333496249840425315" //  &
           "260483680241891966697616887289397465885493861812930613441993149861" //  &
           "75026053269580573584851572426023443652902431378207237270671672948970109M-59"
      CALL FMST2M(ST,C(121),QX)
      ST = " 2.061036435840163246497927510477654121008516108356441555748893883" //  &
           "538337771585715140176109550136417103188492842915425790968199189673" //  &
           "75115850238127872748852300922000306375635048830126739836684145179941549M-59"
      CALL FMST2M(ST,C(122),QX)
      ST = " 6.870121452800544891946141735609200171965629448722202434217816987" //  &
           "853447483793178217562366316730782300693739885096060635165076652920" //  &
           "41995525029854871068500757566629399110685057219153231404821304733713204M-60"
      CALL FMST2M(ST,C(123),QX)
      ST = " 2.290040484266848481553643087076101079355964961713023345779978400" //  &
           "982834140969803837340319397848019038722638870138573135003750122280" //  &
           "67644649360313184772818630784452829131845685063424590204739986167925734M-60"
      CALL FMST2M(ST,C(124),QX)
      ST = " 7.633468280889495399107799895007148312706155591452982323077149986" //  &
           "120899748236386385448066771935353332443050965065257767414246512604" //  &
           "54742904592796348751455213798689879834161009662040701046444537526427115M-61"
      CALL FMST2M(ST,C(125),QX)
      ST = " 2.544489426963165248184847366204930714902412817306190051775615959" //  &
           "530879632335665207219382767168166468926593335092194936311475724489" //  &
           "22045567698482778031098111145226005087891270132458202092192296860039337M-61"
      CALL FMST2M(ST,C(126),QX)
      ST = " 8.481631423210551115155109723717829106916950881296846054083649985" //  &
           "810525218550324029659230629073310007635840875342630862789117074541" //  &
           "87098166442436318923705470772023710069850200723928832617470068484538900M-62"
      CALL FMST2M(ST,C(127),QX)
      ST = " 2.827210474403517110353107867003629422731212331386162488716730521" //  &
           "351064005716979204840102164742676308078783782599324060431157817109" //  &
           "88654841674710921627884749621343607380343694451939622450448527669612216M-62"
      CALL FMST2M(ST,C(128),QX)
      ST = " 9.424034914678390547763871121100990122397792341363117728757038903" //  &
           "649538172737671552516290289880795766718250080584367536271759196670" //  &
           "39697325553891033518536553021634662617083010606852575129875069462163167M-63"
      CALL FMST2M(ST,C(129),QX)
      ST = " 3.141344971559463560901334931474821601568811602982335715041502627" //  &
           "827982932089655486622557870156127718095126494732372850918038888332" //  &
           "54551941638266722522763646352278545149136303285285604558173356388928708M-63"
      CALL FMST2M(ST,C(130),QX)
      ST = " 1.047114990519821198212122783269017133872736396216455065194396848" //  &
           "772182771964575553018906528347835085989108829213513953424609300128" //  &
           "95630377523418163375718344777771305545237149991145713842104433495405185M-63"
      CALL FMST2M(ST,C(131),QX)
      ST = " 3.490383301732737355486270459507822699258345311341941846849921659" //  &
           "545613492122376436148560471436321288125576975707576514288727189135" //  &
           "81234008256049155059395856211182401981576994675285833396791180771117772M-64"
      CALL FMST2M(ST,C(132),QX)
      ST = " 1.163461100577579125523555448655563780187894154820747936001916075" //  &
           "833373823024344903789897831688942109838607391549196509166544386710" //  &
           "32984677138183863587254008956883033409075083480154979676313298835611005M-64"
      CALL FMST2M(ST,C(133),QX)
      ST = " 3.878203668591930435982181400901299436435180157598905860060992780" //  &
           "769432703831655807641542938250104063615345695580486254706194715454" //  &
           "60229972174586144050891402920273633768999530012198276610097006412695734M-65"
      CALL FMST2M(ST,C(134),QX)
      ST = " 1.292734556197310149719976276646194118747432707279683488755745696" //  &
           "740947679118453560585318506784845508484302703353713015155212188239" //  &
           "59563349122999271475430680808380714359508027924891221587469189007133570M-65"
      CALL FMST2M(ST,C(135),QX)
      ST = " 4.309115187324367176714710446351861339597497796718143278961320946" //  &
           "586948534200778409616190905114541820432168004724255101140047339531" //  &
           "16503452628730864113604659140394417734969121530536316322243286765720986M-66"
      CALL FMST2M(ST,C(136),QX)
      ST = " 1.436371729108122394983600863166786192397968628737741530628906208" //  &
           "660940944816769480739740878584831113565249313940195309419096432913" //  &
           "23986224865537803560999682866769231274805486620569029108114354610082602M-66"
      CALL FMST2M(ST,C(137),QX)
      ST = " 4.787905763693741323475412996513093551712741258381159384549759206" //  &
           "662442822072738588515832300420257228803664662013090680472314997210" //  &
           "47994366822587964409268875557318665191628748298284520227769123490709406M-67"
      CALL FMST2M(ST,C(138),QX)
      ST = " 1.595968587897913776207656861993669785407285064500745185434113800" //  &
           "096356494376241989760638754749237977344465547010132327612679509965" //  &
           "90606634208693254568607053260913032981301281185089491854456988622988789M-67"
      CALL FMST2M(ST,C(139),QX)
      ST = " 5.319895292993045924981820864535497749048234307774210374132739226" //  &
           "662962493896584326632876715466366610480847242863534749368020824442" //  &
           "26347859777033625778816141835475590087036758263889428530371159240382397M-68"
      CALL FMST2M(ST,C(140),QX)
      ST = " 1.773298430997681976066348119317279371541102493785396123709304532" //  &
           "963732653591086234204258910992398206481527117154837605280677866587" //  &
           "40860519847234648346851518177302296315561478928449266143246491562286927M-68"
      CALL FMST2M(ST,C(141),QX)
      ST = " 5.910994769992273256235513308905467236327084289024213039675731610" //  &
           "148156011515848201203908937219678972731231236325011698208574736079" //  &
           "80168427550976937837979750480068076198135077050989661245596743172379630M-69"
      CALL FMST2M(ST,C(142),QX)
      ST = " 1.970331589997424419415425997445581585340102744812802313473388703" //  &
           "562069927312660229009236127416616182518232875620838559077842053926" //  &
           "92349876121987505300275410560304423025355686582773348179088042892097570M-69"
      CALL FMST2M(ST,C(143),QX)
      ST = " 6.567771966658081399727057227641186570727529727910776691977632634" //  &
           "165946988657121076389626270986170591723497353782252176685973776995" //  &
           "43528417602815951738160201869055681397572348387528732209187423794662534M-70"
      CALL FMST2M(ST,C(144),QX)
      ST = " 2.189257322219360466994595051007995333389857163416210506204122933" //  &
           "434092909606199446262463730440462471061414357649669288454519822486" //  &
           "33439286916366526139243135196086518512441365472582736479048872262858017M-70"
      CALL FMST2M(ST,C(145),QX)
      ST = " 7.297524407397868224362590109254773419614298510807208602130225559" //  &
           "169843334057978765051658253298688634379979983044623872624689424224" //  &
           "07554019829693239747911909633693703476580188084738005493123701521791467M-71"
      CALL FMST2M(ST,C(146),QX)
      ST = " 2.432508135799289408382681708766459710814072648334087437525650247" //  &
           "402627470576079904894860765869748078205431190272078201162332612662" //  &
           "86925426506431278564366927546261623009686964819372619868333948357411039M-71"
      CALL FMST2M(ST,C(147),QX)
      ST = " 8.108360452664298028596818159143547381983866077866697620113475392" //  &
           "867557609420149388391146208299955439299097511073088600020008797364" //  &
           "90254145831112916894519121436284980569670233198361465597386807462396245M-72"
      CALL FMST2M(ST,C(148),QX)
      ST = " 2.702786817554766009695908457319192274936196517820205990720071929" //  &
           "267436760629307786446087225623272749165348119673554381961913455458" //  &
           "93050660537495047726291186100258874974179781198259808664194749915523789M-72"
      CALL FMST2M(ST,C(149),QX)
      ST = " 9.009289391849220032728785940466253732893526544523495429162278552" //  &
           "296342689979948102270331957628702643264702399700740206586719143369" //  &
           "63516748801336419497668271497140970017083857566651892279908542196784275M-73"
      CALL FMST2M(ST,C(150),QX)
      ST = " 3.003096463949740011011890954041623476083928522268342083771940551" //  &
           "403977301983996687445005688089790997335068650775774411500709972696" //  &
           "00052352997217396436659500075907900727290635046242137258265027272046707M-73"
      CALL FMST2M(ST,C(151),QX)
      ST = " 1.001032154649913337029531966564025740882006821416233309378396854" //  &
           "352648141475996724306705629001209846327383244434702908491488661840" //  &
           "33666122248311247777472186264526745924646761167750923503037999124457410M-73"
      CALL FMST2M(ST,C(152),QX)
      ST = " 3.336773848833044456828335032653876240316804704924144044073849579" //  &
           "816206165795104200289660358785996996484528456071385377435139123676" //  &
           "57709192610536558746890780425020107260403503414920896791666418548557679M-74"
      CALL FMST2M(ST,C(153),QX)
      ST = " 1.112257949611014818958755021576306436637772541032306466006509854" //  &
           "188967690019629658157071337514432146127855476046945605695950179554" //  &
           "39845790791214616926248699635001115509938807913024195016995950944619712M-74"
      CALL FMST2M(ST,C(154),QX)
      ST = " 3.707526498703382729922171432032250515805881149465794264372984724" //  &
           "327809012896984209000978195800679443631566152731613311969108735093" //  &
           "51590966384556456803036744807880814153226574822433894031208374029742738M-75"
      CALL FMST2M(ST,C(155),QX)
      ST = " 1.235842166234460909984137514518387752942293928074591712157524109" //  &
           "560139067764692539980008571135341128797657051727809999365157975182" //  &
           "53322235173852278845187716078871110242776570216352174337398795667971328M-75"
      CALL FMST2M(ST,C(156),QX)
      ST = " 4.119473887448203032778434343895875695597840528814474282367848794" //  &
           "205301550322451475974554397356862932040320235498247930630480575568" //  &
           "25417807718570483485133432555365627049395094885528093686245256557591509M-76"
      CALL FMST2M(ST,C(157),QX)
      ST = " 1.373157962482734344263376419251248172548827589625457941472696797" //  &
           "100175825647692982915548765225643706779206935633946071637767635709" //  &
           "79966315426397983742300900492572704510866186342432593363321634147388215M-76"
      CALL FMST2M(ST,C(158),QX)
      ST = " 4.577193208275781160777550837017921925055088338901698850930906043" //  &
           "311063967012540679380363564085256672110282867832397021602920753059" //  &
           "62941763379439217899247719980351463557310935320189195654346581389521961M-77"
      CALL FMST2M(ST,C(159),QX)
      ST = " 1.525731069425260386985167951519330997746387629867941705993359606" //  &
           "803096607303855736985249240116888915751939824222470295586537784557" //  &
           "14766559903817261522752203057544899378743721133360484530771023423930290M-77"
      CALL FMST2M(ST,C(160),QX)
      ST = " 5.085770231417534312974277748264028715371006669759625749888114997" //  &
           "040535088461914628203462029057668451395058320957895155954018999649" //  &
           "89570133824275977321769674422087255596053232511973102592783007464375573M-78"
      CALL FMST2M(ST,C(161),QX)
      ST = " 1.695256743805844769769991874189352969259021005362418248962236686" //  &
           "450929128768148436336404059930819742510685161671532907373324896396" //  &
           "92385277655969091090205296324356998243606127274626181023449273081779115M-78"
      CALL FMST2M(ST,C(162),QX)
      ST = " 5.650855812686156039218806037909235903455451213739689260418037318" //  &
           "509446943950605499341032642835238412850215403194710979806557582704" //  &
           "37936259002958165848823746298586989930806700558037154118861273544045145M-79"
      CALL FMST2M(ST,C(163),QX)
      ST = " 1.883618604228718704933778437940690307805004962163899221957470918" //  &
           "058716333776074607305943978262640017375578856797709581746515819407" //  &
           "51489901662136678406269201616881521607807260952614167843862068838710312M-79"
      CALL FMST2M(ST,C(164),QX)
      ST = " 6.278728680762256512126149402150794782943415735579294630724544224" //  &
           "964157228232060226941740181573870879258048900467741995915140892478" //  &
           "63661908097641164941373210234799596031030310767570648902522277881849187M-80"
      CALL FMST2M(ST,C(165),QX)
      ST = " 2.092909560254085021914720610883566852288010979452630217312140514" //  &
           "778472364540695790415885690351086108014265966713921440025212436361" //  &
           "73967300532411889825601604598920039776377478055710366101143130338433473M-80"
      CALL FMST2M(ST,C(166),QX)
      ST = " 6.976365200849595928554228570881565721048784920515468405614250170" //  &
           "741926248557408642176573843779290903009186026063040672689273898432" //  &
           "88910357288258162475303198325632084369407383550262099668489007926100917M-81"
      CALL FMST2M(ST,C(167),QX)
      ST = " 2.325455066949873863603395561978748601800147911008192886172463050" //  &
           "451820515051068562317761231512963759254765453729061173550997868120" //  &
           "58407734788242875774377719715615329774495325545245938734484625573096582M-81"
      CALL FMST2M(ST,C(168),QX)
      ST = " 7.751516889786273230324814807015203014115787760363240263773567207" //  &
           "238770582250611249333986919911192763902738500220512285746471179825" //  &
           "77571260191751902463570497659486034004412403189688932637270843323495731M-82"
      CALL FMST2M(ST,C(169),QX)
      ST = " 2.583838963261950823749231801853943339353886424780054671299212593" //  &
           "953839989881747235093144189509781483529556454394968872792726683435" //  &
           "27643326289916001403186650841236534106807785205861848342075189337865239M-82"
      CALL FMST2M(ST,C(170),QX)
      ST = " 8.612796544966339593458567326158368856673430376795891557224772538" //  &
           "947415233055213978085860502193079097945197318656791149694366866539" //  &
           "72822366330690625287806683992931214418731468102411025539925415006202370M-83"
      CALL FMST2M(ST,C(171),QX)
      ST = " 2.870932181657563853681094248589222833815589612305003013771994066" //  &
           "486301003023979828481138638939770854259457931497871219438623202895" //  &
           "38689833732465547124246759187251713896087958971527124804970116015889039M-83"
      CALL FMST2M(ST,C(172),QX)
      ST = " 9.569773927459502329186355848231519845153615256953762486987693008" //  &
           "642824433756506369875737104132534466116626389178752624525042798289" //  &
           "22548975065811830797487032916317956125950813783158098289413462007841293M-84"
      CALL FMST2M(ST,C(173),QX)
      ST = " 3.189924642457193947274111017893685291988923107347172733780095937" //  &
           "504990242848262256269173114579259710506482337540368636019319969386" //  &
           "73520058153132922629586433368902183759949488890960340616457392616954301M-84"
      CALL FMST2M(ST,C(174),QX)
      ST = " 1.063308229833233763649615961280021009800959973857039083389096247" //  &
           "411276485934365597139214502542489173998160641619626621325276246417" //  &
           "76894303109902050056828926820785431328629167285741168999780547981801651M-84"
      CALL FMST2M(ST,C(175),QX)
      ST = " 3.544360766480896268661403387806726005830929777366570657261489401" //  &
           "694611013460386506117284436161560434270675994478125024682804092939" //  &
           "15998067887747220478181658639560020083789407982402045792182967207779297M-85"
      CALL FMST2M(ST,C(176),QX)
      ST = " 1.181453391991692193233769222790948883554160416544364056162345177" //  &
           "930450135664579747942304147194452606107088227217835015752643760372" //  &
           "89824167494419232372153209806697818554092135462778008255059604732701717M-85"
      CALL FMST2M(ST,C(177),QX)
      ST = " 3.938177969065104259816236800771282813142970611653130614923372425" //  &
           "876301727778466158006947186295720851119739977650492841350794668106" //  &
           "75909743699184418774259697017658821999190863053142757985704314111950238M-86"
      CALL FMST2M(ST,C(178),QX)
      ST = " 1.312728231460229835781690690024789271337659581458734016769897717" //  &
           "615695172767934655904718896955205839028238358310418293184633392500" //  &
           "09974095126152086147719595157884930629859403536081952476482731834669587M-86"
      CALL FMST2M(ST,C(179),QX)
      ST = " 4.375760815315077535413569523720083421030822320092520690986988142" //  &
           "097203566380515277459454385250926657264251938784637571214707790842" //  &
           "13901922704849922902680056772549256776092849835805341467509317300857668M-87"
      CALL FMST2M(ST,C(180),QX)
      ST = " 1.458563929048378339389303099779179984031579246114615330084586060" //  &
           "391340363385450968349489278357541331271188532814617890065655968100" //  &
           "90864106047591784785100253214527821779035249121314752150297703091924694M-87"
      CALL FMST2M(ST,C(181),QX)
      ST = " 4.861879359454319859107717556333622023158902013437521581162884873" //  &
           "340193641755594234893503470462192100416392001882798233766279202968" //  &
           "02742623676171486751287082335949083937364296608060437072511301740262916M-88"
      CALL FMST2M(ST,C(182),QX)
      ST = " 1.620837575639336717669552632235434719742418568812043976527454822" //  &
           "311557369332525067245294696277568831932145434818066929071312277435" //  &
           "59667900060244610446776086220578843202917562200852939911588169882033048M-88"
      CALL FMST2M(ST,C(183),QX)
      ST = " 5.402795219201229254205787739591614371703058387299744106863813045" //  &
           "890074410469634798352875615158044666258805327295738061277040804255" //  &
           "11706167845408641690753715592108911157218063444936673090628364776228851M-89"
      CALL FMST2M(ST,C(184),QX)
      ST = " 1.799216964519093606731199173063133848252752532638951929530332271" //  &
           "088757960440794118609774620691669941349561692799601479867289303361" //  &
           "36573900179559749556590933182210908857440047681409893684369308365396546M-89"
      CALL FMST2M(ST,C(185),QX)
      ST = " 5.997366309057088767075246255186377444897385269608659113392135251" //  &
           "083240010154867782825603589060665479283491811344357943450419502328" //  &
           "30863890415054273770878371228558497389363862954168787497855394907612488M-90"
      CALL FMST2M(ST,C(186),QX)
      ST = " 2.011301294926252140726377746074781953178862150579839442308024059" //  &
           "805516340858995612053131399074329904610352755793706433609739823274" //  &
           "35441280105568641478715458116693621474886783585502490686457813740208553M-90"
      CALL FMST2M(ST,C(187),QX)
      ST = " 6.704482593621562564692904617177008442804824808114929721560806403" //  &
           "083889880113942537426720271890350736903006981375786722754398310176" //  &
           "64290862799510364108316770714557534855989672010291914054754244834573505M-91"
      CALL FMST2M(ST,C(188),QX)
      ST = " 2.160351395289544486253218378105888708749936652071087348664876866" //  &
           "590595135247617954742090212769559780976713437175453455128216319294" //  &
           "79621451615761249300873617293850399062283747501629953564198534458556254M-91"
      CALL FMST2M(ST,C(189),QX)
      ST = " 7.200419569439204992397564583120569704507791779761471734959614293" //  &
           "903195879211244064072895412909288124860635443865351473928153163314" //  &
           "35648140579845782685750371868061482151886800120453245481648754938151403M-92"
      CALL FMST2M(ST,C(190),QX)
      ST = " 2.784319712626698759566042489347515628094423349698152057970857358" //  &
           "347754564870738442303737360847085557292665631767832280403826508366" //  &
           "53961878379952572306276562137966777737866334027041960083257419418474932M-92"
      CALL FMST2M(ST,C(191),QX)
      ST = " 9.284263699802481030477799658347338855061343963325012856142524485" //  &
           "337551481107985173202144915554476793675287039218856327451603285101" //  &
           "60910890143062738353240079101453208140103839949856135593728282192403791M-93"
      CALL FMST2M(ST,C(192),QX)
      ST = " 1.469128321729119845643778628274835930841237239875100463308434786" //  &
           "723561392709397386626554407894406027910890887423959020221165249040" //  &
           "77624688503604251276023392875008399104638564047518405899300367036809361M-93"
      CALL FMST2M(ST,C(193),QX)
      ST = " 4.886379978539319342120516219783307378314461447995883185804991015" //  &
           "296960664895043875586362313203658735183472813064062209400386162722" //  &
           "42806131645480493919198786449897808824436924850601891974937230254873784M-94"
      CALL FMST2M(ST,C(194),QX)
      ST = " 7.046670647920504479063472745872909513874517692559573509267252909" //  &
           "755965774748698930668458487567120021155413053722800379339662049820" //  &
           "26470884186471084008635684699341681154401901074420825646205892400124466M-94"
      CALL FMST2M(ST,C(195),QX)
      ST = " 2.351541158501990523752731183260855698650611680331234753194545827" //  &
           "615066582884384059556932538832948082760844393963381962615300495238" //  &
           "72892129343291577201989578726783775602985638203462774865396580295272103M-94"
      CALL FMST2M(ST,C(196),QX)

      QX%NDIG = NDSAVE

      END SUBROUTINE FMGAM_C

      SUBROUTINE FMCANCEL(MA,MB,MC,NC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

!  Return NC as the number of bits of precision lost to cancellation after
!  MC = MA + MB or MC = MA - MB.

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: NC
      INTENT(IN) :: MA,MB,MC
      INTENT(INOUT) :: NC
      TYPE(MULTI) :: MXY(5)
      TYPE(FM_SETTINGS) :: QX

      IF (MA%MP(3) == 0 .OR. MA%MP(3) == 0) THEN
          NC = 0
          RETURN
      ENDIF
      IF (MC%MP(3) == 0) THEN
          NC = NINT(QX%NDIG*QX%ALOGM2)
          RETURN
      ENDIF
      IF (ABS(MA%MP(2)) >= QX%MEXPOV .OR. ABS(MB%MP(2)) >= QX%MEXPOV .OR.  &
          ABS(MC%MP(2)) >= QX%MEXPOV) THEN
          NC = 0
          RETURN
      ENDIF

      CALL FMABS(MA,MXY(1),QX)
      CALL FMABS(MB,MXY(2),QX)
      CALL FMABS(MC,MXY(3),QX)
      CALL FMMAX(MXY(1),MXY(2),MXY(4),QX)
      CALL FMDIV(MXY(4),MXY(3),MXY(5),QX)
      NC = ( MXY(5)%MP(2)*LOG(QX%MBASE) +  &
           LOG(MXY(5)%MP(3)/QX%MBASE + MXY(5)%MP(4)/QX%MBASE**2) ) / 0.69314718056D0

      END SUBROUTINE FMCANCEL

      SUBROUTINE FMIBTA(MX,MA,MB,MC,QX)

!  MC = Incomplete Beta(MX,MA,MB)

!  Integral from 0 to MX of  t**(MA-1) * (1-t)**(MB-1)  dt.

!  0 <= MX <= 1,    0 < MA,    0 <= MB.

!  Some comments below refer to this function and its arguments as B(x,a,b).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MX,MA,MB,MC
      REAL (KIND(1.0D0)) :: MLA,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,K,KASHIFT,KBIGAB,KBSHIFT,KICK,KL,KOVUN,KR_RETRY,KRESLT,KRS,  &
                 K_RETURN_CODE,N_ACC,NCSAVE,NDGOAL,NDOLD,NDS,NDSAVE,NGOAL,NMETHD,      &
                 NTERMS,NUMTRY,NWDS1
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      INTENT(IN) :: MX,MA,MB
      INTENT(INOUT) :: MC
      TYPE(MULTI) :: MXY(40),MRETRY

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      K_RETURN_CODE = 0

      CALL FMIBTA3(MX,MA,MB,MC,MXY,K_RETURN_CODE,QX)

      IF (K_RETURN_CODE == 1) THEN
          RETURN
      ENDIF

      NCSAVE = QX%NCALL
      CALL FMENT2('FMIBTA   ',MX,MA,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      QX%NCALL = NCSAVE + 1
      KRS = KRESLT
      IF (MB%MP(2) == QX%MEXPOV .OR. MB%MP(2) == QX%MEXPUN) KOVUN = 1
      IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
          NDS = QX%NDIG
          QX%NDIG = NDSAVE
          IF (QX%NTRACE < 0) THEN
              CALL FMNTRJ(MB,QX%NDIG,QX)
          ELSE
              CALL FMPRNT(MB,QX)
          ENDIF
          QX%NDIG = NDS
      ENDIF
      KRESLT = KRS
      IF (MB%MP(2) == QX%MUNKNO .OR. MX%MP(1) < 0 .OR. MA%MP(1) < 0 .OR.  &
          MB%MP(1) < 0) THEN
          KRESLT = 12
          QX%KFLAG = -4
      ENDIF
      IF (KRESLT /= 0) THEN
          QX%NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT,QX)
          IF (QX%KFLAG == -4) THEN
              IF (MX%MP(2) /= QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO .AND.  &
                  MB%MP(2) /= QX%MUNKNO) THEN
                  CALL FMWRN2(QX)
              ENDIF
          ENDIF
          IF (QX%NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1,QX)
          QX%MXEXP = MXSAVE
          QX%NCALL = QX%NCALL - 1
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MX,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB,MXY(3),NDSAVE,QX%NDIG,QX)

!             Handle cases where at least one of X, A, B is underflow or overflow.
!             Increasing any underflowed values to 1/HUGE makes the calculations more stable.
!             If A is underflow and the final result is overflow, it is safe to return overflow.
!             If X is underflow and the final result is underflow, it is safe to return underflow.
!             If B is underflow, it is replaced by zero.
!             Similarly, decreasing any overflowed A or B values to HUGE and then getting a final
!             result of underflow means it is safe to return underflow.
!             Any cases where the inequalities conflict, such as A = underflow, B = overflow,
!             will return unknown.

      KBIGAB = 0
      IF (MA%MP(2) == QX%MEXPOV) THEN
          CALL FMBIG(MXY(2),QX)
          MXY(2)%MP(2) = MXSAVE + 1
          KBIGAB = -1
      ENDIF
      IF (MB%MP(2) == QX%MEXPOV) THEN
          CALL FMBIG(MXY(3),QX)
          MXY(3)%MP(2) = MXSAVE + 1
          KBIGAB = -1
      ENDIF
      IF (MX%MP(2) == QX%MEXPUN) THEN
          CALL FMBIG(MXY(1),QX)
          MXY(1)%MP(2) = MXSAVE + 1
          CALL FMI2M(1,MXY(12),QX)
          CALL FMDIV_R2(MXY(12),MXY(1),QX)
          KBIGAB = -1
      ENDIF
      IF (MA%MP(2) == QX%MEXPUN) THEN
          CALL FMBIG(MXY(2),QX)
          MXY(2)%MP(2) = MXSAVE + 1
          CALL FMI2M(1,MXY(12),QX)
          CALL FMDIV_R2(MXY(12),MXY(2),QX)
          IF (KBIGAB < 0) THEN
              KBIGAB = -9
              CALL FMI2M(0,MXY(21),QX)
              GO TO 150
          ELSE
              KBIGAB = 1
          ENDIF
      ENDIF
      IF (MB%MP(2) == QX%MEXPUN) THEN
          CALL FMI2M(1,MXY(12),QX)
          IF (FMCOMP(MXY(1),'/=',MXY(12),QX)) THEN
              CALL FMI2M(0,MXY(3),QX)
          ENDIF
      ENDIF
      NUMTRY = 0
      NDGOAL = 0
      NWDS1 = 0
      KASHIFT = 0
      KBSHIFT = 0

  120 KICK = 0

!             Check for special cases.

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMIBTA2(K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD,QX)
      IF (K_RETURN_CODE == 1) GO TO 130
      IF (K_RETURN_CODE == 2) GO TO 150

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series for B(x,a,b),
!                    = 2 means use continued fraction expansion 1 for B(x,a,b),
!                    = 3 means use the convergent series for B(1-x,b,a).
!                    = 4 means use continued fraction expansion 1 for B(1-x,b,a).
!                    = 5 means use continued fraction expansion 2 for B(x,a,b).
!                    = 6 means use continued fraction expansion 2 for B(1-x,b,a).

      CALL FMSQR(MXY(2),MXY(12),QX)
      CALL FMDPM(DBLE(0.00173),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(12),MXY(6),QX)
      CALL FMSQR(MXY(3),MXY(12),QX)
      CALL FMDPM(DBLE(0.01253),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(12),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(0.21583),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(0.03891),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(9.14350),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)

      CALL FMDPM(DBLE(0.11709),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(5),QX)
      CALL FMDPM(DBLE(0.62633),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(4),QX)
      CALL FMADD_R1(MXY(5),MXY(4),QX)
      CALL FMADDI(MXY(5),1,QX)

      CALL FMDIV(MXY(5),MXY(6),MXY(33),QX)

      CALL FMDPM(DBLE(0.29217),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(6),QX)
      CALL FMDPM(DBLE(2.09304),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(1.53724),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)

      CALL FMDPM(DBLE(0.29217),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(5),QX)
      CALL FMDPM(DBLE(2.09304),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(4),QX)
      CALL FMADD_R1(MXY(5),MXY(4),QX)
      CALL FMADDI(MXY(5),1,QX)

      CALL FMDIV(MXY(5),MXY(6),MXY(34),QX)

      CALL FMSQR(MXY(2),MXY(12),QX)
      CALL FMDPM(DBLE(0.04038),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(12),MXY(6),QX)
      CALL FMSQR(MXY(3),MXY(12),QX)
      CALL FMDPM(DBLE(0.05754),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(12),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(0.02670),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(0.56206),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(0.13746),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)

      CALL FMDPM(DBLE(0.87312),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(5),QX)
      CALL FMDPM(DBLE(0.20334),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(4),QX)
      CALL FMADD_R1(MXY(5),MXY(4),QX)
      CALL FMADDI(MXY(5),1,QX)

      CALL FMDIV(MXY(5),MXY(6),MXY(35),QX)

      CALL FMDPM(DBLE(0.64584),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(6),QX)
      CALL FMDPM(DBLE(0.64584),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(6.31958),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)

      CALL FMDPM(DBLE(0.64584),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(5),QX)
      CALL FMADDI(MXY(5),1,QX)

      CALL FMDIV(MXY(5),MXY(6),MXY(36),QX)

      CALL FMSQR(MXY(2),MXY(12),QX)
      CALL FMDPM(DBLE(0.11637),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(12),MXY(6),QX)
      CALL FMSQR(MXY(3),MXY(12),QX)
      CALL FMDPM(DBLE(0.10718),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(12),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(0.92626),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(0.05518),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)
      CALL FMDPM(DBLE(0.28962),MXY(5),QX)
      CALL FMADD_R1(MXY(6),MXY(5),QX)

      CALL FMDPM(DBLE(0.99773),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(2),MXY(5),QX)
      CALL FMDPM(DBLE(0.56855),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(3),MXY(4),QX)
      CALL FMADD_R1(MXY(5),MXY(4),QX)
      CALL FMADDI(MXY(5),1,QX)

      CALL FMDIV(MXY(5),MXY(6),MXY(37),QX)
      IF (FMCOMP(MXY(1),'<=',MXY(33),QX)) THEN
          NMETHD = 1
      ELSE IF (FMCOMP(MXY(1),'>=',MXY(34),QX)) THEN
          NMETHD = 3
      ELSE IF (FMCOMP(MXY(1),'<',MXY(37),QX)) THEN
          IF (FMCOMP(MXY(1),'<',MXY(35),QX)) THEN
              NMETHD = 2
          ELSE
              NMETHD = 4
          ENDIF
      ELSE
          IF (FMCOMP(MXY(1),'<',MXY(36),QX)) THEN
              NMETHD = 5
          ELSE
              NMETHD = 6
          ENDIF
      ENDIF
      IF (MXY(3)%MP(2) <= 0 .AND. MXY(2)%MP(2)+QX%NDIG < 0) THEN
          NMETHD = 1
      ENDIF

      IF (NMETHD == 1) CALL FMIBTA_M1(MXY,N_ACC,QX)
      IF (NMETHD == 2) CALL FMIBTA_M2(MXY,N_ACC,QX)
      IF (NMETHD == 5) CALL FMIBTA_M5(MXY,MX,NMETHD,NDSAVE,N_ACC,QX)

!             Method 3, 4, or 6.  B(X,A,B) = B(A,B) - B(1-X,B,A).

      IF (NMETHD == 3 .OR. NMETHD == 4 .OR. NMETHD == 6) THEN
          CALL FMI2M(1,MXY(12),QX)
          CALL FMSUB_R2(MXY(12),MXY(1),QX)
          DO J = 1, QX%NDIG+2
             MLA = MXY(2)%MP(J)
             MXY(2)%MP(J) = MXY(3)%MP(J)
             MXY(3)%MP(J) = MLA
          ENDDO
          IF (NMETHD == 3) THEN
              CALL FMIBTA_M1(MXY,N_ACC,QX)
          ELSE IF (NMETHD == 4) THEN
              CALL FMIBTA_M2(MXY,N_ACC,QX)
          ELSE
              CALL FMIBTA_M5(MXY,MX,NMETHD,NDSAVE,N_ACC,QX)
          ENDIF

          K = NWDS1
          CALL FMEQ(MXY(21),MXY(30),QX)
          CALL FMBETA(MXY(2),MXY(3),MXY(32),QX)
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          IF (MXY(32)%MP(1) > 0) THEN
              CALL FMSUB(MXY(32),MXY(39),MXY(37),QX)
              CALL FMMPYI(MXY(38),-1,MXY(39),QX)
              CALL FMEQ(MXY(37),MXY(38),QX)
          ELSE
              CALL FMSUB(MXY(32),MXY(38),MXY(37),QX)
              CALL FMMPYI(MXY(39),-1,MXY(38),QX)
              CALL FMEQ(MXY(37),MXY(39),QX)
          ENDIF
          CALL FMADD(MXY(38),MXY(39),MXY(21),QX)
          NWDS1 = INT(MAX(MXY(32)%MP(2),MXY(30)%MP(2)))
          CALL FMCANCEL(MXY(38),MXY(39),MXY(21),J,QX)
          N_ACC = N_ACC - J
          NWDS1 = MAX(0,NWDS1-INT(MXY(21)%MP(2)))
          IF (K /= NWDS1 .AND. NUMTRY >= 1) THEN
              IF (KASHIFT == 0 .AND. KBSHIFT == 0) N_ACC = -1
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(21)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      K = QX%KFLAG
      IF (KICK < 0) N_ACC = KICK

!             Reverse the translation if KASHIFT is positive.
!             This is used when a is small and a retry was required because of cancellation.

      IF (KASHIFT > 0 .AND. N_ACC > 0) THEN
          CALL FMEQU(MX,MXY(22),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MA,MXY(23),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(24),NDSAVE,QX%NDIG,QX)
          IF (KBSHIFT > 0) CALL FMADDI(MXY(24),KBSHIFT,QX)
          CALL FMI2M(1,MXY(19),QX)
          CALL FMADD(MXY(23),MXY(24),MXY(16),QX)
          CALL FMI2M(1,MXY(12),QX)
          CALL FMADD(MXY(23),MXY(12),MXY(7),QX)
          CALL FMDIV(MXY(16),MXY(7),MXY(20),QX)
          CALL FMI2M(1,MXY(12),QX)
          CALL FMSUB(MXY(12),MXY(22),MXY(17),QX)
          CALL FMEQ(MXY(22),MXY(18),QX)
          CALL FMMPY(MXY(20),MXY(22),MXY(12),QX)
          CALL FMADD_R1(MXY(19),MXY(12),QX)
          CALL FMEQ(MXY(16),MXY(14),QX)
          CALL FMEQ(MXY(23),MXY(15),QX)
          CALL FMADDI(MXY(15),1,QX)
          DO J = 2, KASHIFT-1
             CALL FMADDI(MXY(14),1,QX)
             CALL FMADDI(MXY(15),1,QX)
             CALL FMMPY_R1(MXY(20),MXY(14),QX)
             CALL FMDIV_R1(MXY(20),MXY(15),QX)
             CALL FMMPY_R1(MXY(18),MXY(22),QX)
             CALL FMMPY(MXY(20),MXY(18),MXY(13),QX)
             CALL FMADD_R1(MXY(19),MXY(13),QX)
          ENDDO
          IF (MXY(22)%MP(2)*(-10) >= QX%NDIG) THEN
              CALL FMEQ(MXY(22),MXY(15),QX)
              CALL FMEQ(MXY(22),MXY(17),QX)
              DO K = 2, NTERMS
                 CALL FMMPY_R1(MXY(15),MXY(22),QX)
                 CALL FMDIVI(MXY(15),K,MXY(12),QX)
                 CALL FMADD_R1(MXY(17),MXY(12),QX)
                 IF (QX%KFLAG /= 0) EXIT
              ENDDO
              CALL FMMPY(MXY(17),MXY(24),MXY(12),QX)
              IF (MXY(12)%MP(2) /= QX%MUNKNO .AND. MXY(12)%MP(3) /= 0)  &
                  MXY(12)%MP(1) = -MXY(12)%MP(1)
              CALL FMEXP(MXY(12),MXY(18),QX)
              CALL FMEQ(MXY(19),MXY(15),QX)
              CALL FMPWR(MXY(22),MXY(23),MXY(12),QX)
              CALL FMMPY(MXY(19),MXY(12),MXY(7),QX)
              CALL FMMPY(MXY(7),MXY(18),MXY(12),QX)
              CALL FMDIV(MXY(12),MXY(23),MXY(19),QX)
              IF (MXY(19)%MP(2) == QX%MUNKNO) THEN
                  CALL FMLN(MXY(22),MXY(12),QX)
                  CALL FMMPY(MXY(23),MXY(12),MXY(19),QX)
                  CALL FMLN(MXY(15),MXY(12),QX)
                  CALL FMADD_R2(MXY(12),MXY(19),QX)
                  CALL FMMPY(MXY(17),MXY(24),MXY(12),QX)
                  CALL FMSUB_R1(MXY(19),MXY(12),QX)
                  CALL FMLN(MXY(23),MXY(12),QX)
                  CALL FMSUB_R2(MXY(19),MXY(12),QX)
                  CALL FMEXP(MXY(12),MXY(19),QX)
              ENDIF
          ELSE
              CALL FMPWR(MXY(22),MXY(23),MXY(12),QX)
              CALL FMMPY_R1(MXY(19),MXY(12),QX)
              CALL FMPWR(MXY(17),MXY(24),MXY(12),QX)
              CALL FMMPY_R1(MXY(19),MXY(12),QX)
              CALL FMDIV_R1(MXY(19),MXY(23),QX)
          ENDIF
          CALL FMMPY(MXY(21),MXY(20),MXY(12),QX)
          CALL FMI2M(KASHIFT-1,MXY(7),QX)
          CALL FMADD_R2(MXY(16),MXY(7),QX)
          CALL FMMPY_R1(MXY(12),MXY(7),QX)
          CALL FMDIV(MXY(12),MXY(23),MXY(20),QX)
          CALL FMADD(MXY(20),MXY(19),MXY(21),QX)
          CALL FMCANCEL(MXY(20),MXY(19),MXY(21),J,QX)
          N_ACC = N_ACC - J
      ENDIF

!             Reverse the translation if KBSHIFT is positive.
!             This is used when x is close to 1, b is small, and a retry was required because
!             of cancellation.

      IF (KBSHIFT > 0 .AND. N_ACC > 0) THEN
          CALL FMEQU(MX,MXY(22),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MA,MXY(23),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(24),NDSAVE,QX%NDIG,QX)
          CALL FMI2M(1,MXY(19),QX)
          CALL FMI2M(1,MXY(12),QX)
          CALL FMADD(MXY(24),MXY(12),MXY(7),QX)
          CALL FMADD(MXY(23),MXY(24),MXY(12),QX)
          CALL FMDIV(MXY(12),MXY(7),MXY(20),QX)
          CALL FMADD(MXY(23),MXY(24),MXY(16),QX)
          CALL FMI2M(1,MXY(12),QX)
          CALL FMSUB(MXY(12),MXY(22),MXY(17),QX)
          CALL FMEQ(MXY(17),MXY(18),QX)
          CALL FMMPY(MXY(20),MXY(18),MXY(12),QX)
          CALL FMADD_R1(MXY(19),MXY(12),QX)
          CALL FMEQ(MXY(16),MXY(14),QX)
          CALL FMEQ(MXY(24),MXY(15),QX)
          CALL FMADDI(MXY(15),1,QX)
          DO J = 2, KBSHIFT-1
             CALL FMADDI(MXY(14),1,QX)
             CALL FMADDI(MXY(15),1,QX)
             CALL FMMPY_R1(MXY(20),MXY(14),QX)
             CALL FMDIV_R1(MXY(20),MXY(15),QX)
             CALL FMMPY_R1(MXY(18),MXY(17),QX)
             CALL FMMPY(MXY(20),MXY(18),MXY(13),QX)
             CALL FMADD_R1(MXY(19),MXY(13),QX)
          ENDDO
          IF (MXY(22)%MP(2)*(-10) >= QX%NDIG) THEN
              CALL FMEQ(MXY(22),MXY(15),QX)
              CALL FMEQ(MXY(22),MXY(17),QX)
              DO K = 2, NTERMS
                 CALL FMMPY_R1(MXY(15),MXY(22),QX)
                 CALL FMDIVI(MXY(15),K,MXY(12),QX)
                 CALL FMADD_R1(MXY(17),MXY(12),QX)
                 IF (QX%KFLAG /= 0) EXIT
              ENDDO
              CALL FMMPY(MXY(17),MXY(24),MXY(12),QX)
              IF (MXY(12)%MP(2) /= QX%MUNKNO .AND. MXY(12)%MP(3) /= 0)  &
                  MXY(12)%MP(1) = -MXY(12)%MP(1)
              CALL FMEXP(MXY(12),MXY(17),QX)
              CALL FMPWR(MXY(22),MXY(23),MXY(12),QX)
              CALL FMMPY(MXY(19),MXY(12),MXY(7),QX)
              CALL FMMPY(MXY(7),MXY(17),MXY(12),QX)
              CALL FMDIV(MXY(12),MXY(24),MXY(19),QX)
          ELSE
              CALL FMPWR(MXY(22),MXY(23),MXY(12),QX)
              CALL FMMPY_R1(MXY(19),MXY(12),QX)
              CALL FMPWR(MXY(17),MXY(24),MXY(12),QX)
              CALL FMMPY_R1(MXY(19),MXY(12),QX)
              CALL FMDIV_R1(MXY(19),MXY(24),QX)
          ENDIF
          CALL FMMPY(MXY(21),MXY(20),MXY(12),QX)
          CALL FMI2M(KBSHIFT-1,MXY(7),QX)
          CALL FMADD_R2(MXY(16),MXY(7),QX)
          CALL FMMPY_R1(MXY(12),MXY(7),QX)
          CALL FMDIV(MXY(12),MXY(24),MXY(20),QX)
          CALL FMSUB(MXY(20),MXY(19),MXY(21),QX)
          CALL FMCANCEL(MXY(20),MXY(19),MXY(21),J,QX)
          N_ACC = N_ACC - J
      ENDIF
      IF (QX%NCALL >= 1) THEN
          NGOAL = 1.06*(INT(DBLE(NDSAVE)*QX%ALOGM2) + 29)
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      NDGOAL = INT(DBLE(NGOAL)/QX%ALOGM2 + 1.0)
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              IF (MXY(21)%MP(3) == 0 .OR. K < 0) GO TO 140
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(21)%MP(J+1)) GO TO 140
              ENDDO
              CALL FMI2M(1,MXY(15),QX)
              N_ACC = NINT(QX%NDIG*QX%ALOGM2)
              GO TO 150
          ENDIF
  140     IEXTRA = INT(DBLE(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = QX%NDIG + IEXTRA
          IF (N_ACC < 0) QX%NDIG = NDOLD + 10*2**NUMTRY
          IF (ABS(MX%MP(2)) >= QX%MEXPOV .OR. ABS(MA%MP(2)) >= QX%MEXPOV .OR.  &
              ABS(MB%MP(2)) >= QX%MEXPOV) THEN
              CALL FMST2M('UNKNOWN',MXY(21),QX)
              QX%KFLAG = -4
              GO TO 150
          ENDIF
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQU_R1(MXY(2),NDSAVE,QX%NDIG,QX)
          CALL FMEQU_R1(MXY(3),NDSAVE,QX%NDIG,QX)
          IF (NMETHD == 3 .OR. NMETHD == 4 .OR. NMETHD == 6) THEN
              CALL FMEQU(MX,MXY(1),NDSAVE,QX%NDIG,QX)
              DO J = 1, QX%NDIG+2
                 MLA = MXY(2)%MP(J)
                 MXY(2)%MP(J) = MXY(3)%MP(J)
                 MXY(3)%MP(J) = MLA
              ENDDO
          ENDIF

          IF (KASHIFT > 0) THEN
              CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
              IF (KASHIFT <= 2000) THEN
                  KASHIFT = 9*KASHIFT
              ELSE
                  KASHIFT = QX%NDIG
              ENDIF
              CALL FMADDI(MXY(2),KASHIFT,QX)
          ENDIF
          IF (KBSHIFT > 0) THEN
              CALL FMEQU(MB,MXY(3),NDSAVE,QX%NDIG,QX)
              IF (KBSHIFT <= 2000) THEN
                  KBSHIFT = 9*KBSHIFT
              ELSE
                  KBSHIFT = QX%NDIG
              ENDIF
              CALL FMADDI(MXY(3),KBSHIFT,QX)
          ENDIF

!             Check to see if a retry is about to be done for small a and large b.
!             If so, raise a by 2*NDIG to reduce the potential cancellation error.

          CALL FMI2M(200,MXY(12),QX)
          IF (NUMTRY == 0 .AND.                     &
              FMCOMP(MXY(2),'<=',MXY(12),QX) .AND.  &
              FMCOMP(MXY(3),'>=',MXY(2),QX)) THEN
              KASHIFT = 2*QX%NDIG
              CALL FMADDI(MXY(2),2*QX%NDIG,QX)
          ENDIF

!             Check to see if a retry is about to be done for a > 100 and b < 2.
!             If so, raise b by 2*NDIG to reduce the potential cancellation error.

          CALL FMI2M(100,MXY(12),QX)
          CALL FMI2M(2,MXY(7),QX)
          IF (NUMTRY == 0 .AND.                     &
              FMCOMP(MXY(2),'>=',MXY(12),QX) .AND.  &
              FMCOMP(MXY(3),'<=',MXY(7),QX)) THEN
              KBSHIFT = 2*QX%NDIG
              CALL FMADDI(MXY(3),2*QX%NDIG,QX)
          ENDIF

          CALL FMI2M(40*NUMTRY,MXY(12),QX)
          CALL FMI2M(100,MXY(7),QX)
          IF (NUMTRY > 0 .AND. KASHIFT == 0 .AND.   &
              FMCOMP(MXY(2),'<=',MXY(12),QX) .AND.  &
              FMCOMP(MXY(3),'>=',MXY(7),QX)) THEN
              KASHIFT = 2*QX%NDIG
              CALL FMADDI(MXY(2),2*QX%NDIG,QX)
          ENDIF

          CALL FMI2M(40*NUMTRY,MXY(12),QX)
          CALL FMI2M(100,MXY(7),QX)
          IF (NUMTRY > 0 .AND. KBSHIFT == 0 .AND.   &
              FMCOMP(MXY(2),'>=',MXY(12),QX) .AND.  &
              FMCOMP(MXY(3),'<=',MXY(7),QX)) THEN
              KBSHIFT = 2*QX%NDIG
              CALL FMADDI(MXY(3),2*QX%NDIG,QX)
          ENDIF

          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(21),MRETRY,NDOLD,QX%NDIG,QX)
          IF (KASHIFT == 2*QX%NDIG .OR. KBSHIFT == 2*QX%NDIG) THEN
              QX%NDIG = MAX(QX%NDIG,NDOLD+2)
          ENDIF
          GO TO 120
      ENDIF

  150 QX%MXEXP = MXSAVE
      CALL FMEQU(MXY(21),MXY(20),QX%NDIG,NDSAVE,QX)
      IF (KBIGAB /= 0) THEN
          IF ((MXY(20)%MP(2) >= -MXSAVE  .AND. KBIGAB == -1) .OR.  &
              (MXY(20)%MP(2) <= MXSAVE+1 .AND. KBIGAB ==  1) .OR. (KBIGAB == -9)) THEN
              CALL FMST2M('UNKNOWN',MXY(21),QX)
              QX%KFLAG = -4
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(21),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMIBTA

      SUBROUTINE FMIBTA_M1(MXY,N_ACC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MXY(40)
      INTEGER :: N_ACC
      INTENT(INOUT) :: MXY,N_ACC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: INT_TEMP1,INT_TEMP2,INT_TEMP3,INT_TEMP4,J,JCHECK,JEXTRA,K,KRSAVE,NDIG2,  &
                 NDSAV1,NTERMS

!             Method 1.  Use the Pochhammer(1-B,N)*X**N/((A+N)*N!) series.

!             MXY(21) is the sum.
!             MXY(17) is the current term.
!             MXY(18) is J-B.
!             MXY(19) is 1.
!             MXY(20) is A+J.

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      NTERMS = INT(INTMAX/10)
      JEXTRA = INT(0.06*QX%NDIG)
      IF (QX%NDIG+JEXTRA > QX%NDIG) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+JEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+JEXTRA,QX)
          CALL FMEQU_R1(MXY(3),QX%NDIG,QX%NDIG+JEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + JEXTRA
      CALL FMI2M(1,MXY(17),QX)
      CALL FMDIV(MXY(17),MXY(2),MXY(38),QX)
      CALL FMI2M(0,MXY(39),QX)
      CALL FMEQ(MXY(3),MXY(18),QX)
      IF (MXY(18)%MP(2) /= QX%MUNKNO .AND. MXY(18)%MP(3) /= 0)  &
          MXY(18)%MP(1) = -MXY(18)%MP(1)
      CALL FMEQ(MXY(2),MXY(20),QX)
      CALL FMI2M(1,MXY(19),QX)
      CALL FMI2M(0,MXY(16),QX)
      CALL FMI2M(0,MXY(22),QX)
      JCHECK = 5
      NDSAV1 = QX%NDIG

!             Method 1 summation loop.

      KRSAVE = QX%KROUND
      QX%KROUND = 1
      DO J = 1, NTERMS
         QX%NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(18),MXY(19),QX)
         INT_TEMP3 = NDSAV1 - INT(MXY(38)%MP(2) - MXY(17)%MP(2))
         INT_TEMP4 = NDSAV1 - INT(MXY(39)%MP(2) - MXY(17)%MP(2))
         INT_TEMP1 = MAX(INT_TEMP3,INT_TEMP4)
         INT_TEMP2 = MAX(QX%NGRD22,INT_TEMP1)
         NDIG2 = MIN(NDSAV1,INT_TEMP2)
         QX%NDIG = NDIG2
         CALL FMCSMPY_R1(MXY(17),MXY(18),QX)
         CALL FMCSMPY_R1(MXY(17),MXY(1),QX)
         IF (J > 1) CALL FMDIVI_R1(MXY(17),J,QX)
         QX%NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(20),MXY(19),QX)
         QX%NDIG = NDIG2
         CALL FMCSDIV(MXY(17),MXY(20),MXY(16),QX)

         QX%NDIG = NDSAV1
         IF (INT(MXY(16)%MP(1)) < 0) THEN
             CALL FMADD_R2(MXY(16),MXY(39),QX)
         ELSE
             CALL FMADD_R2(MXY(16),MXY(38),QX)
         ENDIF

         IF (QX%KFLAG < 0) EXIT
         IF (MOD(J,JCHECK) == 0) THEN
             CALL FMADD(MXY(38),MXY(39),MXY(16),QX)
             DO K = QX%NDIG+1, 1, -1
                IF (MXY(16)%MP(K+1) /= MXY(22)%MP(K+1)) THEN
                    CALL FMEQ(MXY(16),MXY(22),QX)
!                    CYCLE SUM_M1
                    GO TO 110
                ENDIF
             ENDDO
             EXIT
         ENDIF
  110    K = -31
      ENDDO
      QX%KROUND = KRSAVE

      CALL FMPWR(MXY(1),MXY(2),MXY(12),QX)
      CALL FMADD(MXY(38),MXY(39),MXY(7),QX)
      CALL FMCANCEL(MXY(38),MXY(39),MXY(7),J,QX)
      N_ACC = N_ACC - J
      CALL FMMPY(MXY(7),MXY(12),MXY(21),QX)
      CALL FMMPY_R1(MXY(38),MXY(12),QX)
      CALL FMMPY_R1(MXY(39),MXY(12),QX)

      END SUBROUTINE FMIBTA_M1


      SUBROUTINE FMIBTA_M2(MXY,N_ACC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MXY(40)
      INTEGER :: N_ACC
      INTENT(INOUT) :: MXY,N_ACC
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: INT_TEMP1,INT_TEMP2,J,JEXTRA,K,KFLAG1,KRSAVE,NDSAV1,NTERMS

!             Method 2.  Continued fraction expansion for B(x,a,b).

!             MXY(22) is the current approximation.
!             MXY(21) is the term in the sum, S(k).
!             MXY(19), MXY(20) are the latest denominators, Q(k-1) and Q(k).

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      NTERMS = INT(INTMAX/10)
      JEXTRA = INT(MAX(1.0,5.76/QX%ALOGMB + 1.0)) + QX%NGRD52 + INT(0.152*QX%NDIG)
      IF (QX%NDIG+JEXTRA > QX%NDIG) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+JEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+JEXTRA,QX)
          CALL FMEQU_R1(MXY(3),QX%NDIG,QX%NDIG+JEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + JEXTRA
      NDSAV1 = QX%NDIG
      CALL FMI2M(1,MXY(19),QX)
      CALL FMI2M(1,MXY(20),QX)
      CALL FMI2M(1,MXY(21),QX)
      CALL FMEQ(MXY(21),MXY(38),QX)
      CALL FMI2M(0,MXY(39),QX)
      CALL FMEQ(MXY(2),MXY(24),QX)
      CALL FMADD(MXY(2),MXY(3),MXY(25),QX)
      CALL FMEQ(MXY(2),MXY(26),QX)
      CALL FMI2M(1,MXY(12),QX)
      CALL FMADD(MXY(2),MXY(12),MXY(27),QX)
      CALL FMEQ(MXY(3),MXY(28),QX)
      CALL FMSQR(MXY(2),MXY(29),QX)
      CALL FMADD(MXY(29),MXY(26),MXY(30),QX)
      CALL FMSUB(MXY(29),MXY(26),MXY(31),QX)
      CALL FMMPY(MXY(24),MXY(25),MXY(12),QX)
      CALL FMMPY(MXY(12),MXY(1),MXY(7),QX)
      CALL FMDIV(MXY(7),MXY(30),MXY(33),QX)
      IF (MXY(33)%MP(2) /= QX%MUNKNO .AND. MXY(33)%MP(3) /= 0)  &
          MXY(33)%MP(1) = -MXY(33)%MP(1)
      CALL FMMPY(MXY(33),MXY(19),MXY(18),QX)
      CALL FMADD(MXY(20),MXY(18),MXY(17),QX)
      CALL FMMPY(MXY(18),MXY(21),MXY(12),QX)
      CALL FMDIV(MXY(12),MXY(17),MXY(21),QX)
      IF (MXY(21)%MP(2) /= QX%MUNKNO .AND. MXY(21)%MP(3) /= 0)  &
          MXY(21)%MP(1) = -MXY(21)%MP(1)
      IF (MXY(21)%MP(1) > 0) THEN
          CALL FMADD(MXY(38),MXY(21),MXY(19),QX)
          CALL FMEQ(MXY(19),MXY(38),QX)
      ELSE
          CALL FMADD(MXY(39),MXY(21),MXY(19),QX)
          CALL FMEQ(MXY(19),MXY(39),QX)
      ENDIF
      CALL FMEQ(MXY(20),MXY(19),QX)
      CALL FMEQ(MXY(17),MXY(20),QX)

!             Method 2 continued fraction loop.

      KRSAVE = QX%KROUND
      QX%KROUND = 1
      DO J = 1, NTERMS
         CALL FMADDI(MXY(24),1,QX)
         CALL FMADDI(MXY(25),1,QX)
         CALL FMADDI(MXY(26),2,QX)
         CALL FMADDI(MXY(27),2,QX)
         CALL FMADDI(MXY(28),-1,QX)
         CALL FMMPYI(MXY(26),4,MXY(15),QX)
         CALL FMADDI(MXY(15),-4,QX)
         CALL FMCSADD_R1(MXY(29),MXY(15),QX)
         CALL FMADD(MXY(29),MXY(26),MXY(30),QX)
         CALL FMSUB(MXY(29),MXY(26),MXY(31),QX)

         CALL FMEQ(MXY(28),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(1),QX)
         CALL FMMPYI_R1(MXY(15),J,QX)
         CALL FMCSDIV(MXY(15),MXY(31),MXY(33),QX)

         CALL FMEQ(MXY(33),MXY(18),QX)
         CALL FMCSMPY_R1(MXY(18),MXY(19),QX)
         CALL FMADD(MXY(20),MXY(18),MXY(17),QX)
         CALL FMEQ(MXY(18),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(21),QX)
         CALL FMCSDIV(MXY(15),MXY(17),MXY(21),QX)
         IF (MXY(21)%MP(2) /= QX%MUNKNO .AND. MXY(21)%MP(3) /= 0)  &
             MXY(21)%MP(1) = -MXY(21)%MP(1)

         QX%NDIG = NDSAV1
         IF (MXY(21)%MP(1) > 0) THEN
             CALL FMADD(MXY(38),MXY(21),MXY(19),QX)
             INT_TEMP1 = QX%KFLAG
             CALL FMEQ(MXY(19),MXY(38),QX)
         ELSE
             CALL FMADD(MXY(39),MXY(21),MXY(19),QX)
             INT_TEMP1 = QX%KFLAG
             CALL FMEQ(MXY(19),MXY(39),QX)
         ENDIF
         KFLAG1 = INT_TEMP1

         CALL FMEQ(MXY(20),MXY(19),QX)
         CALL FMEQ(MXY(17),MXY(20),QX)
         CALL FMADD(MXY(38),MXY(39),MXY(15),QX)
         INT_TEMP1 = NDSAV1 - INT(MXY(15)%MP(2) - MXY(21)%MP(2))
         INT_TEMP2 = MAX(QX%NGRD22,INT_TEMP1)
         QX%NDIG = MIN(NDSAV1,INT_TEMP2)
         CALL FMEQ(MXY(24),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(25),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(1),QX)
         CALL FMCSDIV(MXY(15),MXY(30),MXY(33),QX)
         IF (MXY(33)%MP(2) /= QX%MUNKNO .AND. MXY(33)%MP(3) /= 0)  &
             MXY(33)%MP(1) = -MXY(33)%MP(1)

         CALL FMEQ(MXY(33),MXY(18),QX)
         CALL FMCSMPY_R1(MXY(18),MXY(19),QX)
         CALL FMADD(MXY(20),MXY(18),MXY(17),QX)
         CALL FMEQ(MXY(18),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(21),QX)
         CALL FMCSDIV(MXY(15),MXY(17),MXY(21),QX)
         IF (MXY(21)%MP(2) /= QX%MUNKNO .AND. MXY(21)%MP(3) /= 0)  &
             MXY(21)%MP(1) = -MXY(21)%MP(1)

         QX%NDIG = NDSAV1
         IF (MXY(21)%MP(1) > 0) THEN
             CALL FMADD(MXY(38),MXY(21),MXY(19),QX)
             INT_TEMP1 = QX%KFLAG
             CALL FMEQ(MXY(19),MXY(38),QX)
         ELSE
             CALL FMADD(MXY(39),MXY(21),MXY(19),QX)
             INT_TEMP1 = QX%KFLAG
             CALL FMEQ(MXY(19),MXY(39),QX)
         ENDIF
         QX%KFLAG = INT_TEMP1

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. QX%KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(20),MXY(19),QX)
         CALL FMEQ(MXY(17),MXY(20),QX)
         CALL FMADD(MXY(38),MXY(39),MXY(15),QX)
         INT_TEMP1 = NDSAV1 - INT(MXY(15)%MP(2) - MXY(21)%MP(2))
         INT_TEMP2 = MAX(QX%NGRD22,INT_TEMP1)
         QX%NDIG = MIN(NDSAV1,INT_TEMP2)
      ENDDO
      CALL FMADD(MXY(38),MXY(39),MXY(15),QX)
      CALL FMCANCEL(MXY(38),MXY(39),MXY(15),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(15),MXY(22),QX)
      QX%KROUND = KRSAVE

!             Multiply the sums by x^a * (1-x)^b / a

      CALL FMEQ(MXY(38),MXY(40),QX)
      CALL FMIBTA_M2B(MXY,QX)
      CALL FMEQ(MXY(40),MXY(38),QX)
      CALL FMEQ(MXY(39),MXY(40),QX)
      CALL FMIBTA_M2B(MXY,QX)
      CALL FMEQ(MXY(40),MXY(39),QX)
      CALL FMEQ(MXY(22),MXY(40),QX)
      CALL FMIBTA_M2B(MXY,QX)
      CALL FMEQ(MXY(40),MXY(21),QX)

      END SUBROUTINE FMIBTA_M2

      SUBROUTINE FMIBTA_M2B(MXY,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MXY(40)
      INTENT(INOUT) :: MXY
      INTEGER :: K,NTERMS
      TYPE(FM_SETTINGS) :: QX

      NTERMS = INT(INTMAX/10)

      CALL FMLN(MXY(1),MXY(19),QX)
      CALL FMMPY_R1(MXY(19),MXY(2),QX)
      IF (MXY(1)%MP(2)*(-10) >= QX%NDIG) THEN
          CALL FMEQ(MXY(1),MXY(15),QX)
          CALL FMEQ(MXY(1),MXY(20),QX)
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(1),QX)
             CALL FMDIVI(MXY(15),K,MXY(12),QX)
             CALL FMADD_R1(MXY(20),MXY(12),QX)
             IF (QX%KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY_R1(MXY(20),MXY(3),QX)
          IF (MXY(20)%MP(2) /= QX%MUNKNO .AND. MXY(20)%MP(3) /= 0)  &
              MXY(20)%MP(1) = -MXY(20)%MP(1)
      ELSE
          CALL FMI2M(1,MXY(12),QX)
          CALL FMSUB_R1(MXY(12),MXY(1),QX)
          CALL FMLN(MXY(12),MXY(20),QX)
          CALL FMMPY_R1(MXY(20),MXY(3),QX)
      ENDIF
      CALL FMADD(MXY(19),MXY(20),MXY(12),QX)
      CALL FMEXP(MXY(12),MXY(21),QX)
      CALL FMMPY_R1(MXY(40),MXY(21),QX)
      IF (MXY(21)%MP(2) == QX%MUNKNO) THEN
          IF (MXY(40)%MP(1)*MXY(40)%MP(3) > 0) THEN
              CALL FMLN(MXY(40),MXY(12),QX)
              CALL FMADD(MXY(12),MXY(19),MXY(7),QX)
              CALL FMADD(MXY(7),MXY(20),MXY(12),QX)
              CALL FMEXP(MXY(12),MXY(21),QX)
          ELSE
              CALL FMEQ(MXY(40),MXY(13),QX)
              IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
                  MXY(13)%MP(1) = -MXY(13)%MP(1)
              CALL FMLN(MXY(13),MXY(12),QX)
              CALL FMADD(MXY(12),MXY(19),MXY(7),QX)
              CALL FMADD(MXY(7),MXY(20),MXY(12),QX)
              CALL FMEXP(MXY(12),MXY(21),QX)
              IF (MXY(21)%MP(2) /= QX%MUNKNO .AND. MXY(21)%MP(3) /= 0)  &
                  MXY(21)%MP(1) = -MXY(21)%MP(1)
          ENDIF
      ENDIF
      IF (ABS(MXY(40)%MP(2)) < QX%MEXPOV) CALL FMDIV_R1(MXY(40),MXY(2),QX)

      END SUBROUTINE FMIBTA_M2B

      SUBROUTINE FMIBTA_M5(MXY,MX,NMETHD,NDSAVE,N_ACC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MXY(40), MX
      INTEGER :: NMETHD, NDSAVE, N_ACC
      TYPE(FM_SETTINGS) :: QX

      INTENT(IN) :: MX, NMETHD, NDSAVE
      INTENT(INOUT) :: MXY

      INTEGER :: INT_TEMP1,INT_TEMP2,J,JEXTRA,K,KRSAVE,NDSAV1,NTERMS

!             Method 5.  Continued fraction expansion 2 for B(x,a,b).

!             MXY(22) is the current sum.
!             MXY(21) is the term in the sum, S(k).
!             MXY(19), MXY(20) are the latest denominators, Q(k-1) and Q(k).

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      NTERMS = INT(INTMAX/10)
      JEXTRA = INT(MAX(1.0,5.76/QX%ALOGMB + 1.0)) + INT(0.07*QX%NDIG)
      IF (QX%NDIG+JEXTRA > QX%NDIG) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+JEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+JEXTRA,QX)
          CALL FMEQU_R1(MXY(3),QX%NDIG,QX%NDIG+JEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + JEXTRA
      NDSAV1 = QX%NDIG
      CALL FMSQR(MXY(1),MXY(23),QX)
      CALL FMI2M(1,MXY(12),QX)
      CALL FMSUB(MXY(2),MXY(12),MXY(24),QX)
      CALL FMADD(MXY(2),MXY(3),MXY(25),QX)
      CALL FMADDI(MXY(25),-1,QX)
      CALL FMEQ(MXY(24),MXY(26),QX)
      CALL FMI2M(1,MXY(12),QX)
      CALL FMADD(MXY(2),MXY(12),MXY(27),QX)
      CALL FMEQ(MXY(3),MXY(28),QX)
      CALL FMI2M(1,MXY(7),QX)
      CALL FMSUB(MXY(2),MXY(7),MXY(12),QX)
      CALL FMSQR(MXY(12),MXY(29),QX)
      CALL FMI2M(2,MXY(12),QX)
      CALL FMSUB(MXY(12),MXY(1),MXY(30),QX)
      IF (NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,QX%NDIG,QX)
          CALL FMMPY(MXY(2),MXY(19),MXY(7),QX)
          CALL FMMPY(MXY(3),MXY(1),MXY(12),QX)
          CALL FMSUB(MXY(7),MXY(12),MXY(31),QX)
          CALL FMADDI(MXY(31),1,QX)
      ELSE
          CALL FMADD(MXY(2),MXY(3),MXY(7),QX)
          CALL FMMPY(MXY(7),MXY(1),MXY(12),QX)
          CALL FMSUB(MXY(2),MXY(12),MXY(31),QX)
          CALL FMADDI(MXY(31),1,QX)
      ENDIF
      CALL FMEQ(MXY(2),MXY(35),QX)
      CALL FMI2M(2,MXY(7),QX)
      CALL FMSUB(MXY(2),MXY(7),MXY(12),QX)
      CALL FMMPYI(MXY(12),4,MXY(36),QX)

      CALL FMI2M(1,MXY(33),QX)
      CALL FMMPY(MXY(35),MXY(31),MXY(12),QX)
      CALL FMDIV(MXY(12),MXY(27),MXY(34),QX)

      CALL FMI2M(1,MXY(19),QX)
      CALL FMEQ(MXY(34),MXY(20),QX)
      CALL FMDIV(MXY(33),MXY(34),MXY(21),QX)
      IF (MXY(21)%MP(1) > 0) THEN
          CALL FMEQ(MXY(21),MXY(38),QX)
          CALL FMI2M(0,MXY(39),QX)
      ELSE
          CALL FMEQ(MXY(21),MXY(39),QX)
          CALL FMI2M(0,MXY(38),QX)
      ENDIF

!             Method 5 continued fraction loop.

      KRSAVE = QX%KROUND
      QX%KROUND = 1
      DO J = 1, NTERMS
         CALL FMADDI(MXY(24),1,QX)
         CALL FMADDI(MXY(25),1,QX)
         CALL FMADDI(MXY(26),2,QX)
         CALL FMADDI(MXY(27),2,QX)
         CALL FMADDI(MXY(28),-1,QX)
         CALL FMADDI(MXY(36),8,QX)
         CALL FMCSADD_R1(MXY(29),MXY(36),QX)
         CALL FMCSADD_R1(MXY(31),MXY(30),QX)
         CALL FMADDI(MXY(35),1,QX)

         CALL FMEQ(MXY(24),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(25),QX)
         CALL FMCSMPYI_R1(MXY(15),J,QX)
         CALL FMCSMPY_R1(MXY(15),MXY(28),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(23),QX)
         CALL FMCSDIV(MXY(15),MXY(29),MXY(33),QX)

         CALL FMEQ(MXY(35),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(31),QX)
         CALL FMCSDIV(MXY(15),MXY(27),MXY(34),QX)
         CALL FMEQ(MXY(28),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(1),QX)
         CALL FMCSMPYI_R1(MXY(15),J,QX)
         CALL FMDIV_R1(MXY(15),MXY(26),QX)
         CALL FMCSADD_R1(MXY(34),MXY(15),QX)
         CALL FMADDI(MXY(34),J,QX)

         CALL FMEQ(MXY(33),MXY(18),QX)
         CALL FMCSMPY_R1(MXY(18),MXY(19),QX)
         CALL FMEQ(MXY(34),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(20),QX)
         CALL FMADD(MXY(15),MXY(18),MXY(17),QX)
         CALL FMEQ(MXY(18),MXY(15),QX)
         CALL FMCSMPY_R1(MXY(15),MXY(21),QX)
         CALL FMCSDIV(MXY(15),MXY(17),MXY(21),QX)
         IF (MXY(21)%MP(2) /= QX%MUNKNO .AND. MXY(21)%MP(3) /= 0)  &
             MXY(21)%MP(1) = -MXY(21)%MP(1)

         QX%NDIG = NDSAV1
         IF (MXY(21)%MP(1) > 0) THEN
             CALL FMADD(MXY(38),MXY(21),MXY(19),QX)
             INT_TEMP1 = QX%KFLAG
             CALL FMEQ(MXY(19),MXY(38),QX)
         ELSE
             CALL FMADD(MXY(39),MXY(21),MXY(19),QX)
             INT_TEMP1 = QX%KFLAG
             CALL FMEQ(MXY(19),MXY(39),QX)
         ENDIF
         QX%KFLAG = INT_TEMP1

!             Check for convergence.

         IF (QX%KFLAG == 1 .AND. J > 4) THEN
             EXIT
         ENDIF

         CALL FMEQ(MXY(20),MXY(19),QX)
         CALL FMEQ(MXY(17),MXY(20),QX)
         CALL FMADD(MXY(38),MXY(39),MXY(15),QX)
         INT_TEMP1 = NDSAV1 - INT(MXY(15)%MP(2) - MXY(21)%MP(2))
         INT_TEMP2 = MAX(QX%NGRD22,INT_TEMP1)
         QX%NDIG = MIN(NDSAV1,INT_TEMP2)
      ENDDO
      CALL FMADD(MXY(38),MXY(39),MXY(15),QX)
      CALL FMCANCEL(MXY(38),MXY(39),MXY(15),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(15),MXY(22),QX)

      QX%KROUND = KRSAVE
      QX%NDIG = NDSAV1

!             Multiply the sums by x^a * (1-x)^b

      CALL FMEQ(MXY(38),MXY(40),QX)
      CALL FMIBTA_M5B(MX,MXY,NDSAVE,NMETHD,QX)
      CALL FMEQ(MXY(40),MXY(38),QX)
      CALL FMEQ(MXY(39),MXY(40),QX)
      CALL FMIBTA_M5B(MX,MXY,NDSAVE,NMETHD,QX)
      CALL FMEQ(MXY(40),MXY(39),QX)
      CALL FMEQ(MXY(22),MXY(40),QX)
      CALL FMIBTA_M5B(MX,MXY,NDSAVE,NMETHD,QX)
      CALL FMEQ(MXY(40),MXY(21),QX)

      END SUBROUTINE FMIBTA_M5

      SUBROUTINE FMIBTA_M5B(MX,MXY,NDSAVE,NMETHD,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MX,MXY(40)
      INTEGER :: NDSAVE,NMETHD
      INTENT(IN) :: MX,NDSAVE,NMETHD
      INTENT(INOUT) :: MXY
      INTEGER :: K,NTERMS
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      NTERMS = INT(INTMAX/10)
      CALL FMI2M(1,MXY(12),QX)
      IF (FMCOMP(MXY(1),'==',MXY(12),QX) .AND.  &
          NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,QX%NDIG,QX)
          CALL FMMPY_R1(MXY(19),MXY(2),QX)
          IF (MXY(19)%MP(2) /= QX%MUNKNO .AND. MXY(19)%MP(3) /= 0)  &
              MXY(19)%MP(1) = -MXY(19)%MP(1)
      ELSE IF (MX%MP(2) <= -1 .AND. NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,QX%NDIG,QX)
          CALL FMEQ(MXY(19),MXY(15),QX)
          CALL FMEQ(MXY(19),MXY(20),QX)
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(19),QX)
             CALL FMDIVI(MXY(15),K,MXY(12),QX)
             CALL FMADD_R1(MXY(20),MXY(12),QX)
             IF (QX%KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY(MXY(20),MXY(2),MXY(19),QX)
          IF (MXY(19)%MP(2) /= QX%MUNKNO .AND. MXY(19)%MP(3) /= 0)  &
              MXY(19)%MP(1) = -MXY(19)%MP(1)
      ELSE
          CALL FMLN(MXY(1),MXY(19),QX)
          CALL FMMPY_R1(MXY(19),MXY(2),QX)
      ENDIF
      IF (NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(20),NDSAVE,QX%NDIG,QX)
          CALL FMLN(MXY(20),MXY(10),QX)
          CALL FMMPY(MXY(10),MXY(3),MXY(20),QX)
      ELSE IF (MXY(1)%MP(2) <= -1) THEN
          CALL FMEQ(MXY(1),MXY(15),QX)
          CALL FMEQ(MXY(1),MXY(20),QX)
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(1),QX)
             CALL FMDIVI(MXY(15),K,MXY(12),QX)
             CALL FMADD_R1(MXY(20),MXY(12),QX)
             IF (QX%KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY_R1(MXY(20),MXY(3),QX)
          IF (MXY(20)%MP(2) /= QX%MUNKNO .AND. MXY(20)%MP(3) /= 0)  &
              MXY(20)%MP(1) = -MXY(20)%MP(1)
      ELSE
          CALL FMI2M(1,MXY(12),QX)
          CALL FMSUB_R1(MXY(12),MXY(1),QX)
          CALL FMLN(MXY(12),MXY(20),QX)
          CALL FMMPY_R1(MXY(20),MXY(3),QX)
      ENDIF
      CALL FMADD(MXY(19),MXY(20),MXY(12),QX)
      CALL FMEXP(MXY(12),MXY(21),QX)
      CALL FMMPY_R2(MXY(40),MXY(21),QX)
      IF (MXY(21)%MP(2) == QX%MUNKNO) THEN
          IF (MXY(40)%MP(1)*MXY(40)%MP(3) > 0) THEN
              CALL FMLN(MXY(40),MXY(12),QX)
              CALL FMADD(MXY(12),MXY(19),MXY(7),QX)
              CALL FMADD(MXY(7),MXY(20),MXY(12),QX)
              CALL FMEXP(MXY(12),MXY(21),QX)
          ELSE
              CALL FMEQ(MXY(40),MXY(13),QX)
              IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
                  MXY(13)%MP(1) = -MXY(13)%MP(1)
              CALL FMLN(MXY(13),MXY(12),QX)
              CALL FMADD(MXY(12),MXY(19),MXY(7),QX)
              CALL FMADD(MXY(7),MXY(20),MXY(12),QX)
              CALL FMEXP(MXY(12),MXY(21),QX)
              IF (MXY(21)%MP(2) /= QX%MUNKNO .AND. MXY(21)%MP(3) /= 0)  &
                  MXY(21)%MP(1) = -MXY(21)%MP(1)
          ENDIF
      ENDIF
      CALL FMEQ(MXY(21),MXY(40),QX)

      END SUBROUTINE FMIBTA_M5B

      SUBROUTINE FMIBTA2(K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD,QX)

!  Check for various special cases in Incomplete Beta.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      REAL (KIND(1.0D0)) :: MXSAVE
      REAL (KIND(1.0D0)) :: MBSBRN
      INTEGER :: NUMBRN
      TYPE(MULTI) :: MBERN(LMBERN)
      INTEGER :: NDBERN(LMBERN)
      INTEGER :: IEXTRA,J,J4,JR,JSWITCH,K,KRSAVE,K_RETURN_CODE,N,NDSAV1,NMETHD,NTERMS,NUMTRY,NUP
      INTEGER, PARAMETER :: KPRIME(8) = (/ 2, 3, 5, 7, 11, 13, 17, 19 /)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI) :: MXY(37),MJSUMS(LJSUMS)
      INTENT (INOUT) :: K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD
      TYPE(FM_SETTINGS) :: QX

      MBSBRN = 0
      NUMBRN = 0
      NDBERN = 0

      K_RETURN_CODE = 0
      CALL FMI2M(0,MXY(32),QX)
      NDSAV1 = QX%NDIG

!             If B is small, use more guard digits.

      CALL FMDPM(1.0D-10,MXY(12),QX)
      IF (FMCOMP(MXY(3),'<=',MXY(12),QX)) THEN
          IEXTRA = QX%NGRD52
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(3),QX%NDIG,QX%NDIG+IEXTRA,QX)
          QX%NDIG = QX%NDIG + IEXTRA
      ENDIF

      NTERMS = INT(INTMAX/10)
      NMETHD = 0

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(21),QX)
          K_RETURN_CODE = 1
          RETURN
      ENDIF
      CALL FMI2M(1,MXY(28),QX)
      IF (FMCOMP(MXY(28),'==',MXY(1),QX)) THEN
          IEXTRA = QX%NGRD52
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(3),QX%NDIG,QX%NDIG+IEXTRA,QX)
          QX%NDIG = QX%NDIG + IEXTRA
          CALL FMBETA(MXY(2),MXY(3),MXY(31),QX)
          CALL FMEQ(MXY(31),MXY(21),QX)
          K_RETURN_CODE = 1
          RETURN
      ELSE IF (MXY(1)%MP(1) < 0 .OR. FMCOMP(MXY(1),'>',MXY(28),QX)) THEN
          CALL FMST2M('UNKNOWN',MXY(21),QX)
          QX%KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      IF (MXY(2)%MP(1) < 0 .OR. MXY(2)%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(21),QX)
          QX%KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      IF (MXY(3)%MP(1) < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(21),QX)
          QX%KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      JR = NUMTRY
      IF (MXY(2)%MP(2) < (-QX%NDIG) .AND. MXY(3)%MP(2) < (-QX%NDIG)) THEN
          CALL FMSUB(MXY(28),MXY(1),MXY(12),QX)
          CALL FMLN(MXY(12),MXY(21),QX)
          CALL FMDIV(MXY(28),MXY(2),MXY(12),QX)
          CALL FMSUB(MXY(12),MXY(21),MXY(13),QX)
          CALL FMPWR(MXY(1),MXY(2),MXY(12),QX)
          CALL FMMPY(MXY(13),MXY(12),MXY(21),QX)
          K_RETURN_CODE = 1
          RETURN
      ENDIF
      CALL FMI2M(1,MXY(12),QX)
      CALL FMSUB(MXY(12),MXY(3),MXY(7),QX)
      CALL FMMPY(MXY(1),MXY(7),MXY(12),QX)
      JR = QX%KROUND
      QX%KROUND = 1
      CALL FMADD(MXY(12),MXY(28),MXY(7),QX)
      QX%KROUND = JR
      IF (FMCOMP(MXY(7),'==',MXY(28),QX)) THEN
          CALL FMLN(MXY(1),MXY(12),QX)
          CALL FMMPY(MXY(2),MXY(12),MXY(21),QX)
          CALL FMLN(MXY(2),MXY(12),QX)
          CALL FMSUB_R2(MXY(21),MXY(12),QX)
          CALL FMEXP(MXY(12),MXY(21),QX)
          K_RETURN_CODE = 2
          RETURN
      ENDIF

!             When A or B is large, check for an underflowed result.

      CALL FMDPM(1.0D+7,MXY(12),QX)
      IF (FMCOMP(MXY(2),'>',MXY(12),QX) .OR. FMCOMP(MXY(3),'>',MXY(12),QX)) THEN

!             If B is much larger than A, approximate BETA(A,B) and use that as an upper bound.

          IF (MXY(3)%MP(2) >= MXY(2)%MP(2)+QX%NDIG) THEN
              CALL FMADD(MXY(3),MXY(2),MXY(12),QX)
              CALL FMLN(MXY(12),MXY(23),QX)
              CALL FMMPY_R2(MXY(2),MXY(23),QX)
              CALL FMEQ(MXY(2),MXY(27),QX)
              CALL FMLNGM(MXY(27),MXY(24),QX)
              CALL FMSUB(MXY(24),MXY(23),MXY(12),QX)
              CALL FMEXP(MXY(12),MXY(21),QX)
              IF (MXY(21)%MP(2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF

!             If A > 2 > B, use the bound
!                C = min( X , (A-2)/(A+B-2) )
!                BETA(X,A,B) < (A-1)*X/B * C**(A-2) * (1-C)**B
!
!             An alternate bound is also tried:
!                C = min( X , (A-1)/(A+B-2) )
!                BETA(X,A,B) < C**A * (1-C)**(1-B)

          CALL FMI2M(2,MXY(12),QX)
          IF (FMCOMP(MXY(2),'>',MXY(12),QX) .AND. FMCOMP(MXY(3),'<',MXY(12),QX)) THEN
              CALL FMI2M(2,MXY(6),QX)
              CALL FMSUB(MXY(2),MXY(6),MXY(12),QX)
              CALL FMADD(MXY(2),MXY(3),MXY(7),QX)
              CALL FMSUB_R1(MXY(7),MXY(6),QX)
              CALL FMDIV_R1(MXY(12),MXY(7),QX)
              CALL FMMIN(MXY(1),MXY(12),MXY(23),QX)
              CALL FMI2M(1,MXY(12),QX)
              CALL FMSUB_R2(MXY(2),MXY(12),QX)
              CALL FMLN(MXY(12),MXY(27),QX)
              CALL FMLN(MXY(1),MXY(12),QX)
              CALL FMADD_R1(MXY(27),MXY(12),QX)
              CALL FMLN(MXY(3),MXY(12),QX)
              CALL FMSUB_R1(MXY(27),MXY(12),QX)
              CALL FMI2M(2,MXY(7),QX)
              CALL FMSUB(MXY(2),MXY(7),MXY(21),QX)
              CALL FMLN(MXY(23),MXY(12),QX)
              CALL FMMPY_R2(MXY(21),MXY(12),QX)
              CALL FMADD_R1(MXY(27),MXY(12),QX)
              CALL FMI2M(1,MXY(7),QX)
              CALL FMSUB(MXY(7),MXY(23),MXY(12),QX)
              CALL FMLN(MXY(12),MXY(21),QX)
              CALL FMMPY(MXY(3),MXY(21),MXY(12),QX)
              CALL FMADD_R1(MXY(27),MXY(12),QX)
              CALL FMEXP(MXY(27),MXY(21),QX)
              IF (MXY(21)%MP(2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
              CALL FMI2M(1,MXY(7),QX)
              CALL FMSUB(MXY(2),MXY(7),MXY(12),QX)
              CALL FMADD(MXY(2),MXY(3),MXY(7),QX)
              CALL FMI2M(2,MXY(6),QX)
              CALL FMSUB_R1(MXY(7),MXY(6),QX)
              CALL FMDIV_R1(MXY(12),MXY(7),QX)
              CALL FMMIN(MXY(1),MXY(12),MXY(23),QX)
              CALL FMI2M(1,MXY(7),QX)
              CALL FMSUB(MXY(7),MXY(23),MXY(12),QX)
              CALL FMLN(MXY(12),MXY(27),QX)
              CALL FMSUB(MXY(3),MXY(7),MXY(6),QX)
              CALL FMMPY_R2(MXY(6),MXY(27),QX)
              CALL FMLN(MXY(1),MXY(12),QX)
              CALL FMMPY_R2(MXY(2),MXY(12),QX)
              CALL FMADD_R2(MXY(12),MXY(27),QX)
              CALL FMEXP(MXY(27),MXY(21),QX)
              IF (MXY(21)%MP(2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF

!             If A > 2 and B > 2, use the bound
!                C = min( X , (A-1)/(A+B-2) )
!                BETA(X,A,B) < X * C**(A-1) * (1-C)**(B-1)

          CALL FMI2M(2,MXY(12),QX)
          IF (FMCOMP(MXY(2),'>',MXY(12),QX) .AND. FMCOMP(MXY(3),'>',MXY(12),QX)) THEN
              CALL FMI2M(1,MXY(7),QX)
              CALL FMSUB(MXY(2),MXY(7),MXY(12),QX)
              CALL FMADD(MXY(2),MXY(3),MXY(7),QX)
              CALL FMI2M(2,MXY(6),QX)
              CALL FMSUB_R1(MXY(7),MXY(6),QX)
              CALL FMDIV_R1(MXY(12),MXY(7),QX)
              CALL FMMIN(MXY(1),MXY(12),MXY(23),QX)
              CALL FMI2M(1,MXY(7),QX)
              CALL FMSUB(MXY(7),MXY(23),MXY(12),QX)
              CALL FMLN(MXY(12),MXY(27),QX)
              CALL FMSUB(MXY(3),MXY(7),MXY(6),QX)
              CALL FMMPY_R2(MXY(6),MXY(27),QX)
              CALL FMLN(MXY(23),MXY(12),QX)
              CALL FMSUB(MXY(2),MXY(7),MXY(6),QX)
              CALL FMMPY_R2(MXY(6),MXY(12),QX)
              CALL FMADD_R2(MXY(12),MXY(27),QX)
              CALL FMLN(MXY(1),MXY(12),QX)
              CALL FMADD_R2(MXY(12),MXY(27),QX)
              CALL FMEXP(MXY(27),MXY(21),QX)
              IF (MXY(21)%MP(2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for cases where X is large enough so that at this precision, B(X,A,B) = B(A,B).
!             These are often unstable, so it is better to use Beta.

      CALL FMI2M(1,MXY(12),QX)
      CALL FMI2M(2,MXY(6),QX)
      CALL FMADD(MXY(2),MXY(3),MXY(7),QX)
      IF (FMCOMP(MXY(2),'>',MXY(12),QX) .AND. FMCOMP(MXY(7),'>',MXY(6),QX)) THEN
              CALL FMI2M(1,MXY(7),QX)
              CALL FMSUB(MXY(2),MXY(7),MXY(12),QX)
              CALL FMADD(MXY(2),MXY(3),MXY(7),QX)
              CALL FMI2M(2,MXY(6),QX)
              CALL FMSUB_R1(MXY(7),MXY(6),QX)
              CALL FMDIV(MXY(12),MXY(7),MXY(31),QX)
          CALL FMI2M(1,MXY(12),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(7),QX)
          CALL FMADDI(MXY(7),-3,QX)
          IF (FMCOMP(MXY(31),'<',MXY(12),QX) .AND. FMCOMP(MXY(1),'>',MXY(31),QX) .AND.  &
              MXY(7)%MP(3) /= 0) THEN
              CALL FMI2M(1,MXY(7),QX)
              CALL FMSUB(MXY(2),MXY(7),MXY(6),QX)
              CALL FMSUB(MXY(3),MXY(7),MXY(12),QX)
              CALL FMMPY_R2(MXY(6),MXY(12),QX)
              CALL FMADD(MXY(2),MXY(3),MXY(6),QX)
              CALL FMI2M(3,MXY(7),QX)
              CALL FMSUB_R2(MXY(6),MXY(7),QX)
              CALL FMDIV(MXY(12),MXY(7),MXY(30),QX)
              IF (MXY(30)%MP(1) >= 0) THEN
                  CALL FMI2M(1,MXY(7),QX)
                  CALL FMSUB_R2(MXY(2),MXY(7),QX)
                  CALL FMSQRT(MXY(30),MXY(12),QX)
                  CALL FMADD(MXY(7),MXY(12),MXY(30),QX)
                  CALL FMADD(MXY(2),MXY(3),MXY(7),QX)
                  CALL FMI2M(2,MXY(6),QX)
                  CALL FMSUB_R1(MXY(7),MXY(6),QX)
                  CALL FMDIV_R1(MXY(30),MXY(7),QX)
              ELSE
                  CALL FMDPM(DBLE(1.1),MXY(30),QX)
              ENDIF
              CALL FMI2M(1,MXY(12),QX)
              IF (FMCOMP(MXY(30),'>',MXY(31),QX) .AND. FMCOMP(MXY(30),'<',MXY(12),QX) .AND.  &
                  FMCOMP(MXY(1),'>=',MXY(30),QX)) THEN

!                 Approximate B(A,B).

                  JR = QX%KROUND
                  QX%KROUND = 1
                  CALL FMADD(MXY(2),MXY(3),MXY(12),QX)
                  QX%KROUND = JR
                  IF (FMCOMP(MXY(12),'==',MXY(2),QX)) THEN
                      CALL FMLN(MXY(3),MXY(12),QX)
                      CALL FMDPM(0.5D0,MXY(7),QX)
                      CALL FMSUB_R2(MXY(3),MXY(7),QX)
                      CALL FMMPY(MXY(7),MXY(12),MXY(29),QX)
                      CALL FMSUB_R1(MXY(29),MXY(3),QX)
                      CALL FMDPM(QX%DLOGTP/2.0D0,MXY(12),QX)
                      CALL FMSUB_R1(MXY(29),MXY(12),QX)
                      CALL FMLN(MXY(2),MXY(12),QX)
                      CALL FMMPY_R2(MXY(3),MXY(12),QX)
                      CALL FMSUB_R1(MXY(29),MXY(12),QX)
                  ELSE IF (FMCOMP(MXY(12),'==',MXY(3),QX)) THEN
                      CALL FMLN(MXY(2),MXY(12),QX)
                      CALL FMDP2M(0.5D0,MXY(7),QX)
                      CALL FMSUB_R2(MXY(2),MXY(7),QX)
                      CALL FMMPY(MXY(7),MXY(12),MXY(29),QX)
                      CALL FMSUB_R1(MXY(29),MXY(2),QX)
                      CALL FMDPM(QX%DLOGTP/2.0D0,MXY(12),QX)
                      CALL FMSUB_R1(MXY(29),MXY(12),QX)
                      CALL FMLN(MXY(3),MXY(12),QX)
                      CALL FMMPY_R2(MXY(2),MXY(12),QX)
                      CALL FMSUB_R1(MXY(29),MXY(12),QX)
                  ELSE
                      CALL FMLN(MXY(2),MXY(12),QX)
                      CALL FMDP2M(0.5D0,MXY(7),QX)
                      CALL FMSUB_R2(MXY(2),MXY(7),QX)
                      CALL FMMPY(MXY(7),MXY(12),MXY(29),QX)
                      CALL FMLN(MXY(3),MXY(12),QX)
                      CALL FMDP2M(0.5D0,MXY(7),QX)
                      CALL FMSUB_R2(MXY(3),MXY(7),QX)
                      CALL FMMPY_R2(MXY(7),MXY(12),QX)
                      CALL FMADD_R1(MXY(29),MXY(12),QX)
                      CALL FMADD(MXY(2),MXY(3),MXY(12),QX)
                      CALL FMLN(MXY(12),MXY(7),QX)
                      CALL FMDP2M(0.5D0,MXY(6),QX)
                      CALL FMSUB_R2(MXY(12),MXY(6),QX)
                      CALL FMMPY(MXY(6),MXY(7),MXY(12),QX)
                      CALL FMSUB_R1(MXY(29),MXY(12),QX)
                      CALL FMDPM(QX%DLOGTP/2.0D0,MXY(12),QX)
                      CALL FMSUB_R1(MXY(29),MXY(12),QX)
                  ENDIF
                  CALL FMEXP(MXY(29),MXY(9),QX)
                  CALL FMEQ(MXY(9),MXY(29),QX)

!                 Bound the area from X to 1.

                  CALL FMI2M(1,MXY(12),QX)
                  JR = QX%KROUND
                  QX%KROUND = 1
                  CALL FMSUB(MXY(12),MXY(1),MXY(7),QX)
                  QX%KROUND = JR
                  IF (FMCOMP(MXY(7),'==',MXY(12),QX)) THEN
                      CALL FMLN(MXY(1),MXY(12),QX)
                      CALL FMI2M(1,MXY(6),QX)
                      CALL FMSUB(MXY(2),MXY(6),MXY(7),QX)
                      CALL FMMPY(MXY(7),MXY(12),MXY(28),QX)
                      CALL FMSUB(MXY(3),MXY(6),MXY(7),QX)
                      CALL FMMPY(MXY(1),MXY(7),MXY(12),QX)
                      CALL FMSUB_R1(MXY(28),MXY(12),QX)
                      CALL FMSUB(MXY(6),MXY(1),MXY(12),QX)
                      CALL FMDIVI_R1(MXY(12),2,QX)
                      CALL FMLN(MXY(12),MXY(13),QX)
                      CALL FMSUB_R1(MXY(28),MXY(13),QX)
                  ELSE
                      CALL FMLN(MXY(1),MXY(12),QX)
                      CALL FMI2M(1,MXY(6),QX)
                      CALL FMSUB(MXY(2),MXY(6),MXY(7),QX)
                      CALL FMMPY(MXY(7),MXY(12),MXY(28),QX)
                      CALL FMSUB(MXY(3),MXY(6),MXY(7),QX)
                      CALL FMSUB(MXY(6),MXY(1),MXY(12),QX)
                      CALL FMLN(MXY(12),MXY(13),QX)
                      CALL FMMPY_R2(MXY(7),MXY(13),QX)
                      CALL FMADD_R1(MXY(28),MXY(13),QX)
                      CALL FMDIVI_R1(MXY(12),2,QX)
                      CALL FMLN(MXY(12),MXY(13),QX)
                      CALL FMADD_R1(MXY(28),MXY(13),QX)
                  ENDIF
                  CALL FMEXP(MXY(28),MXY(9),QX)
                  CALL FMEQ(MXY(9),MXY(28),QX)
                  JR = QX%KROUND
                  QX%KROUND = 1
                  CALL FMSUB(MXY(29),MXY(28),MXY(12),QX)
                  QX%KROUND = JR
                  IF (FMCOMP(MXY(12),'==',MXY(29),QX)) THEN
                      CALL FMEQ(MXY(28),MXY(33),QX)
                      CALL FMBETA(MXY(2),MXY(3),MXY(31),QX)
                      JR = QX%KROUND
                      QX%KROUND = 1
                      CALL FMSUB(MXY(31),MXY(33),MXY(12),QX)
                      QX%KROUND = JR
                      IF (FMCOMP(MXY(12),'==',MXY(31),QX)) THEN
                          CALL FMEQ(MXY(31),MXY(21),QX)
                          K_RETURN_CODE = 1
                          RETURN
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
      ELSE IF (MXY(2)%MP(2) < 1 .AND. FMCOMP(MXY(3),'>',MXY(12),QX)) THEN

!                 Approximate B(A,B).

          JR = QX%KROUND
          QX%KROUND = 1
          CALL FMADD(MXY(2),MXY(3),MXY(12),QX)
          QX%KROUND = JR
          IF (FMCOMP(MXY(12),'==',MXY(2),QX)) THEN
              CALL FMLN(MXY(3),MXY(12),QX)
              CALL FMDP2M(0.5D0,MXY(7),QX)
              CALL FMSUB_R2(MXY(3),MXY(7),QX)
              CALL FMMPY(MXY(7),MXY(12),MXY(29),QX)
              CALL FMSUB_R1(MXY(29),MXY(3),QX)
              CALL FMDPM(QX%DLOGTP/2.0D0,MXY(12),QX)
              CALL FMSUB_R1(MXY(29),MXY(12),QX)
              CALL FMLN(MXY(2),MXY(12),QX)
              CALL FMMPY_R2(MXY(3),MXY(12),QX)
              CALL FMSUB_R1(MXY(29),MXY(12),QX)
          ELSE IF (FMCOMP(MXY(12),'==',MXY(3),QX)) THEN
              CALL FMLN(MXY(2),MXY(12),QX)
              CALL FMDP2M(0.5D0,MXY(7),QX)
              CALL FMSUB_R2(MXY(2),MXY(7),QX)
              CALL FMMPY(MXY(7),MXY(12),MXY(29),QX)
              CALL FMSUB_R1(MXY(29),MXY(2),QX)
              CALL FMDPM(QX%DLOGTP/2.0D0,MXY(12),QX)
              CALL FMSUB_R1(MXY(29),MXY(12),QX)
              CALL FMLN(MXY(3),MXY(12),QX)
              CALL FMMPY_R2(MXY(2),MXY(12),QX)
              CALL FMSUB_R1(MXY(29),MXY(12),QX)
          ELSE
              CALL FMLN(MXY(2),MXY(12),QX)
              CALL FMDP2M(0.5D0,MXY(7),QX)
              CALL FMSUB_R2(MXY(2),MXY(7),QX)
              CALL FMMPY(MXY(7),MXY(12),MXY(29),QX)
              CALL FMLN(MXY(3),MXY(12),QX)
              CALL FMDP2M(0.5D0,MXY(7),QX)
              CALL FMSUB_R2(MXY(3),MXY(7),QX)
              CALL FMMPY_R2(MXY(7),MXY(12),QX)
              CALL FMADD_R1(MXY(29),MXY(12),QX)
              CALL FMADD(MXY(2),MXY(3),MXY(12),QX)
              CALL FMLN(MXY(12),MXY(7),QX)
              CALL FMDP2M(0.5D0,MXY(6),QX)
              CALL FMSUB_R2(MXY(12),MXY(6),QX)
              CALL FMMPY(MXY(6),MXY(7),MXY(12),QX)
              CALL FMSUB_R1(MXY(29),MXY(12),QX)
              CALL FMDPM(QX%DLOGTP/2.0D0,MXY(12),QX)
              CALL FMSUB_R1(MXY(29),MXY(12),QX)
          ENDIF
          CALL FMEXP(MXY(29),MXY(9),QX)
          CALL FMEQ(MXY(9),MXY(29),QX)

!                 Bound the area from X to 1.

          CALL FMI2M(1,MXY(12),QX)
          JR = QX%KROUND
          QX%KROUND = 1
          CALL FMSUB(MXY(12),MXY(1),MXY(7),QX)
          QX%KROUND = JR
          IF (FMCOMP(MXY(7),'==',MXY(12),QX)) THEN
              CALL FMLN(MXY(1),MXY(12),QX)
              CALL FMI2M(1,MXY(6),QX)
              CALL FMSUB(MXY(2),MXY(6),MXY(7),QX)
              CALL FMMPY(MXY(7),MXY(12),MXY(28),QX)
              CALL FMSUB(MXY(3),MXY(6),MXY(7),QX)
              CALL FMMPY(MXY(1),MXY(7),MXY(12),QX)
              CALL FMSUB_R1(MXY(28),MXY(12),QX)
              CALL FMSUB(MXY(6),MXY(1),MXY(12),QX)
              CALL FMDIVI_R1(MXY(12),2,QX)
              CALL FMLN(MXY(12),MXY(13),QX)
              CALL FMSUB_R1(MXY(28),MXY(13),QX)
              CALL FMEXP(MXY(28),MXY(9),QX)
              CALL FMEQ(MXY(9),MXY(28),QX)
          ELSE
              CALL FMLN(MXY(1),MXY(12),QX)
              CALL FMI2M(1,MXY(6),QX)
              CALL FMSUB(MXY(2),MXY(6),MXY(7),QX)
              CALL FMMPY(MXY(7),MXY(12),MXY(28),QX)
              CALL FMSUB(MXY(3),MXY(6),MXY(7),QX)
              CALL FMSUB(MXY(6),MXY(1),MXY(12),QX)
              CALL FMLN(MXY(12),MXY(13),QX)
              CALL FMMPY_R2(MXY(7),MXY(13),QX)
              CALL FMADD_R1(MXY(28),MXY(13),QX)
              CALL FMDIVI_R1(MXY(12),2,QX)
              CALL FMLN(MXY(12),MXY(13),QX)
              CALL FMADD_R1(MXY(28),MXY(13),QX)
              CALL FMEXP(MXY(28),MXY(9),QX)
              CALL FMEQ(MXY(9),MXY(28),QX)
          ENDIF
          JR = QX%KROUND
          QX%KROUND = 1
          CALL FMSUB(MXY(29),MXY(28),MXY(12),QX)
          QX%KROUND = JR
          IF (FMCOMP(MXY(12),'==',MXY(29),QX)) THEN
              CALL FMBETA(MXY(2),MXY(3),MXY(31),QX)
              CALL FMEQ(MXY(31),MXY(21),QX)
              K_RETURN_CODE = 1
              RETURN
          ENDIF
      ENDIF

!             If B is small enough, use one of two series or an asymptotic series,
!             depending on the size of X and A.

      CALL FMI2M(1,MXY(6),QX)
      JR = QX%KROUND
      QX%KROUND = 1
      CALL FMADD(MXY(6),MXY(3),MXY(7),QX)
      CALL FMADD(MXY(2),MXY(3),MXY(12),QX)
      QX%KROUND = JR
      IF ((FMCOMP(MXY(7),'==',MXY(6),QX) .AND. FMCOMP(MXY(12),'==',MXY(2),QX)) ) THEN
          CALL FMDP2M(0.5D0,MXY(12),QX)
          IF (FMCOMP(MXY(1),'<=',MXY(12),QX)) THEN
              CALL FMI2M(0,MXY(22),QX)
              CALL FMEQ(MXY(1),MXY(23),QX)
              CALL FMI2M(1,MXY(7),QX)
              CALL FMADD(MXY(2),MXY(7),MXY(12),QX)
              CALL FMDIV(MXY(23),MXY(12),MXY(24),QX)
              CALL FMEQ(MXY(2),MXY(14),QX)
              CALL FMADDI(MXY(14),1,QX)
              NDSAV1 = QX%NDIG
              DO J = 2, NTERMS
                 CALL FMADD_R1(MXY(22),MXY(24),QX)
                 IF (QX%KFLAG /= 0 .AND. J >= 3) EXIT
                 QX%NDIG = MIN(NDSAV1,MAX(QX%NGRD22,NDSAV1-INT(MXY(22)%MP(2)-  &
                                                         MXY(24)%MP(2))+1))
                 CALL FMMPY_R1(MXY(23),MXY(1),QX)
                 CALL FMADDI(MXY(14),1,QX)
                 CALL FMDIV(MXY(23),MXY(14),MXY(24),QX)
                 QX%NDIG = NDSAV1
              ENDDO
              CALL FMPWR(MXY(1),MXY(2),MXY(12),QX)
              CALL FMI2M(1,MXY(6),QX)
              CALL FMDIV(MXY(6),MXY(2),MXY(7),QX)
              CALL FMADD(MXY(7),MXY(22),MXY(6),QX)
              CALL FMMPY(MXY(12),MXY(6),MXY(22),QX)
              CALL FMEQ(MXY(22),MXY(21),QX)
              K_RETURN_CODE = 1
              RETURN
          ENDIF
          CALL FMDP2M(0.5D0,MXY(12),QX)
          CALL FMI2M(20,MXY(7),QX)
          IF ((FMCOMP(MXY(1),'>',MXY(12),QX) .AND. FMCOMP(MXY(2),'<',MXY(7),QX))) THEN
              CALL FMI2M(0,MXY(22),QX)
              CALL FMI2M(1,MXY(12),QX)
              CALL FMSUB(MXY(12),MXY(1),MXY(25),QX)
              CALL FMI2M(1,MXY(7),QX)
              CALL FMADD(MXY(3),MXY(7),MXY(12),QX)
              CALL FMPWR(MXY(25),MXY(12),MXY(23),QX)
              CALL FMI2M(1,MXY(12),QX)
              CALL FMSUB(MXY(12),MXY(2),MXY(7),QX)
              CALL FMMPY_R2(MXY(7),MXY(23),QX)

              CALL FMEQ(MXY(23),MXY(24),QX)
              NDSAV1 = QX%NDIG
              DO J = 2, NTERMS
                 CALL FMADD_R1(MXY(22),MXY(24),QX)
                 IF (QX%KFLAG /= 0 .AND. J >= 3) EXIT
                 QX%NDIG = MIN(NDSAV1,MAX(QX%NGRD22,NDSAV1-INT(MXY(22)%MP(2)-  &
                                                         MXY(24)%MP(2))+1))
                 CALL FMI2M(J,MXY(7),QX)
                 CALL FMSUB(MXY(7),MXY(2),MXY(12),QX)
                 CALL FMMPY(MXY(23),MXY(12),MXY(7),QX)
                 CALL FMMPY(MXY(7),MXY(25),MXY(12),QX)
                 CALL FMDIVI(MXY(12),J,MXY(23),QX)
                 CALL FMDIVI(MXY(23),J,MXY(24),QX)
                 QX%NDIG = NDSAV1
              ENDDO
              CALL FMLN(MXY(25),MXY(12),QX)
              CALL FMI2M(1,MXY(7),QX)
              CALL FMDIV(MXY(7),MXY(2),MXY(6),QX)
              CALL FMSUB(MXY(6),MXY(12),MXY(7),QX)
              CALL FMSUB(MXY(7),MXY(22),MXY(23),QX)
              CALL FMEULR(MXY(24),QX)
              CALL FMI2M(1,MXY(12),QX)
              CALL FMADD(MXY(2),MXY(12),MXY(25),QX)
              CALL FMPSI(MXY(25),MXY(11),QX)
              CALL FMEQ(MXY(11),MXY(25),QX)
              CALL FMSUB(MXY(23),MXY(24),MXY(12),QX)
              CALL FMSUB(MXY(12),MXY(25),MXY(21),QX)
              K_RETURN_CODE = 1
              RETURN
          ENDIF

          CALL FMDP2M(0.5D0,MXY(12),QX)
          CALL FMI2M(20,MXY(7),QX)
          IF ((FMCOMP(MXY(1),'>',MXY(12),QX) .AND. FMCOMP(MXY(2),'>=',MXY(7),QX))) THEN
              CALL FMSP2M(0.7*REAL(QX%NDIG)*QX%ALOGMT,MXY(28),QX)
              IF (FMCOMP(MXY(2),'>=',MXY(28),QX)) THEN
                  NUP = 0
                  CALL FMEQ(MXY(2),MXY(32),QX)
                  CALL FMI2M(0,MXY(33),QX)
              ELSE
                  CALL FMSUB(MXY(28),MXY(2),MXY(12),QX)
                  CALL FMADDI(MXY(12),1,QX)
                  CALL FMM2I(MXY(12),NUP,QX)
                  CALL FMI2M(NUP,MXY(12),QX)
                  CALL FMADD(MXY(2),MXY(12),MXY(32),QX)
                  CALL FMI2M(1,MXY(33),QX)
                  CALL FMEQ(MXY(2),MXY(23),QX)
                  NDSAV1 = QX%NDIG
                  DO J = 1, NUP-1
                     CALL FMMPY_R1(MXY(23),MXY(1),QX)
                     CALL FMI2M(J,MXY(12),QX)
                     CALL FMADD(MXY(2),MXY(12),MXY(7),QX)
                     CALL FMDIV(MXY(23),MXY(7),MXY(24),QX)
                     QX%NDIG = NDSAV1
                     CALL FMADD_R1(MXY(33),MXY(24),QX)
                     QX%NDIG = MIN(NDSAV1,  &
                            MAX(QX%NGRD22,NDSAV1-INT(MXY(33)%MP(2)-MXY(24)%MP(2))+1))
                  ENDDO
                  QX%NDIG = NDSAV1
                  CALL FMPWR(MXY(1),MXY(2),MXY(12),QX)
                  CALL FMMPY(MXY(33),MXY(12),MXY(13),QX)
                  CALL FMI2M(1,MXY(7),QX)
                  CALL FMSUB(MXY(7),MXY(1),MXY(12),QX)
                  CALL FMPWR(MXY(12),MXY(3),MXY(33),QX)
                  CALL FMMPY_R2(MXY(13),MXY(33),QX)
                  CALL FMDIV_R1(MXY(33),MXY(2),QX)
              ENDIF

              CALL FMI2M(1,MXY(7),QX)
              CALL FMDIVI(MXY(7),2,MXY(12),QX)
              CALL FMSUB(MXY(32),MXY(12),MXY(29),QX)
              CALL FMLN(MXY(1),MXY(12),QX)
              CALL FMMPY(MXY(29),MXY(12),MXY(30),QX)
              IF (MXY(30)%MP(2) /= QX%MUNKNO .AND. MXY(30)%MP(3) /= 0)  &
                  MXY(30)%MP(1) = -MXY(30)%MP(1)
              CALL FMIGM2(MXY(3),MXY(30),MXY(31),QX)
              CALL FMPWR(MXY(30),MXY(3),MXY(12),QX)
              CALL FMEQ(MXY(30),MXY(13),QX)
              IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
                  MXY(13)%MP(1) = -MXY(13)%MP(1)
              CALL FMEXP(MXY(13),MXY(7),QX)
              CALL FMMPY(MXY(7),MXY(12),MXY(13),QX)
              CALL FMDIV_R1(MXY(31),MXY(13),QX)
              CALL FMEQ(MXY(31),MXY(22),QX)
              CALL FMSQR(MXY(29),MXY(12),QX)
              CALL FMMPYI(MXY(12),4,MXY(23),QX)
              CALL FMI2M(1,MXY(24),QX)
              CALL FMI2M(1,MXY(25),QX)
              CALL FMI2M(1,MXY(26),QX)
              CALL FMLN(MXY(1),MXY(12),QX)
              CALL FMDIVI(MXY(12),2,MXY(7),QX)
              CALL FMSQR(MXY(7),MXY(28),QX)
              NDSAV1 = QX%NDIG
              J4 = 0
              KRSAVE = QX%KROUND
              QX%KROUND = 1
              DO J = 1, NTERMS
                 JSWITCH = MAX(2,INT(QX%NDIG*QX%DLOGMB/(2.0D0*LOG(23.0)) + 2))
                 IF (J < JSWITCH) THEN
                     J4 = 0
                     CALL FMMPYI_R1(MXY(25),4,QX)
                     CALL FMMPYI(MXY(26),2*J-1,MXY(12),QX)
                     CALL FMMPYI(MXY(12),2*J,MXY(26),QX)
                     CALL FMI2M(2,MXY(7),QX)
                     CALL FMSUB(MXY(7),MXY(25),MXY(12),QX)
                     CALL FMDIV(MXY(12),MXY(26),MXY(27),QX)
                     CALL FMBERN(2*J,MXY(27),MXY(8),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
                     CALL FMEQ(MXY(8),MXY(27),QX)
                 ELSE
                     IF (J4 == 0) THEN
                         J4 = 1
                         N = 2*J
                         DO K = 1, 8
                            CALL FMI2M(KPRIME(K),MJSUMS(K),QX)
                            CALL FMIPWR(MJSUMS(K),N,MXY(12),QX)
                            CALL FMEQ(MXY(12),MJSUMS(K),QX)
                         ENDDO
                     ELSE
                         DO K = 1, 8
                            CALL FMMPYI_R1(MJSUMS(K),KPRIME(K)**2,QX)
                         ENDDO
                     ENDIF
                     CALL FMPI(MXY(18),QX)
                     CALL FMI2M(1,MXY(14),QX)
                     CALL FMI2M(1,MXY(15),QX)
                     DO K = 1, 8
                        CALL FMEQ(MJSUMS(K),MXY(17),QX)
                        CALL FMI2M(KPRIME(K)**2-1,MXY(12),QX)
                        JR = QX%KROUND
                        QX%KROUND = 1
                        CALL FMSUB(MXY(17),MXY(14),MXY(7),QX)
                        CALL FMDIV_R2(MXY(12),MXY(7),QX)
                        CALL FMSUB(MXY(14),MXY(7),MXY(16),QX)
                        QX%KROUND = JR
                        CALL FMI2M(1,MXY(12),QX)
                        IF (FMCOMP(MXY(16),'==',MXY(12),QX)) EXIT
                        CALL FMMPY_R1(MXY(15),MXY(16),QX)
                     ENDDO
                     CALL FMEQ(MJSUMS(1),MXY(17),QX)
                     CALL FMI2M(-1,MXY(7),QX)
                     CALL FMSQR(MXY(18),MXY(13),QX)
                     CALL FMDIV(MXY(7),MXY(13),MXY(12),QX)
                     CALL FMI2M(2,MXY(7),QX)
                     CALL FMSUB(MXY(7),MXY(17),MXY(6),QX)
                     CALL FMI2M(8,MXY(7),QX)
                     CALL FMSUB_R1(MXY(7),MXY(17),QX)
                     CALL FMDIV(MXY(6),MXY(7),MXY(13),QX)
                     CALL FMMPY(MXY(12),MXY(13),MXY(7),QX)
                     CALL FMMPY(MXY(7),MXY(15),MXY(16),QX)
                     CALL FMMPY_R2(MXY(16),MXY(27),QX)
                 ENDIF
                 CALL FMI2M(2*J-2,MXY(7),QX)
                 CALL FMADD(MXY(3),MXY(7),MXY(12),QX)
                 CALL FMMPY(MXY(12),MXY(31),MXY(7),QX)
                 CALL FMMPYI(MXY(7),2*J-1,MXY(31),QX)
                 CALL FMI2M(2*J-1,MXY(7),QX)
                 CALL FMADD(MXY(30),MXY(7),MXY(12),QX)
                 CALL FMMPY(MXY(24),MXY(12),MXY(7),QX)
                 CALL FMADD_R1(MXY(31),MXY(7),QX)
                 CALL FMDIV_R1(MXY(31),MXY(23),QX)
                 CALL FMMPY_R1(MXY(24),MXY(28),QX)
                 CALL FMMPY(MXY(27),MXY(31),MXY(19),QX)
                 QX%NDIG = NDSAV1
                 CALL FMADD_R1(MXY(22),MXY(19),QX)
                 IF (QX%KFLAG /= 0 .AND. J >= 3) EXIT
                 QX%NDIG = MIN(NDSAV1,MAX(QX%NGRD22,NDSAV1-INT(MXY(22)%MP(2)-  &
                                                         MXY(19)%MP(2))+1))
              ENDDO
              QX%KROUND = KRSAVE
              QX%NDIG = NDSAV1
              CALL FMPWR(MXY(1),MXY(29),MXY(12),QX)
              CALL FMLN(MXY(1),MXY(13),QX)
              IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
                  MXY(13)%MP(1) = -MXY(13)%MP(1)
              CALL FMPWR(MXY(13),MXY(3),MXY(21),QX)
              CALL FMMPY(MXY(22),MXY(12),MXY(7),QX)
              CALL FMMPY_R2(MXY(7),MXY(21),QX)
              CALL FMADD_R2(MXY(33),MXY(21),QX)
              K_RETURN_CODE = 1
              RETURN
          ENDIF
      ENDIF

!             If A or B is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(2)%MP(2)),INT(MXY(3)%MP(2)),0) ,  &
                   INT(1.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(3),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      RETURN
      END SUBROUTINE FMIBTA2

      SUBROUTINE FMIBTA3(MX,MA,MB,MC,MXY,K_RETURN_CODE,QX)

!  Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MX,MA,MB,MC
      INTEGER :: J,J1,J2,K,K1,K2,K_RETURN_CODE,KRSAVE,NDS,NDSAVE
      TYPE(FM_SETTINGS) :: QX
      INTENT (IN) :: MX,MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(37)

      J = QX%NTRACE
      QX%NTRACE = 0
      K = QX%KWARN
      QX%KWARN = 0
      NDSAVE = QX%NDIG
      KRSAVE = QX%KROUND
      QX%KROUND = 1
      CALL FMI2M(1,MXY(1),QX)
      CALL FMSUB(MXY(1),MX,MXY(2),QX)
      IF (MX%MP(1) < 0 .OR. MXY(2)%MP(1) < 0 .OR. MA%MP(1) < 0 .OR.  &
          MB%MP(1) < 0) GO TO 110
      IF (KRSAVE /= 1 .AND. (MXY(2)%MP(3) == 0 .OR. MX%MP(2) < -QX%NDIG .OR.  &
                             MA%MP(2) < -QX%NDIG .OR. MB%MP(2) < -QX%NDIG)) THEN
          IF (MXY(2)%MP(3) == 0) THEN
              QX%KROUND = KRSAVE
              CALL FMBETA(MA,MB,MC,QX)
              K_RETURN_CODE = 1
          ELSE IF (MX%MP(3) == 0) THEN
              QX%KROUND = KRSAVE
              CALL FMI2M(0,MC,QX)
              K_RETURN_CODE = 1
          ELSE
              QX%NDIG = QX%NDIG + QX%NGRD52
              CALL FMEQU(MX,MXY(1),NDSAVE,QX%NDIG,QX)
              CALL FMEQU(MA,MXY(2),NDSAVE,QX%NDIG,QX)
              CALL FMEQU(MB,MXY(3),NDSAVE,QX%NDIG,QX)
              CALL FMI2M(1,MXY(4),QX)
              CALL FMSUB(MXY(4),MXY(3),MXY(5),QX)
              CALL FMMPY(MXY(1),MXY(5),MXY(6),QX)
              CALL FMADD(MXY(2),MXY(4),MXY(7),QX)
              CALL FMDIV(MXY(6),MXY(7),MXY(8),QX)
              CALL FMDIV(MXY(4),MXY(2),MXY(9),QX)
              IF (MXY(9)%MP(2) - MXY(8)%MP(2) > QX%NDIG) THEN
                  CALL FMPWR(MXY(1),MXY(2),MXY(10),QX)
                  IF (MXY(10)%MP(2) > QX%MEXPUN .AND. MXY(10)%MP(2) < QX%MEXPOV) THEN
                      CALL FMDIV(MXY(10),MXY(2),MXY(11),QX)
                      CALL FMMPY(MXY(10),MXY(8),MXY(12),QX)
                      IF (MA%MP(2) < -NDSAVE) THEN
                          CALL FMLN(MXY(1),MXY(13),QX)
                          CALL FMADD_R1(MXY(12),MXY(13),QX)
                          CALL FMEQU(MXY(9),MXY(5),QX%NDIG,NDSAVE,QX)
                          CALL FMEQU(MXY(13),MXY(6),QX%NDIG,NDSAVE,QX)
                          QX%NDIG = NDSAVE
                          QX%KROUND = KRSAVE
                          CALL FMADD(MXY(5),MXY(6),MC,QX)
                          K_RETURN_CODE = 1
                      ELSE IF (MXY(11)%MP(2) < QX%MEXPOV) THEN
                          CALL FMEQU(MXY(11),MXY(5),QX%NDIG,NDSAVE,QX)
                          CALL FMEQU(MXY(5),MXY(13),NDSAVE,QX%NDIG,QX)
                          CALL FMSUB(MXY(11),MXY(13),MXY(8),QX)
                          IF (MXY(8)%MP(3) == 0) THEN
                              CALL FMEQU(MXY(12),MXY(6),QX%NDIG,NDSAVE,QX)
                              QX%NDIG = NDSAVE
                              QX%KROUND = KRSAVE
                              CALL FMADD(MXY(5),MXY(6),MC,QX)
                              IF (MC%MP(2) == QX%MUNKNO) THEN
                                  J1 = MXY(5)%MP(2)
                                  K1 = MXY(6)%MP(2)
                                  J2 = J1
                                  IF (J1 /= QX%MEXPUN .AND. J1 < 0) J2 = J1 + 2*QX%NDIG
                                  IF (J1 /= QX%MEXPOV .AND. J1 > 0) J2 = J1 - 2*QX%NDIG
                                  K2 = K1
                                  IF (K1 /= QX%MEXPUN .AND. K1 < 0) K2 = K1 + 2*QX%NDIG
                                  IF (K1 /= QX%MEXPOV .AND. K1 > 0) K2 = K1 - 2*QX%NDIG
                                  MXY(5)%MP(2) = J2
                                  MXY(6)%MP(2) = K2
                                  CALL FMADD(MXY(5),MXY(6),MC,QX)
                                  K2 = MC%MP(2) - (J2 - J1) - (K2 - K1)
                                  IF (MC%MP(2) /= QX%MUNKNO) MC%MP(2) = K2
                              ENDIF
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQU(MXY(11),MC,QX%NDIG,NDSAVE,QX)
                          ENDIF
                          K_RETURN_CODE = 1
                      ENDIF
                  ENDIF
              ENDIF
              IF (K_RETURN_CODE /= 1) THEN
                  CALL FMI2M(1,MXY(4),QX)
                  CALL FMSUB(MXY(4),MXY(1),MXY(5),QX)
                  CALL FMPWR(MXY(5),MXY(3),MXY(6),QX)
                  CALL FMDIV(MXY(4),MXY(3),MXY(7),QX)
                  CALL FMSUB(MXY(4),MXY(2),MXY(8),QX)
                  CALL FMMPY(MXY(1),MXY(8),MXY(9),QX)
                  CALL FMADD(MXY(3),MXY(4),MXY(10),QX)
                  CALL FMDIV(MXY(9),MXY(10),MXY(11),QX)
                  IF (MXY(6)%MP(2) <= QX%MEXPUN) THEN
                      QX%NDIG = NDSAVE
                      QX%KROUND = KRSAVE
                      CALL FMBETA(MA,MB,MC,QX)
                      K_RETURN_CODE = 1
                  ELSE
                      CALL FMADD(MXY(7),MXY(11),MXY(12),QX)
                      CALL FMMPY(MXY(6),MXY(12),MXY(8),QX)
                      QX%NDIG = NDSAVE
                      QX%KROUND = KRSAVE
                      CALL FMBETA(MA,MB,MC,QX)
                      IF (MC%MP(2) - MXY(8)%MP(2) > QX%NDIG) K_RETURN_CODE = 1
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

  110 QX%KFLAG = 0
      QX%NTRACE = J
      QX%KWARN = K
      QX%NDIG = NDSAVE
      QX%KROUND = KRSAVE
      IF (K_RETURN_CODE == 1) THEN
          IF (MC%MP(2) == QX%MUNKNO .AND. MX%MP(2) /= QX%MUNKNO .AND.  &
              MA%MP(2) /= QX%MUNKNO .AND. MB%MP(2) /= QX%MUNKNO) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMIBTA'
              QX%KFLAG = -4
              CALL FMWRN2(QX)
              QX%NCALL = QX%NCALL - 1
          ELSE IF (ABS(MC%MP(2)) == QX%MEXPOV .AND. ABS(MX%MP(2)) < QX%MEXPOV .AND.  &
                   ABS(MA%MP(2))  < QX%MEXPOV .AND. ABS(MB%MP(2)) < QX%MEXPOV) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMIBTA'
              IF (MC%MP(2) == QX%MEXPOV) QX%KFLAG = -5
              IF (MC%MP(2) == QX%MEXPUN) QX%KFLAG = -6
              CALL FMWRN2(QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMIBTA'
              CALL FMNTR(2,MX,MA,2,1,QX)
              IF (ABS(QX%NTRACE) >= 2 .AND. QX%NCALL <= QX%LVLTRC) THEN
                  NDS = QX%NDIG
                  QX%NDIG = NDSAVE
                  IF (QX%NTRACE < 0) THEN
                      CALL FMNTRJ(MB,QX%NDIG,QX)
                  ELSE
                      CALL FMPRNT(MB,QX)
                  ENDIF
                  QX%NDIG = NDS
              ENDIF
              CALL FMNTR(1,MC,MC,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMIBTA3

      SUBROUTINE FMIGM1(MA,MB,MC,QX)

!  MC = Incomplete Gamma(MA,MB)

!  Integral from 0 to MB of e**(-t) * t**(MA-1)  dt.

!  This is (lower case) gamma(a,x).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      DOUBLE PRECISION :: X,A,B,ERR,SMALL,BIG,TOL,T1,BIGJ,YT
      REAL (KIND(1.0D0)) :: MAXE,MODA2,MXSAVE
      INTEGER :: IEXTRA,INTA,INTG,J,JEXTRA,JR,JTERMS,K,KFLAG1,KFLAGA,KFLAGI,KFLAGX,KFLGOK,      &
                 KL,KOVUN,KR_RETRY,KRESLT,K_RETURN_CODE,KRSAVE,KWRNSV,KXNEG,LESS,NDGOAL,NDIG2,  &
                 NDOLD,NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NMNNDG,NMXDIF,NT,NTERMS,NUMTRY,N_ACC
      LOGICAL, EXTERNAL :: FMCOMP
      DOUBLE PRECISION, EXTERNAL :: FMDPLG
      REAL :: C,C1,C2,D,T,TLNB,Y
      TYPE(FM_SETTINGS) :: QX
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(19),MRETRY
      INTEGER :: INT_TEMP1

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      K_RETURN_CODE = 0
      IF (MB%MP(3) == 0) GO TO 110

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. (MA%MP(2) < -QX%NDIG .OR. MB%MP(2) < -QX%NDIG)) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          NDSAVE = QX%NDIG
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          QX%NDIG = QX%NDIG + QX%NGRD52
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
          CALL FMI2M(1,MXY(3),QX)
          CALL FMADD(MXY(1),MXY(3),MXY(4),QX)
          IF (MXY(1)%MP(3) /= 0 .AND. MXY(4)%MP(3) /= 0) THEN
              CALL FMDIV(MXY(2),MXY(4),MXY(6),QX)
              CALL FMMPY(MXY(6),MXY(1),MXY(5),QX)
              IF (MXY(3)%MP(2) - MXY(5)%MP(2) > QX%NDIG) THEN
                  CALL FMPWR(MXY(2),MXY(1),MXY(6),QX)
                  CALL FMDIV(MXY(6),MXY(1),MXY(7),QX)
                  CALL FMEQU(MXY(7),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
                  CALL FMSUB(MXY(7),MXY(8),MXY(6),QX)
                  IF (MXY(6)%MP(3) == 0) THEN
                      CALL FMMPY(MXY(5),MXY(7),MXY(8),QX)
                      CALL FMEQU(MXY(7),MXY(9),QX%NDIG,NDSAVE,QX)
                      CALL FMEQU(MXY(8),MXY(6),QX%NDIG,NDSAVE,QX)
                      QX%NDIG = NDSAVE
                      QX%KROUND = KRSAVE
                      CALL FMSUB(MXY(9),MXY(6),MC,QX)
                      IF (MC%MP(2) == QX%MUNKNO) THEN
                          CALL FMI2M(2,MXY(9),QX)
                          CALL FMMOD(MA,MXY(9),MXY(8),QX)
                          IF (MB%MP(1) < 0 .AND. MXY(8)%MP(3) /= 0) THEN
                              IF (KRSAVE ==  2) QX%KROUND = -1
                              IF (KRSAVE == -1) QX%KROUND =  2
                          ENDIF
                          CALL FMI2M(1,MXY(8),QX)
                          CALL FMSUB(MXY(8),MXY(5),MXY(6),QX)
                          CALL FMMPY(MXY(7),MXY(6),MC,QX)
                      ENDIF
                  ELSE
                      CALL FMSUB(MXY(3),MXY(5),MXY(6),QX)
                      CALL FMMPY(MXY(6),MXY(7),MXY(8),QX)
                      QX%KROUND = KRSAVE
                      CALL FMEQU(MXY(8),MC,QX%NDIG,NDSAVE,QX)
                  ENDIF
                  K_RETURN_CODE = 1
              ENDIF
              IF (K_RETURN_CODE /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
                  CALL FMDIV(MXY(3),MXY(1),MXY(4),QX)
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(6),MXY(5),NDSAVE,QX%NDIG,QX)
                  CALL FMSUB(MXY(4),MXY(5),MXY(6),QX)
                  IF (MXY(6)%MP(3) == 0) THEN
                      CALL FMI2M(0,MXY(5),QX)
                      CALL FMSUB(MXY(5),MXY(2),MXY(6),QX)
                      CALL FMEI(MXY(6),MXY(7),QX)
                      CALL FMLN(MXY(2),MXY(8),QX)
                      CALL FMSUB(MXY(7),MXY(8),MXY(9),QX)
                      CALL FMEULR(MXY(10),QX)
                      CALL FMSUB(MXY(9),MXY(10),MXY(11),QX)
                      CALL FMPWR(MXY(2),MXY(1),MXY(5),QX)
                      CALL FMMPY(MXY(5),MXY(11),MXY(12),QX)
                      CALL FMADD(MXY(8),MXY(12),MXY(13),QX)
                      CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                      CALL FMEQU(MXY(13),MXY(7),QX%NDIG,NDSAVE,QX)
                      QX%NDIG = NDSAVE
                      QX%KROUND = KRSAVE
                      CALL FMADD(MXY(6),MXY(7),MC,QX)
                      K_RETURN_CODE = 1
                  ENDIF
              ENDIF
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMIGM1'
                  CALL FMNTR(2,MA,MB,2,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              IF (MC%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO .AND.  &
                  MB%MP(2) /= QX%MUNKNO) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMIGM1'
                  QX%KFLAG = -4
                  CALL FMWRN2(QX)
                  QX%NCALL = QX%NCALL - 1
              ELSE IF (ABS(MC%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV .AND.  &
                       ABS(MB%MP(2))  < QX%MEXPOV) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMIGM1'
                  IF (MC%MP(2) == QX%MEXPOV) QX%KFLAG = -5
                  IF (MC%MP(2) == QX%MEXPUN) QX%KFLAG = -6
                  CALL FMWRN2(QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMIGM1'
                  CALL FMNTR(1,MC,MC,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

  110 CALL FMENT2('FMIGM1   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
      NUMTRY = 0

  130 NTERMS = INT(INTMAX/10)

!             Check for special cases.

!             See if A is small enough so that the result is X**A/A.

      CALL FMI2M(1,MXY(5),QX)
      JR = QX%KROUND
      QX%KROUND = 1
      CALL FMADD(MXY(1),MXY(5),MXY(4),QX)
      QX%KROUND = JR
      IF (FMCOMP(MXY(4),'==',MXY(5),QX)) THEN
          CALL FMPWR(MXY(2),MXY(1),MXY(5),QX)
          CALL FMDIV(MXY(5),MXY(1),MXY(13),QX)
          IF (MXY(13)%MP(2) /= QX%MUNKNO) GO TO 200
      ENDIF

!             Check to see if X is large enough so that the result is Gamma(A).

      CALL FMI2M(1,MXY(5),QX)
      CALL FMDIV(MXY(1),MXY(2),MXY(4),QX)
      MXY(4)%MP(1) = 1
      CALL FMDPM(DBLE(0.001),MXY(3),QX)
      IF (FMCOMP(MXY(2),'>',MXY(5),QX) .AND. FMCOMP(MXY(4),'<=',MXY(3),QX)) THEN
          CALL FMI2M(1,MXY(4),QX)
          CALL FMSUB(MXY(1),MXY(4),MXY(5),QX)
          CALL FMLN(MXY(2),MXY(6),QX)
          CALL FMMPY(MXY(5),MXY(6),MXY(4),QX)
          CALL FMSUB(MXY(4),MXY(2),MXY(6),QX)
          CALL FMEXP(MXY(6),MXY(15),QX)
          IF (MXY(15)%MP(2) /= QX%MUNKNO) THEN
              CALL FMGAM(MXY(1),MXY(14),QX)
              CALL FMSUB_R1(MXY(14),MXY(15),QX)
              IF (MXY(14)%MP(2) > MXY(15)%MP(2)+QX%NDIG .AND.  &
                  MXY(14)%MP(2) /= QX%MUNKNO) THEN
                  CALL FMEQ(MXY(14),MXY(13),QX)
                  GO TO 200
              ENDIF
          ENDIF
      ENDIF

!             A,X are double precision approximations to the two arguments to this function.
!             INTA = A if A is a small integer.  It is used to limit the number of terms used in
!                    the asymptotic series and in the continued fraction expansion.

      INTA = NTERMS
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(1),INTG,QX)
      KFLAGI = QX%KFLAG
      IF (QX%KFLAG == 0) INTA = INTG
      CALL FMM2DP(MXY(1),A,QX)
      KFLAGA = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          A = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) A = -A
          KFLAGA = 0
      ENDIF
      CALL FMM2DP(MXY(2),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(2)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(2)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF
      QX%KWARN = KWRNSV

!             If A or X is large in magnitude, use more guard digits.

      J = MXY(1)%MP(2)
      IF (MXY(1)%MP(3) >= SQRT(DBLE(QX%MBASE))) J = J + 1
      K = MXY(2)%MP(2)
      IF (MXY(2)%MP(3) >= SQRT(DBLE(QX%MBASE))) K = K + 1
      IEXTRA = MIN(MAX(J,K,0) , INT(1.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      NDOLD = QX%NDIG
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             KXNEG = 1 if X is negative and A is a positive integer.

      KXNEG = 0

!             MODA2 = MOD(A,2) when KXNEG is 1.

      MODA2 = 0

      IF (MXY(1)%MP(2) == QX%MEXPOV .OR. MXY(2)%MP(2) == QX%MEXPOV) THEN
          IF (MXY(1)%MP(2) == QX%MEXPOV .AND. MXY(1)%MP(1) > 0) THEN
              IF (MXY(2)%MP(3) == 0) THEN
                  CALL FMI2M(0,MXY(13),QX)
                  GO TO 180
              ENDIF
              IF (MXY(2)%MP(2) == QX%MEXPOV .AND. MXY(2)%MP(1) > 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(13),QX)
                  QX%KFLAG = -5
                  GO TO 180
              ELSE IF (MXY(2)%MP(1) > 0) THEN
                  CALL FMI2M(1,MXY(13),QX)
                  IF (FMCOMP(MXY(2),'<=',MXY(13),QX)) THEN
                      CALL FMST2M('UNDERFLOW',MXY(13),QX)
                      QX%KFLAG = -6
                      GO TO 180
                  ELSE
                      CALL FMST2M('OVERFLOW',MXY(13),QX)
                      QX%KFLAG = -5
                      GO TO 180
                  ENDIF
              ENDIF
          ENDIF
          IF (MXY(2)%MP(2) == QX%MEXPOV .AND. MXY(2)%MP(1) > 0) THEN
              CALL FMGAM(MXY(1),MXY(15),QX)
              CALL FMEQ(MXY(15),MXY(13),QX)
              GO TO 180
          ENDIF
          IF (MXY(2)%MP(2) == QX%MEXPOV .AND. MXY(2)%MP(1) < 0 .AND.  &
              MXY(1)%MP(1) > 0.AND. MXY(1)%MP(3) > 0) THEN
              IF (MXY(1)%MP(2) /= QX%MEXPOV) THEN
                  CALL FMINT(MXY(1),MXY(12),QX)
                  IF (FMCOMP(MXY(1),'==',MXY(12),QX)) THEN
                      CALL FMI2M(2,MXY(9),QX)
                      CALL FMMOD(MXY(12),MXY(9),MXY(5),QX)
                      CALL FMEQ(MXY(5),MXY(9),QX)
                      IF (MXY(9)%MP(3) /= 0) THEN
                          CALL FMST2M('-OVERFLOW',MXY(13),QX)
                          QX%KFLAG = -5
                          GO TO 180
                      ELSE
                          CALL FMST2M('OVERFLOW',MXY(13),QX)
                          QX%KFLAG = -5
                          GO TO 180
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
          CALL FMST2M('UNKNOWN',MXY(13),QX)
          QX%KFLAG = -4
          GO TO 200
      ENDIF

      IF (MXY(1)%MP(2) == QX%MEXPUN .OR. MXY(2)%MP(2) == QX%MEXPUN) THEN
          CALL FMABS(MXY(1),MXY(4),QX)
          CALL FMI2M(1,MXY(5),QX)
          IF (FMCOMP(MXY(4),'<',MXY(5),QX) .AND. MXY(2)%MP(2) == QX%MEXPUN) THEN
              CALL FMST2M('UNKNOWN',MXY(13),QX)
              QX%KFLAG = -4
              GO TO 200
          ENDIF
          CALL FMABS(MXY(1),MXY(4),QX)
          CALL FMI2M(1,MXY(5),QX)
          IF (FMCOMP(MXY(4),'>=',MXY(5),QX) .AND. MXY(2)%MP(2) == QX%MEXPUN .AND.  &
              MXY(1)%MP(1) > 0 .AND. MXY(2)%MP(1) > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(13),QX)
              QX%KFLAG = -6
              GO TO 200
          ENDIF
      ENDIF

      IF (MXY(1)%MP(1) < 0 .OR. MXY(1)%MP(3) == 0) THEN
          CALL FMINT(MXY(1),MXY(12),QX)
          IF (FMCOMP(MXY(1),'==',MXY(12),QX)) THEN
              CALL FMST2M('UNKNOWN',MXY(13),QX)
              QX%KFLAG = -4
              GO TO 200
          ENDIF
      ENDIF
      IF (MXY(2)%MP(3) == 0) THEN
          IF (MXY(1)%MP(1) <= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(13),QX)
              QX%KFLAG = -4
              GO TO 200
          ELSE
              CALL FMI2M(0,MXY(13),QX)
              GO TO 200
          ENDIF
      ENDIF
      IF (MXY(2)%MP(1) < 0) THEN
          CALL FMINT(MXY(1),MXY(12),QX)
          IF (FMCOMP(MXY(1),'==',MXY(12),QX)) THEN
              KXNEG = 1
              CALL FMI2M(2,MXY(9),QX)
              CALL FMMOD(MXY(12),MXY(9),MXY(5),QX)
              CALL FMEQ(MXY(5),MXY(9),QX)
              IF (MXY(9)%MP(3) /= 0) MODA2 = 1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(13),QX)
              QX%KFLAG = -4
              GO TO 200
          ENDIF
      ENDIF
      CALL FMMAX(MXY(1),MXY(2),MXY(5),QX)
      CALL FMMIN(MXY(1),MXY(2),MXY(6),QX)
      CALL FMDPM(1.0D6,MXY(3),QX)
      CALL FMDPM(1.0D2,MXY(4),QX)
      IF (FMCOMP(MXY(5),'>=',MXY(3),QX) .AND. FMCOMP(MXY(6),'>=',MXY(4),QX)) THEN
          CALL FMI2M(1,MXY(5),QX)
          CALL FMSUB(MXY(1),MXY(5),MXY(7),QX)
          CALL FMMIN(MXY(7),MXY(2),MXY(8),QX)
          CALL FMADDI(MXY(8),-1,QX)
          CALL FMLN(MXY(8),MXY(5),QX)
          CALL FMMPY(MXY(7),MXY(5),MXY(4),QX)
          CALL FMSUB(MXY(4),MXY(8),MXY(5),QX)
          CALL FMEXP(MXY(5),MXY(10),QX)
          IF ((MXY(10)%MP(2) == QX%MEXPOV .AND. MXY(10)%MP(1) > 0) .OR.  &
              MXY(10)%MP(2) > MXSAVE+1) THEN
              CALL FMST2M('OVERFLOW',MXY(13),QX)
              QX%KFLAG = -5
              GO TO 180
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(5),QX)
      IF (FMCOMP(MXY(1),'==',MXY(5),QX) .AND. MXY(2)%MP(2) >= 0) THEN
          IF (ABS(MXY(2)%MP(2)) < QX%MEXPOV) THEN
              CALL FMEQ(MXY(2),MXY(6),QX)
              IF (MXY(6)%MP(2) /= QX%MUNKNO .AND. MXY(6)%MP(3) /= 0)  &
                  MXY(6)%MP(1) = -MXY(6)%MP(1)
              CALL FMEXP(MXY(6),MXY(7),QX)
              CALL FMSUB(MXY(5),MXY(7),MXY(13),QX)
              IF (MXY(13)%MP(2) /= QX%MUNKNO) GO TO 200
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      CALL FMI2M(-10000,MXY(8),QX)
      CALL FMI2M(10000,MXY(9),QX)
      CALL FMABS(MXY(1),MXY(11),QX)
      CALL FMABS(MXY(2),MXY(12),QX)
      CALL FMSUB(MXY(12),MXY(11),MXY(10),QX)

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      IF (KFLAGA /= 0 .OR. KFLAGX /= 0) THEN
          CALL FMDIV(MXY(12),MXY(11),MXY(10),QX)
          CALL FMI2M(1,MXY(8),QX)
          CALL FMSUB(MXY(8),MXY(10),MXY(9),QX)
          IF (MXY(9)%MP(1) < 0) THEN
              NMETHD = 2
          ELSE
              NMETHD = 1
          ENDIF
      ELSE
          T1 = FMDPLG(A,QX)
          SMALL = T1 - FMDPLG(-ABS(X),QX) - (A+ABS(X))*LOG(ABS(X))
          TOL = -DBLE(QX%NDIG+2)*QX%DLOGMB - 12.0D0
          B = 1.0D0
          IF (A > ABS(X)) B = A - ABS(X)
          BIG = T1 - FMDPLG(A-B,QX) - B*LOG(ABS(X))

          IF (FMCOMP(MXY(10),'<=',MXY(8),QX)) THEN
              NMETHD = 1
          ELSE IF (FMCOMP(MXY(10),'>=',MXY(9),QX) .AND. MXY(1)%MP(1) > 0  &
                   .AND. MXY(2)%MP(1) > 0) THEN
              NMETHD = 3
              IF (SMALL < TOL+BIG) NMETHD = 2
          ELSE IF (FMCOMP(MXY(10),'>=',MXY(9),QX)) THEN
              NMETHD = 3
          ELSE IF (MXY(1)%MP(1) > 0 .AND. MXY(2)%MP(1) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(8),QX)
              IF (FMCOMP(MXY(2),'>=',MXY(8),QX)) THEN
                  QX%KFLAG = -5
                  CALL FMST2M('OVERFLOW',MXY(13),QX)
                  GO TO 180
              ENDIF

              C2 = REAL(DBLE(NDSAVE)*QX%DLOGMB)
              C1 = REAL(DBLE(C2)/10.0D0 + A + 10.0D0)
              C2 = REAL(MAX( 10.0D0 , DBLE(C2)/6.0D0 , A - 3.5D0*A/(SQRT(A)+1.0D0)))
              IF (X < C1) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
              IF (X > C2) THEN
                  NMETHD = 3
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
          ELSE IF (MXY(1)%MP(1) < 0 .AND. MXY(2)%MP(1) > 0) THEN
              TLNB = REAL(QX%NDIG)*QX%ALOGMB
              C = 0.75/TLNB**0.35
              D = 0.80*TLNB**0.70
              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T = REAL(-A) - D/C
                  Y = D + C*T/2.0 + (C/2.0)*SQRT(T**2 + T + (2.0/C)**2)
                  IF (X > Y) THEN
                      NMETHD = 3
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE
                  CALL FMDPM(DBLE(C),MXY(5),QX)
                  CALL FMMPY(MXY(5),MXY(1),MXY(8),QX)
                  MXY(8)%MP(1) = 1
                  IF (FMCOMP(MXY(2),'>',MXY(8),QX)) THEN
                      NMETHD = 3
                  ELSE
                      NMETHD = 1
                  ENDIF
              ENDIF
          ELSE IF (MXY(1)%MP(1) > 0 .AND. MXY(2)%MP(1) < 0) THEN
              CALL FMDPM(DBLE(-0.8),MXY(5),QX)
              CALL FMMPY(MXY(5),MXY(1),MXY(8),QX)
              IF (FMCOMP(MXY(8),'<',MXY(2),QX)) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 170

!             Method 1.  Use the X**N/Pochhammer(A+1,N) series.

!             MXY(13) = MXY(18) + MXY(19) is the current sum.
!             MXY(9) is the current term.
!             MXY(8) is (A+N)/X.
!             MXY(14) is 1/X

!             Raise the precision if A is negative and near an integer, to compensate
!             for cancellation when (A+N)/X is near zero.

      IF (MXY(1)%MP(1) < 0) THEN
          CALL FMNINT(MXY(1),MXY(18),QX)
          CALL FMSUB(MXY(1),MXY(18),MXY(14),QX)
          IEXTRA = MAX(-INT(MXY(14)%MP(2)),0)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
              CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
          NDOLD = QX%NDIG
          QX%NDIG = QX%NDIG + IEXTRA
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      ENDIF

      JEXTRA = 0

  140 CALL FMI2M(1,MXY(18),QX)
      CALL FMI2M(0,MXY(19),QX)
      CALL FMI2M(1,MXY(7),QX)
      CALL FMADD(MXY(1),MXY(7),MXY(8),QX)
      CALL FMDIV(MXY(2),MXY(8),MXY(9),QX)
      CALL FMDIV_R1(MXY(8),MXY(2),QX)
      CALL FMDIV(MXY(7),MXY(2),MXY(14),QX)
      NDSAV1 = QX%NDIG
      MAXE = 1

!             If A is negative and ABS(A) > ABS(X), the terms in the series first decrease,
!             then increase, then decrease.  Try to predict the number of extra digits required
!             to keep the precision from prematurely becoming too small.

      KFLGOK = 1
      IF (MXY(1)%MP(1) < 0) THEN
          IF (KFLAGA == 0) THEN
              IF (ABS(A) > 1.0D3) THEN
                  NMETHD = 3
                  GO TO 170
              ENDIF
          ELSE
              NMETHD = 3
              GO TO 170
          ENDIF
          KFLGOK = 0
          CALL FMABS(MXY(1),MXY(3),QX)
          CALL FMABS(MXY(2),MXY(4),QX)
          IF (FMCOMP(MXY(3),'>',MXY(4),QX)) THEN
              IF (JEXTRA == 0) THEN
                  IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                      T1 = FMDPLG(A+AINT(-ABS(X)-A),QX) - FMDPLG(A+1.0D0+AINT(ABS(X)-A),QX)
                      T1 = (T1 + 2.0D0*ABS(X)*LOG(ABS(X)+1.0D-10))/QX%DLOGMB
                      T1 = MAX(0.0D0,T1+1.0D0)
                      JEXTRA = T1
                  ENDIF
              ENDIF

!             If A is negative and ABS(A) is much bigger than ABS(X), the later increase in
!             the size of the terms can be ignored.

              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T1 = (AINT(X-A)*LOG(ABS(X)+1.0D-10) + FMDPLG(A+1.0D0,QX)  &
                       - FMDPLG(A+1.0D0+AINT(X-A),QX)) / QX%DLOGMB
                  IF (T1 < -DBLE(QX%NDIG)) KFLGOK = 1
              ELSE
                  KFLGOK = 1
              ENDIF
          ENDIF
      ENDIF

      NMNNDG = NDSAV1
      NMXDIF = 0

!             Method 1 summation loop.

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      DO J = 1, NTERMS
         QX%NDIG = NDSAV1
         MAXE = MAX(MAXE,MXY(9)%MP(2))
         IF (MXY(9)%MP(1) > 0) THEN
             CALL FMADD(MXY(18),MXY(9),MXY(17),QX)
             INT_TEMP1 = QX%KFLAG
             CALL FMEQ(MXY(17),MXY(18),QX)
         ELSE
             CALL FMADD(MXY(19),MXY(9),MXY(17),QX)
             INT_TEMP1 = QX%KFLAG
             CALL FMEQ(MXY(17),MXY(19),QX)
         ENDIF
         CALL FMADD(MXY(18),MXY(19),MXY(13),QX)
         QX%KFLAG = INT_TEMP1
         IF (QX%KFLAG /= 0 .AND. (J > 2 .OR. ABS(MXY(18)%MP(2)) > QX%MXEXP .OR.  &
             ABS(MXY(19)%MP(2)) > QX%MXEXP)) THEN
             IF (KFLGOK == 0 .AND. KFLAGA == 0 .AND. KFLAGX == 0) THEN
                 IF (DBLE(J) > X-A) EXIT
             ELSE
                 EXIT
             ENDIF
         ENDIF

         CALL FMCSADD_R1(MXY(8),MXY(14),QX)

         NDIG2 = MAX(QX%NGRD22,NDSAV1-INT(MXY(13)%MP(2)-MXY(9)%MP(2)))
         QX%NDIG = MIN(NDSAV1,NDIG2+JEXTRA)
         NMNNDG = MIN(NMNNDG,QX%NDIG)
         NMXDIF = MAX(NMXDIF,QX%NDIG-NMNNDG)
         CALL FMCSDIV(MXY(9),MXY(8),MXY(5),QX)
         CALL FMEQ(MXY(5),MXY(9),QX)
      ENDDO
      CALL FMADD(MXY(18),MXY(19),MXY(17),QX)
      CALL FMCANCEL(MXY(18),MXY(19),MXY(17),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(17),MXY(13),QX)

      QX%NDIG = NDSAV1
      IF (NMXDIF > JEXTRA+1) THEN
          JEXTRA = NMXDIF
          GO TO 140
      ENDIF

      CALL FMABS(MXY(2),MXY(5),QX)
      CALL FMLN(MXY(5),MXY(6),QX)
      CALL FMMPY(MXY(1),MXY(6),MXY(4),QX)
      CALL FMSUB(MXY(4),MXY(2),MXY(14),QX)
      CALL FMEXP(MXY(14),MXY(15),QX)
      IF (MXY(15)%MP(2) == QX%MUNKNO) THEN
          CALL FMPWR(MXY(5),MXY(1),MXY(4),QX)
          CALL FMEXP(MXY(2),MXY(6),QX)
          CALL FMDIV(MXY(4),MXY(6),MXY(15),QX)
      ENDIF
      CALL FMDIV(MXY(13),MXY(1),MXY(12),QX)
      CALL FMMPY(MXY(15),MXY(12),MXY(11),QX)
      IF (MXY(11)%MP(2) == QX%MUNKNO) THEN
          CALL FMLN(MXY(13),MXY(5),QX)
          CALL FMLN(MXY(1),MXY(6),QX)
          CALL FMADD(MXY(14),MXY(5),MXY(4),QX)
          CALL FMSUB(MXY(4),MXY(6),MXY(14),QX)
          CALL FMEXP(MXY(14),MXY(13),QX)
      ELSE
          CALL FMEQ(MXY(11),MXY(13),QX)
      ENDIF
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MXY(13)%MP(2) /= QX%MUNKNO  &
          .AND. MXY(13)%MP(3) /= 0) THEN
          MXY(13)%MP(1) = -MXY(13)%MP(1)
      ENDIF

      GO TO 180

!             Method 2.  Use the Pochhammer(A-N,N)/X**N series.

!             MXY(13) = MXY(18) + MXY(19) is the current sum.
!             MXY(9) is the current term.
!             MXY(8) is (A-N)/X.
!             MXY(14) is -1/X

!             Raise the precision if A is positive and near an integer, to compensate for
!             cancellation when (A-N)/X is near zero.

  150 IF (MXY(1)%MP(1) > 0) THEN
          CALL FMNINT(MXY(1),MXY(13),QX)
          CALL FMSUB(MXY(1),MXY(13),MXY(14),QX)
          IEXTRA = MAX(-INT(MXY(14)%MP(2)),0)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
              CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
          NDOLD = QX%NDIG
          QX%NDIG = QX%NDIG + IEXTRA
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

      CALL FMGAM(MXY(1),MXY(15),QX)
      IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          NT = INT(((A-1)*LOG(ABS(X)+1.0D-10) - X)/QX%DLOGMB)
          LESS = MAX(0,INT(MXY(15)%MP(2)) - NT - 1)
          IF (LESS > QX%NDIG .AND. ABS(A) < ABS(X)) THEN
              CALL FMEQ(MXY(15),MXY(13),QX)
              GO TO 180
          ENDIF
      ENDIF
      IF (QX%KFLAG /= 0) THEN
          CALL FMEQ(MXY(15),MXY(13),QX)
          GO TO 180
      ENDIF
      IF (KXNEG == 0) THEN
          CALL FMLN(MXY(2),MXY(14),QX)
          CALL FMMPY(MXY(1),MXY(14),MXY(5),QX)
          CALL FMSUB(MXY(5),MXY(2),MXY(13),QX)
          CALL FMSUB_R2(MXY(13),MXY(14),QX)
          CALL FMEXP(MXY(14),MXY(9),QX)
      ELSE
          CALL FMI2M(1,MXY(5),QX)
          CALL FMSUB(MXY(1),MXY(5),MXY(13),QX)
          CALL FMPWR(MXY(2),MXY(13),MXY(14),QX)
          CALL FMEXP(MXY(2),MXY(12),QX)
          CALL FMDIV(MXY(14),MXY(12),MXY(9),QX)
      ENDIF

!             Here MXY(9) is X**(A-1)/EXP(X).

      IF (MXY(9)%MP(2) /= QX%MUNKNO .AND. MXY(9)%MP(3) /= 0)  &
          MXY(9)%MP(1) = -MXY(9)%MP(1)
      CALL FMEQ(MXY(15),MXY(13),QX)
      IF (MXY(15)%MP(1) > 0) THEN
          CALL FMEQ(MXY(15),MXY(18),QX)
          CALL FMI2M(0,MXY(19),QX)
      ELSE
          CALL FMEQ(MXY(15),MXY(19),QX)
          CALL FMI2M(0,MXY(18),QX)
      ENDIF
      CALL FMDIV(MXY(1),MXY(2),MXY(8),QX)
      CALL FMI2M(1,MXY(5),QX)
      CALL FMDIV(MXY(5),MXY(2),MXY(14),QX)
      IF (MXY(14)%MP(2) /= QX%MUNKNO .AND. MXY(14)%MP(3) /= 0)  &
          MXY(14)%MP(1) = -MXY(14)%MP(1)
      NDSAV1 = QX%NDIG

!             Disable NDIG reduction until the terms in the sum begin to decrease in size.

      BIGJ = 0
      IF (KFLAGA == 0 .AND. KFLAGX == 0) BIGJ = ABS(A) - ABS(X)
      JTERMS = NTERMS
      IF (KFLAGI == 0 .AND. INTA > 0) THEN
          JTERMS = INTA
      ELSE IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          T1 = A + ABS(X)
          IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
      ENDIF

!             Method 2 summation loop.

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      DO J = 1, JTERMS
         QX%NDIG = NDSAV1
         CALL FMCSADD_R1(MXY(13),MXY(9),QX)
         IF (MXY(9)%MP(1) > 0) THEN
             CALL FMADD_R2(MXY(9),MXY(18),QX)
         ELSE
             CALL FMADD_R2(MXY(9),MXY(19),QX)
         ENDIF
         K = MAX(MXY(18)%MP(2),MXY(19)%MP(2)) - QX%NDIG
         IF (MXY(9)%MP(2) < K) QX%KFLAG = 1
         IF (QX%KFLAG /= 0 .AND. J > 1) GO TO 160
         CALL FMCSADD_R1(MXY(8),MXY(14),QX)
         IF (REAL(J) >= BIGJ) THEN
             CALL FMADD(MXY(18),MXY(19),MXY(13),QX)
             NDIG2 = MAX(QX%NGRD22,NDSAV1-INT(MXY(13)%MP(2)-MXY(9)%MP(2)))
             QX%NDIG = MIN(NDSAV1,NDIG2)
         ENDIF
         CALL FMCSMPY_R1(MXY(9),MXY(8),QX)
      ENDDO

  160 QX%NDIG = NDSAV1
      CALL FMADD(MXY(18),MXY(19),MXY(13),QX)
      CALL FMCANCEL(MXY(18),MXY(19),MXY(13),K,QX)
      N_ACC = N_ACC - K
      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) = MXY(18) + MXY(19) is the current approximation.
!             MXY(13) is the term in the sum, S(k).
!             MXY(11), MXY(12) are the latest denominators, Q(k-1) and Q(k).

  170 CALL FMGAM(MXY(1),MXY(15),QX)
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      NDSAV1 = QX%NDIG
      IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          YT = MIN(DBLE(HUGE(1))/11,AINT(((A-1)*LOG(ABS(X)+1.0D-10) - X)/QX%DLOGMB))
          NT = HUGE(1)/10
          NT = MIN(DBLE(NT),YT)
          LESS = MAX(0,INT(MXY(15)%MP(2)) - NT - 1)
          IF (LESS > QX%NDIG) THEN
              CALL FMEQ(MXY(15),MXY(13),QX)
              GO TO 180
          ENDIF
          QX%NDIG = MIN(NDSAV1,MAX(QX%NGRD22,QX%NDIG-LESS))
      ENDIF
      JEXTRA = INT(MAX(1.0,5.76/QX%ALOGMB + 1.0))
      IF (QX%NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA,QX)
          CALL FMEQU_R1(MXY(2),NDSAV1,NDSAV1+JEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + JEXTRA
      CALL FMEQU(MXY(1),MXY(8),NDSAV1,QX%NDIG,QX)
      IF (MXY(8)%MP(2) /= QX%MUNKNO .AND. MXY(8)%MP(3) /= 0)  &
          MXY(8)%MP(1) = -MXY(8)%MP(1)
      CALL FMI2M(1,MXY(11),QX)
      CALL FMEQU(MXY(2),MXY(12),NDSAV1,QX%NDIG,QX)
      CALL FMI2M(1,MXY(5),QX)
      CALL FMDIV(MXY(5),MXY(12),MXY(13),QX)
      IF (MXY(13)%MP(1) > 0) THEN
          CALL FMEQ(MXY(13),MXY(18),QX)
          CALL FMI2M(0,MXY(19),QX)
      ELSE
          CALL FMEQ(MXY(13),MXY(19),QX)
          CALL FMI2M(0,MXY(18),QX)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Method 3 continued fraction loop.

      NDSAV2 = QX%NDIG
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      DO J = 1, MIN(NTERMS,INTA-1)
         CALL FMADDI(MXY(8),1,QX)
         CALL FMEQ(MXY(8),MXY(10),QX)
         CALL FMCSMPY_R1(MXY(10),MXY(11),QX)
         CALL FMADD(MXY(12),MXY(10),MXY(9),QX)
         CALL FMEQ(MXY(10),MXY(6),QX)
         CALL FMCSMPY_R1(MXY(6),MXY(13),QX)
         CALL FMCSDIV(MXY(6),MXY(9),MXY(13),QX)
         IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
             MXY(13)%MP(1) = -MXY(13)%MP(1)
         QX%NDIG = NDSAV2
         IF (MXY(13)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(18),MXY(13),QX)
         ELSE
             CALL FMADD_R1(MXY(19),MXY(13),QX)
         ENDIF
         KFLAG1 = QX%KFLAG
         CALL FMADD(MXY(18),MXY(19),MXY(14),QX)
         CALL FMEQ(MXY(12),MXY(11),QX)
         CALL FMEQ(MXY(9),MXY(12),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(14)%MP(2)-MXY(13)%MP(2))))
         CALL FMCSMPYI(MXY(11),J,MXY(10),QX)
         CALL FMEQ(MXY(2),MXY(6),QX)
         CALL FMCSMPY_R1(MXY(6),MXY(12),QX)
         CALL FMADD(MXY(6),MXY(10),MXY(9),QX)
         CALL FMEQ(MXY(10),MXY(6),QX)
         CALL FMCSMPY_R1(MXY(6),MXY(13),QX)
         CALL FMCSDIV(MXY(6),MXY(9),MXY(13),QX)
         IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
             MXY(13)%MP(1) = -MXY(13)%MP(1)
         QX%NDIG = NDSAV2
         IF (MXY(13)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(18),MXY(13),QX)
         ELSE
             CALL FMADD_R1(MXY(19),MXY(13),QX)
         ENDIF

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. QX%KFLAG == 1 .AND. J > 2) THEN
             EXIT
         ENDIF
         CALL FMADD(MXY(18),MXY(19),MXY(14),QX)
         CALL FMEQ(MXY(12),MXY(11),QX)
         CALL FMEQ(MXY(9),MXY(12),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(14)%MP(2)-MXY(13)%MP(2))))
      ENDDO

      QX%NDIG = NDSAV2
      CALL FMEQU_R1(MXY(14),QX%NDIG,NDSAV1,QX)
      CALL FMEQU_R1(MXY(18),QX%NDIG,NDSAV1,QX)
      CALL FMEQU_R1(MXY(19),QX%NDIG,NDSAV1,QX)
      QX%NDIG = NDSAV1
      IF (MXY(2)%MP(1) > 0) THEN
          CALL FMLN(MXY(2),MXY(5),QX)
          CALL FMMPY(MXY(1),MXY(5),MXY(4),QX)
          CALL FMSUB(MXY(4),MXY(2),MXY(5),QX)
          CALL FMEXP(MXY(5),MXY(12),QX)
      ELSE IF (KFLAGI == 0) THEN
          CALL FMEXP(MXY(2),MXY(13),QX)
          CALL FMIPWR(MXY(2),INTA,MXY(5),QX)
          CALL FMDIV(MXY(5),MXY(13),MXY(12),QX)
      ELSE
          CALL FMABS(MXY(2),MXY(5),QX)
          CALL FMLN(MXY(5),MXY(6),QX)
          CALL FMMPY(MXY(1),MXY(6),MXY(4),QX)
          CALL FMSUB(MXY(4),MXY(2),MXY(5),QX)
          CALL FMEXP(MXY(5),MXY(12),QX)
          IF (MODA2 == 1 .AND. MXY(12)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(12)%MP(3) /= 0) MXY(12)%MP(1) = -MXY(12)%MP(1)
      ENDIF

      IF (MXY(12)%MP(2) /= QX%MEXPOV) THEN
          CALL FMMPY_R2(MXY(12),MXY(18),QX)
          CALL FMMPY_R2(MXY(12),MXY(19),QX)
      ELSE IF (MXY(12)%MP(2)+MXY(14)%MP(2) >= QX%MXEXP2/2) THEN
          CALL FMEQ(MXY(12),MXY(13),QX)
          IF (MXY(14)%MP(1) < 0 .AND. MXY(13)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(13)%MP(3) /= 0) MXY(13)%MP(1) = -MXY(13)%MP(1)
      ELSE
          CALL FMMPY_R2(MXY(12),MXY(18),QX)
          CALL FMMPY_R2(MXY(12),MXY(19),QX)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      IF (MXY(15)%MP(1) > 0) THEN
          CALL FMSUB(MXY(15),MXY(19),MXY(17),QX)
          CALL FMMPYI(MXY(18),-1,MXY(19),QX)
          CALL FMEQ(MXY(17),MXY(18),QX)
      ELSE
          CALL FMSUB(MXY(15),MXY(18),MXY(17),QX)
          CALL FMMPYI(MXY(19),-1,MXY(18),QX)
          CALL FMEQ(MXY(17),MXY(19),QX)
      ENDIF
      CALL FMADD(MXY(18),MXY(19),MXY(13),QX)
      CALL FMCANCEL(MXY(18),MXY(19),MXY(13),K,QX)
      N_ACC = N_ACC - K

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(13)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(13)%MP(J+1)) GO TO 190
              ENDDO
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = QX%NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQU_R1(MXY(2),NDSAVE,QX%NDIG,QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(13),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 130
      ENDIF

  200 CALL FMEXT2(MXY(13),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMIGM1

      SUBROUTINE FMIGM2(MA,MB,MC,QX)

!  MC = Incomplete Gamma(MA,MB)

!  Integral from MB to infinity of e**(-t) * t**(MA-1)  dt.

!  This is (upper case) Gamma(a,x).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      DOUBLE PRECISION :: X,A,B,ERR,SMALL,BIG,TOL,T1,T2,BIGJ,C1,C2
      REAL (KIND(1.0D0)) :: MAS,MAXM09,MBS,MODA2,MXSAVE
      INTEGER :: IEXTRA,INTA,INTG,J,JEXTRA,JR,JTERMS,K,KABIGR,KFLAG1,KFLAGA,KFLAGI,KFLAGX,         &
                 KFLGOK,KL,KMETH4,KOVUN,KR_RETRY,KRESLT,KRSAVE,KWRNSV,KXNEG,N,NDGOAL,NDIG2,NDOLD,  &
                 NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NMNNDG,NTERMS,NUMTRY,N_ACC
      LOGICAL, EXTERNAL :: FMCOMP
      DOUBLE PRECISION, EXTERNAL :: FMDPLG
      TYPE(FM_SETTINGS) :: QX
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MXY(22),MRETRY

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MB%MP(1) > 0 .AND. MA%MP(3) /= 0 .AND.   &
          MB%MP(2) < -QX%NDIG - QX%NGRD52) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          NDSAVE = QX%NDIG
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          QX%NDIG = QX%NDIG + QX%NGRD52
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
          CALL FMGAM(MXY(1),MXY(3),QX)
          IF (MXY(3)%MP(2) /= QX%MUNKNO) THEN
              CALL FMIGM1(MXY(1),MXY(2),MXY(4),QX)
              QX%KROUND = KRSAVE
              CALL FMSUB(MXY(3),MXY(4),MXY(5),QX)
              IF (MXY(5)%MP(3) == 0 .OR.  &
                  MXY(5)%MP(2) < MXY(3)%MP(2)-QX%NGRD52) THEN
                  QX%KFLAG = 0
                  QX%NTRACE = J
                  QX%KWARN = K
                  QX%NDIG = NDSAVE
                  GO TO 110
              ENDIF
          ELSE
              CALL FMM2I(MXY(1),KL,QX)
              CALL FMIPWR(MXY(2),KL,MXY(4),QX)
              IF (MXY(4)%MP(2) /= QX%MEXPOV) THEN
                  CALL FMDIVI_R1(MXY(4),-KL,QX)
              ENDIF
              CALL FMTINY(MXY(5),QX)
              QX%KROUND = KRSAVE
              CALL FMSUB_R2(MXY(4),MXY(5),QX)
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          CALL FMEQU(MXY(5),MC,QX%NDIG,NDSAVE,QX)
          QX%NDIG = NDSAVE
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMIGM2'
              CALL FMNTR(2,MA,MB,2,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (MC%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO .AND.  &
              MB%MP(2) /= QX%MUNKNO) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMIGM2'
              QX%KFLAG = -4
              CALL FMWRN2(QX)
              QX%NCALL = QX%NCALL - 1
          ELSE IF (ABS(MC%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV .AND.  &
                   ABS(MB%MP(2))  < QX%MEXPOV) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMIGM2'
              IF (MC%MP(2) == QX%MEXPOV) QX%KFLAG = -5
              IF (MC%MP(2) == QX%MEXPUN) QX%KFLAG = -6
              CALL FMWRN2(QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          IF (QX%NTRACE /= 0) THEN
              QX%NCALL = QX%NCALL + 1
              QX%NAMEST(QX%NCALL) = 'FMIGM2'
              CALL FMNTR(1,MC,MC,1,1,QX)
              QX%NCALL = QX%NCALL - 1
          ENDIF
          RETURN
      ENDIF

  110 CALL FMENT2('FMIGM2   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      MAS = MA%MP(1)
      MBS = MB%MP(1)
      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQU(MB,MXY(2),NDSAVE,QX%NDIG,QX)
      KMETH4 = 0
      NUMTRY = 0

  130 NTERMS = INT(INTMAX/10)

!             A,X are double precision approximations to the two arguments to this function.
!             INTA = A if A is a small integer.  It is used to limit the number of terms used
!                    in the asymptotic series and in the continued fraction expansion.

      INTA = NTERMS
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(1),INTG,QX)
      KFLAGI = QX%KFLAG
      IF (QX%KFLAG == 0) INTA = INTG
      CALL FMM2DP(MXY(1),A,QX)
      KFLAGA = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          A = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) A = -A
          KFLAGA = 0
      ENDIF
      CALL FMM2DP(MXY(2),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(2)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(2)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF
      QX%KWARN = KWRNSV

!             If A or X is large in magnitude use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(1)%MP(2)),INT(MXY(2)%MP(2)),0) ,  &
                   INT(1.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             KXNEG = 1 if X is negative and A is a positive integer.

      KXNEG = 0

!             MODA2 = MOD(A,2) when KXNEG is 1.

      MODA2 = 0

!             Check for special cases.

      IF (MXY(1)%MP(2) == QX%MEXPOV .OR. MXY(2)%MP(2) == QX%MEXPOV) THEN
          IF (MXY(1)%MP(2) == QX%MEXPOV .AND. MXY(1)%MP(3) /= 0 .AND.  &
              MXY(1)%MP(1) > 0) THEN
              IF (MXY(2)%MP(2) /= QX%MEXPOV) THEN
                  CALL FMST2M('OVERFLOW',MXY(16),QX)
                  QX%KFLAG = -5
                  GO TO 180
              ENDIF
          ENDIF
          IF (MXY(2)%MP(2) == QX%MEXPOV .AND. MXY(2)%MP(3) /= 0 .AND.  &
              MXY(2)%MP(1) > 0) THEN
              CALL FMBIG(MXY(17),QX)
              MXY(17)%MP(2) = MXSAVE + 1
              CALL FMLN(MXY(17),MXY(7),QX)
              CALL FMDIV(MXY(17),MXY(7),MXY(18),QX)
              IF (FMCOMP(MXY(1),'<=',MXY(18),QX)) THEN
                  CALL FMST2M('UNDERFLOW',MXY(16),QX)
                  QX%KFLAG = -6
                  GO TO 180
              ELSE
                  CALL FMST2M('UNKNOWN',MXY(16),QX)
                  QX%KFLAG = -4
                  GO TO 200
              ENDIF
          ENDIF
          IF (MXY(2)%MP(2) == QX%MEXPOV .AND. MXY(2)%MP(1) < 0 .AND.  &
              MXY(1)%MP(1) > 0 .AND. MXY(1)%MP(3) /= 0) THEN
              IF (MXY(1)%MP(2) /= QX%MEXPOV) THEN
                  CALL FMINT(MXY(1),MXY(15),QX)
                  IF (FMCOMP(MXY(1),'==',MXY(15),QX)) THEN
                      CALL FMI2M(2,MXY(12),QX)
                      CALL FMMOD(MXY(15),MXY(12),MXY(7),QX)
                      CALL FMEQ(MXY(7),MXY(12),QX)
                      IF (MXY(12)%MP(3) /= 0) THEN
                          CALL FMST2M('OVERFLOW',MXY(16),QX)
                          QX%KFLAG = -5
                          GO TO 180
                      ELSE
                          CALL FMST2M('-OVERFLOW',MXY(16),QX)
                          QX%KFLAG = -5
                          GO TO 180
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
          IF (MXY(1)%MP(2) == QX%MEXPOV .AND. MXY(1)%MP(1) < 0 .AND.  &
              MXY(1)%MP(3) /= 0) THEN
              IF (MXY(2)%MP(2) /= QX%MEXPOV .AND. MXY(2)%MP(1) > 0 .AND.  &
                  MXY(2)%MP(3) /= 0) THEN
                  CALL FMI2M(1,MXY(7),QX)
                  IF (FMCOMP(MXY(2),'<',MXY(7),QX)) THEN
                      CALL FMST2M('OVERFLOW',MXY(16),QX)
                      QX%KFLAG = -5
                      GO TO 180
                  ELSE
                      CALL FMST2M('UNDERFLOW',MXY(16),QX)
                      QX%KFLAG = -6
                      GO TO 180
                  ENDIF
              ENDIF
          ENDIF
          CALL FMST2M('UNKNOWN',MXY(16),QX)
          QX%KFLAG = -4
          GO TO 200
      ENDIF

      IF (MXY(1)%MP(2) == QX%MEXPUN .OR. MXY(2)%MP(2) == QX%MEXPUN) THEN
          IF (MXY(1)%MP(2) == QX%MEXPUN .AND. MXY(2)%MP(2) == QX%MEXPUN) THEN
              CALL FMST2M('UNKNOWN',MXY(16),QX)
              QX%KFLAG = -4
              GO TO 200
          ENDIF
          IF (MXY(2)%MP(2) == QX%MEXPUN .AND. MXY(2)%MP(1) > 0 .AND.  &
              MXY(2)%MP(3) /= 0                                     ) THEN
              IF (MXY(1)%MP(2) >= 1 .AND. MXY(1)%MP(1) > 0) THEN
                  CALL FMGAM(MXY(1),MXY(20),QX)
                  CALL FMEQ(MXY(20),MXY(16),QX)
                  GO TO 180
              ELSE IF (MXY(1)%MP(2) >= 1 .AND. MXY(1)%MP(1) < 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(16),QX)
                  QX%KFLAG = -5
                  GO TO 200
              ELSE
                  CALL FMST2M('UNKNOWN',MXY(16),QX)
                  QX%KFLAG = -4
                  GO TO 200
              ENDIF
          ENDIF
      ENDIF

      IF (MXY(2)%MP(3) == 0) THEN
          IF (MXY(1)%MP(1) < 0 .OR. MXY(1)%MP(3) == 0) THEN
              CALL FMST2M('UNKNOWN',MXY(16),QX)
              QX%KFLAG = -4
              GO TO 200
          ELSE
              CALL FMGAM(MXY(1),MXY(20),QX)
              CALL FMEQ(MXY(20),MXY(16),QX)
              GO TO 180
          ENDIF
      ENDIF
      IF (MXY(2)%MP(1) < 0) THEN
          CALL FMINT(MXY(1),MXY(15),QX)
          IF (FMCOMP(MXY(1),'==',MXY(15),QX) .AND. MXY(1)%MP(1)*MXY(1)%MP(3) > 0) THEN
              KXNEG = 1
              CALL FMI2M(2,MXY(12),QX)
              CALL FMMOD(MXY(15),MXY(12),MXY(7),QX)
              CALL FMEQ(MXY(7),MXY(12),QX)
              IF (MXY(12)%MP(3) /= 0) MODA2 = 1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(16),QX)
              QX%KFLAG = -4
              GO TO 200
          ENDIF
      ENDIF
      IF (MXY(2)%MP(2) == QX%MEXPUN) THEN
          IF (MXY(1)%MP(1) < 0 .AND. MXY(1)%MP(2) >= 1) THEN
              CALL FMST2M('OVERFLOW',MXY(16),QX)
              QX%KFLAG = -5
          ELSE
              CALL FMGAM(MXY(1),MXY(20),QX)
              CALL FMEQ(MXY(20),MXY(16),QX)
          ENDIF
          GO TO 180
      ENDIF
      IF (MXY(1)%MP(2) == QX%MEXPUN) THEN
          CALL FMI2M(0,MXY(1),QX)
          MAS = 1
      ENDIF
      CALL FMMAX(MXY(1),MXY(2),MXY(7),QX)
      CALL FMMIN(MXY(1),MXY(2),MXY(8),QX)
      CALL FMDPM(1.0D6,MXY(3),QX)
      CALL FMDPM(1.0D2,MXY(4),QX)
      IF (FMCOMP(MXY(7),'>=',MXY(3),QX) .AND. FMCOMP(MXY(8),'>=',MXY(4),QX)) THEN
          CALL FMI2M(1,MXY(7),QX)
          CALL FMSUB(MXY(1),MXY(7),MXY(9),QX)
          CALL FMMAX(MXY(9),MXY(2),MXY(11),QX)
          CALL FMADDI(MXY(11),1,QX)
          CALL FMLN(MXY(11),MXY(7),QX)
          CALL FMMPY(MXY(9),MXY(7),MXY(4),QX)
          CALL FMSUB(MXY(4),MXY(11),MXY(7),QX)
          CALL FMEXP(MXY(7),MXY(13),QX)
          IF ((MXY(13)%MP(2) == QX%MEXPOV .AND. MXY(13)%MP(1) > 0 .AND.  &
              MXY(13)%MP(3) /= 0) .OR. MXY(13)%MP(2) > MXSAVE+1) THEN
              CALL FMST2M('OVERFLOW',MXY(16),QX)
              QX%KFLAG = -5
              GO TO 180
          ENDIF
      ENDIF

!             If A is 1 the result is exp(-X).

      CALL FMI2M(1,MXY(7),QX)
      IF (FMCOMP(MXY(1),'==',MXY(7),QX)) THEN
          IF (ABS(MXY(2)%MP(2)) < QX%MEXPOV) THEN
              CALL FMEQ(MXY(2),MXY(8),QX)
              IF (MXY(8)%MP(2) /= QX%MUNKNO .AND. MXY(8)%MP(3) /= 0)  &
                  MXY(8)%MP(1) = -MXY(8)%MP(1)
              CALL FMEXP(MXY(8),MXY(16),QX)
              IF (MXY(16)%MP(2) /= QX%MUNKNO) GO TO 200
          ENDIF
      ENDIF

!             If A is negative and X is small, the result is -X**A / A.

      IF (MXY(1)%MP(1) == -1 .AND. MXY(2)%MP(2) < -QX%NDIG) THEN
          CALL FMPWR(MXY(2),MXY(1),MXY(8),QX)
          CALL FMDIV(MXY(8),MXY(1),MXY(16),QX)
          IF (MXY(16)%MP(2) == QX%MUNKNO) THEN
              CALL FMLN(MXY(2),MXY(8),QX)
              CALL FMMPY(MXY(8),MXY(1),MXY(9),QX)
              CALL FMABS(MXY(1),MXY(10),QX)
              CALL FMLN(MXY(10),MXY(11),QX)
              CALL FMSUB(MXY(9),MXY(11),MXY(10),QX)
              CALL FMEXP(MXY(10),MXY(16),QX)
              IF (MXY(16)%MP(2) /= QX%MUNKNO .AND. MXY(16)%MP(3) /= 0)  &
                  MXY(16)%MP(1) = -MXY(16)%MP(1)
          ENDIF
          IF (MXY(16)%MP(2) /= QX%MUNKNO .AND. MXY(16)%MP(3) /= 0)  &
              MXY(16)%MP(1) = -MXY(16)%MP(1)
          IF (MXY(16)%MP(2) /= QX%MUNKNO) GO TO 200
      ENDIF
      IF (MXY(1)%MP(1) == -1 .AND. MXY(2)%MP(1) == 1 .AND.  &
          MXY(1)%MP(2) > QX%NDIG .AND.                      &
          MXY(1)%MP(2) - MXY(2)%MP(2) > QX%NDIG) THEN
          CALL FMI2M(1,MXY(3),QX)
          CALL FMSUB(MXY(3),MXY(1),MXY(4),QX)
          CALL FMADD(MXY(4),MXY(2),MXY(6),QX)
          CALL FMDIV(MXY(3),MXY(6),MXY(5),QX)
          CALL FMSQR(MXY(1),MXY(4),QX)
          CALL FMMPYI(MXY(2),2,MXY(6),QX)
          CALL FMADDI(MXY(6),3,QX)
          CALL FMMPY(MXY(1),MXY(6),MXY(7),QX)
          CALL FMSUB(MXY(4),MXY(7),MXY(8),QX)
          CALL FMDIV(MXY(5),MXY(8),MXY(9),QX)
          CALL FMSUB(MXY(1),MXY(3),MXY(10),QX)
          CALL FMMPY(MXY(10),MXY(9),MXY(11),QX)
          IF (MXY(11)%MP(2) /= QX%MUNKNO) THEN
              CALL FMADD(MXY(5),MXY(11),MXY(12),QX)
          ELSE
              CALL FMEQ(MXY(5),MXY(12),QX)
          ENDIF
          CALL FMPWR(MXY(2),MXY(1),MXY(13),QX)
          IF (MXY(1)%MP(2) == QX%MEXPOV .OR. MXY(1)%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MXY(13),MXY(16),QX)
          ELSE
              CALL FMEXP(MXY(2),MXY(14),QX)
              CALL FMMPY(MXY(12),MXY(13),MXY(15),QX)
              CALL FMDIV(MXY(15),MXY(14),MXY(16),QX)
          ENDIF
          IF (MXY(16)%MP(2) /= QX%MUNKNO) GO TO 200
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion,
!                    = 4 means use an O(A**2) formula.

      CALL FMI2M(-10000,MXY(11),QX)
      CALL FMI2M(10000,MXY(12),QX)
      CALL FMABS(MXY(1),MXY(14),QX)
      CALL FMABS(MXY(2),MXY(15),QX)
      CALL FMSUB(MXY(15),MXY(14),MXY(13),QX)
      KABIGR = 1
      IF (MXY(13)%MP(3) >= 0 .AND. MXY(13)%MP(1) > 0) KABIGR = 0

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      IF (KFLAGA /= 0 .OR. KFLAGX /= 0) THEN
          CALL FMDIV(MXY(14),MXY(15),MXY(10),QX)
          CALL FMI2M(1,MXY(8),QX)
          CALL FMSUB(MXY(8),MXY(10),MXY(9),QX)
          IF (MXY(9)%MP(1) < 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          T1 = FMDPLG(A,QX)
          SMALL = T1 - FMDPLG(-ABS(X),QX) - (A+ABS(X))*LOG(ABS(X))
          TOL = -DBLE(QX%NDIG+2)*QX%DLOGMB - 12.0D0
          B = 1.0D0
          IF (A > ABS(X)) B = A - ABS(X)
          BIG = T1 - FMDPLG(A-B,QX) - B*LOG(ABS(X))

          NMETHD = 0
          IF (FMCOMP(MXY(13),'<=',MXY(11),QX)) THEN
              IF (MXY(1)%MP(1) > 0 .AND. MXY(1)%MP(3) /= 0) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
          ELSE IF (FMCOMP(MXY(13),'>=',MXY(12),QX) .AND. MXY(1)%MP(1) > 0 .AND.  &
                   MXY(1)%MP(3) > 0 .AND. MXY(2)%MP(1) > 0 .AND.                 &
                   MXY(2)%MP(3) > 0) THEN
              NMETHD = 3
              IF (SMALL < TOL+BIG) NMETHD = 2
          ELSE IF (FMCOMP(MXY(13),'>=',MXY(12),QX)) THEN
              NMETHD = 3
          ELSE IF (MXY(1)%MP(1) > 0 .AND. MXY(2)%MP(1) > 0 .AND.  &
                   MXY(2)%MP(3) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(11),QX)
              IF (FMCOMP(MXY(2),'>=',MXY(11),QX)) THEN
                  QX%KFLAG = -5
                  CALL FMST2M('OVERFLOW',MXY(16),QX)
                  GO TO 180
              ENDIF

              IF (MXY(1)%MP(1) > 0 .AND. MXY(1)%MP(3) /= 0) THEN
                  C2 = DBLE(NDSAVE)*QX%DLOGMB/6.0D0
                  C1 = MAX( 10.0D0 , C2 , A )
                  C2 = MAX( 10.0D0 , C2 , A - 6.5D0*A/(SQRT(A)+1.0D0) )
              ELSE
                  C1 = MAX( 15.0D0 , DBLE(NDSAVE)*QX%DLOGMB/5.0D0 )
                  C2 = C1
              ENDIF
              IF (X < MIN(C1,C2)) THEN
                  IF (-2*MXY(1)%MP(2) > QX%NDIG .OR. MXY(1)%MP(3) == 0) THEN
                      NMETHD = 4
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE IF (X > C2) THEN
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
              IF (NMETHD == 0 .AND. X > C1) NMETHD = 3
              IF (NMETHD == 0) NMETHD = 1
          ELSE IF (MXY(1)%MP(1) < 0 .AND. MXY(2)%MP(1) > 0 .AND.  &
              MXY(2)%MP(3) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(11),QX)
              IF (FMCOMP(MXY(2),'>=',MXY(11),QX)) THEN
                  QX%KFLAG = -6
                  CALL FMST2M('UNDERFLOW',MXY(16),QX)
                  GO TO 180
              ENDIF

              C1 = MAX( 10.0D0 , DBLE(NDSAVE)*QX%DLOGMB/7.0D0 )
              C2 = -2.0D0*A
              IF (X < C1) THEN
                  IF (-2*MXY(1)%MP(2) > QX%NDIG) THEN
                      NMETHD = 4
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE IF (X > C2) THEN
                  T1 = FMDPLG(A,QX)
                  SMALL = T1 - FMDPLG(-ABS(X),QX) - (A+ABS(X))*LOG(ABS(X))
                  TOL = -DBLE(QX%NDIG+2)*QX%DLOGMB - 12.0D0
                  B = 1.0D0
                  IF (A > ABS(X)) B = A - ABS(X)
                  BIG = T1 - FMDPLG(A-B,QX) - B*LOG(ABS(X))
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
              IF (NMETHD == 0 .AND. X > C1) NMETHD = 3
              IF (NMETHD == 0) NMETHD = 1
          ELSE IF (MXY(1)%MP(1) > 0 .AND. MXY(1)%MP(3) > 0 .AND.  &
              MXY(2)%MP(1) < 0) THEN
              CALL FMEQ(MXY(2),MXY(11),QX)
              IF (MXY(11)%MP(2) /= QX%MUNKNO .AND. MXY(11)%MP(3) /= 0)  &
                  MXY(11)%MP(1) = -MXY(11)%MP(1)
              CALL FMMPYI(MXY(1),2,MXY(12),QX)
              IF (FMCOMP(MXY(11),'<',MXY(1),QX)) THEN
                  NMETHD = 1
              ELSE IF (FMCOMP(MXY(11),'<',MXY(12),QX)) THEN
                  NMETHD = 3
              ELSE
                  NMETHD = 3
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 140
      IF (NMETHD == 3) GO TO 160
      IF (NMETHD == 4) GO TO 170

!             Method 1.  Use the X**N/Pochhammer(A+1,N) series.

!             MXY(16) = MXY(21) + MXY(22) is the current sum.
!             MXY(12) is the current term.
!             MXY(11) is (A+N)/X.
!             MXY(19) is 1/X

!             Raise the precision if A is negative and near an integer, to compensate for
!             cancellation when (A+N)/X is near zero.
!             Raise the precision if A is positive and near zero, since there will be cancellation
!             in subtracting the sum from Gamma(A).
!             If A is a negative integer use method 3 or 4.

      IEXTRA = 0
      IF (MXY(1)%MP(1) < 0) THEN
          IF (KFLAGA == 0) THEN
              IF (ABS(A) > 1.0D3) THEN
                  NMETHD = 3
                  GO TO 160
              ENDIF
          ELSE
              NMETHD = 3
              GO TO 160
          ENDIF
          CALL FMNINT(MXY(1),MXY(16),QX)
          IF (FMCOMP(MXY(16),'==',MXY(1),QX)) THEN
              IF (KFLAGI == 0) THEN
                  IF (KFLAGX /= 0) THEN
                      GO TO 160
                  ELSE
                      IF (ABS(X) <= 20.0D0) THEN
                          C1 = 0.7D0*(DBLE(NDSAVE)*QX%DLOGMB*(20.0D0-X))**0.75D0
                          IF (ABS(A) > C1) THEN
                              GO TO 160
                          ELSE
                              GO TO 170
                          ENDIF
                      ELSE
                          GO TO 160
                      ENDIF
                  ENDIF
              ELSE
                  GO TO 160
              ENDIF
          ENDIF
          CALL FMSUB(MXY(1),MXY(16),MXY(19),QX)
          IEXTRA = MAX(-2*INT(MXY(19)%MP(2)),-INT(MXY(1)%MP(2))+1,0)
      ELSE
          IEXTRA = MAX(-INT(MXY(1)%MP(2))+1,0)
      ENDIF

!             Raise the precision further as X increases in magnitude.

      IF (KFLAGX == 0 .AND. KFLAGA == 0) THEN
          T1 = (0.92D0 + (X-A) + (A-0.5D0)*LOG(ABS(A)+1.0D-10) -  &
               (A-1.0D0)*LOG(ABS(X)+1.0D-10))/QX%DLOGMB
          IF (T1 > 0 .AND. ABS(X) > 1.0D0) THEN
              IF (A < 0.0D0 .OR. X >= A) THEN
                  IEXTRA = IEXTRA + MAX(0,INT(T1)+1)
              ENDIF
          ENDIF
      ENDIF

      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

      JEXTRA = 0

      IF (KABIGR == 1) THEN
          CALL FMGAM(MXY(1),MXY(20),QX)
          IF (QX%KFLAG /= 0) THEN
              CALL FMEQ(MXY(20),MXY(16),QX)
              GO TO 180
          ENDIF
          CALL FMEQ(MXY(20),MXY(16),QX)
          IF (MXY(20)%MP(1) > 0) THEN
              CALL FMEQ(MXY(20),MXY(21),QX)
              CALL FMI2M(0,MXY(22),QX)
          ELSE
              CALL FMEQ(MXY(20),MXY(22),QX)
              CALL FMI2M(0,MXY(21),QX)
          ENDIF
      ELSE
          CALL FMI2M(0,MXY(16),QX)
          CALL FMI2M(0,MXY(21),QX)
          CALL FMI2M(0,MXY(22),QX)
      ENDIF

      MAXM09 = MXY(16)%MP(2)

      CALL FMABS(MXY(2),MXY(19),QX)
      CALL FMLN(MXY(19),MXY(6),QX)
      CALL FMMPY_R2(MXY(1),MXY(6),QX)
      CALL FMSUB_R1(MXY(6),MXY(2),QX)
      CALL FMEXP(MXY(6),MXY(20),QX)
      CALL FMDIV(MXY(20),MXY(1),MXY(12),QX)
      IF (MXY(12)%MP(2) == QX%MUNKNO) THEN
          CALL FMLN(MXY(1),MXY(15),QX)
          CALL FMSUB_R1(MXY(6),MXY(15),QX)
          CALL FMEXP(MXY(6),MXY(12),QX)
      ENDIF
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MXY(12)%MP(2) /= QX%MUNKNO  &
          .AND. MXY(12)%MP(3) /= 0) THEN
          MXY(12)%MP(1) = -MXY(12)%MP(1)
      ENDIF

      IF (MXY(12)%MP(2) /= QX%MUNKNO .AND. MXY(12)%MP(3) /= 0) THEN
          MXY(12)%MP(1) = -MXY(12)%MP(1)
      ENDIF
      CALL FMADD_R1(MXY(16),MXY(12),QX)
      IF (MXY(12)%MP(1) > 0) THEN
          CALL FMADD_R1(MXY(21),MXY(12),QX)
      ELSE
          CALL FMADD_R1(MXY(22),MXY(12),QX)
      ENDIF
      MAXM09 = MAX(MAXM09,MXY(16)%MP(2))

      CALL FMI2M(1,MXY(9),QX)
      CALL FMADD(MXY(1),MXY(9),MXY(11),QX)
      CALL FMDIV_R1(MXY(12),MXY(11),QX)
      CALL FMMPY_R1(MXY(12),MXY(2),QX)
      CALL FMDIV_R1(MXY(11),MXY(2),QX)
      CALL FMDIV(MXY(9),MXY(2),MXY(19),QX)
      NDSAV1 = QX%NDIG

!             If A is negative and ABS(A) > ABS(X), the terms in the series first decrease,
!             then increase, then decrease. Try to predict the number of extra digits required to
!             keep the precision from prematurely becoming too small.

      KFLGOK = 1
      IF (MXY(1)%MP(1) < 0) THEN
          KFLGOK = 0
          MXY(1)%MP(1) = 1
          MXY(2)%MP(1) = 1
          IF (FMCOMP(MXY(1),'>',MXY(2),QX)) THEN
              IF (JEXTRA == 0) THEN
                  IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                      T1 = FMDPLG(A+AINT(-ABS(X)-A),QX) - FMDPLG(A+1.0D0+AINT(ABS(X)-A),QX)
                      T1 = (T1 + 2.0D0*ABS(X)*LOG(ABS(X)+1.0D-10))/QX%DLOGMB
                      T1 = MAX(0.0D0,T1+1.0D0)
                      JEXTRA = T1
                  ENDIF
              ENDIF

!             If A is negative and ABS(A) is much bigger than ABS(X), then the later increase
!             in the size of the terms can be ignored.

              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T1 = (AINT(X-A)*LOG(ABS(X)+1.0D-10) + FMDPLG(A+1.0D0,QX)  &
                       - FMDPLG(A+1.0D0+AINT(X-A),QX)) / QX%DLOGMB
                  IF (T1 < -DBLE(QX%NDIG)) KFLGOK = 1
              ELSE
                  KFLGOK = 1
              ENDIF
          ENDIF
          MXY(1)%MP(1) = MAS
          MXY(2)%MP(1) = MBS
      ENDIF

      NMNNDG = NDSAV1

!             Method 1 summation loop.

      DO J = 1, NTERMS
         QX%NDIG = NDSAV1
         IF (MXY(12)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(21),MXY(12),QX)
         ELSE
             CALL FMADD_R1(MXY(22),MXY(12),QX)
         ENDIF
         CALL FMCSADD_R1(MXY(16),MXY(12),QX)
         MAXM09 = MAX(MAXM09,MXY(16)%MP(2))
         IF (QX%KFLAG /= 0) THEN
             IF (KFLGOK == 0 .AND. KFLAGA == 0 .AND. KFLAGX == 0) THEN
                 IF (DBLE(J) > X-A) EXIT
             ELSE
                 EXIT
             ENDIF
         ENDIF

         CALL FMCSADD_R1(MXY(11),MXY(19),QX)

         NDIG2 = MAX(QX%NGRD22,NDSAV1-INT(MXY(16)%MP(2)-MXY(12)%MP(2)))
         QX%NDIG = MIN(NDSAV1,NDIG2+JEXTRA)
         NMNNDG = MIN(NMNNDG,QX%NDIG)
         CALL FMCSDIV(MXY(12),MXY(11),MXY(5),QX)
         CALL FMEQ(MXY(5),MXY(12),QX)
      ENDDO

      QX%NDIG = NDSAV1
      IF (KABIGR == 0) THEN
          CALL FMEQ(MXY(16),MXY(19),QX)
          CALL FMGAM(MXY(1),MXY(20),QX)
          IF (QX%KFLAG /= 0) THEN
              CALL FMEQ(MXY(20),MXY(16),QX)
              GO TO 180
          ENDIF
          CALL FMADD(MXY(20),MXY(19),MXY(16),QX)
          IF (MXY(9)%MP(1) > 0) THEN
              CALL FMADD_R1(MXY(21),MXY(20),QX)
          ELSE
              CALL FMADD_R1(MXY(22),MXY(20),QX)
          ENDIF

      ENDIF

!             If too much cancellation occurred, raise the precision and do the calculation again.

      CALL FMADD(MXY(21),MXY(22),MXY(16),QX)
      CALL FMCANCEL(MXY(21),MXY(22),MXY(16),K,QX)
      N_ACC = N_ACC - K

      GO TO 180

!             Method 2.  Use the Pochhammer(A-N,N)/X**N series.

!             MXY(16) is the current sum.
!             MXY(12) is the current term.
!             MXY(11) is (A-N)/X.
!             MXY(19) is -1/X

  140 CALL FMABS(MXY(2),MXY(19),QX)
      CALL FMLN(MXY(19),MXY(6),QX)
      CALL FMMPY(MXY(1),MXY(6),MXY(16),QX)
      CALL FMSUB_R2(MXY(16),MXY(6),QX)
      CALL FMSUB_R1(MXY(6),MXY(2),QX)
      CALL FMEXP(MXY(6),MXY(12),QX)
      IF (KXNEG == 1 .AND. MODA2 == 0 .AND. MXY(12)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(12)%MP(3) /= 0) MXY(12)%MP(1) = -MXY(12)%MP(1)
      IF (ABS(MXY(12)%MP(2)) >= QX%MXEXP2) THEN
          CALL FMEQ(MXY(12),MXY(16),QX)
          GO TO 180
      ENDIF

!             Here MXY(12) is X**(A-1)/EXP(X).

      CALL FMI2M(0,MXY(16),QX)
      CALL FMI2M(0,MXY(21),QX)
      CALL FMI2M(0,MXY(22),QX)
      CALL FMEQ(MXY(1),MXY(11),QX)
      CALL FMDIV_R1(MXY(11),MXY(2),QX)
      CALL FMI2M(1,MXY(9),QX)
      CALL FMDIV(MXY(9),MXY(2),MXY(19),QX)
      IF (MXY(19)%MP(2) /= QX%MUNKNO .AND. MXY(19)%MP(3) /= 0)  &
          MXY(19)%MP(1) = -MXY(19)%MP(1)
      NDSAV1 = QX%NDIG

!             Disable NDIG reduction until the terms in the sum begin to decrease in size.

      BIGJ = 0
      IF (KFLAGA == 0 .AND. KFLAGX == 0) BIGJ = ABS(A) - ABS(X)
      JTERMS = NTERMS
      IF (KFLAGI == 0 .AND. INTA > 0) THEN
          JTERMS = INTA
      ELSE IF (KFLAGX == 0) THEN
          IF (KFLAGA == 0) THEN
              T1 = A + ABS(X)
              IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
          ELSE IF (MXY(1)%MP(2) < 0) THEN
              T1 = ABS(X)
              IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
          ENDIF
      ENDIF

!             Method 2 summation loop.

      DO J = 1, JTERMS
         QX%NDIG = NDSAV1
         IF (MXY(12)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(21),MXY(12),QX)
         ELSE
             CALL FMADD_R1(MXY(22),MXY(12),QX)
         ENDIF
         CALL FMCSADD_R1(MXY(16),MXY(12),QX)
         IF (QX%KFLAG /= 0 .AND. J > 1) GO TO 150
         CALL FMCSADD_R1(MXY(11),MXY(19),QX)
         IF (REAL(J) >= BIGJ) THEN
             NDIG2 = MAX(QX%NGRD22,NDSAV1-INT(MXY(16)%MP(2)-MXY(12)%MP(2)))
             QX%NDIG = MIN(NDSAV1,NDIG2)
         ENDIF
         CALL FMCSMPY_R1(MXY(12),MXY(11),QX)
      ENDDO

  150 QX%NDIG = NDSAV1
      CALL FMADD(MXY(21),MXY(22),MXY(16),QX)
      CALL FMCANCEL(MXY(21),MXY(22),MXY(16),K,QX)
      N_ACC = N_ACC - K
      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(19) = MXY(21) + MXY(22) is the current approximation.
!             MXY(16) is the term in the sum, S(k).
!             MXY(14), MXY(15) are the latest denominators, Q(k-1) and Q(k).

!             Raise the precision so that convergence of the continued fraction expansion
!             is easier to detect.

  160 JEXTRA = INT(MAX(1.0,5.76/QX%ALOGMB + 1.0))

!             Raise the precision further for small X if A is positive.

      IF (KFLAGX == 0 .AND. KFLAGA == 0) THEN
          T1 = (0.92D0 + (ABS(X)-A) + (A-0.5D0)*LOG(ABS(A)+1.0D-10) -  &
               (A-1.0D0)*LOG(ABS(X)+1.0D-10))/QX%DLOGMB
          IF (T1 > 0.0D0 .AND. A > 0.0D0) THEN
              IF (ABS(X) < A) THEN
                  JEXTRA = JEXTRA + MAX(0,INT(1.5D0*T1)+1)
              ENDIF
          ENDIF
      ENDIF
      NDSAV1 = QX%NDIG
      IF (QX%NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA,QX)
          CALL FMEQU_R1(MXY(2),NDSAV1,NDSAV1+JEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + JEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MXY(1),MXY(11),NDSAV1,QX%NDIG,QX)
      IF (MXY(11)%MP(2) /= QX%MUNKNO .AND. MXY(11)%MP(3) /= 0)  &
          MXY(11)%MP(1) = -MXY(11)%MP(1)
      CALL FMI2M(1,MXY(14),QX)
      CALL FMEQU(MXY(2),MXY(15),NDSAV1,QX%NDIG,QX)
      CALL FMI2M(1,MXY(7),QX)
      CALL FMDIV(MXY(7),MXY(15),MXY(16),QX)
      CALL FMEQ(MXY(16),MXY(19),QX)
      IF (MXY(19)%MP(1) > 0) THEN
          CALL FMEQ(MXY(19),MXY(21),QX)
          CALL FMI2M(0,MXY(22),QX)
      ELSE
          CALL FMEQ(MXY(19),MXY(22),QX)
          CALL FMI2M(0,MXY(21),QX)
      ENDIF

      JTERMS = NTERMS
      IF (INTA > 0) JTERMS = INTA - 1

!             Method 3 continued fraction loop.

      NDSAV2 = QX%NDIG
      DO J = 1, JTERMS
         CALL FMADDI(MXY(11),1,QX)
         CALL FMEQ(MXY(11),MXY(13),QX)
         CALL FMCSMPY_R1(MXY(13),MXY(14),QX)
         CALL FMADD(MXY(15),MXY(13),MXY(12),QX)
         CALL FMEQ(MXY(13),MXY(8),QX)
         CALL FMCSMPY_R1(MXY(8),MXY(16),QX)
         CALL FMCSDIV(MXY(8),MXY(12),MXY(16),QX)
         IF (MXY(16)%MP(2) /= QX%MUNKNO .AND. MXY(16)%MP(3) /= 0)  &
             MXY(16)%MP(1) = -MXY(16)%MP(1)
         QX%NDIG = NDSAV2
         IF (MXY(16)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(21),MXY(16),QX)
         ELSE
             CALL FMADD_R1(MXY(22),MXY(16),QX)
         ENDIF
         CALL FMCSADD_R1(MXY(19),MXY(16),QX)
         KFLAG1 = QX%KFLAG
         CALL FMEQ(MXY(15),MXY(14),QX)
         CALL FMEQ(MXY(12),MXY(15),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(19)%MP(2)-MXY(16)%MP(2))))
         CALL FMCSMPYI(MXY(14),J,MXY(13),QX)
         CALL FMEQ(MXY(2),MXY(8),QX)
         CALL FMCSMPY_R1(MXY(8),MXY(15),QX)
         CALL FMADD(MXY(8),MXY(13),MXY(12),QX)
         CALL FMEQ(MXY(13),MXY(8),QX)
         CALL FMCSMPY_R1(MXY(8),MXY(16),QX)
         CALL FMCSDIV(MXY(8),MXY(12),MXY(16),QX)
         IF (MXY(16)%MP(2) /= QX%MUNKNO .AND. MXY(16)%MP(3) /= 0)  &
             MXY(16)%MP(1) = -MXY(16)%MP(1)
         QX%NDIG = NDSAV2
         IF (MXY(16)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(21),MXY(16),QX)
         ELSE
             CALL FMADD_R1(MXY(22),MXY(16),QX)
         ENDIF
         CALL FMCSADD_R1(MXY(19),MXY(16),QX)

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. QX%KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(15),MXY(14),QX)
         CALL FMEQ(MXY(12),MXY(15),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(19)%MP(2)-MXY(16)%MP(2))))
      ENDDO

      QX%NDIG = NDSAV2
      CALL FMADD(MXY(21),MXY(22),MXY(19),QX)
      CALL FMCANCEL(MXY(21),MXY(22),MXY(19),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQU_R1(MXY(19),QX%NDIG,NDSAV1,QX)
      QX%NDIG = NDSAV1
      CALL FMABS(MXY(2),MXY(15),QX)
      CALL FMLN(MXY(15),MXY(6),QX)
      CALL FMMPY_R2(MXY(1),MXY(6),QX)
      CALL FMSUB_R1(MXY(6),MXY(2),QX)
      CALL FMEXP(MXY(6),MXY(5),QX)
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MXY(5)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(5)%MP(3) /= 0) MXY(5)%MP(1) = -MXY(5)%MP(1)
      IF (ABS(MXY(5)%MP(2)) >= QX%MXEXP2) THEN
          CALL FMEQ(MXY(5),MXY(16),QX)
          IF (MXY(19)%MP(1) < 0 .AND. MXY(16)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(16)%MP(3) /= 0) MXY(16)%MP(1) = -MXY(16)%MP(1)
          GO TO 180
      ENDIF

      CALL FMMPY(MXY(5),MXY(19),MXY(16),QX)
      GO TO 180

!             Method 4.  Use the O(A**2) formula when A is small.

!             MXY(16) is the current term.
!             MXY(19) is the current sum.

!             Raise the precision if X is larger than A in magnitude.
!             The terms initially increase in size, and the final sum is small.

  170 IEXTRA = 0

!             If A is a negative integer, replace it by zero and later use a recurrence to recover
!             the original function value.

      IF (KFLAGI == 0 .AND. INTA < 0) THEN
          CALL FMI2M(0,MXY(1),QX)
          A = 0.0D0
          KMETH4 = 1
      ENDIF

      IF (KFLAGX == 0) THEN
          IF (KFLAGA == 0) THEN
              T1 = ABS(X) - ABS(A)
          ELSE
              T1 = ABS(X)
          ENDIF
          IF (T1 > 0) THEN
              T2 = (T1 + LOG(T1))/QX%DLOGMB
              IF (T2 > DBLE(QX%MXEXP2/10)) T2 = DBLE(QX%MXEXP2/10)
              IEXTRA = INT(MAX(0.0D0,T2))
          ENDIF
          T1 = ABS(X)+1.0D-10
          T2 = (T1 - 0.5D0*LOG(6.2831853D0*T1))/QX%DLOGMB
          IF (T2 > DBLE(QX%MXEXP2/10)) T2 = DBLE(QX%MXEXP2/10)
          IEXTRA = IEXTRA + INT(MAX(0.0D0,T2))
      ENDIF

      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          CALL FMEQU_R1(MXY(2),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

      CALL FMEULR(MXY(19),QX)
      CALL FMEQ(MXY(19),MXY(20),QX)
      MXY(19)%MP(1) = -1
      CALL FMABS(MXY(2),MXY(16),QX)
      CALL FMLN(MXY(16),MXY(15),QX)
      CALL FMSUB_R1(MXY(19),MXY(15),QX)
      IF (MXY(1)%MP(3) /= 0 .AND. MXY(1)%MP(2) >= -QX%NDIG-1) THEN
          CALL FMSQR(MXY(15),MXY(7),QX)
          CALL FMMPY(MXY(7),MXY(1),MXY(4),QX)
          CALL FMDIVI(MXY(4),2,MXY(16),QX)
          CALL FMSUB_R1(MXY(19),MXY(16),QX)

          CALL FMSQR(MXY(20),MXY(14),QX)
          CALL FMPI(MXY(13),QX)
          CALL FMSQR(MXY(13),MXY(7),QX)
          CALL FMDIVI(MXY(7),6,MXY(13),QX)
          CALL FMADD(MXY(13),MXY(14),MXY(7),QX)
          CALL FMMPY(MXY(7),MXY(1),MXY(4),QX)
          CALL FMDIVI(MXY(4),2,MXY(14),QX)
          CALL FMADD_R1(MXY(19),MXY(14),QX)
      ENDIF

      NDSAV1 = QX%NDIG
      CALL FMI2M(1,MXY(14),QX)
      JR = QX%KROUND
      QX%KROUND = 1
      CALL FMADD(MXY(1),MXY(14),MXY(13),QX)
      QX%KROUND = JR
      IF (FMCOMP(MXY(14),'==',MXY(13),QX)) THEN
          CALL FMI2M(-1,MXY(16),QX)
          DO J = 1, NTERMS
             NDIG2 = MAX(QX%NGRD22,NDSAV1-INT(MXY(19)%MP(2)-MXY(16)%MP(2)))
             QX%NDIG = MIN(NDSAV1,NDIG2)
             CALL FMMPY_R1(MXY(16),MXY(2),QX)
             IF (MXY(16)%MP(2) /= QX%MUNKNO .AND. MXY(16)%MP(3) /= 0)  &
                 MXY(16)%MP(1) = -MXY(16)%MP(1)
             CALL FMDIVI_R1(MXY(16),J,QX)
             CALL FMDIVI(MXY(16),J,MXY(15),QX)
             QX%NDIG = NDSAV1
             CALL FMADD_R1(MXY(19),MXY(15),QX)
             IF (QX%KFLAG /= 0) EXIT
          ENDDO
      ELSE
          CALL FMPWR(MXY(2),MXY(1),MXY(16),QX)
          IF (MXY(16)%MP(2) /= QX%MUNKNO .AND. MXY(16)%MP(3) /= 0)  &
              MXY(16)%MP(1) = -MXY(16)%MP(1)
          CALL FMEQ(MXY(1),MXY(20),QX)
          DO J = 1, NTERMS
             NDIG2 = MAX(QX%NGRD22,NDSAV1-INT(MXY(19)%MP(2)-MXY(16)%MP(2)))
             QX%NDIG = MIN(NDSAV1,NDIG2)
             CALL FMMPY_R1(MXY(16),MXY(2),QX)
             IF (MXY(16)%MP(2) /= QX%MUNKNO .AND. MXY(16)%MP(3) /= 0)  &
                 MXY(16)%MP(1) = -MXY(16)%MP(1)
             CALL FMDIVI_R1(MXY(16),J,QX)
             QX%NDIG = NDSAV1
             CALL FMADD_R1(MXY(20),MXY(14),QX)
             QX%NDIG = MIN(NDSAV1,NDIG2)
             CALL FMDIV(MXY(16),MXY(20),MXY(15),QX)
             QX%NDIG = NDSAV1
             CALL FMADD_R1(MXY(19),MXY(15),QX)
             IF (QX%KFLAG /= 0) EXIT
          ENDDO
      ENDIF
      CALL FMEQ(MXY(19),MXY(16),QX)

!             Use the recurrence relation if A was a negative integer.

      IF (KFLAGI == 0 .AND. INTA < 0) THEN
          N = -INTA
          CALL FMI2M(1,MXY(19),QX)
          CALL FMDIV_R1(MXY(19),MXY(2),QX)
          CALL FMEQ(MXY(19),MXY(15),QX)
          CALL FMEQ(MXY(19),MXY(14),QX)
          DO J = 1, N-1
             CALL FMMPYI_R1(MXY(15),J,QX)
             CALL FMMPY_R1(MXY(15),MXY(14),QX)
             IF (MXY(15)%MP(2) /= QX%MUNKNO .AND. MXY(15)%MP(3) /= 0)  &
                 MXY(15)%MP(1) = -MXY(15)%MP(1)
             CALL FMADD_R1(MXY(19),MXY(15),QX)
          ENDDO
          CALL FMEXP(MXY(2),MXY(14),QX)
          CALL FMDIV_R1(MXY(19),MXY(14),QX)
          CALL FMSUB_R1(MXY(16),MXY(19),QX)
          CALL FMFCTI(N,MXY(14),QX)
          CALL FMDIV_R1(MXY(16),MXY(14),QX)
          IF (MOD(N,2) == 1 .AND. MXY(16)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(16)%MP(3) /= 0) MXY(16)%MP(1) = -MXY(16)%MP(1)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(16)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1 .AND. ABS(MXY(16)%MP(2)) <= QX%MXEXP) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(16)%MP(J+1)) GO TO 190
              ENDDO
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = QX%NDIG + IEXTRA
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          IF (KMETH4 == 1) THEN
              CALL FMI2M(INTA,MXY(1),QX)
          ENDIF
          CALL FMEQU_R1(MXY(2),NDSAVE,QX%NDIG,QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(16),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 130
      ENDIF

  200 CALL FMEXT2(MXY(16),MC,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMIGM2

      SUBROUTINE FMLNGM(MA,MB,QX)

!  MB = LN(GAMMA(MA))

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MPISAV,M_LN_2PI
      REAL (KIND(1.0D0)) :: MBSBRN
      INTEGER :: NUMBRN
      TYPE(MULTI) :: MBERN(LMBERN)
      INTEGER :: NDBERN(LMBERN)
      REAL (KIND(1.0D0)) :: MAS,MXSAVE
      DOUBLE PRECISION :: ERR,X,Z
      INTEGER :: IEXTRA,INTA,J,J2,K,K0,K1,K2,KFL,KL,KOVUN,KC_RETRY,KR_RETRY,KRESLT,KRSAVE,     &
                 KSIGN,KWRNSV,LSHIFT,NDENOM,NDGOAL,NDIG2,NDMB,NDOLD,NDSAV1,NDSAVE,NDSV,NGOAL,  &
                 NMETHD,NMXDIF,NTERM,NUMTRY,N_ACC
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(155) :: STRING
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(15),MJSUMS(LJSUMS),MRETRY,C(0:196)
      INTEGER :: NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      TYPE(FM_SETTINGS) :: QX

      QX%NDG2PI = 0
      MBSBRN = 0
      NUMBRN = 0
      NDBERN = 0
      NDIG_C = 0
      MBASE_C = 0

      CALL FMENT2('FMLNGM   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      MAS = MA%MP(1)
      KR_RETRY = 0
      KC_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQ(MXY(1),MXY(13),QX)
      NUMTRY = 0

!             Near zero Gamma(x) is about 1/x.

  120 IF (MXY(13)%MP(2) < (-QX%NDIG-3)) THEN
          CALL FMLN(MXY(13),MXY(10),QX)
          IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
              MXY(10)%MP(1) = -MXY(10)%MP(1)
          GO TO 190
      ENDIF

!             Check for special cases.

      IF (MAS < 0) THEN
          KFL = 0
          IF (MXY(1)%MP(2) <= NDSAVE) THEN
              CALL FMINT(MXY(13),MXY(9),QX)
              IF (FMCOMP(MXY(13),'==',MXY(9),QX)) KFL = -4
              CALL FMI2M(2,MXY(10),QX)
              MXY(9)%MP(1) = 1
              CALL FMMOD(MXY(9),MXY(10),MXY(5),QX)
              CALL FMEQ(MXY(5),MXY(10),QX)
              IF (MXY(10)%MP(3) == 0) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(10),QX)
              QX%KFLAG = -4
              GO TO 210
          ELSE
              CALL FMI2M(1,MXY(5),QX)
              CALL FMSUB_R2(MXY(5),MXY(13),QX)
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      CALL FMNINT(MXY(13),MXY(2),QX)
      CALL FMSUB(MXY(13),MXY(2),MXY(6),QX)
      CALL FMM2DP(MXY(6),Z,QX)
      Z = MAX(ABS(Z),1.0D-50)
      IF (QX%KFLAG /= 0 .OR. ABS(Z) >= 1) THEN
          NMETHD = 2
      ELSE
          IF (190*LOG(Z) - 90*QX%DLOGTN >= -QX%NDIG*QX%DLOGMB .OR. -190*QX%DLOGTN >= -QX%NDIG*QX%DLOGMB) THEN
              NMETHD = 2
          ENDIF
      ENDIF
      CALL FMM2DP(MXY(13),X,QX)
      IF (QX%KFLAG /= 0) THEN
          NMETHD = 2
      ELSE IF (NMETHD == 1) THEN
          IF (X > 35 - 8*LOG(Z) + QX%NDIG*QX%DLOGMB/(2.5*QX%DLOGTN) .OR. X > 250) NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      IF (MA%MP(1) > 0 .AND. NDSAVE+QX%NGRD52 < QX%NDIG .AND. KR_RETRY == 0 .AND. KC_RETRY == 0)  &
          QX%NDIG = NDSAVE + QX%NGRD52
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMM2I(MXY(2),LSHIFT,QX)
      LSHIFT = LSHIFT - 3
      IF (NDIG_C < QX%NDIG .OR. MBASE_C /= QX%MBASE) THEN
          CALL FMLNGM_C(NDIG_C,MBASE_C,C,QX)
      ENDIF
      J2 = 0.42*LOG(Z) + 7.9
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      NDSAV1 = QX%NDIG
      DO J = 1, J2
         CALL FMEQ(C(J+1),MJSUMS(J),QX)
      ENDDO
      CALL FMIPWR(MXY(6),J2,MXY(5),QX)
      CALL FMEQ(MXY(5),MXY(7),QX)
      NTERM = J2 + 1
  130 IF (NTERM > J2+1) CALL FMCSMPY_R1(MXY(7),MXY(5),QX)
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL FMEQ(MXY(7),MXY(4),QX)
         CALL FMCSMPY_R1(MXY(4),C(NTERM),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0 .OR. NTERM == 196) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 130
  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      QX%NDIG = NDSAV1
      IF (NTERM == 196) THEN
          GO TO 150
      ENDIF
      CALL FMEQ(MJSUMS(J2),MXY(8),QX)
      CALL FMEQ(MXY(6),MXY(3),QX)
      MXY(3)%MP(1) = -MXY(3)%MP(1)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(8),MXY(3),QX)
         CALL FMCSADD_R1(MXY(8),MJSUMS(J2-J+1),QX)
      ENDDO
      CALL FMSQR(MXY(6),MXY(3),QX)
      CALL FMCSMPY_R1(MXY(8),MXY(3),QX)
      CALL FMADD(MXY(8),C(0),MXY(10),QX)
      CALL FMMPY(MXY(6),C(1),MXY(3),QX)
      CALL FMADD_R1(MXY(10),MXY(3),QX)

!             Recover from using a shifted argument.

      IF (LSHIFT < 0) THEN
          CALL FMEQ(MXY(13),MXY(3),QX)
          CALL FMEQ(MXY(13),MXY(14),QX)
          DO J = 2, -LSHIFT
             CALL FMADDI(MXY(14),1,QX)
             CALL FMMPY_R1(MXY(3),MXY(14),QX)
          ENDDO
          CALL FMLN(MXY(3),MXY(4),QX)
          CALL FMSUB(MXY(10),MXY(4),MXY(3),QX)
          CALL FMCANCEL(MXY(10),MXY(4),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(10),QX)
      ENDIF
      IF (LSHIFT > 0) THEN
          IF (MOD(LSHIFT,4) == 0) THEN
              CALL FMI2M(1,MXY(3),QX)
              CALL FMEQ(MXY(6),MXY(14),QX)
              CALL FMADDI(MXY(14),3,QX)
          ELSE
              CALL FMEQ(MXY(6),MXY(3),QX)
              CALL FMADDI(MXY(3),3,QX)
              CALL FMEQ(MXY(3),MXY(14),QX)
              DO J = 1, MOD(LSHIFT,4)-1
                 CALL FMADDI(MXY(14),1,QX)
                 CALL FMMPY_R1(MXY(3),MXY(14),QX)
              ENDDO
              CALL FMADDI(MXY(14),1,QX)
          ENDIF
          LSHIFT = LSHIFT - MOD(LSHIFT,4)

!             The product Z*(Z+1)*...*(Z+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(14) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

          CALL FMI2M(1,MXY(11),QX)
          IF (LSHIFT > 0) THEN
              CALL FMSQR(MXY(14),MXY(6),QX)
              CALL FMMPY(MXY(14),MXY(6),MXY(7),QX)
              CALL FMSQR(MXY(6),MXY(8),QX)
              CALL FMCSMPYI(MXY(7),6,MXY(12),QX)
              CALL FMCSADD_R1(MXY(8),MXY(12),QX)
              CALL FMCSMPYI(MXY(6),11,MXY(12),QX)
              CALL FMCSADD_R1(MXY(8),MXY(12),QX)
              CALL FMCSMPYI(MXY(14),6,MXY(12),QX)
              CALL FMCSADD_R1(MXY(8),MXY(12),QX)
              CALL FMEQ(MXY(8),MXY(11),QX)
              CALL FMCSMPYI_R1(MXY(7),16,QX)
              DO K = 0, LSHIFT-8, 4
                 CALL FMCSADD_R1(MXY(8),MXY(7),QX)
                 K2 = 24*(2*K + 7)
                 CALL FMCSMPYI(MXY(6),K2,MXY(12),QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                     K1 = 8*(6*K*K + 42*K + 79)
                     CALL FMCSMPYI(MXY(14),K1,MXY(12),QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 ELSE
                     K1 = 48*K
                     CALL FMCSMPYI(MXY(14),K1,MXY(12),QX)
                     CALL FMCSMPYI_R1(MXY(12),K,QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                     K1 = 336*K + 632
                     CALL FMCSMPYI(MXY(14),K1,MXY(12),QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 ENDIF
                 IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                     K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                     CALL FMADDI(MXY(8),K0,QX)
                 ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                     K0 = 8*(2*K + 7)
                     CALL FMI2M(K0,MXY(12),QX)
                     K0 = K*K + 7*K + 15
                     CALL FMCSMPYI_R1(MXY(12),K0,QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 ELSE
                     K0 = 8*(2*K + 7)
                     CALL FMI2M(K0,MXY(12),QX)
                     CALL FMCSMPYI(MXY(12),K,MXY(9),QX)
                     CALL FMCSMPYI_R1(MXY(9),K,QX)
                     CALL FMCSADD_R1(MXY(8),MXY(9),QX)
                     K0 = 7*K + 15
                     CALL FMCSMPYI_R1(MXY(12),K0,QX)
                     CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 ENDIF
                 CALL FMCSMPY_R1(MXY(11),MXY(8),QX)
              ENDDO
          ENDIF
          CALL FMMPY_R1(MXY(11),MXY(3),QX)
          CALL FMLN(MXY(11),MXY(4),QX)
          CALL FMADD(MXY(10),MXY(4),MXY(3),QX)
          CALL FMCANCEL(MXY(10),MXY(4),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(10),QX)
      ENDIF
      GO TO 180

!             Method 2.  Use the B(2n)/(2n*(2n-1)*X**(2n-1) asymptotic series.
!                        To speed the asymptotic series calculation,
!                        increase the argument by LSHIFT.

  150 IEXTRA = 0
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(13),INTA,QX)
      QX%KWARN = KWRNSV

      IF (QX%KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(QX%NDIG)*QX%ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)
      IF (QX%KFLAG == 0) THEN
          IF (LSHIFT > 0 .OR. INTA <= 10) THEN
              IF (INTA <= 2) THEN
                  CALL FMI2M(0,MXY(10),QX)
                  GO TO 190
              ENDIF
              INTA = INTA - 1
              CALL FMFCTI(INTA,MXY(13),QX)
              CALL FMLN(MXY(13),MXY(10),QX)
              GO TO 190
          ENDIF
      ENDIF

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(5),QX)
          CALL FMADD(MXY(13),MXY(5),MXY(12),QX)
      ELSE
          CALL FMEQ(MXY(13),MXY(12),QX)
      ENDIF

!             Sum the asymptotic series.

!       MXY(13) is Z
!       MXY(12) is Z + LSHIFT
!       MXY(9)  is X**J2 = (1/(Z+LSHIFT)**2)**J2
!       MXY(10) is the current power of X
!       MXY(11) is the current term in the sum
!       MJSUMS  is the partial sum

      J2 = INT(0.3*QX%ALOGMB + 0.2*SQRT(REAL(QX%NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = QX%NDIG
      CALL FMI2M(1,MXY(10),QX)
      J = -2*J2
      CALL FMIPWR(MXY(12),J,MXY(9),QX)
      IF (ABS(MXY(9)%MP(2)) >= QX%MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(12),-2,MXY(9),QX)
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(10),MXY(11),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         IF (QX%KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10),QX)
             QX%KFLAG = -4
             GO TO 210
         ENDIF
         NDENOM = NTERM*(NTERM-1)
         CALL FMCSDIVI(MXY(11),NDENOM,MJSUMS(J),QX)
      ENDDO

      NDIG2 = QX%NDIG
  160 CALL FMCSMPY_R1(MXY(10),MXY(9),QX)

      NMXDIF = MIN(NDSAV1,QX%NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(10),MXY(11),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         IF (QX%KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10),QX)
             QX%KFLAG = -4
             GO TO 210
         ENDIF
         NDENOM = NTERM*(NTERM-1)
         IF (NTERM <= MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(11),NDENOM,QX)
         ELSE
             CALL FMCSDIVI_R1(MXY(11),NTERM,QX)
             NDENOM = NTERM - 1
             CALL FMCSDIVI_R1(MXY(11),NDENOM,QX)
         ENDIF
         QX%NDIG = NDSAV1
         CALL FMCSADD_R1(MJSUMS(J),MXY(11),QX)
         NMXDIF = MAX(NMXDIF,NDSAV1-INT(MJSUMS(J)%MP(2)-MXY(11)%MP(2)))
         QX%NDIG = NDIG2
         IF (QX%KFLAG /= 0) GO TO 170
      ENDDO
      NDIG2 = NMXDIF
      QX%NDIG = NDIG2
      GO TO 160

!             Put the J2 concurrent sums back together.

  170 QX%NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMSQR(MXY(12),MXY(11),QX)
          CALL FMI2M(1,MXY(5),QX)
          CALL FMDIV_R2(MXY(5),MXY(11),QX)
          CALL FMEQ(MJSUMS(J2),MXY(9),QX)
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(9),MXY(11),QX)
             CALL FMCSADD_R1(MXY(9),MJSUMS(J),QX)
          ENDDO
          CALL FMEQ(MXY(9),MJSUMS(1),QX)
      ENDIF

!             Add the log terms to the asymptotic series.

!       MXY(10) is the current sum as the log terms are added
!       MXY(11) is now LN(Z+LSHIFT)

      CALL FMDIV(MJSUMS(1),MXY(12),MXY(10),QX)
      CALL FMLN(MXY(12),MXY(11),QX)
      IF (QX%MBASE /= QX%MBS2PI .OR. QX%NDIG > QX%NDG2PI) THEN
          NDMB = INT(150.0*2.302585/QX%ALOGMB)
          IF (NDMB >= QX%NDIG) THEN
              NDSV = QX%NDIG
              QX%NDIG = NDMB
              STRING = '1.837877066409345483560659472811235279722794'//  &
              '94727556682563430308096553139185452079538948659727190'//  &
              '8395244011293249268674892733725763681587144311751830445'
              CALL FMST2M(STRING,M_LN_2PI,QX)
              QX%MBS2PI = QX%MBASE
              QX%NDG2PI = QX%NDIG
              IF (ABS(M_LN_2PI%MP(2)) > 10) QX%NDG2PI = 0
              QX%NDIG = NDSV
          ELSE
              NDSV = QX%NDIG
              QX%NDIG = QX%NDIG + 2
              CALL FMPI(MXY(9),QX)
              CALL FMMPYI(MXY(9),2,MXY(5),QX)
              CALL FMLN(MXY(5),M_LN_2PI,QX)
              QX%MBS2PI = QX%MBASE
              QX%NDG2PI = QX%NDIG
              IF (ABS(M_LN_2PI%MP(2)) > 10) QX%NDG2PI = 0
              QX%NDIG = NDSV
          ENDIF
      ENDIF
      CALL FMSUB(M_LN_2PI,MXY(11),MXY(5),QX)
      CALL FMCANCEL(M_LN_2PI,MXY(11),MXY(5),K,QX)
      N_ACC = N_ACC - K
      CALL FMCSDIVI(MXY(5),2,MXY(9),QX)
      CALL FMADD(MXY(10),MXY(9),MXY(3),QX)
      CALL FMCANCEL(MXY(10),MXY(9),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(10),QX)
      CALL FMSUB(MXY(10),MXY(12),MXY(3),QX)
      CALL FMCANCEL(MXY(10),MXY(12),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(10),QX)
      CALL FMMPY(MXY(11),MXY(12),MXY(9),QX)
      CALL FMADD(MXY(10),MXY(9),MXY(3),QX)
      CALL FMCANCEL(MXY(10),MXY(9),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(10),QX)

!             Now the log of gamma of the shifted argument has been computed.  Reverse the shifting.
!             The product MA*(MA+1)*...*(MA+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(13) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(13),MXY(6),QX)
          CALL FMMPY(MXY(13),MXY(6),MXY(7),QX)
          CALL FMSQR(MXY(6),MXY(8),QX)
          CALL FMCSMPYI(MXY(7),6,MXY(12),QX)
          CALL FMCSADD_R1(MXY(8),MXY(12),QX)
          CALL FMCSMPYI(MXY(6),11,MXY(12),QX)
          CALL FMCSADD_R1(MXY(8),MXY(12),QX)
          CALL FMCSMPYI(MXY(13),6,MXY(12),QX)
          CALL FMCSADD_R1(MXY(8),MXY(12),QX)
          CALL FMEQ(MXY(8),MXY(11),QX)
          CALL FMCSMPYI_R1(MXY(7),16,QX)
          DO K = 0, LSHIFT-8, 4
             CALL FMCSADD_R1(MXY(8),MXY(7),QX)
             K2 = 24*(2*K + 7)
             CALL FMCSMPYI(MXY(6),K2,MXY(12),QX)
             CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMCSMPYI(MXY(13),K1,MXY(12),QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             ELSE
                 K1 = 48*K
                 CALL FMCSMPYI(MXY(13),K1,MXY(12),QX)
                 CALL FMCSMPYI_R1(MXY(12),K,QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 K1 = 336*K + 632
                 CALL FMCSMPYI(MXY(13),K1,MXY(12),QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(8),K0,QX)
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12),QX)
                 K0 = K*K + 7*K + 15
                 CALL FMCSMPYI_R1(MXY(12),K0,QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12),QX)
                 CALL FMCSMPYI(MXY(12),K,MXY(9),QX)
                 CALL FMCSMPYI_R1(MXY(9),K,QX)
                 CALL FMCSADD_R1(MXY(8),MXY(9),QX)
                 K0 = 7*K + 15
                 CALL FMCSMPYI_R1(MXY(12),K0,QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             ENDIF
             CALL FMCSMPY_R1(MXY(11),MXY(8),QX)
          ENDDO
          CALL FMLN(MXY(11),MXY(4),QX)
          CALL FMSUB(MXY(10),MXY(4),MXY(3),QX)
          CALL FMCANCEL(MXY(10),MXY(4),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(10),QX)
      ENDIF

!             Use the reflection formula if MA was negative.

  180 IF (MAS < 0) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(13),MXY(6),QX)
          CALL FMDIVI(MXY(6),2,MXY(7),QX)
          CALL FMINT(MXY(7),MXY(2),QX)
          CALL FMMPYI(MXY(2),2,MXY(8),QX)
          KSIGN = -1
          IF (FMCOMP(MXY(6),'==',MXY(8),QX)) KSIGN = 1
          CALL FMSUB(MXY(13),MXY(6),MXY(9),QX)
          CALL FMCANCEL(MXY(13),MXY(6),MXY(9),K,QX)
          N_ACC = N_ACC - K
          CALL FMPI(MXY(11),QX)
          CALL FMMPY_R1(MXY(11),MXY(9),QX)
          KRSAVE = QX%KRAD
          QX%KRAD = 1
          CALL FMSIN(MXY(11),MXY(3),QX)
          MXY(3)%MP(1) = KSIGN*MXY(3)%MP(1)
          QX%KRAD = KRSAVE
          CALL FMPI(MPISAV,QX)
          CALL FMDIV_R2(MPISAV,MXY(3),QX)
          CALL FMLN(MXY(3),MXY(4),QX)
          CALL FMSUB(MXY(4),MXY(10),MXY(3),QX)
          CALL FMCANCEL(MXY(4),MXY(10),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(10),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(10)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(10)%MP(J+1)) GO TO 200
              ENDDO
              GO TO 210
          ENDIF
  200     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = QX%NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQ(MXY(1),MXY(13),QX)
          KC_RETRY = 1
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  210 CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMLNGM

      SUBROUTINE FMLNGM_C(NDIG_C,MBASE_C,C,QX)

!  Initialize the constants used in the log gamma polynomial.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: C(0:196)
      INTEGER :: NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      INTENT (INOUT) :: C,NDIG_C,MBASE_C
      INTEGER :: NDSAVE
      CHARACTER(220) :: ST
      TYPE(FM_SETTINGS) :: QX

      NDSAVE = QX%NDIG
      QX%NDIG = MAX(QX%NDIG,NINT(210*QX%DLOGTN/QX%DLOGMB))
      NDIG_C = QX%NDIG
      MBASE_C = QX%MBASE

      ST = " 6.931471805599453094172321214581765680755001343602552541206800094" //  &
           "933936219696947156058633269964186875420014810205706857336855202357" //  &
           "58130557032670751635075961930727570828371435190307038623891673471123350M-1"
      CALL FMST2M(ST,C(0),QX)
      ST = " 9.227843350984671393934879099175975689578406640600764011942327651" //  &
           "151322732223353290630529367082532504853685527501929175190394959855" //  &
           "13457163775826002355076463746499666257062662262326057207404741752905084M-1"
      CALL FMST2M(ST,C(1),QX)
      ST = " 1.974670334241132182362075833230125946094749506033992188677791146" //  &
           "850037352016004369168144503098793526520021594811685953398143623435" //  &
           "02503893967551473165433138415866654683881302547625503436070027398405779M-1"
      CALL FMST2M(ST,C(2),QX)
      ST = " 2.568563438653142846657938717048333025499543078016629393075718511" //  &
           "394606859543769672881862453644508604873305259842023980616399866622" //  &
           "44277379254656124026333871513139276497866889063971918407474980813205213M-2"
      CALL FMST2M(ST,C(3),QX)
      ST = " 4.955808427784547879000924135291975693687737979681726920744053861" //  &
           "030154046742211639227408985424979308247703477010685603646017893642" //  &
           "51133732050087867905480177194587022770925733154718370654381840105887655M-3"
      CALL FMST2M(ST,C(4),QX)
      ST = " 1.135551028673985266273097291406833611416183900382562394838535580" //  &
           "760717957256296912008621311426667275924068293311321808560192355831" //  &
           "19416836702214436017528973257267436070719672792473025777796267055355048M-3"
      CALL FMST2M(ST,C(5),QX)
      ST = " 2.863436640748566190863216318200879836362483388089269737347773340" //  &
           "553638169929829804623296564225284217131985270424264778996969080555" //  &
           "16975632152723012109455292088401608926031282713256898710394755277209657M-4"
      CALL FMST2M(ST,C(6),QX)
      ST = " 7.668248313183240568536426425667994283765150931981520246901951022" //  &
           "878261676510504944242413055018913842306480735586784104096820283433" //  &
           "36343308283287191406517315813519407491295119077092395710810995273468308M-5"
      CALL FMST2M(ST,C(7),QX)
      ST = " 2.138827474304242233565481358155815737009883123125254113877533157" //  &
           "286907184360179941090379654649639056545605878533625329428744350917" //  &
           "29963707838227249505773740942777859121824166285189382035452217278554155M-5"
      CALL FMST2M(ST,C(8),QX)
      ST = " 6.140869564690490872529914712451165067316821654306283177401767753" //  &
           "894821139822105599229903018842906378733862871895584602819330080270" //  &
           "01700768138875158345454772076408505044108823934202891440461609291305270M-6"
      CALL FMST2M(ST,C(9),QX)
      ST = " 1.801262781808533714595890031901700601953156447751725778899463629" //  &
           "146515191295439704196861038565275400689206320530767736809020353629" //  &
           "38073190695949842873953621603334722352596732052178932328832066543779584M-6"
      CALL FMST2M(ST,C(10),QX)
      ST = " 5.370321926785962456620478609033153278577962007833744674032818230" //  &
           "963452927104275083493657782390759550975407401180548454361763677022" //  &
           "25719502127813332819843513403345897099400330508911246024488125358988974M-7"
      CALL FMST2M(ST,C(11),QX)
      ST = " 1.621606923373582198331706449725800346740381669503777534126777710" //  &
           "016401617427540869007126583916228785817454388595224584374431558565" //  &
           "62424003947302186656188945000933064454593249101343833268069567881424866M-7"
      CALL FMST2M(ST,C(12),QX)
      ST = " 4.946423680685744244896356595351648270045350075731820789781699205" //  &
           "590998801613945328568871293350300180372347783056466467421940336962" //  &
           "37993051766799459115354359781619794227922798691721786471256812355243228M-8"
      CALL FMST2M(ST,C(13),QX)
      ST = " 1.521277205034494703893608109526767726401208246782019680016091878" //  &
           "150165553006261855592657131910806289218694348060771816544039319519" //  &
           "70268151503584997891542218258262605500864512242956007183617857332741602M-8"
      CALL FMST2M(ST,C(14),QX)
      ST = " 4.710545468032903448567376337505841863247123878500437995526222151" //  &
           "143756151971538155623134503232957797896283285550201985050591879362" //  &
           "14529603180002288823222154049517099193894892610640999441314930078235979M-9"
      CALL FMST2M(ST,C(15),QX)
      ST = " 1.466896634491983285717977295126452336811904470697069075224299192" //  &
           "939247071986642850302895153896641951172329934777380990036068940704" //  &
           "92049327640255496401589822485890032872392277699930611719523121420745147M-9"
      CALL FMST2M(ST,C(16),QX)
      ST = " 4.590062735154278588407978252478287205347213340644341084689962143" //  &
           "111930858436518669786421571299766271527706531603537599776303515851" //  &
           "07346286911988982005532291493494947163957826550954358278107733999478261M-10"
      CALL FMST2M(ST,C(17),QX)
      ST = " 1.442221874911031367580345522072474831788307406190652461104238910" //  &
           "857027803132223315927216471971838450273509423200923289440756059767" //  &
           "68857423403274844425475990232160708382227977333807182882605816718263351M-10"
      CALL FMST2M(ST,C(18),QX)
      ST = " 4.547809165468029773462079480806624058657045422294384456641178682" //  &
           "659691101645601195358296330035349908208769392426188702234370516180" //  &
           "56888377164494448967006811680025457321926050295945478985302205704218490M-11"
      CALL FMST2M(ST,C(19),QX)
      ST = " 1.438587332730565760193417246729718970937052978750282449255687568" //  &
           "655719501289180489881937394774257940434077254947095313349728878573" //  &
           "86843008158160916187514601728862636178280076324418505631445853717950171M-11"
      CALL FMST2M(ST,C(20),QX)
      ST = " 4.563265937212529367600208240284116509275473219057499398885563766" //  &
           "090388563517935169737964577745895815190180995118452252225828163120" //  &
           "99722426850021624306978846433211406278468453662456948824141382999031282M-12"
      CALL FMST2M(ST,C(21),QX)
      ST = " 1.451073916840454711281216045224320082808166284993163778021566315" //  &
           "255587037332552553079272066121649499425851990060321384124955433677" //  &
           "67207993278060823840271886615031403999360286605743411932260491743002791M-12"
      CALL FMST2M(ST,C(22),QX)
      ST = " 4.624528056444812082051687967994458694688921677653576433580975534" //  &
           "968450053554049283580808625060631085218986361103614972923204710045" //  &
           "87054803107018718005909662543849301887854984204280816281128477629296891M-13"
      CALL FMST2M(ST,C(23),QX)
      ST = " 1.476781612022755183419973250511459966182209498276769571800718539" //  &
           "731445227020086180343751505787486916705816774093130509272233480605" //  &
           "44047487934404934553435264532664986314948239961478420907068538648968405M-13"
      CALL FMST2M(ST,C(24),QX)
      ST = " 4.724507827870744254820277464047378923678173249594725356053537843" //  &
           "069856328276686251584801735153843799291487544822727471278651677292" //  &
           "03640042606725210618105758740751314683086483423378587429797730710810703M-14"
      CALL FMST2M(ST,C(25),QX)
      ST = " 1.513978913019171763487041148572556877568791963643984495346043449" //  &
           "018701962532639151560210080671482947559816365848586253646530778070" //  &
           "18537123717716793256274213468254921216965019092087180696648092689644960M-14"
      CALL FMST2M(ST,C(26),QX)
      ST = " 4.858996725976554852006318671090915519699354289999749614013042503" //  &
           "935984106218549522233834213516072290014623125419558504921174284920" //  &
           "78107160688407534237846157628451620609106027079137343790816294845243811M-15"
      CALL FMST2M(ST,C(27),QX)
      ST = " 1.561654519392582828714942943686889037831993268563190525220343034" //  &
           "296584463347814354645233174014087011036651133377861482059644157593" //  &
           "18350440790655464091846868252936233878726656395056209922850191735361446M-15"
      CALL FMST2M(ST,C(28),QX)
      ST = " 5.025614514474191003429454120021263907058345057163756484675204032" //  &
           "160626854269473972760278335161149373855516115547324556053250680761" //  &
           "35960353957624688528998376864715123324194768194244608331227956016708835M-16"
      CALL FMST2M(ST,C(29),QX)
      ST = " 1.619268063222415588245007073271189318378938728336204453480653557" //  &
           "646832121167874868009309695437374462682430335955717169955384406157" //  &
           "35461655626485084754177259606520323581270018242949002547200222070367875M-16"
      CALL FMST2M(ST,C(30),QX)
      ST = " 5.223211739191891688145554861633126404312733249590231268939276354" //  &
           "483256718224458681957003067572062210319658187678206505904762786890" //  &
           "39036962584739426283467796928036615339321696596679043636072535930177735M-17"
      CALL FMST2M(ST,C(31),QX)
      ST = " 1.686605565375918423742481404695259319639157222117507057462225591" //  &
           "850533083720983505743619854637504171953994487105802289063236646168" //  &
           "31565771482245546699030298377683203899275714959867483319947682463166471M-17"
      CALL FMST2M(ST,C(32),QX)
      ST = " 5.451517284342611284349867604595522641598896765349022422637246200" //  &
           "744471171937423465939660935482207447703449379192989322923063888266" //  &
           "31229372543901089934035916918836653287495719335136501890625959613216773M-18"
      CALL FMST2M(ST,C(33),QX)
      ST = " 1.763692929460761010585031266299209488371094586913873180122443276" //  &
           "358212007822366334544290589814884405499150265809186554929224793099" //  &
           "67159580614375385516830687382686358909934655641565142758100304193688125M-18"
      CALL FMST2M(ST,C(34),QX)
      ST = " 5.710924940930289429222525846887709139266580644631501378754425400" //  &
           "402344096734033498368417722870024289649356569956325790061028789490" //  &
           "90201209337135311180824855625236387835485476090642686407138148182122938M-19"
      CALL FMST2M(ST,C(35),QX)
      ST = " 1.850743092341469168679255116939946915034455019205428394047707184" //  &
           "730616709166372869327273711967997594444383081358747754694208065117" //  &
           "59243078812287887751986055564202797220696526499221359781019466183552083M-19"
      CALL FMST2M(ST,C(36),QX)
      ST = " 6.002362311111352855438751511526624123122881372177829574698482082" //  &
           "268472189497794035844163044963208202280717860883655584808569201908" //  &
           "84840540664364095292197489013673097320200190188150543497148096517991518M-20"
      CALL FMST2M(ST,C(37),QX)
      ST = " 1.948123521680466000278613877664857969433940710389346300112405920" //  &
           "570813255255307791273062459813736293577657819726099571791897412896" //  &
           "04499052083706223596278073126974722712855926508631000226750654451336437M-20"
      CALL FMST2M(ST,C(38),QX)
      ST = " 6.327210499275762922454617564886905374837540270134647521961777337" //  &
           "241208973850468966202699863294902233722101674486074157046009900783" //  &
           "94943168708628546063295850691161365924829349560770067069849204243333875M-21"
      CALL FMST2M(ST,C(39),QX)
      ST = " 2.056336517258456819404872718846500024771970712636992752800634217" //  &
           "390177588265180513218328462256818578504975537617618012477658735253" //  &
           "91357901005319898451317799466679533736509835947206121997945730419581125M-21"
      CALL FMST2M(ST,C(40),QX)
      ST = " 6.687256410663997968707038300952324368643567824691228269512829884" //  &
           "600241200120276396209386234811912763595929600746527477568692380093" //  &
           "65846941054535500737409129245379236794232295378392955072876104303576437M-22"
      CALL FMST2M(ST,C(41),QX)
      ST = " 2.176007902867600569564968838424519571170445852508011400529276121" //  &
           "985778848606677081067574991228552820893084306450020295730062213612" //  &
           "47319852047491615671942139635029927212587004293525094112235574131058548M-22"
      CALL FMST2M(ST,C(42),QX)
      ST = " 7.084666872547745583697885218008349498259999765144828626416539742" //  &
           "112817790036483006355449086393842354631309401157315763399808881211" //  &
           "63034428362049804231045013084677403365104232875460124915055150115352532M-23"
      CALL FMST2M(ST,C(43),QX)
      ST = " 2.307881457325186109702251558024026338622462538196464637417250145" //  &
           "271014677258724350821337105472668901649544195158107332539530013289" //  &
           "58690754615380156771062458199324618311119940721724411263802909784747175M-23"
      CALL FMST2M(ST,C(44),QX)
      ST = " 7.521978024882350363251147127637517006885196169534728483482110729" //  &
           "767330760893859561440994301232670866451144204592673539313561020703" //  &
           "16229680624073031879503528876975581601231458676853213367966509358616500M-24"
      CALL FMST2M(ST,C(45),QX)
      ST = " 2.452817457661126560656022558232578383346781683732614004543641047" //  &
           "950608697083659342320485224577786541964544409466877827518882696166" //  &
           "77785583812635059733861275531662340097681814492066607106278651398864552M-24"
      CALL FMST2M(ST,C(46),QX)
      ST = " 8.002095926418321660462882983562136934827167736984869734245484961" //  &
           "990362339894468819446499270621544724743989273983343985659243797090" //  &
           "02617723679997529884675116233201816776147675793642923747702696525736417M-25"
      CALL FMST2M(ST,C(47),QX)
      ST = " 2.611794321654760040868482915030344896471378127607902926579083608" //  &
           "600355795254414772701179436107007717915331779124504018381582369712" //  &
           "35303338971473297210813756554582658474866145972030534849911654352767572M-25"
      CALL FMST2M(ST,C(48),QX)
      ST = " 8.528305842439874174397891979909201174136636691345390271985961340" //  &
           "951635472717713994160270983358301811012414732109357429143927205677" //  &
           "24451493207732247380061110874133984404716199859823728402868897884262789M-26"
      CALL FMST2M(ST,C(49),QX)
      ST = " 2.785912715941407608332964765121774292928933289953979801676819715" //  &
           "042211815722358756877838540023159292634878096952517082899902453482" //  &
           "75453420374439979087786662261117071847545271472089893478013180932399900M-26"
      CALL FMST2M(ST,C(50),QX)
      ST = " 9.104288632359302486087921738156084451459177031330022615977426375" //  &
           "389281113948847333526780396722062239770555955153203912544147152689" //  &
           "10635505098052873178484650793531962248685195239569728214014565219560910M-27"
      CALL FMST2M(ST,C(51),QX)
      ST = " 2.976401736830878380813487190839719864305643062243346972314080928" //  &
           "571659774700309771395429511816849731798335554291299072632159561785" //  &
           "13853498257646786277128193242849488156599291079190249617494763928122532M-27"
      CALL FMST2M(ST,C(52),QX)
      ST = " 9.734143269753073619444573395909866046087281775327043563820191216" //  &
           "592074666762884461637185638436344417629043795119832288445119716594" //  &
           "54681757554722607199255640890946515559342596226071714786376672991314824M-28"
      CALL FMST2M(ST,C(53),QX)
      ST = " 3.184626928899218981583942072541398262319779552845939844429551688" //  &
           "572650417481499150961066174605543822869303332888433674715027707880" //  &
           "04490731942311456494319892555319423931924782646792891555889559629511546M-28"
      CALL FMST2M(ST,C(54),QX)
      ST = " 1.042241493677369606594579977699800680670958579629702706075164525" //  &
           "911994152904008645633144958538688068689955477642378460321912420061" //  &
           "44713093711611925694102923080704525452321573189336778639403115171327402M-28"
      CALL FMST2M(ST,C(55),QX)
      ST = " 3.412100013470891170294585716908258368140834550044525411190398041" //  &
           "104754921079862028936399162559763428726672165337980689582820113040" //  &
           "13416198464826440959995204574451765227502181269455928284526174312187664M-29"
      CALL FMST2M(ST,C(56),QX)
      ST = " 1.117412841751556843302074248615568735696721287113186281328504084" //  &
           "312562222725968138902580374246217663276066641488490501477225640253" //  &
           "42579986440180416098324496187285052304475776686406646945052809161071102M-29"
      CALL FMST2M(ST,C(57),QX)
      ST = " 3.660490274490043678026226644620183224238038689661082986523077162" //  &
           "981414308819425679643969633533180026092880760915904811622562886923" //  &
           "84487396264603185012812742600008480127678888705848700357490206046685979M-30"
      CALL FMST2M(ST,C(58),QX)
      ST = " 1.199482671814381161791341850793296252666044625258418739613110049" //  &
           "104551626086380287997089537812232630867438710978470875637869385419" //  &
           "01607003246251775392139826953129400440619709892748008039595593739769704M-30"
      CALL FMST2M(ST,C(59),QX)
      ST = " 3.931637604707211006390296608348190956772148951812063256727344243" //  &
           "900822542438555764328768554173091304365555553142603137727525766441" //  &
           "84525659723982712681986023184076666876842449810082867584381453291908627M-31"
      CALL FMST2M(ST,C(60),QX)
      ST = " 1.289061499462497744696303533633690434193534414239284689686070597" //  &
           "676814880055275326028949838642762828605994974529472129232550363697" //  &
           "60950396038294052993668381573708577221742561680239596349647149571718672M-31"
      CALL FMST2M(ST,C(61),QX)
      ST = " 4.227567257903962351790508597715893632841769835136110706800940837" //  &
           "829652461572432184043919015812076564236545988931174492991859433101" //  &
           "25778000859246543191517786955778130308647637177926547762610318839215217M-32"
      CALL FMST2M(ST,C(62),QX)
      ST = " 1.386820999018780266062944049316369528834057757206382128765313047" //  &
           "270244006158501294298057326510552601141951742736581362353221200763" //  &
           "47128739854666116108186922912060771673278920840786086509429347218298547M-32"
      CALL FMST2M(ST,C(63),QX)
      ST = " 4.550506387724437506082055927268146785006102873281969302732936243" //  &
           "298895572505202160358438794407807710437237187496655791039130216893" //  &
           "87511924875421792179416180376854086009363053011270507639350841775560466M-33"
      CALL FMST2M(ST,C(64),QX)
      ST = " 1.493499528613739965372638972965391238482547633295265869054828367" //  &
           "829416466398480374395870941759362578697731625235707888992530344564" //  &
           "64118616870137110287959590352137938213456367349222761768780656871967062M-33"
      CALL FMST2M(ST,C(65),QX)
      ST = " 4.902902483647573629190444872668433339026722693539103782664050983" //  &
           "225694025564768841074155141457059295428474046880275907189034299237" //  &
           "32944103681204447082846734232378539796234753927604216121433267289535418M-34"
      CALL FMST2M(ST,C(66),QX)
      ST = " 1.609908275928169570082165607481456370083831087969406562557256167" //  &
           "364188362846846549047875066952892162692919458759129310778349489953" //  &
           "22770448873819282967830858947780630728913545194644474976588962028982890M-34"
      CALL FMST2M(ST,C(67),QX)
      ST = " 5.287443841783967253336743861164853484418810262590989794938834387" //  &
           "073299404536655202675616502143848847208164288382903044431016858516" //  &
           "20009538336266282148044005430788026679223320414557498337146361309107021M-35"
      CALL FMST2M(ST,C(68),QX)
      ST = " 1.736938072243109805185530725881959995611305822994512775248040487" //  &
           "238177289693647144646295113799732566680032754548503116064306224752" //  &
           "78198414114124592660116717229603109916607439068859873993478598764324167M-35"
      CALL FMST2M(ST,C(69),QX)
      ST = " 5.707082233953717693925573957068774870416069447922801957662691273" //  &
           "270987710445603289113054181853887859043710418144298938936434365836" //  &
           "22910905014974542359781276508954019188261527426571788239315967868621528M-36"
      CALL FMST2M(ST,C(70),QX)
      ST = " 1.875566930504197126372674019737550486762741857855257836323427280" //  &
           "225964790637523226088657691476666774290875901414134481518247331060" //  &
           "71906874659900660807946217987043810912477339050139457949133330400430348M-36"
      CALL FMST2M(ST,C(71),QX)
      ST = " 6.165057963933168318023358517808802281756068067015463002715232153" //  &
           "371564234012532194529099415076087246371078651694171463516031915534" //  &
           "01898954460353148685542639895937235904606585101085654511370630295486436M-37"
      CALL FMST2M(ST,C(72),QX)
      ST = " 2.026868371192165401197185010283739193718905421948964225522412850" //  &
           "262737204848695188406921800082238582127540011428039129914658458542" //  &
           "37634642867581786423872725394317163245280102057930986208119247853710652M-37"
      CALL FMST2M(ST,C(73),QX)
      ST = " 6.664927525630725280315186707639828112376671188813408419458083523" //  &
           "173661970136566062651079390703015968881216092673504456192083877599" //  &
           "15804352132821230683566017780795660498858012885579266098347848714173428M-38"
      CALL FMST2M(ST,C(74),QX)
      ST = " 2.192020608118261066539037933528189571558724587838583580744609163" //  &
           "952034074131032109073883254528947795371825396404707207594960566130" //  &
           "08388120561413633077336889145268058079508281341166298919160705693687869M-38"
      CALL FMST2M(ST,C(75),QX)
      ST = " 7.210594104883918757684569353059178987815466143353338512729476387" //  &
           "590176795023385801954403484227849398454243048187188857331730164109" //  &
           "61130821394037069074892323683471141755158288684895958165035966426280590M-39"
      CALL FMST2M(ST,C(76),QX)
      ST = " 2.372316675010334396327093341566291045560598544381746314200798914" //  &
           "361335388290174563770200693760939384221618459565684611293948349762" //  &
           "99760715272696457406804603245507893941691344795060823654575302742922341M-39"
      CALL FMST2M(ST,C(77),QX)
      ST = " 7.806341195078978788896796569353844545546683670636287097360101000" //  &
           "674819867286255396945996712341079701193140494784764939652507657527" //  &
           "10776509577749635871445825212032538401033636476215858432876024174293608M-40"
      CALL FMST2M(ST,C(78),QX)
      ST = " 2.569175583075068496597802624641121843008905917144485747977702000" //  &
           "084716234785945953181138133105853830584529894491272387561559175918" //  &
           "06056635101515773378678277304459406269213364274389438074596955963853941M-40"
      CALL FMST2M(ST,C(79),QX)
      ST = " 8.456869627337005555483543945000411129981141780087868584229158532" //  &
           "975156474362982393176600086105992624536940685475408780825634971862" //  &
           "82928746682884903136048829786952212289839035702247341347744500864695940M-41"
      CALL FMST2M(ST,C(80),QX)
      ST = " 2.784154609752488682347830682317399839437808496760216533359957844" //  &
           "108419936184123983123382869988781032193042150722634481595940148079" //  &
           "47471887024692990616525022991390619756225607915282611367773077871045722M-41"
      CALL FMST2M(ST,C(81),QX)
      ST = " 9.167338349011185351110270732877594395344097568799016206592150045" //  &
           "211148681681966966935859814202597754161577071431235188923674247559" //  &
           "93097788462831296346214350780525347998671878506396254329112437194116937M-42"
      CALL FMST2M(ST,C(82),QX)
      ST = " 3.018962829751912207860422524685002365325324396585948666388970238" //  &
           "468900826307200635678324473325455973126327818463443937367696783407" //  &
           "31216822788529908321030119923263022821575928202721712476375757572174960M-42"
      CALL FMST2M(ST,C(83),QX)
      ST = " 9.943409320108569385064969631771335447816687861933253786118347289" //  &
           "942417796521205611575152291429262471820315825809582098019324351274" //  &
           "19736007449168383766428225696036997597572676990996005739875078089934258M-43"
      CALL FMST2M(ST,C(84),QX)
      ST = " 3.275476011303678103893551709440913333007415558028940493123054436" //  &
           "102576111138063293549771997379461070822607505834700351586923416924" //  &
           "36130515829060972565436000080016114747837549174742969323583514548979337M-43"
      CALL FMST2M(ST,C(85),QX)
      ST = " 1.079129693640085894851434181915227380977317782277815512357487683" //  &
           "235378082315776477576402633427103515916665364561427248912637998286" //  &
           "84497336603622824659763899982809691142662878118295489894583048485526949M-43"
      CALL FMST2M(ST,C(86),QX)
      ST = " 3.555753013510719060083393999120543994047683529242126292544972222" //  &
           "356576357296720319402739291176562890757829588273748247638519856640" //  &
           "67480610895714757344602846046498898788815371622608783151322531494411842M-44"
      CALL FMST2M(ST,C(87),QX)
      ST = " 1.171782243084804960250703836375832017652851729860152530408648875" //  &
           "579920584019031061094655011368498851035103058003948560022564877979" //  &
           "17046691205570131651535433024120306105982182247803947139577240760760240M-44"
      CALL FMST2M(ST,C(88),QX)
      ST = " 3.862053834876472821052586382551496075098455346933359196501245526" //  &
           "180729685642432233621061970152222441386142907366726076208958805328" //  &
           "70627198276478969445218445704378235779473329084661077747371015095013204M-45"
      CALL FMST2M(ST,C(89),QX)
      ST = " 1.273047375197605743053349834215496117644063043473174035166207181" //  &
           "768692059655110422250456339545311971995535730478050915338536261677" //  &
           "65444071293612365602178273688293636174364964871538328370023554265881805M-45"
      CALL FMST2M(ST,C(90),QX)
      ST = " 4.196859478667449972989243439715623246016537566511261080114559563" //  &
           "758135987775813449384022624930316510736358259866183402630340459291" //  &
           "72668526906989173105067164347823743598675043393233726870416684054894389M-46"
      CALL FMST2M(ST,C(91),QX)
      ST = " 1.383747146950471434825293091024083280747013661478053604841911598" //  &
           "022310276318757265593640560735257184999994184693906229160627176389" //  &
           "15615636692838842344470182112269725385554047172321124664394879685510285M-46"
      CALL FMST2M(ST,C(92),QX)
      ST = " 4.562893817897541724781950430442496378260377512288497109803666040" //  &
           "621854629198431249084998659248405128970881921614143709856471314566" //  &
           "71187340235712918767373708561614114398918238461996856137728111624669887M-47"
      CALL FMST2M(ST,C(93),QX)
      ST = " 1.504784131433391793257248428485220036318516611757628814861273953" //  &
           "241786001999746507693533747202375916340889614020197821617964401281" //  &
           "09223232430673952549932990159444752780504141754928914375319317506618075M-47"
      CALL FMST2M(ST,C(94),QX)
      ST = " 4.963147661567547539987958807734897162902530398116312148944960055" //  &
           "796268377992054321453624007551095855206124470724586679336263613115" //  &
           "89091300344790164050318056261092913116282166570730942288235067198317928M-48"
      CALL FMST2M(ST,C(95),QX)
      ST = " 1.637149402252630927456890226306016168030553715912510338166421018" //  &
           "082250171874970269061229738963393420354696075864382273796383465054" //  &
           "54500820509537840793087307985392209620656037379007014938893681782187286M-48"
      CALL FMST2M(ST,C(96),QX)
      ST = " 5.400905244543393186874620589431418037639831941879628434368248998" //  &
           "722906347036053715166862260092049668825631280975790017953688626636" //  &
           "15617148734065300820447033765217546328421226646834925099741473350545005M-49"
      CALL FMST2M(ST,C(97),QX)
      ST = " 1.781931322178944118647377674747852837095476406297808108639777839" //  &
           "710695191748931947375083891115191186633327477558489708276330078077" //  &
           "84355945700557484952518727190790584478520941307748997078811897348262566M-49"
      CALL FMST2M(ST,C(98),QX)
      ST = " 5.879773386313522948360905422632431077145168395771420120384935880" //  &
           "807587039058575601777312600437920559716301465154041152414856698220" //  &
           "03215044402130085493835602372831521053966369492752843371900098859590805M-50"
      CALL FMST2M(ST,C(99),QX)
      ST = " 1.940325217483255139116418908036918257576300407306275798031334364" //  &
           "409600080862034828483316076995017274377332356098893076821893973234" //  &
           "40382503373462356947628021148992374363794778068565614630007284818985556M-50"
      CALL FMST2M(ST,C(100),QX)
      ST = " 6.403713589053133873710962618711106281414140108122214547412024301" //  &
           "692917083153216025874647060197659674432573844849077628829246217574" //  &
           "60249742706649007645817489620506941120553080709097100788465375868770515M-51"
      CALL FMST2M(ST,C(101),QX)
      ST = " 2.113644027759240612416047225977851974737748960538792675174058961" //  &
           "161021976645079782965719680309463063367873086114357869089879642560" //  &
           "91741774488093918815994311848793042306225840389086585033999559719325383M-51"
      CALL FMST2M(ST,C(102),QX)
      ST = " 6.977077373185528123141201643198765846940778946562652437177053180" //  &
           "068202610894634761485494475059094517798144344611412525007119040744" //  &
           "47619138364742657951321893292966244857904586187576743960389378098756527M-52"
      CALL FMST2M(ST,C(103),QX)
      ST = " 2.303330030250272718045226178470266630636882414669936525013604526" //  &
           "663877295122333165527547705932002051525319167095677157791507288736" //  &
           "64026571366295683502084852088545059435402597033343652161501470364354290M-52"
      CALL FMST2M(ST,C(104),QX)
      ST = " 7.604645179238802714709378571216485567328230281028063584140295724" //  &
           "376585957946481904384646230934323963536666254241381678030728396763" //  &
           "58178737195689600607109967321748886837389095954530241223910865091320330M-53"
      CALL FMST2M(ST,C(105),QX)
      ST = " 2.510967747861821044453112929896090858886255004999542279673792434" //  &
           "537208309423086735805390141224743694821441092754412288490320556507" //  &
           "90129078122051056660926795028903236517945321893911606739679056323908271M-53"
      CALL FMST2M(ST,C(106),QX)
      ST = " 8.291669198546705061835867356103780154660596199979498029660459478" //  &
           "188005146704679300246430992623307755626947749069085299081605791921" //  &
           "74019998848391467377542111031322996337770209654839668772234104877607677M-54"
      CALL FMST2M(ST,C(107),QX)
      ST = " 2.738298161248419586570035179837181952253572874107137240705415238" //  &
           "006265247194645939919863261646299211192029639655806078478918931977" //  &
           "00593190887265237361465699889511989159926295238433577049420127008639310M-54"
      CALL FMST2M(ST,C(108),QX)
      ST = " 9.043920532563515029285236381202044755606494352793597664587001938" //  &
           "974036674170391738386361814188362066318933595609565234700634164118" //  &
           "70487847122956051574723330382189769818956900012640799709823774379723508M-55"
      CALL FMST2M(ST,C(109),QX)
      ST = " 2.987234357725506677158331533521097034607039220763832901730464971" //  &
           "787758443274701147417241273125203557371693807601776736455273977366" //  &
           "05803089099448475489215616434095538698506543339535511526713482057801648M-55"
      CALL FMST2M(ST,C(110),QX)
      ST = " 9.867741121615743267416100354228158234050959334204884456346592478" //  &
           "319239204688512319808683885900238794688432245788378036339502910311" //  &
           "95256267366461853050971201508370739481479021507935296576188223198846781M-56"
      CALL FMST2M(ST,C(111),QX)
      ST = " 3.259878763390904147253084369202388245824453621447959285540458582" //  &
           "736012876275248713545534462435398177897630905297446122213135317168" //  &
           "82679622090783961983706156224847005117892642811444666243882001638133683M-56"
      CALL FMST2M(ST,C(112),QX)
      ST = " 1.077010092919706009412412261729007614456466446787757717767031010" //  &
           "139026034411384632610387807051427675075586800080476142293720773922" //  &
           "20272670887152593395631417854201652294534598158204732976231392133784649M-56"
      CALL FMST2M(ST,C(113),QX)
      ST = " 3.558542119880893194099946299932858465278352616190909402621150713" //  &
           "569585013772896155460681917876143100438779403865861290242704606012" //  &
           "88545096496889803741553260243082158570103416935736970008787448980973697M-57"
      CALL FMST2M(ST,C(114),QX)
      ST = " 1.175866091786728245112848768043708292858352425382756439383320272" //  &
           "578862130652141603853077265569964741389836105657992359851950676535" //  &
           "04338748169984545024264075261487170842373741152762109550508117751868574M-57"
      CALL FMST2M(ST,C(115),QX)
      ST = " 3.885764383777977106238860501037171757872128590510931610888692650" //  &
           "910285334868201439319749230933970529786352570062128138073985716014" //  &
           "24775116761936632328170508559558303761107738144547614997375397249406443M-58"
      CALL FMST2M(ST,C(116),QX)
      ST = " 1.284184240792720746713802455067655929838349505783919451560002320" //  &
           "126603715783906155689196669126320213369826150934215436793861556561" //  &
           "85972584789613262065820990433273679374866590546774541475968702317884481M-58"
      CALL FMST2M(ST,C(117),QX)
      ST = " 4.244337744992888045444183568112374868793650501308024498979691533" //  &
           "890762987246535790550234061933625766554201413681894303054318079987" //  &
           "15016824304537959514257416420938167100044999559848904364273216745412168M-59"
      CALL FMST2M(ST,C(118),QX)
      ST = " 1.402890347084483369665088764818551961487912000082962187928218261" //  &
           "785089551297393342668713450909249794752403435631477836303274921114" //  &
           "55362046946784217832779503423966063510800253866244156993968505509787734M-59"
      CALL FMST2M(ST,C(119),QX)
      ST = " 4.637331980640374010893092224461382977846892054658359797965131441" //  &
           "456865261185257586124099243621668370219467668437596174204742705530" //  &
           "83668639386769597559944266590300361763651777592096905886759195912398458M-60"
      CALL FMST2M(ST,C(120),QX)
      ST = " 1.533002307649710027030813938667476629444482989777771349009392774" //  &
           "898001472950267391452028201567335345539750749325735733749863033002" //  &
           "69548753895579308292780126786018722213349444264135999363029954583214006M-60"
      CALL FMST2M(ST,C(121),QX)
      ST = " 5.068122383213521254015903956436646089688648450514341540538884175" //  &
           "869469050644753957457320055403310802554634158264858859825705672789" //  &
           "91662731199394270951038339532656379827609414997054764442302975300731162M-61"
      CALL FMST2M(ST,C(122),QX)
      ST = " 1.675639378731841475760363897846833007051598415558153712467179977" //  &
           "432925958506220080221518370999946501032024092613108461163906099341" //  &
           "82913060234132996850622927932164528031237880466865308048851412708423659M-61"
      CALL FMST2M(ST,C(123),QX)
      ST = " 5.540420526452055898116485439538895779663375849440317942175183295" //  &
           "232404269513749797742436944684450241469393462030971608777003451754" //  &
           "24373370189591105970695273793446260615786377827169998532420885870021362M-62"
      CALL FMST2M(ST,C(124),QX)
      ST = " 1.832032387413479669586574511502151686557921294324566012744100766" //  &
           "650543443902590363016386993218294974037346220641170740186656299364" //  &
           "35042400328594920807120027126914313294894904628053322733053994091135028M-62"
      CALL FMST2M(ST,C(125),QX)
      ST = " 6.058308159436109652922013909249826504043342021872382519752917607" //  &
           "688622870375413804432273155114051562335231336139713200850863559312" //  &
           "92844948695425942146384859065918295663347978412467638683301971137894309M-63"
      CALL FMST2M(ST,C(126),QX)
      ST = " 2.003534981860760581951442341610686092565547269730489837317963845" //  &
           "620455952950683642101005961045434369116586359058385158147557980542" //  &
           "11638367930496346396938524050401454422736023568038546321742832881166705M-63"
      CALL FMST2M(ST,C(127),QX)
      ST = " 6.626274549383244408116266205294449505997555094384610044245319246" //  &
           "030550314415978028317676220529142615194623162680155029534077714720" //  &
           "63797428182476797631017411639144206566456794143210250637764789933866701M-64"
      CALL FMST2M(ST,C(128),QX)
      ST = " 2.191636026669393443536074125395262735461777636080096892966692835" //  &
           "413006758477349117295402033106637857465621733449271837481434101507" //  &
           "59193133722553066298412025354918228064474978225340425161474540247412694M-64"
      CALL FMST2M(ST,C(129),QX)
      ST = " 7.249257626675685867142261929211249822372411007081385395432760399" //  &
           "456066369908496028419563900512609131853389393280859633882497500591" //  &
           "28369747912197909028518904445517467819162688494876358555633787825066496M-65"
      CALL FMST2M(ST,C(130),QX)
      ST = " 2.397973260732415138001223113122005679063725787264243397335901198" //  &
           "698321759116583811702053382300628630291425464911847398771216167493" //  &
           "18664813035306053986440746004247939745287869514463237143921611339050020M-65"
      CALL FMST2M(ST,C(131),QX)
      ST = " 7.932689322119858073349921363235515368474949336836316506068072766" //  &
           "546624999168511473276482943408448126386413211956579156398290157039" //  &
           "88529011287347733351088257288781160869062308105566110665892110886142277M-66"
      CALL FMST2M(ST,C(132),QX)
      ST = " 2.624348347167471822677772594888450230485642320545658876475286310" //  &
           "055771115343647866370773378641890749683248791810064619124781313040" //  &
           "39655556535083837498441324798836325222767712349195699260834872702802847M-66"
      CALL FMST2M(ST,C(133),QX)
      ST = " 8.682545526698351997704083743124967023750577000605836108664866495" //  &
           "160128302689923574758622135053769717872441667362682928425542104432" //  &
           "66558278030150559101531475636719213636150787481043024038745922498650758M-67"
      CALL FMST2M(ST,C(134),QX)
      ST = " 2.872743458216244845484563580154599626121124250656149184804291244" //  &
           "427536302457588668570923419780410649470498203175250876036620935134" //  &
           "64093415505201626499567870169234200516491544807537627932184985980888123M-67"
      CALL FMST2M(ST,C(135),QX)
      ST = " 9.505401148509633647613758343551012792444980481501235466486933914" //  &
           "265907192633387738944843898328544931131135589195243791819300008378" //  &
           "30106163188879275241944204168059306729141838253133216063222884137562944M-68"
      CALL FMST2M(ST,C(136),QX)
      ST = " 3.145339552791508936206896052221534466211147212254477273131941831" //  &
           "512277630670890754387204205624927221141107680833883854535942453092" //  &
           "60656013674364311521617359444957869733091866905428746679446531471773156M-68"
      CALL FMST2M(ST,C(137),QX)
      ST = " 1.040849079063856819895496485119313778206922325391046796592400903" //  &
           "438704272609812766874547219070728506140021601572906667448239089200" //  &
           "17410157182972609752570220147431398012450147044399178635448118006623721M-68"
      CALL FMST2M(ST,C(138),QX)
      ST = " 3.444536520642979399033002670688986667656937918697573314979061458" //  &
           "919964194677753822933252127653285396401597050249715424969440622451" //  &
           "73896561346967424455299327210221686160915541794905027119226479284135693M-69"
      CALL FMST2M(ST,C(139),QX)
      ST = " 1.139977562784224133216265743521281955028156700765266508712800967" //  &
           "848831883748374530246175200161064830753252846881090666971108606926" //  &
           "84608508079113604819022125345471848395222113457719457394701080327610407M-69"
      CALL FMST2M(ST,C(140),QX)
      ST = " 3.772975385101451028879155185726947819831206176127486435982734889" //  &
           "252802708561571080135558366656253315506022065599884895931599609988" //  &
           "98731864477490133149597217959601291802546927566215903357984266276909864M-70"
      CALL FMST2M(ST,C(141),QX)
      ST = " 1.248801711970198579225912046586232268562301776030667048611621632" //  &
           "465628194502888533349817467748088996697006070450714611279370044918" //  &
           "58919189486279287758063253685579639080251285807174486835285307209688606M-70"
      CALL FMST2M(ST,C(142),QX)
      ST = " 4.133562776218372917707434109108607724393370061767622907143777544" //  &
           "878888798728408345872714164317266154909605719593487267350335578853" //  &
           "93934162223974482538311480054078977999291506457599828857537063130739588M-71"
      CALL FMST2M(ST,C(143),QX)
      ST = " 1.368285826387100294053441225148146980381219160778152569563356532" //  &
           "725964967014895839699806485363534911338607141236453063094587484467" //  &
           "66893839721308893253877636532577439328086482952402541207429714733339152M-71"
      CALL FMST2M(ST,C(144),QX)
      ST = " 4.529497908040056144676469409188309794321421988959637669575342522" //  &
           "116514782664298860106021153887341542873949848678983271520138033675" //  &
           "79495262187662834453100157981375055331539396277574179995789688030466410M-72"
      CALL FMST2M(ST,C(145),QX)
      ST = " 1.499491316588603061306884181776653655545748070661401693040695069" //  &
           "053696590521220167504120163356893714569898088385033607285458815124" //  &
           "35872442007725124320485376254435248066997500475451183595538404386947583M-72"
      CALL FMST2M(ST,C(146),QX)
      ST = " 4.964302317957733490235530469745361589786652164074076392491530822" //  &
           "224428024784809035798407669056637309772933378074926314581475254129" //  &
           "86616192319821312175154821971972127073013580628971532023157018109185362M-73"
      CALL FMST2M(ST,C(147),QX)
      ST = " 1.643586578242763114833507846160154608374622266203265530676336751" //  &
           "694818277497961440503117616606491252858317008970780154993421364483" //  &
           "78099010504715300393033107665724003113140293042459780949957368683890959M-73"
      CALL FMST2M(ST,C(148),QX)
      ST = " 5.441852652794830894311470706477538221849565053218214215349180811" //  &
           "064294636030553844028448630827867613349267037250477900533924480506" //  &
           "82460851565237813605665759673888889710736177209599734575799006709861746M-74"
      CALL FMST2M(ST,C(149),QX)
      ST = " 1.801857878369844007118484883880761798414766692597217574900046197" //  &
           "360262152730609587228705384643316107409543482294232641569660175011" //  &
           "79519154781224338457932814908298988696375455365226741142441036489254992M-74"
      CALL FMST2M(ST,C(150),QX)
      ST = " 5.966416815794185453763830530254737531064047428340471319398688069" //  &
           "007552470288020366752010161084016011730287854271568912859552337203" //  &
           "41453128747443716412531087761908717466819377449540627696187031359721010M-75"
      CALL FMST2M(ST,C(151),QX)
      ST = " 1.975721357861671060279948825620105307975444162740595055137362881" //  &
           "848246417197234999961571849669754470375412457219647332906833168922" //  &
           "68071772240997929407621098946132582262214118221958928604276333611006417M-75"
      CALL FMST2M(ST,C(152),QX)
      ST = " 6.542693821241263641717538449532346497940622472878710087928587547" //  &
           "135890790293782933631752384033436259896798958027902059478261401316" //  &
           "51898760968041471004067759299223993845873964885693255185054469449588983M-76"
      CALL FMST2M(ST,C(153),QX)
      ST = " 2.166736265476002894293516585134968365492470343594290484160425853" //  &
           "634757103189631345447367869704134537187600769397997799583921963715" //  &
           "66991272921221434244459511112119776440312273606272563588060032932425347M-76"
      CALL FMST2M(ST,C(154),QX)
      ST = " 7.175857739425902058446366213267163717870002184056285139492810907" //  &
           "165151388326241994224874557956711286862577806517065215553936524682" //  &
           "13250466673505382651861797375923534026910443196181011966541606084919661M-77"
      CALL FMST2M(ST,C(155),QX)
      ST = " 2.376619550450886365485623751880291284047099214872959375092451724" //  &
           "342950586001550942436415678973426556922327249108654045209317268184" //  &
           "82082947451080863768578126711240615665895962605984771627264126442044223M-77"
      CALL FMST2M(ST,C(156),QX)
      ST = " 7.871606154359623630068573317612764902762392638995019862408631291" //  &
           "008061939353640535233024537980362873819209185759931590349366135182" //  &
           "14586054502659862300174333186280592070419277216786077915707312111770211M-78"
      CALL FMST2M(ST,C(157),QX)
      ST = " 2.607261954081141160150797999367222244498208263011867403220673096" //  &
           "800582313576057737826578818707489920864730296871775420774049041364" //  &
           "79431809641123667403151516016216413258555378265536018764789936965838617M-78"
      CALL FMST2M(ST,C(158),QX)
      ST = " 8.636213600520341807753750476732474442820999819309686673192125811" //  &
           "444182648267187160168499080611902341484327275294303024770270222135" //  &
           "59223769662625003083305590998863860730206646251762971580585644914132026M-79"
      CALL FMST2M(ST,C(159),QX)
      ST = " 2.860745755172363223898311967180521130986380848162555027528393662" //  &
           "915983444061966784564310775020004680613450195420353857249494047775" //  &
           "73818249551580545509645629320363387364925214204842915131007525800466880M-79"
      CALL FMST2M(ST,C(160),QX)
      ST = " 9.476590493324598214557576012349336522703693594124571054279111616" //  &
           "798531592192686914431167230715058815630334239433475110837262090138" //  &
           "33301645943249512127076707890530532222551337127599066189782985037412169M-80"
      CALL FMST2M(ST,C(161),QX)
      ST = " 3.139364340381194056746408425980351704553046571903970795447364975" //  &
           "882887158738580119004810652625014397096678884159435971472598704137" //  &
           "54339572525201214956186891250608510839418632104354221549889413573604846M-80"
      CALL FMST2M(ST,C(162),QX)
      ST = " 1.040034812150826026710373679719002963399053176200107466780745572" //  &
           "000065388516270021753222010998681619656807884101412895225381983273" //  &
           "03585371769586543699202508103518904235084186177627200599704020839402387M-80"
      CALL FMST2M(ST,C(163),QX)
      ST = " 3.445643788223265129236923220146442325334098948153988879546081638" //  &
           "282932221486522368247949883425191269877715114051526159278376683546" //  &
           "54478379087683377717562788666572331232941361970188301510421846831598762M-81"
      CALL FMST2M(ST,C(164),QX)
      ST = " 1.141587032865869378324299022323731794401778416670178670987733185" //  &
           "814446261010130113286467916958273916598065282809528144498877625408" //  &
           "51786835211126241486118129987351739916755135907809166050772678111097018M-81"
      CALL FMST2M(ST,C(165),QX)
      ST = " 3.782366675158000172438186031560392817938018879105893232376963665" //  &
           "758045582935962507746785156805849115039876109316259116490068195664" //  &
           "22154600940352929680886350387924367311407243398433694317491879496500728M-82"
      CALL FMST2M(ST,C(166),QX)
      ST = " 1.253239257637571101011205444147249909041208363526150999161557930" //  &
           "530122175707904339132697555874221097743565894565280785124100424739" //  &
           "12341727673603475533755872933253879415498534305672767854397632835354647M-82"
      CALL FMST2M(ST,C(167),QX)
      ST = " 4.152598333838791095457780574441131208990623618377645706663873970" //  &
           "409219842573498216786365580094065012089293058629821760308697172924" //  &
           "25649947447826939431820718042482922400940273337175959594512550863844028M-83"
      CALL FMST2M(ST,C(168),QX)
      ST = " 1.376008915348001441142775089390756952291415569331728264389528531" //  &
           "840532583703944779638084800244642630871018954424019239838171107774" //  &
           "08455142709222529998017403722473530832343485779953472597270935996990435M-83"
      CALL FMST2M(ST,C(169),QX)
      ST = " 4.559715817525503407894512559569944355041250549999373143331298588" //  &
           "042902011136449984273691723063087171534265607563490346238292992622" //  &
           "43694334064073133108518335548127416155718965768703096927698154664008186M-84"
      CALL FMST2M(ST,C(170),QX)
      ST = " 1.511016937693380717359102098553590521576253151812935620881255183" //  &
           "676747573506694189735416802045982192198119977018955499638830448943" //  &
           "99139906962195905603908709462882471176378436053656496936740374119626233M-84"
      CALL FMST2M(ST,C(171),QX)
      ST = " 5.007439851661721308524939431791288925473304269198627995505717966" //  &
           "042698143618956580402359781596868665105789229557574207071195578504" //  &
           "34784490998580851675508563655209200033656690762499193037679456058834741M-85"
      CALL FMST2M(ST,C(172),QX)
      ST = " 1.659498369200591197022274845367449670587666822869779371596678693" //  &
           "434849663818573237359515507605355977016921178742109368988856546946" //  &
           "53987167820516459592809407463255771494757163532540963217681912265486931M-85"
      CALL FMST2M(ST,C(173),QX)
      ST = " 5.499870074123138278587253453863123198782240874965235399880295435" //  &
           "189868323747896824633224719144787009990778913499316775325760318709" //  &
           "84151200565534853443611640092085568829894647596561585415506088061475496M-86"
      CALL FMST2M(ST,C(174),QX)
      ST = " 1.822814104787822173171970582684126136729373783986451680232463776" //  &
           "995284747235440436579147791215434063408671873139502336867256882493" //  &
           "52907684446136684618467464533340860151713404827732293178363163584088691M-86"
      CALL FMST2M(ST,C(175),QX)
      ST = " 6.041524022149206216514749478207951898414628220569359023936273098" //  &
           "431129999705544414314317322005670901754042242107672777454004410860" //  &
           "23728922114946882252911249911639377024536952401619252235639914064675297M-87"
      CALL FMST2M(ST,C(176),QX)
      ST = " 2.002463416328745336974658582823885810920380274053175588795927666" //  &
           "714050828711674000372182654975669270167646317724425684411171485274" //  &
           "63888736139146918349514677140009027878433312540016907441088200168772901M-87"
      CALL FMST2M(ST,C(177),QX)
      ST = " 6.637378732657623720229439419358377518409139927005258254140285180" //  &
           "914849963099373381335080302807182958739736822642496046941955995156" //  &
           "47580543357281795983541588632113533651700800850371216214989020246965499M-88"
      CALL FMST2M(ST,C(178),QX)
      ST = " 2.200102767530555026604991024957956952823900377482112800591761008" //  &
           "660084843014248387788035100004987819764909462237889078992186315330" //  &
           "60158332375064476625052936559137839280476740402400480416136592265795082M-88"
      CALL FMST2M(ST,C(179),QX)
      ST = " 7.292933318740382159132169272746181235841016457994964554263454208" //  &
           "492201073732473833848574569619679758849986320998185690723690770932" //  &
           "41462402016226262443880472321890006685113024701301315267987027615012503M-89"
      CALL FMST2M(ST,C(180),QX)
      ST = " 2.417513092202831923304643749980362419472891672259150932920867637" //  &
           "832384236931175709234025174145241123797309720555077484497334156484" //  &
           "70273284353674851435852469743857826682908838509841004308849506350039697M-89"
      CALL FMST2M(ST,C(181),QX)
      ST = " 8.014099523920820532691698949493969623669374514095447937521752186" //  &
           "098803953643697356090844942590659454999844318173870304557001940555" //  &
           "42525475893078866822127874440270390910047929036227162217460866884004221M-90"
      CALL FMST2M(ST,C(182),QX)
      ST = " 2.657079598189421611225399332494614836172370837056707080573411081" //  &
           "077314111961101307612637519570469581636094934124837596398237792257" //  &
           "42836805118176886050043438632186029854385799944806006391590874149011746M-90"
      CALL FMST2M(ST,C(183),QX)
      ST = " 8.808801832338891822547417575762619398673718065912507825752674890" //  &
           "111044965171749095170501464417801064468367983054179217820785485005" //  &
           "97684256880162841894825031174637280632623961080123218247631394854404406M-91"
      CALL FMST2M(ST,C(184),QX)
      ST = " 2.917871827472767744801985504187470385461224411949197505438209784" //  &
           "552995184888997609387528889784137922680585612807183342956402094608" //  &
           "01943529407670923901992925226137852941513101357366936300944346484030974M-91"
      CALL FMST2M(ST,C(185),QX)
      ST = " 9.673909686763801191886681572020182885252222531903039060187477306" //  &
           "277095817639315200476096440352681128855627885542339760940019503157" //  &
           "11902076792371625818162067652299279665268178569377108196296372219380510M-92"
      CALL FMST2M(ST,C(186),QX)
      ST = " 3.225317339965144219466139388048879231367171359221844461940917969" //  &
           "250112356759739827102732375554724422636709224874307206769709880215" //  &
           "16808317218174915989091357841379986431733603301918969106178493014736385M-92"
      CALL FMST2M(ST,C(187),QX)
      ST = " 1.069410576590312480755235192735211157086107353088423400669923656" //  &
           "677428694478915259443669100953558846603833879903904822845298497420" //  &
           "71143211982703738257538091316334035362562254796294606412951506359364815M-92"
      CALL FMST2M(ST,C(188),QX)
      ST = " 3.436230247075590625300285568770398628374034305782922085529568066" //  &
           "268230300872273810320168642643487560176713818087616304872506761508" //  &
           "46310739710431810178913824922315129263580429076241251322833952169352928M-93"
      CALL FMST2M(ST,C(189),QX)
      ST = " 1.139260014627810596016761865641404521146852141822567620126418127" //  &
           "549772266075482248466335323616377804969776249070578213315603095439" //  &
           "66803478295001515092190429139446518480363880483757347561526976211621457M-93"
      CALL FMST2M(ST,C(190),QX)
      ST = " 4.343070458433874603042514728830057473477940614398096372223763568" //  &
           "372476710887610850250214061613248238834003723272762897566055896217" //  &
           "49542103193171278645483518744915143059042740324768324837960269146747307M-94"
      CALL FMST2M(ST,C(191),QX)
      ST = " 1.440667367566540553672654836910082201055609375400592746447756244" //  &
           "176284526124155943246633922603816785133029633668454281491778597874" //  &
           "45028943290797079216498815025085467176654584077190605132981537168513742M-94"
      CALL FMST2M(ST,C(192),QX)
      ST = " 2.384816222561370113514027430584139466337689187141928475880205055" //  &
           "969980605519512189876139389796445441195296187421190296481218115986" //  &
           "36517542721807591974162349259651427967273755554095270040863620533051177M-95"
      CALL FMST2M(ST,C(193),QX)
      ST = " 7.891080859500628750618564157769100520532680589132484946442038829" //  &
           "299825933371426348457257350822254140519284945880389565858120333678" //  &
           "80845449586455112014663973071181240064800376338635797974159751681049875M-96"
      CALL FMST2M(ST,C(194),QX)
      ST = " 1.059066626703749406081450817511793688125712964427249229411570236" //  &
           "550112600348902027013047427990927965524515088187243012802502472093" //  &
           "22261048153901594967680556527547070843534915035469463356163636215773539M-95"
      CALL FMST2M(ST,C(195),QX)
      ST = " 3.516498583838005375775193339944623281315914658931041130875008620" //  &
           "636983702886095342086986357214180450129972642316547945003279723791" //  &
           "81126461652035134771983947459420613651499692168433361308886876030693800M-96"
      CALL FMST2M(ST,C(196),QX)

      QX%NDIG = NDSAVE

      END SUBROUTINE FMLNGM_C

      SUBROUTINE FMPGAM(N,MA,MB,QX)

!  MB = POLYGAMMA(N,MA)      (Nth Derivative of PSI)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N
      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MPISAV
      REAL (KIND(1.0D0)) :: MBSBRN
      INTEGER :: NUMBRN
      TYPE(MULTI) :: MBERN(LMBERN)
      INTEGER :: NDBERN(LMBERN)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTA,J,J2,JN,JNC,JSTART,K,KFL,KL,KOVUN,KR_RETRY,KRESLT,KRFLCT,  &
                 KRSAVE,KWRNSV,K_RETURN_CODE,LSHIFT,N1,NBOT,NC,NDGOAL,NDIG2,NDOLD,      &
                 NDSAV1,NDSAVE,NDSV2,NGOAL,NMXDIF,NTERM,NTOP,NUMTRY,N_ACC

!             Set the coefficients used in computing various derivatives of COT(Pi*X)
!             for the reflection formula.

      INTEGER :: KGCD(14) =  &
              (/ 1, 2, 2, 8, 8, 16, 16, 128, 128, 256, 256, 1024, 1024, 2048 /)
      INTEGER :: KCOEFF(56) = (/                                                     &
                    1,          1,              3, 1,     3, 2,                      &
                    15, 15, 2,                  45, 60, 17,                          &
                    315, 525, 231, 17,          315, 630, 378, 62,                   &
                    2835, 6615, 5040, 1320, 62,                                      &
                    14175, 37800, 34965, 12720, 1382,                                &
                    155925, 467775, 509355, 238425, 42306, 1382,                     &
                    467775, 1559250, 1954260, 1121670, 280731, 21844,                &
                    6081075, 22297275, 31621590, 21531510, 7012005,  907725, 21844,  &
                    42567525, 170270100, 269594325, 212612400, 85630545, 15839460, 929569 /)
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(13),MRETRY,MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      MBSBRN = 0
      NUMBRN = 0
      NDBERN = 0
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. N >= 0) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMI2M(0,MXY(2),QX)
          CALL FMSUB(MXY(2),MXY(1),MXY(3),QX)
          CALL FMIPWR(MXY(3),-N-1,MXY(4),QX)
          IF (N >= 2) THEN
              CALL FMI2M(N,MXY(6),QX)
              CALL FMFACT(MXY(6),MXY(7),QX)
              CALL FMMPY_R1(MXY(4),MXY(7),QX)
          ENDIF
          IF (N == 0) THEN
              CALL FMEULR(MXY(2),QX)
              CALL FMMPYI(MXY(2),-1,MXY(5),QX)
          ELSE IF (MOD(N,2) == 1) THEN
              CALL FMI2M(1,MXY(2),QX)
              CALL FMBERN(N+1,MXY(2),MXY(3),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
              CALL FMABS(MXY(3),MXY(6),QX)
              CALL FMPI(MXY(7),QX)
              CALL FMIPWR(MXY(7),N+1,MXY(8),QX)
              CALL FMMPY(MXY(6),MXY(8),MXY(7),QX)
              CALL FMI2M(2,MXY(2),QX)
              CALL FMIPWR(MXY(2),N-1,MXY(6),QX)
              CALL FMMPY(MXY(6),MXY(7),MXY(8),QX)
              CALL FMDIVI(MXY(8),(N+1)/2,MXY(5),QX)
          ELSE
              CALL FMI2M(1,MXY(2),QX)
              CALL FMBERN(N,MXY(2),MXY(3),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
              CALL FMABS(MXY(3),MXY(6),QX)
              CALL FMPI(MXY(7),QX)
              CALL FMIPWR(MXY(7),N,MXY(8),QX)
              CALL FMMPY(MXY(6),MXY(8),MXY(7),QX)
              CALL FMI2M(2,MXY(2),QX)
              CALL FMIPWR(MXY(2),N-2,MXY(6),QX)
              CALL FMMPY(MXY(6),MXY(7),MXY(8),QX)
              CALL FMDIVI(MXY(8),N/2,MXY(10),QX)
              CALL FMI2M(1,MXY(2),QX)
              CALL FMBERN(N+2,MXY(2),MXY(3),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
              CALL FMABS(MXY(3),MXY(6),QX)
              CALL FMPI(MXY(7),QX)
              CALL FMIPWR(MXY(7),N+2,MXY(8),QX)
              CALL FMMPY(MXY(6),MXY(8),MXY(7),QX)
              CALL FMI2M(2,MXY(2),QX)
              CALL FMIPWR(MXY(2),N,MXY(6),QX)
              CALL FMMPY(MXY(6),MXY(7),MXY(8),QX)
              CALL FMDIVI(MXY(8),(N+2)/2,MXY(11),QX)
              CALL FMMPY(MXY(10),MXY(11),MXY(9),QX)
              CALL FMSQRT(MXY(9),MXY(10),QX)
              CALL FMI2M(0,MXY(8),QX)
              CALL FMSUB(MXY(8),MXY(10),MXY(5),QX)
          ENDIF
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG+1 .AND.  &
              MXY(4)%MP(2) < QX%MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(4),MXY(8),MXY(6),QX)
              IF (MXY(6)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB,QX)
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMPGAM'
                  CALL FMNTRI(2,N,1,QX)
                  CALL FMNTR(2,MA,MA,1,0,QX)
                  CALL FMNTR(1,MB,MB,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (QX%NTRACE /= 0) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMPGAM'
          CALL FMNTRI(2,N,1,QX)
          QX%NCALL = QX%NCALL - 1
      ENDIF
      CALL FMENT2('FMPGAM   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQ(MXY(1),MXY(13),QX)
      NUMTRY = 0

  120 IF (N == 0) THEN
          CALL FMPSI(MXY(1),MXY(10),QX)
          GO TO 160
      ENDIF
      IF (N < 0 .OR. MA%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(10),QX)
          QX%KFLAG = -4
          GO TO 180
      ENDIF

!             Near zero PGAM(x) is about n!/(-x)**(n+1).

      IF (MXY(13)%MP(2) < (-QX%NDIG-1)) THEN
          CALL FMFCTI(N,MXY(12),QX)
          IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
              MXY(13)%MP(1) = -MXY(13)%MP(1)
          CALL FMIPWR(MXY(13),N+1,MXY(11),QX)
          CALL FMDIV(MXY(12),MXY(11),MXY(10),QX)
          GO TO 160
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDP2M(-0.5D0,MXY(5),QX)
      IF (FMCOMP(MXY(13),'<=',MXY(5),QX)) THEN
          KRFLCT = 1
          KFL = 0
          IF (MA%MP(2) <= NDSAVE) THEN
              CALL FMINT(MXY(13),MXY(9),QX)
              IF (FMCOMP(MXY(13),'==',MXY(9),QX)) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(10),QX)
              QX%KFLAG = -4
              GO TO 180
          ELSE
              CALL FMI2M(1,MXY(4),QX)
              CALL FMSUB_R2(MXY(4),MXY(13),QX)
          ENDIF
      ENDIF
      IF (MA%MP(2) > QX%NDIG+3) THEN
          CALL FMIPWR(MXY(13),-N,MXY(10),QX)
          IF (MXY(10)%MP(2) /= QX%MEXPUN) THEN
              CALL FMFCTI(N-1,MXY(9),QX)
              CALL FMMPY_R1(MXY(10),MXY(9),QX)
          ENDIF
          IF (MOD(N-1,2) == 1 .AND. MXY(10)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(10)%MP(3) /= 0) MXY(10)%MP(1) = -MXY(10)%MP(1)
          IF (QX%KROUND /= 1) THEN
              IF (MXY(10)%MP(2) /= QX%MEXPUN) THEN
                  CALL FMMPYI(MXY(10),N,MXY(4),QX)
                  CALL FMDIVI_R1(MXY(4),2,QX)
                  CALL FMDIV_R1(MXY(4),MXY(13),QX)
                  CALL FMADD_R1(MXY(10),MXY(4),QX)
              ENDIF
          ENDIF
          GO TO 160
      ENDIF

!             To speed the asymptotic series calculation, increase the argument by LSHIFT.

      IEXTRA = 0
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(13),INTA,QX)
      QX%KWARN = KWRNSV

      IF (QX%KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(QX%NDIG)*QX%ALOGMB/4.46-REAL(INTA)))
          LSHIFT = LSHIFT + (7*N)/20
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(4),QX)
          CALL FMADD(MXY(13),MXY(4),MXY(12),QX)
      ELSE
          CALL FMEQ(MXY(13),MXY(12),QX)
      ENDIF

!             Sum the asymptotic series.

      J2 = INT(0.3*QX%ALOGMB + 0.2*SQRT(REAL(QX%NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             MXY(13) is Z
!             MXY(12) is Z + LSHIFT
!             MXY(9) is X**J2 = (1/(Z+LSHIFT)**2)**J2
!             MXY(10) is the current power of X times the quotient of factorials in each term
!             MXY(11) is the current term in the sum
!             MXY(8) is (N+1)!
!             MJSUMS holds the partial sums

      NDSAV1 = QX%NDIG
      CALL FMFCTI(N+1,MXY(8),QX)
      CALL FMDIVI(MXY(8),2,MXY(10),QX)
      J = -2*J2
      CALL FMIPWR(MXY(12),J,MXY(9),QX)
      IF (ABS(MXY(9)%MP(2)) >= QX%MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(12),-2,MXY(9),QX)
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(10),MJSUMS(J),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         IF (QX%KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10),QX)
             QX%KFLAG = -4
             GO TO 180
         ENDIF
         NTOP = (N+NTERM)*(N+NTERM+1)
         CALL FMCSMPYI_R1(MXY(10),NTOP,QX)
         NBOT = (NTERM+1)*(NTERM+2)
         CALL FMCSDIVI_R1(MXY(10),NBOT,QX)
      ENDDO

      NDIG2 = QX%NDIG
  130 CALL FMCSMPY_R1(MXY(10),MXY(9),QX)
      NMXDIF = MIN(NDSAV1,QX%NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(10),MXY(11),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         IF (QX%KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10),QX)
             QX%KFLAG = -4
             GO TO 180
         ENDIF
         QX%NDIG = NDSAV1
         CALL FMCSADD_R1(MJSUMS(J),MXY(11),QX)
         IF (QX%KFLAG /= 0) THEN
             GO TO 140
         ELSE
             NMXDIF = MAX(NMXDIF,NDSAV1-INT(MJSUMS(J)%MP(2)-MXY(11)%MP(2)))
             QX%NDIG = NDIG2
             IF (N+NTERM > INTMAX/(N+NTERM+1) .OR. N+NTERM > MXBASE/(N+NTERM+1)) THEN
                 CALL FMCSMPYI_R1(MXY(10),N+NTERM,QX)
                 CALL FMCSMPYI_R1(MXY(10),N+NTERM+1,QX)
                 CALL FMCSDIVI_R1(MXY(10),NTERM+1,QX)
                 CALL FMCSDIVI_R1(MXY(10),NTERM+2,QX)
             ELSE
                 NTOP = (N+NTERM)*(N+NTERM+1)
                 CALL FMCSMPYI_R1(MXY(10),NTOP,QX)
                 NBOT = (NTERM+1)*(NTERM+2)
                 CALL FMCSDIVI_R1(MXY(10),NBOT,QX)
             ENDIF
         ENDIF
      ENDDO
      NDIG2 = NMXDIF
      QX%NDIG = NDIG2
      GO TO 130

!             Put the J2 concurrent sums back together.

  140 QX%NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMI2M(1,MXY(9),QX)
          CALL FMSQR(MXY(12),MXY(11),QX)
          CALL FMDIV_R2(MXY(9),MXY(11),QX)
          CALL FMEQ(MJSUMS(J2),MXY(9),QX)
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(9),MXY(11),QX)
             CALL FMADD_R1(MXY(9),MJSUMS(J),QX)
          ENDDO
          CALL FMEQ(MXY(9),MJSUMS(1),QX)
      ENDIF
      CALL FMIPWR(MXY(12),N+2,MXY(6),QX)
      CALL FMDIV_R1(MJSUMS(1),MXY(6),QX)

!             Add the initial terms to the asymptotic series.

      CALL FMDIVI(MXY(8),N+1,MXY(9),QX)
      CALL FMDIVI(MXY(9),N,MXY(8),QX)
      CALL FMMPYI(MXY(12),2,MXY(7),QX)
      CALL FMI2M(N,MXY(10),QX)
      CALL FMADD(MXY(7),MXY(10),MXY(3),QX)
      CALL FMCANCEL(MXY(7),MXY(10),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(7),QX)
      CALL FMMPY_R1(MXY(7),MXY(8),QX)
      CALL FMMPYI_R1(MXY(6),2,QX)
      CALL FMDIV_R1(MXY(6),MXY(12),QX)
      CALL FMDIV(MXY(7),MXY(6),MXY(10),QX)
      CALL FMADD(MJSUMS(1),MXY(10),MXY(3),QX)
      CALL FMCANCEL(MJSUMS(1),MXY(10),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(10),QX)
      IF (MOD(N-1,2) == 1 .AND. MXY(10)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(10)%MP(3) /= 0) MXY(10)%MP(1) = -MXY(10)%MP(1)

!             Now PGAM of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(MA)**(N+1) + ... + 1/(MA+LSHIFT-1)**(N+1) is computed.

!             MXY(13) is Z
!             MXY(9) is N!
!             MXY(10) is the sum of the asymptotic series
!             MXY(11) is the sum 1/(MA)**(N+1) + ... + 1/(MA+LSHIFT-1)**(N+1)

      IF (LSHIFT > 0) THEN
          CALL FMI2M(1,MXY(6),QX)
          CALL FMEQ(MXY(13),MXY(7),QX)
          N1 = -(N + 1)
          CALL FMIPWR(MXY(7),N1,MXY(11),QX)
          DO K = 1, LSHIFT-1
             CALL FMADD_R1(MXY(7),MXY(6),QX)
             CALL FMIPWR(MXY(7),N1,MXY(12),QX)
             CALL FMADD_R1(MXY(11),MXY(12),QX)
          ENDDO
          CALL FMMPY_R2(MXY(9),MXY(11),QX)
          IF (MOD(N+1,2) == 1 .AND. MXY(11)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(11)%MP(3) /= 0) MXY(11)%MP(1) = -MXY(11)%MP(1)
          CALL FMADD(MXY(10),MXY(11),MXY(3),QX)
          CALL FMCANCEL(MXY(10),MXY(11),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(10),QX)
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

      IF (KRFLCT == 1) THEN

!             MXY(11) is COT(Pi*Z)
!             MXY(9) is MXY(11)**2

!             Reduce the argument before multiplying by Pi.

          CALL FMMPYI(MXY(13),2,MXY(5),QX)
          CALL FMINT(MXY(5),MXY(9),QX)
          IF (FMCOMP(MXY(5),'==',MXY(9),QX)) THEN
              CALL FMI2M(0,MXY(11),QX)
              CALL FMEQ(MXY(11),MXY(9),QX)
              CALL FMI2M(1,MXY(5),QX)
          ELSE
              CALL FMNINT(MXY(13),MXY(5),QX)
              CALL FMSUB(MXY(13),MXY(5),MXY(9),QX)
              NDSV2 = QX%NDIG
  150         CALL FMPI(MXY(11),QX)
              CALL FMMPY_R1(MXY(11),MXY(9),QX)
              KRSAVE = QX%KRAD
              QX%KRAD = 1
              CALL FMTAN(MXY(11),MXY(2),QX)
              CALL FMEQ(MXY(2),MXY(11),QX)
              QX%KRAD = KRSAVE
              IF ((MXY(11)%MP(2) < 0 .OR. MXY(11)%MP(2) > 1) .AND.  &
                  NDSV2 == QX%NDIG) THEN
                  IEXTRA = INT(MAX(-MXY(11)%MP(2),MXY(11)%MP(2)))
                  IF (IEXTRA > 0) THEN
                      CALL FMEQU_R1(MXY(9),QX%NDIG,QX%NDIG+IEXTRA,QX)
                  ENDIF
                  QX%NDIG = QX%NDIG + IEXTRA
                  GO TO 150
              ENDIF

              QX%NDIG = NDSV2
              CALL FMI2M(1,MXY(5),QX)
              CALL FMDIV_R2(MXY(5),MXY(11),QX)
              CALL FMSQR(MXY(11),MXY(9),QX)
          ENDIF
          NC = (N+1)/2

!             For N up to 14, use the stored coefficients to compute the Nth derivative
!             of Cot(Pi*Z).  For larger N, the coefficients are generated from a recurrence
!             relation and stored as FM numbers.

          IF (N <= 14) THEN
              JSTART = (N*N + 4 - MOD(N,2))/4
              IF (N <= 2) THEN
                  CALL FMI2M(1,MXY(6),QX)
              ELSE
                  CALL FMMPYI(MXY(9),KCOEFF(JSTART),MXY(6),QX)
              ENDIF
              DO J = 2, NC
                 CALL FMI2M(KCOEFF(JSTART+J-1),MXY(7),QX)
                 CALL FMADD_R1(MXY(6),MXY(7),QX)
                 IF (J < NC) CALL FMMPY_R1(MXY(6),MXY(9),QX)
              ENDDO
              IF (MOD(N,2) == 0) CALL FMMPY_R1(MXY(6),MXY(11),QX)
              IF (N > 1) CALL FMMPYI_R1(MXY(6),KGCD(N),QX)
          ELSE
              IF (NC > LJSUMS) THEN
                  QX%KFLAG = -12
                  CALL FMWRN2(QX)
                  WRITE (KW,                                                  &
                         "(' For PGAM(',I5,',*) with NDIG =',I5,',',I7,"  //  &
                         "' words are needed'/' in array MJSUMS.',"       //  &
                         "'  The current dimension of MJSUMS IS',I7/)"        &
                        ) N,QX%NDIG,NC*(QX%NDIG+3),LJSUMS
                  QX%MXEXP = MXSAVE
                  QX%NDIG = NDSAVE
                  CALL FMST2M('UNKNOWN',MB,QX)
                  IF (QX%NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
                  RETURN
              ENDIF

              DO J = 1, 7
                 CALL FMI2M(KCOEFF(J+49),MJSUMS(J),QX)
                 CALL FMMPYI_R1(MJSUMS(J),KGCD(14),QX)
              ENDDO
              DO JN = 15, N
                 JNC = (JN+1)/2
                 DO K = JNC, 2, -1
                    IF (K == JNC .AND. MOD(JN,2) == 1) THEN
                        CALL FMEQ(MJSUMS(K-1),MJSUMS(K),QX)
                    ELSE
                        CALL FMADD_R2(MJSUMS(K-1),MJSUMS(K),QX)
                        CALL FMMPYI_R1(MJSUMS(K),JN-2*(K-1),QX)
                    ENDIF
                 ENDDO
                 CALL FMMPYI_R1(MJSUMS(1),JN,QX)
              ENDDO

!             MJSUMS now has the coefficients needed for the polynomial in Cot**2 that defines
!             the Nth derivative of Cot.

              CALL FMEQ(MJSUMS(1),MXY(6),QX)
              DO J = 2, NC
                 CALL FMMPY_R1(MXY(6),MXY(9),QX)
                 CALL FMADD_R1(MXY(6),MJSUMS(J),QX)
              ENDDO
              IF (MOD(N,2) == 0) CALL FMMPY_R1(MXY(6),MXY(11),QX)
          ENDIF

!             To complete the calculation of the Nth derivative of Cot, multiply the polynomial
!             in Cot**2 by Csc**2.

          CALL FMADD(MXY(9),MXY(5),MXY(7),QX)
          CALL FMMPY_R1(MXY(6),MXY(7),QX)

          CALL FMPI(MPISAV,QX)
          CALL FMIPWR(MPISAV,N+1,MXY(7),QX)
          CALL FMMPY_R1(MXY(6),MXY(7),QX)
          IF (MOD(N,2) == 1 .AND. MXY(10)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(10)%MP(3) /= 0) MXY(10)%MP(1) = -MXY(10)%MP(1)
          CALL FMADD(MXY(10),MXY(6),MXY(3),QX)
          CALL FMCANCEL(MXY(10),MXY(6),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(10),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(10)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(10)%MP(J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = QX%NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQ(MXY(1),MXY(13),QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  180 CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMPGAM

      SUBROUTINE FMPOCH(MA,N,MB,QX)

!  MB = MA*(MA+1)*(MA+2)*...*(MA+N-1)       (Pochhammer's symbol)

!  MB = Gamma(MA+N)/Gamma(MA)

!  For negative N, Pochhammer(MA,N) = 1/Pochhammer(MA+N,-N).

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: N
      REAL (KIND(1.0D0)) :: MA2,MAS,MBSIGN,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K0,K1,K2,KL,KLAST,KM08,KMB,KOVUN,KR_RETRY,KRESLT,  &
                 KRSAVE,K_RETURN_CODE,LT,NDSAVE,NT
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: T
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(15)
      TYPE(FM_SETTINGS) :: QX

      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG .AND. N /= 0 .AND. N /= 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          NT = ABS(N) - 1
          IF (N < 0) NT = NT + 1
          CALL FMI2M(NT,MXY(2),QX)
          CALL FMFACT(MXY(2),MXY(3),QX)
          CALL FMMPY(MXY(1),MXY(3),MXY(4),QX)
          IF (NT <= 20) THEN
              CALL FMI2M(1,MXY(2),QX)
              CALL FMI2M(1,MXY(5),QX)
              DO K1 = 2, NT
                 CALL FMDIVI(MXY(2),K1,MXY(6),QX)
                 CALL FMADD_R1(MXY(5),MXY(6),QX)
              ENDDO
          ELSE
              CALL FMI2M(NT,MXY(7),QX)
              CALL FMLN(MXY(7),MXY(5),QX)
              CALL FMEULR(MXY(6),QX)
              CALL FMADD_R1(MXY(5),MXY(6),QX)
              CALL FMI2M(1,MXY(2),QX)
              CALL FMDIV(MXY(2),MXY(7),MXY(8),QX)
              CALL FMDIVI(MXY(8),2,MXY(6),QX)
              CALL FMADD_R1(MXY(5),MXY(6),QX)
              CALL FMSQR(MXY(8),MXY(9),QX)
              CALL FMDIVI(MXY(9),12,MXY(6),QX)
              CALL FMSUB_R1(MXY(5),MXY(6),QX)
              CALL FMSQR(MXY(9),MXY(8),QX)
              CALL FMDIVI(MXY(8),120,MXY(6),QX)
              CALL FMADD_R1(MXY(5),MXY(6),QX)
          ENDIF
          IF (N > 0) THEN
              CALL FMEQ(MXY(4),MXY(6),QX)
              CALL FMMPY(MXY(4),MXY(5),MXY(8),QX)
              CALL FMMPY(MXY(1),MXY(8),MXY(7),QX)
          ELSE
              IF (MOD(NT,2) == 0) THEN
                  CALL FMI2M(1,MXY(2),QX)
              ELSE
                  CALL FMI2M(-1,MXY(2),QX)
              ENDIF
              CALL FMDIV(MXY(2),MXY(3),MXY(6),QX)
              CALL FMMPY(MXY(6),MXY(5),MXY(8),QX)
              CALL FMMPY(MXY(1),MXY(8),MXY(7),QX)
          ENDIF
          IF (MXY(6)%MP(2) - MXY(7)%MP(2) > QX%NDIG+1 .AND.  &
              MXY(6)%MP(2) < QX%MEXPOV) THEN
              CALL FMEQU(MXY(6),MXY(10),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(9),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(9),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(6),MXY(8),MXY(9),QX)
              IF (MXY(9)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(6),MXY(8),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(7),MXY(9),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMADD(MXY(8),MXY(9),MB,QX)
                  IF (MB%MP(2) >= QX%MEXPOV) THEN
                      IF (MXY(8)%MP(1) > 0) THEN
                          IF (MXY(9)%MP(1) < 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(8),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(8)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(9)%MP(1) > 0 .AND. QX%KROUND == 2) THEN
                              CALL FMEQ(MXY(8),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(8)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ELSE
                          IF (MXY(9)%MP(1) < 0 .AND. QX%KROUND == -1) THEN
                              CALL FMEQ(MXY(8),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(8)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(9)%MP(1) > 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(8),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(8)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(6),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMPOCH'
                  CALL FMNTR(2,MA,MA,1,1,QX)
                  CALL FMNTRI(2,N,0,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMPOCH'
                  QX%KFLAG = -4
                  CALL FMWRN2(QX)
                  QX%NCALL = QX%NCALL - 1
              ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMPOCH'
                  IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
                  IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
                  CALL FMWRN2(QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMPOCH'
                  CALL FMNTR(1,MB,MB,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMPOCH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      CALL FMNTRI(2,N,0,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      MA2 = MA%MP(3)
      MAS = MA%MP(1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      NT = N
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQ(MXY(1),MXY(13),QX)

!             Check for special cases.

      IEXTRA = 0
      IF (N == 0) THEN
          CALL FMI2M(1,MXY(11),QX)
          GO TO 140
      ENDIF
      IF (NT < 0) THEN
          CALL FMADDI(MXY(1),NT,QX)
          CALL FMEQ(MXY(1),MXY(13),QX)
          NT = -NT
          MA2 = MXY(1)%MP(3)
          MAS = MXY(1)%MP(1)
      ENDIF
      IF (MA2 == 0) THEN
          IF (NT > 0) THEN
              CALL FMI2M(0,MXY(11),QX)
              GO TO 130
          ELSE
              CALL FMST2M('UNKNOWN',MXY(11),QX)
              QX%KFLAG = -4
              GO TO 140
          ENDIF
      ENDIF
      IF (NT == 0) THEN
          CALL FMI2M(1,MXY(11),QX)
          GO TO 130
      ELSE IF (NT == 1) THEN
          CALL FMEQU(MXY(1),MXY(11),NDSAVE,QX%NDIG,QX)
          GO TO 130
      ENDIF
      CALL FMI2M(1,MXY(4),QX)
      JR = QX%KROUND
      QX%KROUND = 1
      CALL FMADD(MXY(1),MXY(4),MXY(5),QX)
      QX%KROUND = JR
      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(11),QX)
          IF (MAS < 0) MXY(11)%MP(1) = (-1)**NT
          GO TO 130
      ELSE IF (MXY(1)%MP(2) == QX%MEXPUN) THEN
          IF (NT == 2) THEN
              CALL FMST2M('UNDERFLOW',MXY(11),QX)
              IF (MAS < 0) MXY(11)%MP(1) = -1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(11),QX)
              QX%KFLAG = -4
          ENDIF
          GO TO 140
      ELSE IF (FMCOMP(MXY(5),'==',MXY(4),QX)) THEN
          T = QX%NDIG
          J = INT(15.21*SQRT(T)*QX%ALOGMT + 42.87*SQRT(T) + 30.0)
          IF (NT <= J) THEN
              K1 = NT - 1
              CALL FMFCTI(K1,MXY(11),QX)
              CALL FMMPY_R2(MXY(1),MXY(11),QX)
              GO TO 130
          ENDIF
      ENDIF

!             Look for cases where overflow is easy to detect.

      CALL FMI2M(NT,MXY(9),QX)
      CALL FMABS(MXY(13),MXY(7),QX)
      IF (MXY(13)%MP(2) > 0 .AND. FMCOMP(MXY(9),'<',MXY(7),QX)) THEN
          CALL FMADD(MXY(13),MXY(9),MXY(8),QX)
          MXY(8)%MP(1) = 1
          CALL FMMIN(MXY(7),MXY(8),MXY(10),QX)
          IF (INT(MXY(10)%MP(2))-1 > INTMAX/NT) THEN
              CALL FMST2M('OVERFLOW',MXY(11),QX)
              IF (MXY(13)%MP(1) > 0) THEN
                  MXY(11)%MP(1) = 1
              ELSE
                  MXY(11)%MP(1) = (-1)**MOD(NT,2)
              ENDIF
              QX%KFLAG = -5
              GO TO 130
          ENDIF
      ENDIF

!             For large values of MA, the result is MA**NT.

      LT = QX%NDIG + 3 + INT(2.0D0*LOG(DBLE(NT))/QX%DLOGMB)
      IF (MXY(1)%MP(2) > LT) THEN
          CALL FMIPWR(MXY(13),NT,MXY(11),QX)
          IF (QX%KROUND /= 1 .AND. NT > 1) THEN
              IF (ABS(MXY(11)%MP(2)) /= QX%MEXPOV) THEN
                  CALL FMDIV(MXY(11),MXY(13),MXY(8),QX)
                  IF (MOD(NT,2) == 0) THEN
                      CALL FMMPYI_R1(MXY(8),NT-1,QX)
                      CALL FMMPYI_R1(MXY(8),NT/2,QX)
                  ELSE
                      CALL FMMPYI_R1(MXY(8),(NT-1)/2,QX)
                      CALL FMMPYI_R1(MXY(8),NT,QX)
                  ENDIF
                  CALL FMADD_R1(MXY(11),MXY(8),QX)
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

      MBSIGN = 1
      IF (MAS < 0) THEN
          CALL FMINT(MXY(13),MXY(8),QX)
          CALL FMI2M(NT,MXY(9),QX)
          JR = QX%KROUND
          QX%KROUND = 1
          CALL FMADD(MXY(13),MXY(9),MXY(10),QX)
          QX%KROUND = JR
          IF (FMCOMP(MXY(13),'==',MXY(8),QX)) THEN

!                  If MA is a negative integer and MA+NT is positive, then the result is zero.

              IF (MXY(10)%MP(1)*MXY(10)%MP(3) > 0) THEN
                  CALL FMI2M(0,MXY(11),QX)
                  GO TO 130
              ENDIF
          ENDIF

!                  If MA is negative and MA+NT-1 is negative, then use the reflection formula
!                  Pochhammer(MA,NT) = (-1)**NT*Pochhammer(-MA-(NT-1),NT).

          CALL FMI2M(1,MXY(11),QX)
          IF (FMCOMP(MXY(10),'<',MXY(11),QX)) THEN

!                 Extra guard digits may be required to insure the reflection formula is accurate.

              IEXTRA = MAX(INT(MXY(13)%MP(2)),IEXTRA)
              IF (IEXTRA > 0) THEN
                  CALL FMEQU_R1(MXY(13),QX%NDIG,QX%NDIG+IEXTRA,QX)
              ENDIF
              QX%NDIG = QX%NDIG + IEXTRA
              CALL FMI2M(NT-1,MXY(11),QX)
              IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
                  MXY(13)%MP(1) = -MXY(13)%MP(1)
              CALL FMSUB_R1(MXY(13),MXY(11),QX)
              IF (MOD(NT,2) == 1) MBSIGN = -1
          ENDIF
      ENDIF

!             If NT is large enough, it is faster to use two calls to FMLNGM.
!             The formula below gives a rough approximation of where to change methods.

      T = QX%NDIG
      J = INT(15.21*SQRT(T)*QX%ALOGMT + 42.87*SQRT(T) + 25.03)
      IF (NT > J) THEN
          CALL FMI2M(NT,MXY(4),QX)
          CALL FMADD(MXY(13),MXY(4),MXY(14),QX)

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          IF (MAX(MXY(13)%MP(2),MXY(14)%MP(2)) > IEXTRA) THEN
              IEXTRA = INT(MAX(MXY(13)%MP(2),MXY(14)%MP(2)))
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(13),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
          QX%NDIG = QX%NDIG + IEXTRA

          CALL FMI2M(-1,MXY(15),QX)
          IF (IEXTRA > 0) THEN
              CALL FMI2M(NT,MXY(4),QX)
              CALL FMADD(MXY(13),MXY(4),MXY(14),QX)
          ENDIF
          CALL FMI2M(2,MXY(9),QX)
          KMB = 0
          IF (MXY(13)%MP(1) < 0) THEN
              CALL FMMOD(MXY(13),MXY(9),MXY(8),QX)
              IF (FMCOMP(MXY(8),'>',MXY(15),QX)) KMB = 1
          ENDIF
          KM08 = 0
          IF (MXY(14)%MP(1) < 0) THEN
              CALL FMMOD(MXY(14),MXY(9),MXY(8),QX)
              IF (FMCOMP(MXY(8),'>',MXY(15),QX)) KM08 = 1
          ENDIF
          CALL FMI2M(1,MXY(15),QX)
          IF (MXY(13)%MP(1) < 0 .AND. KMB == 1) THEN
              CALL FMEQ(MXY(13),MXY(15),QX)
              CALL FMI2M(1,MXY(4),QX)
              CALL FMADD(MXY(13),MXY(4),MXY(2),QX)
              CALL FMLNGM(MXY(2),MXY(13),QX)
          ELSE
              CALL FMLNGM(MXY(13),MXY(3),QX)
              CALL FMEQ(MXY(3),MXY(13),QX)
          ENDIF
          IF (MXY(14)%MP(1) < 0 .AND. KM08 == 1) THEN
              CALL FMI2M(-1,MXY(7),QX)
              CALL FMADD_R1(MXY(14),MXY(7),QX)
              CALL FMMPY(MXY(15),MXY(14),MXY(2),QX)
              CALL FMLNGM(MXY(2),MXY(14),QX)
          ELSE
              CALL FMLNGM(MXY(14),MXY(3),QX)
              CALL FMEQ(MXY(3),MXY(14),QX)
          ENDIF

          CALL FMSUB(MXY(14),MXY(13),MXY(11),QX)
          CALL FMEXP(MXY(11),MXY(2),QX)
          CALL FMMPY(MXY(2),MXY(15),MXY(11),QX)
          GO TO 120
      ENDIF

!             Compute the product Z*(Z+1)*...*(Z+NT-1) four terms at a time to reduce the number
!             of FMMPY calls.

!             MXY(13) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

!             If MXY(13) is negative and MXY(13)+NT is positive, extra digits are required when
!             MXY(13) is close to an integer.

      IF (MXY(13)%MP(1) < 0) THEN
          CALL FMI2M(NT,MXY(8),QX)
          CALL FMADD(MXY(13),MXY(8),MXY(9),QX)
          IF (MXY(9)%MP(1)*MXY(9)%MP(3) > 0) THEN
              CALL FMNINT(MXY(13),MXY(10),QX)
              IF (MXY(10)%MP(3) /= 0) THEN
                  CALL FMSUB(MXY(13),MXY(10),MXY(9),QX)
                  IEXTRA = MAX(IEXTRA,QX%NDIG-NDSAVE)
                  IF (MAX(MXY(13)%MP(2),MXY(9)%MP(2)) > IEXTRA) THEN
                      IEXTRA = INT(MAX(MXY(13)%MP(2),MXY(9)%MP(2)))
                  ENDIF
                  IF (IEXTRA > 0) THEN
                      CALL FMEQU_R1(MXY(13),QX%NDIG,QX%NDIG+IEXTRA,QX)
                  ENDIF
                  QX%NDIG = QX%NDIG + IEXTRA
              ENDIF
          ENDIF
      ENDIF

      CALL FMI2M(1,MXY(11),QX)
      IF (NT >= 4) THEN
          CALL FMSQR(MXY(13),MXY(6),QX)
          CALL FMMPY(MXY(13),MXY(6),MXY(7),QX)
          CALL FMSQR(MXY(6),MXY(8),QX)
          CALL FMCSMPYI(MXY(7),6,MXY(12),QX)
          CALL FMCSADD_R1(MXY(8),MXY(12),QX)
          CALL FMCSMPYI(MXY(6),11,MXY(12),QX)
          CALL FMCSADD_R1(MXY(8),MXY(12),QX)
          CALL FMCSMPYI(MXY(13),6,MXY(12),QX)
          CALL FMCSADD_R1(MXY(8),MXY(12),QX)
          CALL FMEQ(MXY(8),MXY(11),QX)
          CALL FMCSMPYI_R1(MXY(7),16,QX)
          DO K = 0, NT-8, 4
             CALL FMCSADD_R1(MXY(8),MXY(7),QX)
             K2 = 24*(2*K + 7)
             CALL FMCSMPYI(MXY(6),K2,MXY(12),QX)
             CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMCSMPYI(MXY(13),K1,MXY(12),QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             ELSE
                 K1 = 48*K
                 CALL FMCSMPYI(MXY(13),K1,MXY(12),QX)
                 CALL FMCSMPYI_R1(MXY(12),K,QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
                 K1 = 336*K + 632
                 CALL FMCSMPYI(MXY(13),K1,MXY(12),QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(8),K0,QX)
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12),QX)
                 K0 = K*K + 7*K + 15
                 CALL FMCSMPYI_R1(MXY(12),K0,QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12),QX)
                 CALL FMCSMPYI(MXY(12),K,MXY(9),QX)
                 CALL FMCSMPYI_R1(MXY(9),K,QX)
                 CALL FMCSADD_R1(MXY(8),MXY(9),QX)
                 K0 = 7*K + 15
                 CALL FMCSMPYI_R1(MXY(12),K0,QX)
                 CALL FMCSADD_R1(MXY(8),MXY(12),QX)
             ENDIF
             CALL FMCSMPY_R1(MXY(11),MXY(8),QX)
          ENDDO
      ENDIF

      KLAST = (NT/4)*4
      DO J = KLAST, NT-1
         CALL FMI2M(J,MXY(9),QX)
         CALL FMCSADD_R1(MXY(9),MXY(13),QX)
         CALL FMCSMPY_R1(MXY(11),MXY(9),QX)
      ENDDO

!             If the reflection formula was used, multiply by (-1)**NT.

  120 MXY(11)%MP(1) = MBSIGN*MXY(11)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(11)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

  140 IF (N < 0) THEN
          CALL FMI2M(1,MXY(6),QX)
          CALL FMDIV_R2(MXY(6),MXY(11),QX)
      ENDIF
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMPOCH

      SUBROUTINE FMPSI(MA,MB,QX)

!  MB = PSI(MA)      (Derivative of Ln(Gamma(MA))

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      TYPE(MULTI) :: MPISAV
      REAL (KIND(1.0D0)) :: MBSBRN
      INTEGER :: NUMBRN
      TYPE(MULTI) :: MBERN(LMBERN)
      INTEGER :: NDBERN(LMBERN)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR,X,Z
      INTEGER :: IEXTRA,INTA,J,J2,K,K0,K0B,K1,K1B,K2,KFL,KL,KOVUN,KC_RETRY,KR_RETRY,KRESLT,  &
                 KRFLCT,KRSAVE,KWRNSV,K_RETURN_CODE,LSHIFT,NDENOM,NDGOAL,NDIG2,NDOLD,        &
                 NDSAV1,NDSAVE,NGOAL,NMETHD,NMXDIF,NTERM,NUMTRY,N_ACC
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(13),MRETRY,MJSUMS(LJSUMS),C(0:196)
      INTEGER :: NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      TYPE(FM_SETTINGS) :: QX


      MBSBRN = 0
      NUMBRN = 0
      NDBERN = 0
      NDIG_C = 0
      MBASE_C = 0
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMI2M(0,MXY(2),QX)
          CALL FMSUB(MXY(2),MXY(1),MXY(3),QX)
          CALL FMI2M(1,MXY(2),QX)
          CALL FMDIV(MXY(2),MXY(3),MXY(4),QX)
          CALL FMEULR(MXY(6),QX)
          CALL FMMPYI(MXY(6),-1,MXY(5),QX)
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG+1 .AND.  &
              MXY(4)%MP(2) < QX%MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(4),MXY(8),MXY(6),QX)
              IF (MXY(6)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB,QX)
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMPSI'
                  CALL FMNTR(2,MA,MA,1,1,QX)
                  CALL FMNTR(1,MB,MB,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMPSI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0
      KC_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      CALL FMEQ(MXY(1),MXY(11),QX)
      NUMTRY = 0

!             Near zero Psi(x) is about -1/x.

  120 IF (MXY(11)%MP(2) < (-QX%NDIG-1)) THEN
          CALL FMI2M(-1,MXY(3),QX)
          CALL FMDIV(MXY(3),MXY(11),MXY(8),QX)
          GO TO 190
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDPM(DBLE(-0.5),MXY(4),QX)
      IF (FMCOMP(MXY(11),'<=',MXY(4),QX)) THEN
          KRFLCT = 1
          KFL = 0
          IF (MA%MP(2) <= NDSAVE) THEN
              CALL FMINT(MXY(11),MXY(7),QX)
              IF (FMCOMP(MXY(11),'==',MXY(7),QX)) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(8),QX)
              QX%KFLAG = -4
              GO TO 210
          ELSE
              CALL FMI2M(1,MXY(3),QX)
              CALL FMSUB_R2(MXY(3),MXY(11),QX)
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      CALL FMNINT(MXY(11),MXY(2),QX)
      CALL FMSUB(MXY(11),MXY(2),MXY(6),QX)
      CALL FMM2DP(MXY(6),Z,QX)
      Z = MAX(ABS(Z),1.0D-50)
      IF (QX%KFLAG /= 0 .OR. ABS(Z) >= 1) THEN
          NMETHD = 2
      ELSE
          IF (190*LOG(Z) - 90*QX%DLOGTN >= -QX%NDIG*QX%DLOGMB .OR. -190*QX%DLOGTN >= -QX%NDIG*QX%DLOGMB) THEN
              NMETHD = 2
          ENDIF
      ENDIF
      CALL FMM2DP(MXY(11),X,QX)
      IF (QX%KFLAG /= 0) THEN
          NMETHD = 2
      ELSE IF (NMETHD == 1) THEN
          IF (X > 35 - 8*LOG(Z) + QX%NDIG*QX%DLOGMB/(2.5*QX%DLOGTN) .OR. X > 250) NMETHD = 2
      ENDIF
      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      IF (MA%MP(1) > 0 .AND. NDSAVE+QX%NGRD52 < QX%NDIG .AND. KR_RETRY == 0 .AND. KC_RETRY == 0)  &
          QX%NDIG = NDSAVE + QX%NGRD52
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMM2I(MXY(2),LSHIFT,QX)
      LSHIFT = LSHIFT - 3
      IF (NDIG_C < QX%NDIG .OR. MBASE_C /= QX%MBASE) THEN
          CALL FMPSI_C(NDIG_C,MBASE_C,C,QX)
      ENDIF
      J2 = 0.42*LOG(Z) + 7.9
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      NDSAV1 = QX%NDIG
      DO J = 1, J2
         CALL FMEQ(C(J),MJSUMS(J),QX)
      ENDDO
      CALL FMIPWR(MXY(6),J2,MXY(5),QX)
      CALL FMEQ(MXY(5),MXY(7),QX)
      NTERM = J2
  130 IF (NTERM > J2) CALL FMCSMPY_R1(MXY(7),MXY(5),QX)
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL FMEQ(MXY(7),MXY(4),QX)
         CALL FMCSMPY_R1(MXY(4),C(NTERM),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0 .OR. NTERM == 196) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 130
  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      QX%NDIG = NDSAV1
      IF (NTERM == 196) THEN
          GO TO 150
      ENDIF
      CALL FMEQ(MJSUMS(J2),MXY(8),QX)
      CALL FMEQ(MXY(6),MXY(3),QX)
      MXY(3)%MP(1) = -MXY(3)%MP(1)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(8),MXY(3),QX)
         CALL FMCSADD_R1(MXY(8),MJSUMS(J2-J+1),QX)
      ENDDO
      CALL FMCSMPY_R1(MXY(8),MXY(6),QX)
      CALL FMADD_R1(MXY(8),C(0),QX)

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(MA-LSHIFT) + ... + 1/(MA-1) is computed.

!             MXY(11) is Z
!             MXY(4) is Z**2
!             MXY(5) is 16*Z**3
!             MXY(6) is the current four-term numerator
!             MXY(7) is the current four-term denominator
!             MXY(9) is the current sum

      IF (LSHIFT < 0) THEN
          CALL FMI2M(-1,MXY(4),QX)
          CALL FMEQ(MXY(11),MXY(5),QX)
          IF (MXY(8)%MP(1) > 0) THEN
              CALL FMEQ(MXY(8),MXY(12),QX)
              CALL FMI2M(0,MXY(13),QX)
          ELSE
              CALL FMEQ(MXY(8),MXY(13),QX)
              CALL FMI2M(0,MXY(12),QX)
          ENDIF
          DO J = 1, -LSHIFT
             CALL FMCSDIV(MXY(4),MXY(5),MXY(7),QX)
             IF (MXY(7)%MP(1) > 0) THEN
                 CALL FMADD_R1(MXY(12),MXY(7),QX)
             ELSE
                 CALL FMADD_R1(MXY(13),MXY(7),QX)
             ENDIF

             CALL FMCSADD_R1(MXY(8),MXY(7),QX)
             CALL FMSUB_R1(MXY(5),MXY(4),QX)
          ENDDO
          CALL FMADD(MXY(12),MXY(13),MXY(8),QX)
          CALL FMCANCEL(MXY(12),MXY(13),MXY(8),K,QX)
          N_ACC = N_ACC - K
      ENDIF
      IF (LSHIFT > 0) THEN
          CALL FMADDI(MXY(11),-LSHIFT,QX)
          IF (MOD(LSHIFT,4) /= 0) THEN
              CALL FMI2M(1,MXY(4),QX)
              CALL FMEQ(MXY(11),MXY(5),QX)
              DO J = 1, MOD(LSHIFT,4)
                 CALL FMCSDIV(MXY(4),MXY(5),MXY(7),QX)
                 CALL FMCSADD_R1(MXY(8),MXY(7),QX)
                 CALL FMCSADD_R1(MXY(5),MXY(4),QX)
              ENDDO
              CALL FMADDI(MXY(11),MOD(LSHIFT,4),QX)
          ENDIF
          LSHIFT = LSHIFT - MOD(LSHIFT,4)
      ENDIF
      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(11),MXY(4),QX)
          CALL FMMPY(MXY(11),MXY(4),MXY(5),QX)
          CALL FMSQR(MXY(4),MXY(6),QX)
          CALL FMCSMPYI(MXY(5),6,MXY(10),QX)
          CALL FMCSADD_R1(MXY(6),MXY(10),QX)
          CALL FMCSMPYI(MXY(4),11,MXY(10),QX)
          CALL FMCSADD_R1(MXY(6),MXY(10),QX)
          CALL FMCSMPYI(MXY(11),6,MXY(10),QX)
          CALL FMADD(MXY(6),MXY(10),MXY(7),QX)
          CALL FMCSMPYI(MXY(5),4,MXY(6),QX)
          CALL FMCSMPYI(MXY(4),18,MXY(10),QX)
          CALL FMCSADD_R1(MXY(6),MXY(10),QX)
          CALL FMCSMPYI(MXY(11),22,MXY(10),QX)
          CALL FMCSADD_R1(MXY(6),MXY(10),QX)
          CALL FMI2M(6,MXY(10),QX)
          CALL FMCSADD_R1(MXY(6),MXY(10),QX)
          CALL FMCSDIV(MXY(6),MXY(7),MXY(9),QX)
          CALL FMCSMPYI_R1(MXY(5),16,QX)
          DO K = 4, LSHIFT-4, 4
             CALL FMCSADD_R1(MXY(7),MXY(5),QX)

             CALL FMCSMPYI(MXY(4),48,MXY(10),QX)
             CALL FMCSADD_R1(MXY(6),MXY(10),QX)

             K2 = 8*(6*K - 3)
             CALL FMCSMPYI(MXY(4),K2,MXY(10),QX)
             CALL FMCSADD_R1(MXY(7),MXY(10),QX)

             K1 = 16*(6*K - 3)
             CALL FMCSMPYI(MXY(11),K1,MXY(10),QX)
             CALL FMCSADD_R1(MXY(6),MXY(10),QX)

             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K - 6*K + 7)
                 CALL FMCSMPYI(MXY(11),K1,MXY(10),QX)
                 CALL FMCSADD_R1(MXY(7),MXY(10),QX)

                 CALL FMI2M(K1,MXY(10),QX)
                 CALL FMCSADD_R1(MXY(6),MXY(10),QX)
             ELSE
                 K1 = 48*K
                 CALL FMCSMPYI(MXY(11),K1,MXY(10),QX)
                 CALL FMCSMPYI_R1(MXY(10),K,QX)
                 CALL FMCSADD_R1(MXY(7),MXY(10),QX)
                 K1B = 8*(-6*K + 7)
                 CALL FMCSMPYI(MXY(11),K1B,MXY(10),QX)
                 CALL FMCSADD_R1(MXY(7),MXY(10),QX)

                 CALL FMI2M(K1,MXY(10),QX)
                 CALL FMCSMPYI_R1(MXY(10),K,QX)
                 CALL FMCSADD_R1(MXY(6),MXY(10),QX)
                 CALL FMI2M(K1B,MXY(10),QX)
                 CALL FMCSADD_R1(MXY(6),MXY(10),QX)
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K - 1)*(K*K - K + 3)
                 CALL FMI2M(K0,MXY(10),QX)
                 CALL FMCSADD_R1(MXY(7),MXY(10),QX)
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10),QX)
                 K0B = K*K - K + 3
                 CALL FMCSMPYI_R1(MXY(10),K0B,QX)
                 CALL FMCSADD_R1(MXY(7),MXY(10),QX)
             ELSE
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10),QX)
                 CALL FMCSMPYI_R1(MXY(10),K,QX)
                 CALL FMCSMPYI_R1(MXY(10),K,QX)
                 CALL FMCSADD_R1(MXY(7),MXY(10),QX)
                 K0B = -K + 3
                 CALL FMI2M(K0,MXY(10),QX)
                 CALL FMCSMPYI_R1(MXY(10),K0B,QX)
                 CALL FMCSADD_R1(MXY(7),MXY(10),QX)
             ENDIF
             CALL FMCSDIV(MXY(6),MXY(7),MXY(10),QX)
             CALL FMCSADD_R1(MXY(9),MXY(10),QX)
          ENDDO
          CALL FMADD(MXY(8),MXY(9),MXY(3),QX)
          CALL FMCANCEL(MXY(8),MXY(9),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(8),QX)
      ENDIF
      GO TO 180

!             Method 2.  Use the B(2n)/(2n*X**(2n) asymptotic series.
!                        To speed the asymptotic series calculation,
!                        increase the argument by LSHIFT.

  150 IEXTRA = 0
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      KWRNSV = QX%KWARN
      QX%KWARN = 0
      CALL FMM2I(MXY(11),INTA,QX)
      QX%KWARN = KWRNSV

      IF (QX%KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(QX%NDIG)*QX%ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(3),QX)
          CALL FMADD(MXY(11),MXY(3),MXY(10),QX)
      ELSE
          CALL FMEQ(MXY(11),MXY(10),QX)
      ENDIF

!             Sum the asymptotic series.

      J2 = INT(0.3*QX%ALOGMB + 0.2*SQRT(REAL(QX%NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             MXY(11) is Z
!             MXY(10) is Z + LSHIFT
!             MXY(7) is X**J2 = (1/(Z+LSHIFT)**2)**J2
!             MXY(8) is the current power of X
!             MXY(9) is the current term in the sum
!             MJSUMS is the partial sum

      NDSAV1 = QX%NDIG
      CALL FMI2M(1,MXY(8),QX)
      J = -2*J2
      CALL FMIPWR(MXY(10),J,MXY(7),QX)
      IF (ABS(MXY(7)%MP(2)) >= QX%MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(10),-2,MXY(7),QX)
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(8),MXY(9),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         IF (QX%KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(8),QX)
             QX%KFLAG = -4
             GO TO 210
         ENDIF
         NDENOM = NTERM
         CALL FMDIVI(MXY(9),NDENOM,MJSUMS(J),QX)
      ENDDO

      NDIG2 = QX%NDIG
  160 CALL FMMPY_R1(MXY(8),MXY(7),QX)
      NMXDIF = MIN(NDSAV1,QX%NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(8),MXY(9),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         IF (QX%KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(8),QX)
             QX%KFLAG = -4
             GO TO 210
         ENDIF
         NDENOM = NTERM
         CALL FMDIVI_R1(MXY(9),NDENOM,QX)
         QX%NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(9),QX)
         NMXDIF = MAX(NMXDIF,NDSAV1-INT(MJSUMS(J)%MP(2)-MXY(9)%MP(2)))
         QX%NDIG = NDIG2
         IF (QX%KFLAG /= 0) GO TO 170
      ENDDO
      NDIG2 = NMXDIF
      QX%NDIG = NDIG2
      GO TO 160

!             Put the J2 concurrent sums back together.

  170 QX%NDIG = NDSAV1
      CALL FMI2M(1,MXY(7),QX)
      CALL FMSQR(MXY(10),MXY(9),QX)
      CALL FMDIV_R2(MXY(7),MXY(9),QX)
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(7),QX)
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(7),MXY(9),QX)
             CALL FMADD_R1(MXY(7),MJSUMS(J),QX)
          ENDDO
          CALL FMEQ(MXY(7),MJSUMS(1),QX)
      ENDIF

!             Add the log term to the asymptotic series.

!             MXY(8) is the current sum as the log terms are added
!             MXY(9) is now LN(Z+LSHIFT)

      CALL FMMPY(MJSUMS(1),MXY(9),MXY(8),QX)
      CALL FMLN(MXY(10),MXY(9),QX)
      CALL FMI2M(1,MXY(4),QX)
      CALL FMDIV(MXY(4),MXY(10),MXY(5),QX)
      CALL FMDIVI_R1(MXY(5),2,QX)
      CALL FMSUB(MXY(9),MXY(5),MXY(3),QX)
      CALL FMCANCEL(MXY(9),MXY(5),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(5),QX)
      CALL FMSUB(MXY(5),MXY(8),MXY(3),QX)
      CALL FMCANCEL(MXY(5),MXY(8),MXY(3),K,QX)
      N_ACC = N_ACC - K
      CALL FMEQ(MXY(3),MXY(8),QX)

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(MA) + ... + 1/(MA+LSHIFT-1) is computed.

!             MXY(11) is Z
!             MXY(4) is Z**2
!             MXY(5) is 16*Z**3
!             MXY(6) is the current four-term numerator
!             MXY(7) is the current four-term denominator
!             MXY(9) is the current sum

      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(11),MXY(4),QX)
          CALL FMMPY(MXY(11),MXY(4),MXY(5),QX)
          CALL FMSQR(MXY(4),MXY(6),QX)
          CALL FMMPYI(MXY(5),6,MXY(10),QX)
          CALL FMADD_R1(MXY(6),MXY(10),QX)
          CALL FMMPYI(MXY(4),11,MXY(10),QX)
          CALL FMADD_R1(MXY(6),MXY(10),QX)
          CALL FMMPYI(MXY(11),6,MXY(10),QX)
          CALL FMADD(MXY(6),MXY(10),MXY(7),QX)
          CALL FMMPYI(MXY(5),4,MXY(6),QX)
          CALL FMMPYI(MXY(4),18,MXY(10),QX)
          CALL FMADD_R1(MXY(6),MXY(10),QX)
          CALL FMMPYI(MXY(11),22,MXY(10),QX)
          CALL FMADD_R1(MXY(6),MXY(10),QX)
          CALL FMI2M(6,MXY(10),QX)
          CALL FMADD_R1(MXY(6),MXY(10),QX)
          CALL FMDIV(MXY(6),MXY(7),MXY(9),QX)
          CALL FMMPYI_R1(MXY(5),16,QX)
          DO K = 4, LSHIFT-4, 4
             CALL FMADD_R1(MXY(7),MXY(5),QX)

             CALL FMMPYI(MXY(4),48,MXY(10),QX)
             CALL FMADD_R1(MXY(6),MXY(10),QX)

             K2 = 8*(6*K - 3)
             CALL FMMPYI(MXY(4),K2,MXY(10),QX)
             CALL FMADD_R1(MXY(7),MXY(10),QX)

             K1 = 16*(6*K - 3)
             CALL FMMPYI(MXY(11),K1,MXY(10),QX)
             CALL FMADD_R1(MXY(6),MXY(10),QX)

             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K - 6*K + 7)
                 CALL FMMPYI(MXY(11),K1,MXY(10),QX)
                 CALL FMADD_R1(MXY(7),MXY(10),QX)

                 CALL FMI2M(K1,MXY(10),QX)
                 CALL FMADD_R1(MXY(6),MXY(10),QX)
             ELSE
                 K1 = 48*K
                 CALL FMMPYI(MXY(11),K1,MXY(10),QX)
                 CALL FMMPYI_R1(MXY(10),K,QX)
                 CALL FMADD_R1(MXY(7),MXY(10),QX)
                 K1B = 8*(-6*K + 7)
                 CALL FMMPYI(MXY(11),K1B,MXY(10),QX)
                 CALL FMADD_R1(MXY(7),MXY(10),QX)

                 CALL FMI2M(K1,MXY(10),QX)
                 CALL FMMPYI_R1(MXY(10),K,QX)
                 CALL FMADD_R1(MXY(6),MXY(10),QX)
                 CALL FMI2M(K1B,MXY(10),QX)
                 CALL FMADD_R1(MXY(6),MXY(10),QX)
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K - 1)*(K*K - K + 3)
                 CALL FMI2M(K0,MXY(10),QX)
                 CALL FMADD_R1(MXY(7),MXY(10),QX)
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10),QX)
                 K0B = K*K - K + 3
                 CALL FMMPYI_R1(MXY(10),K0B,QX)
                 CALL FMADD_R1(MXY(7),MXY(10),QX)
             ELSE
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10),QX)
                 CALL FMMPYI_R1(MXY(10),K,QX)
                 CALL FMMPYI_R1(MXY(10),K,QX)
                 CALL FMADD_R1(MXY(7),MXY(10),QX)
                 K0B = -K + 3
                 CALL FMI2M(K0,MXY(10),QX)
                 CALL FMMPYI_R1(MXY(10),K0B,QX)
                 CALL FMADD_R1(MXY(7),MXY(10),QX)
             ENDIF
             CALL FMDIV(MXY(6),MXY(7),MXY(10),QX)
             CALL FMADD_R1(MXY(9),MXY(10),QX)
          ENDDO
          CALL FMSUB(MXY(8),MXY(9),MXY(3),QX)
          CALL FMCANCEL(MXY(8),MXY(9),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(8),QX)
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

  180 IF (KRFLCT == 1) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(11),MXY(4),QX)
          CALL FMSUB(MXY(11),MXY(4),MXY(7),QX)
          CALL FMCANCEL(MXY(11),MXY(4),MXY(7),K,QX)
          N_ACC = N_ACC - K
          CALL FMPI(MXY(9),QX)
          CALL FMMPY_R1(MXY(9),MXY(7),QX)
          KRSAVE = QX%KRAD
          QX%KRAD = 1
          CALL FMTAN(MXY(9),MXY(2),QX)
          QX%KRAD = KRSAVE
          CALL FMPI(MPISAV,QX)
          CALL FMDIV_R2(MPISAV,MXY(2),QX)
          CALL FMADD(MXY(8),MXY(2),MXY(3),QX)
          CALL FMCANCEL(MXY(8),MXY(2),MXY(3),K,QX)
          N_ACC = N_ACC - K
          CALL FMEQ(MXY(3),MXY(8),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(8)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(8)%MP(J+1)) GO TO 200
              ENDDO
              GO TO 210
          ENDIF
  200     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = QX%NDIG + IEXTRA
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQ(MXY(1),MXY(11),QX)
          KC_RETRY = 1
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(8),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  210 CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMPSI

      SUBROUTINE FMPSI_C(NDIG_C,MBASE_C,C,QX)

!  Initialize the constants used in the psi polynomial.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: C(0:196)
      INTEGER :: NDIG_C
      REAL (KIND(1.0D0)) :: MBASE_C
      INTENT (INOUT) :: C,NDIG_C,MBASE_C
      INTEGER :: NDSAVE
      CHARACTER(220) :: ST
      TYPE(FM_SETTINGS) :: QX

      NDSAVE = QX%NDIG
      QX%NDIG = MAX(QX%NDIG,NINT(210*QX%DLOGTN/QX%DLOGMB))
      NDIG_C = QX%NDIG
      MBASE_C = QX%MBASE

      ST = " 9.227843350984671393934879099175975689578406640600764011942327651" //  &
           "151322732223353290630529367082532504853685527501929175190394959855" //  &
           "13457163775826002355076463746499666257062662262326057207404741752905084M-1"
      CALL FMST2M(ST,C(0),QX)
      ST = " 3.949340668482264364724151666460251892189499012067984377355582293" //  &
           "700074704032008738336289006197587053040043189623371906796287246870" //  &
           "05007787935102946330866276831733309367762605095251006872140054796811559M-1"
      CALL FMST2M(ST,C(1),QX)
      ST = " 7.705690315959428539973816151144999076498629234049888179227155534" //  &
           "183820578631309018645587360933525814619915779526071941849199599867" //  &
           "32832137763968372079001614539417829493600667191915755222424942439615639M-2"
      CALL FMST2M(ST,C(2),QX)
      ST = " 1.982323371113819151600369654116790277475095191872690768297621544" //  &
           "412061618696884655690963594169991723299081390804274241458407157457" //  &
           "00453492820035147162192070877834809108370293261887348261752736042355062M-2"
      CALL FMST2M(ST,C(3),QX)
      ST = " 5.677755143369926331365486457034168057080919501912811974192677903" //  &
           "803589786281484560043106557133336379620341466556609042800961779155" //  &
           "97084183511072180087644866286337180353598363962365128888981335276775240M-3"
      CALL FMST2M(ST,C(4),QX)
      ST = " 1.718061984449139714517929790920527901817490032853561842408664004" //  &
           "332182901957897882773977938535170530279191162254558867398181448333" //  &
           "10185379291633807265673175253040965355618769627954139226236853166325794M-3"
      CALL FMST2M(ST,C(5),QX)
      ST = " 5.367773819228268397975498497967595998635605652387064172831365716" //  &
           "014783173557353460969689138513239689614536514910748872867774198403" //  &
           "35440315798301033984562121069463585243906583353964676997567696691427804M-4"
      CALL FMST2M(ST,C(6),QX)
      ST = " 1.711061979443393786852385086524652589607906498500203291102026525" //  &
           "829525747488143952872303723719711245236484702826900263542995480733" //  &
           "83970966270581799604618992754222287297459333028151505628361773822843426M-4"
      CALL FMST2M(ST,C(7),QX)
      ST = " 5.526782608221441785276923241206048560585139488875654859661590978" //  &
           "505339025839895039306912716958615740860476584706026142537397072243" //  &
           "01530691324987642510909294868767654539697941540782602296415448362507489M-5"
      CALL FMST2M(ST,C(8),QX)
      ST = " 1.801262781808533714595890031901700601953156447751725778899463629" //  &
           "146515191295439704196861038565275400689206320530767736809020353629" //  &
           "38073190695949842873953621603334722352596732052178932328832066541508011M-5"
      CALL FMST2M(ST,C(9),QX)
      ST = " 5.907354119464558702282526469936468606435758208617119141436100054" //  &
           "059798219814702591843023560629835506072948141298603299797940044724" //  &
           "48291452340594666101827864743680486809340363559802370626936931930763706M-6"
      CALL FMST2M(ST,C(10),QX)
      ST = " 1.945928308048298637998047739670960416088458003404533040952133252" //  &
           "019681940913049042808551900699474542980945266314269501249317870278" //  &
           "74908804736762623987426734001119677345511898921612599921683514419564006M-6"
      CALL FMST2M(ST,C(11),QX)
      ST = " 6.430350784891467518365263573957142751058955098451367026716208967" //  &
           "268298442098128927139532681355390234484052117973406407648522438051" //  &
           "09390967296839296849960667716105732496299638299238322412706670233440209M-7"
      CALL FMST2M(ST,C(12),QX)
      ST = " 2.129788087048292585451051353337474816961691545494827552022528629" //  &
           "410231774208766597829719984675128804906172087285080543161655047327" //  &
           "58375412105018997048159105561567647701210317140138410056728113033026445M-7"
      CALL FMST2M(ST,C(13),QX)
      ST = " 7.065818202049355172851064506258762794870685817750656993289333226" //  &
           "715634227957307233434701754849436696844424928325302977575887819043" //  &
           "21794404770003433234833231074275648790842338915961498517998739808022623M-8"
      CALL FMST2M(ST,C(14),QX)
      ST = " 2.347034615187173257148763672202323738899047153115310520358878708" //  &
           "702795315178628560484632246234627121875727895643809584057710305127" //  &
           "87278924224408794242543715977424052595827644319888981305672643671262471M-8"
      CALL FMST2M(ST,C(15),QX)
      ST = " 7.803106649762273600293563029213088249090262679095379843972935643" //  &
           "290282459342081738636916671209602661597101103726013919619715976946" //  &
           "82488687750381269409404895538941410178728305136626722016628210197601304M-9"
      CALL FMST2M(ST,C(16),QX)
      ST = " 2.595999374839856461644621939730454697218953331143174429987630039" //  &
           "542650045638001968668989649549309210492316961761661920993360907581" //  &
           "83943362125894719965856782417889275088010359200837997812612518790010306M-9"
      CALL FMST2M(ST,C(17),QX)
      ST = " 8.640837414389256569577951013532585711448386302359330467618239497" //  &
           "053413093126642271180763027067164825596661845609758534245303980743" //  &
           "08087916612539453037312942192048368911659495539677311896754022319241514M-10"
      CALL FMST2M(ST,C(18),QX)
      ST = " 2.877174665461131520386834493459437941874105957500564898511375137" //  &
           "311439002578360979763874789548515880868154509894190626699457757147" //  &
           "73686016316321832375029203457725272356560152718132192583462548282779007M-10"
      CALL FMST2M(ST,C(19),QX)
      ST = " 9.582858468146311671960437304596644669478493760020748737659683908" //  &
           "789815983387663856449725613266381211899380089748749729674239142554" //  &
           "09417096385045411044655577509743953184783848043803078810843691683066120M-11"
      CALL FMST2M(ST,C(20),QX)
      ST = " 3.192362617049000364818675299493504182177965826984960311647445893" //  &
           "562291482131615616774398545467628898736874378132707045074901954090" //  &
           "87857585211733812448598150553069088798592369166325857786128311238584878M-11"
      CALL FMST2M(ST,C(21),QX)
      ST = " 1.063641452982306778871888232638725499778451985860322579723624373" //  &
           "042743512317431335223585983763945149600366863053831443772337083310" //  &
           "55022604714614305141359222385085339434173650339778299984225419876751487M-11"
      CALL FMST2M(ST,C(22),QX)
      ST = " 3.544275868854612440207935801227503918837302795864246972321724495" //  &
           "355468544848206832825003613889968600093960257823513222253360353453" //  &
           "05713971042571842928244634878395967156692305652444148244943360077022711M-12"
      CALL FMST2M(ST,C(23),QX)
      ST = " 1.181126956967686063705069366011844730919543312398681339013384460" //  &
           "767464082069171562896200433788460949822871886205681867819662919323" //  &
           "00910010651681302654526439685187828766124647111195799560742489176171727M-12"
      CALL FMST2M(ST,C(24),QX)
      ST = " 3.936345173849846585066306986288647881678859105474359687899712967" //  &
           "448625102584861794056546209745855663655522551206324259480980022982" //  &
           "48196521666063662466312955017462793017857218058858813422030279362129550M-13"
      CALL FMST2M(ST,C(25),QX)
      ST = " 1.311929116013669810041706041194547190318825658299932395783521476" //  &
           "062715708679008371003135237649339518303948243863280796328717056928" //  &
           "61088933385870034244218462559681704119429612455202721574336572434693909M-13"
      CALL FMST2M(ST,C(26),QX)
      ST = " 4.372632654299231920401840242323289305929581151976933470616960496" //  &
           "030436497373880193006652887239443630902623173458012149767003641260" //  &
           "91381234213835299457171231108226264358946266150962591099913744278927353M-14"
      CALL FMST2M(ST,C(27),QX)
      ST = " 1.457428209197515390994541694806166533046920066577489380555809169" //  &
           "326581787738147452100480717196733318418099673508724121255442697420" //  &
           "79428502647711159673409529291257489352915130912350484504348941167745402M-14"
      CALL FMST2M(ST,C(28),QX)
      ST = " 4.857804189667246764735021219813567955136816185008613360441960672" //  &
           "940496363503624604027929086312123388047291007867151509866153218472" //  &
           "06384966879455254262531778810269062220190874499923455125800419069661498M-15"
      CALL FMST2M(ST,C(29),QX)
      ST = " 1.619195639149486423325122007106269185336947307372971693371175669" //  &
           "889809582649582191406670950947339285199094038180244016830476463936" //  &
           "02101458401269222147875016156102854033684337727151883392617646517180429M-15"
      CALL FMST2M(ST,C(30),QX)
      ST = " 5.397137809202938955975940495024829822845303110776022583879121893" //  &
           "921705867907147218379583534840013350252782358738567325002357267738" //  &
           "61010468743185749436896970436317859962951219444890985968097249049622718M-16"
      CALL FMST2M(ST,C(31),QX)
      ST = " 1.799000703833061723835456309516522471727635932565177399470291246" //  &
           "245675486739349743760088108709128457742138295133686476564611083127" //  &
           "88305692939487359678233270751804270008374154159339121093086571227836484M-16"
      CALL FMST2M(ST,C(32),QX)
      ST = " 5.996555960166587435989106305417312260461721595507168812416307139" //  &
           "617920826596045537450588005370606978697110903751234286759364296538" //  &
           "88342574088876310757201262943137995532500249048583561327234609512080698M-17"
      CALL FMST2M(ST,C(33),QX)
      ST = " 1.998823729325601300227884046410698198743303225621025482564048890" //  &
           "140820433856911724428946203004508501377274799484714026521360076321" //  &
           "81570423267997358911300788282146663959893146975667195154844645417775406M-17"
      CALL FMST2M(ST,C(34),QX)
      ST = " 6.662675132429289007245318420983808894124038069139542218571745865" //  &
           "030220152998942329578185363084791339999779092891491916899149034423" //  &
           "33275083724236395937279776479045434110852072326963373822046800189057081M-18"
      CALL FMST2M(ST,C(35),QX)
      ST = " 2.220874055111200556512338059264850925555466107705796942638438370" //  &
           "439334710114183793262340326636387034843865608526952566379170604706" //  &
           "27391000045814717730873567070447343919893162122347939701787863570280570M-18"
      CALL FMST2M(ST,C(36),QX)
      ST = " 7.402869382385770801058732735126460283848974699479515940427142498" //  &
           "169090369970169606837637347292197915595099714959178372809210169004" //  &
           "97096397918083614643468550094209927318490673314894967308013075647465808M-19"
      CALL FMST2M(ST,C(37),QX)
      ST = " 2.467612094717547539757300850305893096186640705352512533565093161" //  &
           "524071499801682896819052946685011871151619653049568921247943861305" //  &
           "74027835796362386640519365699573759086773066188473623555158872217826510M-19"
      CALL FMST2M(ST,C(38),QX)
      ST = " 8.225346069033827277619490875386000099087882850547971011202536869" //  &
           "560710353060722052873313849027274314019902150470472049910634941015" //  &
           "65431604021316042692200940962539817779136949003756418974351775701389418M-20"
      CALL FMST2M(ST,C(39),QX)
      ST = " 2.741775128372239167169885703390452991143862808123403590500260252" //  &
           "686098892049313322445848356272884233074331136306076265803163875838" //  &
           "39997245835097889674208425702496742768010046284312175596063967715214956M-20"
      CALL FMST2M(ST,C(40),QX)
      ST = " 9.139233192043922392172869121382982198915872580533647882222959712" //  &
           "340271164148043740483814963159921847750954087090085242066261297172" //  &
           "38743378565324605175470969019495974103495135080039518080872470260574797M-21"
      CALL FMST2M(ST,C(41),QX)
      ST = " 3.046406755195530600990090643743590284251799899012276309359112089" //  &
           "108511649715687692732843107149352212491463042497645778261917818921" //  &
           "00104801732363345270093806101054860184893098558607015592900408049840396M-21"
      CALL FMST2M(ST,C(42),QX)
      ST = " 1.015467841223081888268990685530571588993883516806444440463590063" //  &
           "919246457993838714361388326407974316725799445869567226317393205847" //  &
           "41823934922206879509013719077372316295552261963694116207153809783055715M-21"
      CALL FMST2M(ST,C(43),QX)
      ST = " 3.384890111197057663463016207436882653098338276290627817566949828" //  &
           "395298842402236802648447435554701889903014892066703092691102459316" //  &
           "42305364341869125221913232186873905776329877020426296097438946487577807M-22"
      CALL FMST2M(ST,C(44),QX)
      ST = " 1.128296030524118217901770376786986056339519574517002442090074882" //  &
           "057280000658483297467423203305781809303690428354763800658686040236" //  &
           "71779144955091790824204211870513439500061673502868286865350206893118470M-22"
      CALL FMST2M(ST,C(45),QX)
      ST = " 3.760985085416611180417555002274204359368768836382888775095377932" //  &
           "135470299750400345139854657192126020629674958772171673259844584632" //  &
           "29740983608860531344547744626628209787912508838546108351215194899892193M-23"
      CALL FMST2M(ST,C(46),QX)
      ST = " 1.253661274394284819616871799214565550306261501251793404757960132" //  &
           "128170781722119090896566129331363704599359253979761928823159537461" //  &
           "94504254386899126662346756986738717779547048333427719023221981595254954M-23"
      CALL FMST2M(ST,C(47),QX)
      ST = " 4.178869862795538345454967070155508575326951978759241233273121057" //  &
           "066301381631679857138532781845567887396083218733585140280524330791" //  &
           "93670559242093402244963076978237398106292624308475677695772071716993274M-24"
      CALL FMST2M(ST,C(48),QX)
      ST = " 1.392956357970703804166482382560887146464466644976989900838409857" //  &
           "521105907861179378438919270011579646317439048476258541449951226731" //  &
           "38419505723140506483598868257584439349831369024815848605796104120125198M-24"
      CALL FMST2M(ST,C(49),QX)
      ST = " 4.643187202503244267904840086459603070244180285978311534148487451" //  &
           "448533368113912140098658002328251742282983537128133995397515041612" //  &
           "48378614922938242264999090255128209599611777303756393485557336865892384M-25"
      CALL FMST2M(ST,C(50),QX)
      ST = " 1.547728903152056758023013339236654329438934392366540425603322082" //  &
           "857263082844161081125623346144761860535134488231475517768722978006" //  &
           "97598742236912925627747252856046998990338903727397536889459369962969529M-25"
      CALL FMST2M(ST,C(51),QX)
      ST = " 5.159095932969129018305623899832229004426259340923333088824701344" //  &
           "793799573384328764667708388371262541343393211413511112875917018796" //  &
           "26630534722311094084888639746029822030436534231881230203368649013498048M-26"
      CALL FMST2M(ST,C(52),QX)
      ST = " 1.719698541605578250055328719172355061652680958536807515991957911" //  &
           "829231225440009541518975734286993664349423799759754184346111779848" //  &
           "98079517451175822251033508127845088987176652373067048423597073312187144M-26"
      CALL FMST2M(ST,C(53),QX)
      ST = " 5.732328215225532836270189877348903743690272187963364883413404892" //  &
           "515967840972047550982297271962784377794755127033081531768642894199" //  &
           "64735397060888178165089361563869938931990240827823701959473704067979558M-27"
      CALL FMST2M(ST,C(54),QX)
      ST = " 1.910776007543699055364968001468624686158867348024934230266622903" //  &
           "018662755804722736204383531033467520086936412589269186167968820789" //  &
           "31707316415310370070101583553225900248595006769483528789991489268005919M-27"
      CALL FMST2M(ST,C(55),QX)
      ST = " 6.369253197983874006821823217108741793471311336545161803572473280" //  &
           "581604669538018391744708133203440680673579856484395859330652484509" //  &
           "72888929728309163536568371996260645727875086529584444740409818707168597M-28"
      CALL FMST2M(ST,C(56),QX)
      ST = " 2.123084359204225333255211453879706270058062440003428132183384754" //  &
           "529220299115266894193502387449244415133870841331224790006731846829" //  &
           "83950869831354206398680371015186352923965072680137000319344572605758909M-28"
      CALL FMST2M(ST,C(57),QX)
      ST = " 7.076947763704848854568916919680447890729663289024670563717349289" //  &
           "716854593909643699182828273092172522117888394772977756940206908939" //  &
           "88161833503128621124125052157189818939182888192518392960394844544910580M-29"
      CALL FMST2M(ST,C(58),QX)
      ST = " 2.358982562824326603834177965008914574063289371087237954036406546" //  &
           "340493525463133458597261132503854782619333331885562197138535071408" //  &
           "23201579847913351266307691059142085404786612749993269600147335936631424M-29"
      CALL FMST2M(ST,C(59),QX)
      ST = " 7.863275146721236242647451555165511648580559926859636607085030645" //  &
           "828570768337179488776594015720853254496569344629950772241890794413" //  &
           "09501208585846001333592788550065884722420498762308117260230188148248777M-30"
      CALL FMST2M(ST,C(60),QX)
      ST = " 2.621091699900456658110115330583854052361897297784388638216583319" //  &
           "454384526174907954107229789803487469826658513137203063896172131706" //  &
           "68596675776534544455338620395186907938046711829117294010990223395191200M-30"
      CALL FMST2M(ST,C(61),QX)
      ST = " 8.736972293818315676196547510693128031654563870400207411221472197" //  &
           "802537238798558154077761157016481387194295979174198832797107057716" //  &
           "55476119097180397397991205334340641881095558538017176052985551441032265M-31"
      CALL FMST2M(ST,C(62),QX)
      ST = " 2.912324088143640003892515793451613942403905838900460353749079195" //  &
           "711293166403329382629400828420996934679831800044190489170302330372" //  &
           "89702647828398182289986576193569329546458981411599932131292250327217139M-31"
      CALL FMST2M(ST,C(63),QX)
      ST = " 9.707746935989309774922153324275043050136559616419228148856384390" //  &
           "891207031590122433573161121435856761535255587985039419083521928281" //  &
           "47684192432450134453307134064460958883080711047615861323976659104916668M-32"
      CALL FMST2M(ST,C(64),QX)
      ST = " 3.235915639207398595265693615961166003757636977735808496558273648" //  &
           "928958056872747435108942393361659134982792854945130370217146958406" //  &
           "96083858500218202729498941860260710013473689957089195606216847161948489M-32"
      CALL FMST2M(ST,C(65),QX)
      ST = " 1.078638544871873611955050957012575767956166828939502396913361632" //  &
           "134006203107387187862076294858437749004255229312668679921800233056" //  &
           "74417612290238598612397811829199658493331617719065112441605814593748378M-32"
      CALL FMST2M(ST,C(66),QX)
      ST = " 3.595461812413097732268985825592100369404790978561873060558407383" //  &
           "209843595084925537819419221457817216101556873881028197503043710989" //  &
           "71993446117511506289219252721788791857419650690058381970466123873747686M-33"
      CALL FMST2M(ST,C(67),QX)
      ST = " 1.198487269847745765578016200858552396971801017866213814921147936" //  &
           "194342329888616529805943628521815471009477410250705796740507122991" //  &
           "05724055220198767971701073860808057115160815984757015916251499607980512M-33"
      CALL FMST2M(ST,C(68),QX)
      ST = " 3.994957563767602385747901769948142409291248613545961370363883891" //  &
           "289691397311922302379137927297721501329041681797620724073370767562" //  &
           "18203408450216245071443700831249773241142322486002435752961943222542254M-34"
      CALL FMST2M(ST,C(69),QX)
      ST = " 1.331652520657979959724598554013660845601546719077233063789633368" //  &
           "960435001352641490522946960948433409671303505299895763210435682642" //  &
           "64618257123231948431647534610234863412519330901304158646595801812800221M-34"
      CALL FMST2M(ST,C(70),QX)
      ST = " 4.438841734031881188976818132822337642864369008251133361954967150" //  &
           "427526248489023180060951578854782817826656197035293616050385245228" //  &
           "69777224342488088789975020608283234140930896389710286843599614310829011M-35"
      CALL FMST2M(ST,C(71),QX)
      ST = " 1.479613910970280742873945057507129611414800958022743884631361380" //  &
           "691798159539547487537052914060034185767422767130178282321602757860" //  &
           "83348663879834983529553026971940768027904120497673742153199914849116728M-35"
      CALL FMST2M(ST,C(72),QX)
      ST = " 4.932046368966736707433238163653472803158736679721922230398981807" //  &
           "148509857901058886361798749120231700519606437174141329665127637580" //  &
           "60684029229789780624847253236488984529122857484143590545454988280087620M-36"
      CALL FMST2M(ST,C(73),QX)
      ST = " 1.644015456088695799904278450146142178669043440878937685558456872" //  &
           "964025555598274081805412440896705440428517289000442501284221387694" //  &
           "55648732942491166386921283069386388704660866255758554699458240090291278M-36"
      CALL FMST2M(ST,C(74),QX)
      ST = " 5.480051519711778255840272708324976030739754268948537269674402054" //  &
           "568534364217773209485346648013194520472068667682265478950114643548" //  &
           "57817502762576875030228023959898997369951420244275748984693326649040707M-37"
      CALL FMST2M(ST,C(75),QX)
      ST = " 1.826683839757957485171861873006044105081660879173944661934615164" //  &
           "058228248983434414103054534197242809510738787922754612090096010008" //  &
           "32972234391112427466530639806131521397347115826207673334357276487387067M-37"
      CALL FMST2M(ST,C(76),QX)
      ST = " 6.088946132161603455339501324095998745526413263096303935940878780" //  &
           "526359496483279209617877435619263014735196336319313697924877016533" //  &
           "09653632325766553783756318556864993407257715531353455924785891667301524M-38"
      CALL FMST2M(ST,C(77),QX)
      ST = " 2.029648710629304112312264073466486255977035674544143740902384580" //  &
           "066925825480897303013099124850654602496048781418796500497911435814" //  &
           "55895496319542786203501573229289360635504754435873888697991558050538067M-38"
      CALL FMST2M(ST,C(78),QX)
      ST = " 6.765495701869604444386835156000328903984913424070294867383326826" //  &
           "380125179490385914541280070377395224806865489400873522529357739540" //  &
           "13593097642976584317974244356761507356447028338622758884083690956549688M-39"
      CALL FMST2M(ST,C(79),QX)
      ST = " 2.255165233899515832701742852677093869944624882375775392021565853" //  &
           "727820148309140426329940190201858812882180125645736863330093959501" //  &
           "39799185623421035440349003272811535983000708934970150324591131369976675M-39"
      CALL FMST2M(ST,C(80),QX)
      ST = " 7.517217446189171987910422000959627404182160006415193289405563037" //  &
           "073141918979212912887404738051712797448922513382013488736054976966" //  &
           "44850928549751713769786767895881754130344984097285305963557272547145616M-40"
      CALL FMST2M(ST,C(81),QX)
      ST = " 2.505739148694087132524150695488551963220019249166337393102845297" //  &
           "929187685834976527612995960496060104814687111155509389611886823768" //  &
           "45665657833105762416203034605047428562380070279581109059970215759343049M-40"
      CALL FMST2M(ST,C(82),QX)
      ST = " 8.352463828891198283454574490687921776166017804023933180339411723" //  &
           "551630949077812713723188475201183251308083861018090692334062700224" //  &
           "19315941542359676555596601655478811403243506810721773017251413934374514M-41"
      CALL FMST2M(ST,C(83),QX)
      ST = " 2.784154609608126388309518953024776333056303224324599419154596270" //  &
           "687189694467353799519873714017939494084666475975688987152456659642" //  &
           "26654762776582515405508388836892873507912509482458807279902034848895589M-41"
      CALL FMST2M(ST,C(84),QX)
      ST = " 9.280515365304738695722333964470955476404932927589213406274394075" //  &
           "824251507915677707145886824360137294712999378365268640074244947377" //  &
           "75283581062718625871709431187118953937401911092491908328625126927814924M-42"
      CALL FMST2M(ST,C(85),QX)
      ST = " 3.093505121754325582272552779234873274821484670440649874514125833" //  &
           "450221430848146677414227286193944601969620041844899866725992046638" //  &
           "96302520509550456127533362858925937984066799183063861137995551939093475M-42"
      CALL FMST2M(ST,C(86),QX)
      ST = " 1.031168373914628365020619376010732175534509522276934226759611010" //  &
           "510330113936747333958108874337789248731979567783939919999577683507" //  &
           "22523295728071715108784714082583918137083993400414421602035476389181042M-42"
      CALL FMST2M(ST,C(87),QX)
      ST = " 3.437227913040060810736801880470831506837625258770689684886108518" //  &
           "300849420221764767894609466818173933155866849989575822424072255004" //  &
           "78234006087579117395941989824600255765731792341982892120664183263431722M-43"
      CALL FMST2M(ST,C(88),QX)
      ST = " 1.145742637677845168748014850793946505879656739125856631649586463" //  &
           "591822853689599347930344326959430427527959142809100423533805439264" //  &
           "43279388738637495289806414123857142554621616733197424850302473869617722M-43"
      CALL FMST2M(ST,C(89),QX)
      ST = " 3.819142125587379475420211530141217153875049185525247582904249203" //  &
           "019903748875977266231256469090038860233530356197288111009590135316" //  &
           "90898695851949084954771545562975566659699180249151895098720201541444897M-44"
      CALL FMST2M(ST,C(90),QX)
      ST = " 1.273047375194433720039269643742156618287252568559809316454558670" //  &
           "180525454213261685018950248687574295353166212229651718103175620816" //  &
           "43760967542155803486826726482394407727128624904626495857158860946505910M-44"
      CALL FMST2M(ST,C(91),QX)
      ST = " 4.243491250644713804047213900311521631782151086428302312117409417" //  &
           "778324805156532130172471108085960753421387148016192082165090341252" //  &
           "19545466280371097678329835612276755167203138210639186157532227100590980M-45"
      CALL FMST2M(ST,C(92),QX)
      ST = " 1.414497083547388285661813522776106834139405615052171085969597516" //  &
           "047278841879024411976249475067654110853871648213868458414159189231" //  &
           "79891226179605118296023118379963942164595272691469246552143553753880550M-45"
      CALL FMST2M(ST,C(93),QX)
      ST = " 4.714990278489170162988560867348152304757403878210496541497712053" //  &
           "006454958803147191193828617164924983154190125072717651655296406044" //  &
           "51236582999806300249260089437863523751237893569424876357019027689437850M-46"
      CALL FMST2M(ST,C(94),QX)
      ST = " 1.571663426162525690358614617253775521309331567276009924639764177" //  &
           "358960165102899050236124157794756906336803102013665429067943394214" //  &
           "57838273206825762014705848617755003448485196508751247061517100802618351M-46"
      CALL FMST2M(ST,C(95),QX)
      ST = " 5.238878087207091391268381971748475496510636983623239581337201528" //  &
           "761219196441713174722639342282806574120757748535810991181068549199" //  &
           "89053413431795493494028007267927630087829683052755847961739807896841957M-47"
      CALL FMST2M(ST,C(96),QX)
      ST = " 1.746292695735365236274430121252895780353566878171851946466982282" //  &
           "916481274302755866597786442055146506112819565744487880483609437125" //  &
           "77321479855945945213560009077900564250744371125376843314616795699839063M-47"
      CALL FMST2M(ST,C(97),QX)
      ST = " 5.820975652450387718877296368406106766373716711813705919181086521" //  &
           "999505975590854145900097731105648953941956782748776332821329494966" //  &
           "87768367928768066507060035439222042970126325626238817880646490785855621M-48"
      CALL FMST2M(ST,C(98),QX)
      ST = " 1.940325217483255139116418908036918257576300407306275798031334364" //  &
           "409601786683742364221787811915022144162851994955921858529462196970" //  &
           "10653973717672741870614055497821682510355774493997650251816154517127732M-48"
      CALL FMST2M(ST,C(99),QX)
      ST = " 6.467750724943665212448072244898217344228281509203436692886144544" //  &
           "710488376123702904475209151820097662127258578415899891069730495416" //  &
           "37336243969682934496722083054141458419645859035208215900305459742433866M-49"
      CALL FMST2M(ST,C(100),QX)
      ST = " 2.155916908314425424664368170497409014232503939749568528677540140" //  &
           "384039734094541956602791846039169318650021459160866243512075243331" //  &
           "45679505658773347404938241005432513933656138666470399349344701169458177M-49"
      CALL FMST2M(ST,C(101),QX)
      ST = " 7.186389694381093966835437692494728822349002314959532010292364775" //  &
           "394946247059389433028322727013522877670270796020110428790305813054" //  &
           "79391776953852548570365845653848831536967043669276608555999675341559488M-50"
      CALL FMST2M(ST,C(102),QX)
      ST = " 2.395463231460283626767035225609077295862357711256733986014148707" //  &
           "753272199463531514035780844426290282772850231675309468999618270293" //  &
           "06226615257093166993337223904134396989045750924820301622864539591983840M-50"
      CALL FMST2M(ST,C(103),QX)
      ST = " 7.984877438200742850444847499777309845694641795079466763347310518" //  &
           "973477267679513036692556925499430697000376845097566527468301532263" //  &
           "68593074139587048157403440914703927108798266764367635240248126118737063M-51"
      CALL FMST2M(ST,C(104),QX)
      ST = " 2.661625812733530307120299705689856310419430305299514816454219978" //  &
           "167720121577781636596013737099879504260242494410428404547299997096" //  &
           "29214426445076866714408263418452627026007712187686306994919339537176315M-51"
      CALL FMST2M(ST,C(105),QX)
      ST = " 8.872086042444974416164378071031044765486837933978062891736690757" //  &
           "063302976670153482438120949026393088923322321063932750682909484640" //  &
           "80118939886335367290880449750827102760828907286267653373299382121005954M-52"
      CALL FMST2M(ST,C(106),QX)
      ST = " 2.957362014148293153495637994224156508433858704035708219961848704" //  &
           "752814743630032704058576844386754167614614033997051904620347311738" //  &
           "61904345412997662020042929619746892567448362596680832152684925750243880M-52"
      CALL FMST2M(ST,C(107),QX)
      ST = " 9.857873380494231381920907655510228783611078844545021454399920772" //  &
           "141062619227406263790226964711069068688447840761328895136653289698" //  &
           "66981214088475384265075552305006338119605469313298818722398857563732976M-53"
      CALL FMST2M(ST,C(108),QX)
      ST = " 3.285957793498057344874164686873206738067743142840216191903487618" //  &
           "019941680979531742712197349882728018267551869210987929616034749064" //  &
           "30303538626114994902987549690732156800575304242342439460223044767290112M-53"
      CALL FMST2M(ST,C(109),QX)
      ST = " 1.095319264499347502683187139319325563979656486096742174653628128" //  &
           "976581637422575945930267442158932925061363256302618217044235776727" //  &
           "78289678865564842523041070219617158649346807209669750276034200426122137M-53"
      CALL FMST2M(ST,C(110),QX)
      ST = " 3.651064214997812644923454493506674835323388056021714399807493703" //  &
           "605967302048397979154313095594794645711111183057404193592791956678" //  &
           "66172552061879738476243285533776439739119193738969145723129786576511450M-54"
      CALL FMST2M(ST,C(111),QX)
      ST = " 1.217021404999267790636025855753778604335807084870166221152973014" //  &
           "506916159759972779875308117306931009803008009678064932776645093318" //  &
           "00842098229392080507684746488956996056988713932200497206909259105378943M-54"
      CALL FMST2M(ST,C(112),QX)
      ST = " 4.056738016664218241273938781923458650417321982457636718798922936" //  &
           "477302304740685369168107498238001936713766023175775737524892409160" //  &
           "01634272341340971077361157145530586562647498591786411480985240150120553M-55"
      CALL FMST2M(ST,C(113),QX)
      ST = " 1.352246005554737481879776083250264536787105289190169898749791140" //  &
           "348233188200740056915744202769004512689087720776827335229272164151" //  &
           "84364840446652924162659286494044457495071328336364564380197269062778195M-55"
      CALL FMST2M(ST,C(114),QX)
      ST = " 4.507486685182453443237078181203119239131669164992680684219261837" //  &
           "277644454396847551795676165306867658683702735066801164086167252711" //  &
           "19484010084871947031012001315393818015815520382515662702573278448350109M-56"
      CALL FMST2M(ST,C(115),QX)
      ST = " 1.502495561727483273655148872429157437910868921767186291387141573" //  &
           "512573119402964065902228084442655668385002115354783777594857713998" //  &
           "29523050153288241379342972449409357035473017504499197092941874010814147M-56"
      CALL FMST2M(ST,C(116),QX)
      ST = " 5.008318539091607893624136610372602345176507591543467689236137943" //  &
           "884673550591046086592830872513439140608629637038740043915787148541" //  &
           "52394870950686380101306680838055095132070888200259040353691065606620624M-57"
      CALL FMST2M(ST,C(117),QX)
      ST = " 1.669439513030535209901455630134076834170615280098683744729402670" //  &
           "296396657337808597037921736436660468249832659227172779367140247404" //  &
           "03362990043020714217884143429674645399729964793508983794394882884002423M-57"
      CALL FMST2M(ST,C(118),QX)
      ST = " 5.564798376768448813071710669353659573416270465590122350543315121" //  &
           "413388656111319238743752535035180158976403027283093627581775200347" //  &
           "08950549480561185545001882864566882001602568174009919346046996759045750M-58"
      CALL FMST2M(ST,C(119),QX)
      ST = " 1.854932792256149132707284865787646721627824417634136205769228907" //  &
           "351320889807301200265876310886504825399338639660085162561571671143" //  &
           "80178781198866361165024767169800779385647991333075996890986127709064413M-58"
      CALL FMST2M(ST,C(120),QX)
      ST = " 6.183109307520495929899402826852708229420151109621107470264900121" //  &
           "134345986789710812316854495785567736467232785746686941727193331941" //  &
           "56103871513252933011548432169303614875570158457053586066135942237566488M-59"
      CALL FMST2M(ST,C(121),QX)
      ST = " 2.061036435840165015185247594351604598673466050924812223481238383" //  &
           "744650549307488207514436927186243454249400309582767262472952477865" //  &
           "39488089477469737100729325446476505038057243548633416390135776998909246M-59"
      CALL FMST2M(ST,C(122),QX)
      ST = " 6.870121452800549313664441945028230766782586053733765495536930184" //  &
           "148735432170307184364193773249356218482192867580453706078982702322" //  &
           "36906147589341063176294087284637487815185909131173012735635871205970777M-60"
      CALL FMST2M(ST,C(123),QX)
      ST = " 2.290040484266849586983218139377689608197401631939278155837315152" //  &
           "749176998379162942186288612171254733497127165504629660957484257215" //  &
           "03960145633908464981886082313132803826782445898913850664341670496286810M-60"
      CALL FMST2M(ST,C(124),QX)
      ST = " 7.633468280889498162681737525654781395094610920374961079941892134" //  &
           "693686042107521045090976432509818240749828811152884417434183792443" //  &
           "40208045334338980097933050903816256868615301460865703415771912193724986M-61"
      CALL FMST2M(ST,C(125),QX)
      ST = " 2.544489426963165939078331773845571337558244149440634270398446661" //  &
           "730902552806699411443989280898922405978534154707887233634737588764" //  &
           "69277444899419995451128654151512085551424867809084295696469106990521519M-61"
      CALL FMST2M(ST,C(126),QX)
      ST = " 8.481631423210552842388820742776895367676872160158770358942482422" //  &
           "735183525513672190915958631633045631581296672220414159119266677730" //  &
           "00882790484855601476924199497856972658319507003728226425960873810966916M-62"
      CALL FMST2M(ST,C(127),QX)
      ST = " 2.827210474403517542161535621759888928745745898925998679999176972" //  &
           "500449767039313885942472306882332999282623012200216004408023722942" //  &
           "35548228163002484117039136830425719490113419540684925428659006215127579M-62"
      CALL FMST2M(ST,C(128),QX)
      ST = " 9.424034914678391627284940507974624769084040519392748443016620129" //  &
           "151493273032159506798645125157903918497199981418255987213825116544" //  &
           "91313520782402912277192097971388451766192404480480266469096595803740649M-63"
      CALL FMST2M(ST,C(129),QX)
      ST = " 3.141344971559463830781602278189827439570491126580879213267566098" //  &
           "634582653573961371388430476987677106802274861280003439184958337497" //  &
           "55871137194361985101053142410164165629409400589300651854575488722127625M-63"
      CALL FMST2M(ST,C(130),QX)
      ST = " 1.047114990519821265682189619947088028639202210810159318824710297" //  &
           "418144878455534152843738752328520535580617712220747998447348456148" //  &
           "87128390653434870273058245640426383654361423379776610643883264096972007M-63"
      CALL FMST2M(ST,C(131),QX)
      ST = " 3.490383301732737524161437551201638806706639111674055435356822668" //  &
           "242340068122359401431212212101510842260288841134358619348306937471" //  &
           "32292385947826289933592114188205257470612591292887863954967567373067619M-64"
      CALL FMST2M(ST,C(132),QX)
      ST = " 1.163461100577579167692347221578745581156399690416630219259420060" //  &
           "140471624651128200456995286998175955667309375958539555927592191244" //  &
           "69108542176232753118949875989033621399852815112398485508138602381100101M-64"
      CALL FMST2M(ST,C(133),QX)
      ST = " 3.878203668591930541404160833208709487069318555519787588536748926" //  &
           "079489227092349654317217820179356059640911818309293644987827038914" //  &
           "23113705652681321350172045452704473329699236304435049788227394174622197M-65"
      CALL FMST2M(ST,C(134),QX)
      ST = " 1.292734556197310176075471134722937741048543949863716607618949311" //  &
           "134596575499614268058353886586544618677755951138400973297684683800" //  &
           "49929217081801053935564115665217627139106390261578300958135297518693689M-65"
      CALL FMST2M(ST,C(135),QX)
      ST = " 4.309115187324367242603447591543502614635432074915146455974961100" //  &
           "783991800140039817841446475586229840527592677387439828807409996406" //  &
           "58572000140795436674747033557343891137764503605700790270107002153194098M-66"
      CALL FMST2M(ST,C(136),QX)
      ST = " 1.436371729108122411455785149464652955014483913555925454567566343" //  &
           "033751539926464502402671954114290440329353433043868042553216356430" //  &
           "95760927792248401840769385171665086466412488627981015154342470344616262M-66"
      CALL FMST2M(ST,C(137),QX)
      ST = " 4.787905763693741364655873712257673345968093702500400380413759009" //  &
           "343709671855218190105116076110599847270179980048633459127967075496" //  &
           "95329570740860986232312515609865359747150038120760918167660196395395859M-67"
      CALL FMST2M(ST,C(138),QX)
      ST = " 1.595968587897913786502772040929797311513936155534630802777161042" //  &
           "323085710283013809416229252137018873920387828320283701537288724338" //  &
           "18222527779868222288064331588809401461453186408435455724607829956650895M-67"
      CALL FMST2M(ST,C(139),QX)
      ST = " 5.319895292993045950719608811875781719400488218015940339624963833" //  &
           "904468790238424394665705538673163852924018058746539220799914498871" //  &
           "87123883979205073632821149986880853121193839902134978166092188353175974M-68"
      CALL FMST2M(ST,C(140),QX)
      ST = " 1.773298430997681982500795106152343395146291244985375992301024831" //  &
           "172880492620523208419431056495256021417076918908947764372774801634" //  &
           "66308162036559401365955897830840212263006984532789801526556111330540563M-68"
      CALL FMST2M(ST,C(141),QX)
      ST = " 5.910994769992273272321630775993113357374306776150164446878995429" //  &
           "199988365546454090281139320572057370171863201292260358152263114701" //  &
           "84849003352679924628129743645300899848128310062948455843231411729916686M-69"
      CALL FMST2M(ST,C(142),QX)
      ST = " 1.970331589997424423436955364217490328008758498727308342596972914" //  &
           "838317948717210312982993577885955575234727205227508863543462414701" //  &
           "19790327280248261234206607030131137515730415891713737174983639027604997M-69"
      CALL FMST2M(ST,C(143),QX)
      ST = " 6.567771966658081409780880644570952852212869394142774498275969597" //  &
           "051352302027804591436366292098249004955749719212407233759626410804" //  &
           "23094265521905707737671802871297906382006218125926665760693315871567840M-70"
      CALL FMST2M(ST,C(144),QX)
      ST = " 2.189257322219360469508050905240435788723932139126639198455650265" //  &
           "181880562634665346793855787464756222043343074562742957750457331886" //  &
           "51136835170527293161085727720893207671856322049649329515124067695351675M-70"
      CALL FMST2M(ST,C(145),QX)
      ST = " 7.297524407397868230646229744835872327874966073160276767231213689" //  &
           "623218792935837978230418401268856718201925396539510384196175753170" //  &
           "66652198429614667985969715027449338257278758408128943199367755324652975M-71"
      CALL FMST2M(ST,C(146),QX)
      ST = " 2.432508135799289409953591617661733991864335564333111377209692880" //  &
           "074976374750213242253051652321561734041852268969020358465621089424" //  &
           "14424996317706067303976880419998421002358404179645130678096779653358570M-71"
      CALL FMST2M(ST,C(147),QX)
      ST = " 8.108360452664298032524092931381732192579715420011362584102530122" //  &
           "399082594247638810857284958385615023239610775424662458807879174869" //  &
           "99208578767507795046313489342326234225642585624250987626962498888032182M-72"
      CALL FMST2M(ST,C(148),QX)
      ST = " 2.702786817554766010677727150378738299179197264006681328494022283" //  &
           "461713062938474709283827967021738008108993688482511856757752986924" //  &
           "83022205593730217582984347916302439090400201412445704126518051302925734M-72"
      CALL FMST2M(ST,C(149),QX)
      ST = " 9.009289391849220035183332673115118436689105231658609100131576105" //  &
           "746817524522178460300592879017536531814751063263253522537492214691" //  &
           "66287676119612980647194230638456363682773535596502263016913065096674627M-73"
      CALL FMST2M(ST,C(150),QX)
      ST = " 3.003096463949740011625527637203839580670438558448697439316922582" //  &
           "080500699241877972753395936644410394325148621157014967621235051277" //  &
           "19702357955843408402299203602763881244696185804277033716869763248333675M-73"
      CALL FMST2M(ST,C(151),QX)
      ST = " 1.001032154649913337182941137354579752756157403350587184082572655" //  &
           "668720365134577993101924383011283318540511319882434333492124758136" //  &
           "56328900549930706700593452010716708224185836746712866383541238461850333M-73"
      CALL FMST2M(ST,C(152),QX)
      ST = " 3.336773848833044457211857959630261241457227305512566083673355396" //  &
           "481818433800591390918626541367515865084768432579659244905807486980" //  &
           "29134378942434319177868848768173954755492210535184756504211022367766391M-74"
      CALL FMST2M(ST,C(153),QX)
      ST = " 1.112257949611014819054635753320402681213887420341206221531310860" //  &
           "985682956261502881389306545840511198169923612506852778221149565252" //  &
           "81459361368566900183720441504615495296290954141555036222396831117077406M-74"
      CALL FMST2M(ST,C(154),QX)
      ST = " 3.707526498703382730161873261392491115828186807291897198915909604" //  &
           "155674067990161834342683376529820781124868349247913942628339699553" //  &
           "19187594923162356418905498458595704597809148916916571510786341062302288M-75"
      CALL FMST2M(ST,C(155),QX)
      ST = " 1.235842166234460910044062971858447900664274034201950858925878124" //  &
           "083887957837752863211714821751135044697824600808010987957735653910" //  &
           "85021760966460551881259692413828184054079514253554146831394157759200228M-75"
      CALL FMST2M(ST,C(156),QX)
      ST = " 4.119473887448203032928247987246026060335598144698999438082486484" //  &
           "981872504026407021712061503540785866057593612250257886109051123261" //  &
           "20553540800492774307915913243657294990555992068366814198248544293239073M-76"
      CALL FMST2M(ST,C(157),QX)
      ST = " 1.373157962482734344300829830088785762819828470154677406792486349" //  &
           "582215434835624433211455183472833063222300779138846503724376654756" //  &
           "97153990917671843512951431419776274311910081550489091472125204982219742M-76"
      CALL FMST2M(ST,C(158),QX)
      ST = " 4.577193208275781160871184364111765898905714315410964770181334551" //  &
           "559734462338946414187167832153901075953527960902149729732952392999" //  &
           "05739092117020357910064590291184764747354548289282230511803212990314666M-77"
      CALL FMST2M(ST,C(159),QX)
      ST = " 1.525731069425260387008576333292791990843668717239246139931723054" //  &
           "113730949750810518714216058816633073359740920341684018573316882922" //  &
           "19161413294992398162552504179370639600545735768135221710078494678533369M-77"
      CALL FMST2M(ST,C(160),QX)
      ST = " 5.085770231417534313032798702697681197383439273915544588375043156" //  &
           "982436257501835267954582765438953697752001176322824202363456833480" //  &
           "84822237757173265524313083452491401792161623828870993995239601500752613M-78"
      CALL FMST2M(ST,C(161),QX)
      ST = " 1.695256743805844769784622112797766089615978935755501503220932068" //  &
           "343174291091693715417344263720144349029281513168498097220402832110" //  &
           "79996411923403065677514822313169241774858920814773828257766665033772313M-78"
      CALL FMST2M(ST,C(162),QX)
      ST = " 5.650855812686156039255381634430268704055968949073218709347085199" //  &
           "742155287063313738806948673339105867918184157411397848315417982770" //  &
           "28216209989585045629974649193921980908524940232212434747464651403766044M-79"
      CALL FMST2M(ST,C(163),QX)
      ST = " 1.883618604228718704942922337070948507896675501998486050379053659" //  &
           "203222058229334282486849245788565645787611354772468558241052640628" //  &
           "68090996198582244338892337657054683701568414292331480633193743238899042M-79"
      CALL FMST2M(ST,C(164),QX)
      ST = " 6.278728680762256512149009149976440283047018296660977205232840187" //  &
           "711671745561355189005624289121525977497317264018845068610009630166" //  &
           "24422122072055952477161863795374233113339410369040977100353306447007727M-80"
      CALL FMST2M(ST,C(165),QX)
      ST = " 2.092909560254085021920435547839978227290505174219696260063426880" //  &
           "879036670946017746113568504819405540190923727599189799888162522342" //  &
           "82688033004648088111864002916433340227047169032122354503266913856888244M-80"
      CALL FMST2M(ST,C(166),QX)
      ST = " 6.976365200849595928568515913272594158672772019779337814697530205" //  &
           "514328112647957246760099455857571687826289491085647676946101437355" //  &
           "54833971648944261391739603826369822509790583940615701556419202194043338M-81"
      CALL FMST2M(ST,C(167),QX)
      ST = " 2.325455066949873863606967397576505711197188840184692731505571050" //  &
           "057010126988203224760379663164013876837099897428308506101979830146" //  &
           "10509395537389044680077986544130564059305007513097257902320076380128891M-81"
      CALL FMST2M(ST,C(168),QX)
      ST = " 7.751516889786273230333744396009595784689618339833872888076148749" //  &
           "510954270591897268986918218161521302808459344904049745958883339834" //  &
           "97636368620176777364813719377132199681517454923842508307735464876551893M-82"
      CALL FMST2M(ST,C(169),QX)
      ST = " 2.583838963261950823751464199102541531987080961128181249653133059" //  &
           "486343391931814427787289188223115323267471180053604447425299309852" //  &
           "43333277896763688823725567334545875021894956285785557169534759498102028M-82"
      CALL FMST2M(ST,C(170),QX)
      ST = " 8.612796544966339593464148319279864385495846603731409332903857040" //  &
           "341111578596179250787433586544432993469429659882790724588244062567" //  &
           "78136790746398664694553035857800597304056454220060017665421505719967290M-83"
      CALL FMST2M(ST,C(171),QX)
      ST = " 2.870932181657563853682489496869596716118149568767000014172109841" //  &
           "753698478327036128411797178375480340579847035333592372289787795793" //  &
           "96627619330877369349750053557082939116418335842754914658257204585102926M-83"
      CALL FMST2M(ST,C(172),QX)
      ST = " 9.569773927459502329189843968932453842109493094807395751883972275" //  &
           "108106634425357758674379648287072224301747951696615265196165041805" //  &
           "20236585969398304163224702023392754793840706634155432621406698219669058M-84"
      CALL FMST2M(ST,C(173),QX)
      ST = " 3.189924642457193947274983048068918789864588583187967339730200869" //  &
           "383977309483707594218810831491599791827472770895338811393310795354" //  &
           "69234531929746996008196354596059905584934184315535092321474774208305020M-84"
      CALL FMST2M(ST,C(174),QX)
      ST = " 1.063308229833233763649833968823830359312501010885534593366422641" //  &
           "631138341936187529001129656673501820789940104427992740873815715203" //  &
           "53412492554104141309331928436306992144198744553482555692829414468432600M-84"
      CALL FMST2M(ST,C(175),QX)
      ST = " 3.544360766480896268661948406666249396818945618937640720661704673" //  &
           "296436347072454208561096669377429691244542539862734276732737789906" //  &
           "87985432036327462359694991859663225608649510569830536167392892074714882M-85"
      CALL FMST2M(ST,C(176),QX)
      ST = " 1.181453391991692193233905477505817491959791629667967979777058345" //  &
           "391387128260137859898575835696679473316746285686162580343604354886" //  &
           "33746615556680423641254628884245686047585862162458511355057706178924765M-85"
      CALL FMST2M(ST,C(177),QX)
      ST = " 3.938177969065104259816577437558454136986820863927184608342465808" //  &
           "644130213208017150749164656763736226904608349061342579349394401954" //  &
           "11955443745482049001748543874113465084785050139876732361231723529022225M-86"
      CALL FMST2M(ST,C(178),QX)
      ST = " 1.312728231460229835781775849221721497298632770454454059027673781" //  &
           "147657857867325372034109920647863595009065024284231880168892910826" //  &
           "53488283009582034319652319525792167583043745345137953029043134270740314M-86"
      CALL FMST2M(ST,C(179),QX)
      ST = " 4.375760815315077535413782421712416021566276398233684094737691912" //  &
           "768825492780444215747826165057411744207345952312538488710400858828" //  &
           "27700668026171627589196059317745967100234000846254430975531508363872519M-87"
      CALL FMST2M(ST,C(180),QX)
      ST = " 1.458563929048378339389356324275832391447007080182288931684002700" //  &
           "009472184445323295339567304943041273340490012950372985830518037286" //  &
           "27460201464773612755677066535469683435847032008950889605333804095236722M-87"
      CALL FMST2M(ST,C(181),QX)
      ST = " 4.861879359454319859107850617575234255777767433683221708284430699" //  &
           "990829575672698923326870227967687183467108336363217071248382357963" //  &
           "22818905179326628057052156616846776700350617514896748728636343647107755M-88"
      CALL FMST2M(ST,C(182),QX)
      ST = " 1.620837575639336717669585897558965566795189581102158562505695709" //  &
           "761058058214152430539033470517727442776271455644632399079159816470" //  &
           "13032790990474394168725899077889253682309738675257461400762111892656053M-88"
      CALL FMST2M(ST,C(183),QX)
      ST = " 5.402795219201229254205870902900594939962067229843983888917879564" //  &
           "569447106085277432976440651841249190437245953800537313805443864980" //  &
           "06342541344494885255739000367067646594242251182208803771724906930826406M-89"
      CALL FMST2M(ST,C(184),QX)
      ST = " 1.799216964519093606731219963783752545188788013842673930468641591" //  &
           "448479933065901726577672674840349510506058583228709079379586399536" //  &
           "92651555915483777543359909186871398885320260440340033124792023837781809M-89"
      CALL FMST2M(ST,C(185),QX)
      ST = " 5.997366309057088767075298231986828202847652039333576421385057338" //  &
           "145629178278871106675461140725723229061908016307033578803459780175" //  &
           "07666172639242691690123978056031089958911595034842389306632163036435150M-90"
      CALL FMST2M(ST,C(186),QX)
      ST = " 2.011301294926252140726390741032210138299321852132295904710257720" //  &
           "158209117243470457856408196331997445864262615242552875300814542975" //  &
           "47170830674630176097026011113551746496002275896336822879606882224230602M-90"
      CALL FMST2M(ST,C(187),QX)
      ST = " 6.704482593621562564692937104577317810644610039525202376129260569" //  &
           "861749723553513086341477081381278126242511169725032335903896422492" //  &
           "18854955408659222455853625926956312559220163444056344847372949727294762M-91"
      CALL FMST2M(ST,C(188),QX)
      ST = " 2.160351395289544486253226495324951606774126604957407637555483550" //  &
           "521132050784441566021695109519541771023447038718264653048827134039" //  &
           "73414393141529555898480576201941789130545638907969682039980597723815399M-91"
      CALL FMST2M(ST,C(189),QX)
      ST = " 7.200419569439204992397584876133276247439864059745857658513848169" //  &
           "634972230829808411159889094321665351721254003922021586700615812024" //  &
           "99355813646045295572813794504886619128172862586448322114482098387570581M-92"
      CALL FMST2M(ST,C(190),QX)
      ST = " 2.784319712626698759566047586489485590648301900234226820496273235" //  &
           "253278946132569789086775657480520424132403062835830911025372468898" //  &
           "94806632232823225075878972837000029411691959653897178979682691313860829M-92"
      CALL FMST2M(ST,C(191),QX)
      ST = " 9.284263699802481030477812401350944543556932743559221880685236144" //  &
           "608807942910647790463633201299242608070391986248492383364489375260" //  &
           "66506636257311455988821088223165685964257289358894735278070005979762986M-93"
      CALL FMST2M(ST,C(192),QX)
      ST = " 1.469128321729119845643781712942080844517377977136622326900618953" //  &
           "248797751416855621723808444613828590416570423767280724666117572301" //  &
           "34285990191248448522554726873193884488157002183510418398417800853692970M-93"
      CALL FMST2M(ST,C(193),QX)
      ST = " 4.886379978539319342120523930953291961277105452075509621364036950" //  &
           "981474984583217822110836621562995692449070713522036826314376565947" //  &
           "22694606242271109407828035720163781683675686187162678102051578537829111M-94"
      CALL FMST2M(ST,C(194),QX)
      ST = " 7.046670647920504479063475010556879295393094797174920722994400551" //  &
           "715505897095883223398696557122758497726817737906295249088240133320" //  &
           "85226292447629611992116676332110323776745430326383013890000067486498923M-94"
      CALL FMST2M(ST,C(195),QX)
      ST = " 2.351541158501990523752731749555092275030088173405523455954546630" //  &
           "113446321330723773662111826297238234224538212221014494477821368974" //  &
           "29678996883123994564079639022862654561283884722866834645277830050207084M-94"
      CALL FMST2M(ST,C(196),QX)

      QX%NDIG = NDSAVE

      END SUBROUTINE FMPSI_C

      SUBROUTINE FMWRN2(QX)

!  Called by one of the FM routines to print a warning message if any error condition arises
!  in that routine.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      CHARACTER(9) :: NAME
      TYPE(FM_SETTINGS) :: QX

      INTEGER :: NCS

      IF (QX%KFLAG >= 0 .OR. QX%NCALL /= 1 .OR. QX%KWARN <= 0) RETURN
      NCS = QX%NCALL
      NAME = QX%NAMEST(QX%NCALL)
      WRITE (KW,                                   &
             "(/' Error of type KFLAG =',I3,"  //  &
             "' in FM package in routine ',A/)"    &
            ) QX%KFLAG,TRIM(NAME)

  110 QX%NCALL = QX%NCALL - 1
      IF (QX%NCALL > 0) THEN
          NAME = QX%NAMEST(QX%NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (QX%KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (QX%KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (QX%KFLAG == -3) THEN
          WRITE (KW,                                                     &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (QX%KFLAG == -4 .OR. QX%KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (QX%KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (QX%KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (QX%KFLAG == -8) THEN
          WRITE (KW,                                                          &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (QX%KFLAG == -9) THEN
          WRITE (KW,                                                &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,                                        &
                 "(I23,' digits were requested (NDIG).'/)"  &
                ) QX%NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (QX%KFLAG == -10) THEN
          IF (QX%NAMEST(NCS) == 'FMM2SP') THEN
              WRITE (KW,                                                     &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to single precision.'/)"                      &
                    )
          ELSE
              WRITE (KW,                                                     &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to double precision.'/)"                      &
                    )
          ENDIF
          WRITE (KW,"(' Zero has been returned.'/)")
      ELSE IF (QX%KFLAG == -11) THEN
          WRITE (KW,"(' Array MBERN is not large enough.')")
      ELSE IF (QX%KFLAG == -12) THEN
          WRITE (KW,"(' Array MJSUMS is not large enough.')")
      ENDIF

      QX%NCALL = NCS
      IF (QX%KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE FMWRN2

!  These are the longer and more readable routine names, equivalent to the older names.

      SUBROUTINE FMATAN2(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMATN2(MA,MB,MC,QX)
      RETURN
      END SUBROUTINE FMATAN2

      SUBROUTINE FMCOSH_SINH(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMCHSH(MA,MB,MC,QX)
      RETURN
      END SUBROUTINE FMCOSH_SINH

      FUNCTION FMCOMPARE(MA,LREL,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: FMCOMPARE
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(*) :: LREL
      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      FMCOMPARE = FMCOMP(MA,LREL,MB,QX)
      RETURN
      END FUNCTION FMCOMPARE

      SUBROUTINE FMCOS_SIN(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMCSSN(MA,MB,MC,QX)
      RETURN
      END SUBROUTINE FMCOS_SIN

      SUBROUTINE FMEULER(MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEULR(MA,QX)
      RETURN
      END SUBROUTINE FMEULER

      SUBROUTINE FMFPRINT(FORM,MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMFPRT(FORM,MA,QX)
      RETURN
      END SUBROUTINE FMFPRINT

      SUBROUTINE FMIPOWER(MA,IVAL,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMIPWR(MA,IVAL,MB,QX)
      RETURN
      END SUBROUTINE FMIPOWER

      SUBROUTINE FMLOG10(MA,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMLG10(MA,MB,QX)
      RETURN
      END SUBROUTINE FMLOG10

      SUBROUTINE FMPRINT(MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMPRNT(MA,QX)
      RETURN
      END SUBROUTINE FMPRINT

      SUBROUTINE FMPOWER(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMPWR(MA,MB,MC,QX)
      RETURN
      END SUBROUTINE FMPOWER

      SUBROUTINE FMRATIONAL_POWER(MA,IVAL,JVAL,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL,JVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMRPWR(MA,IVAL,JVAL,MB,QX)
      RETURN
      END SUBROUTINE FMRATIONAL_POWER

      SUBROUTINE FMWRITE(KWRITE,MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMWRIT(KWRITE,MA,QX)
      RETURN
      END SUBROUTINE FMWRITE

      FUNCTION IMCOMPARE(MA,LREL,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: IMCOMPARE
      LOGICAL, EXTERNAL :: IMCOMP
      CHARACTER(*) :: LREL
      TYPE(MULTI) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IMCOMPARE = IMCOMP(MA,LREL,MB,QX)
      RETURN
      END FUNCTION IMCOMPARE

      SUBROUTINE IMFPRINT(FORM,MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMFPRT(FORM,MA,QX)
      RETURN
      END SUBROUTINE IMFPRINT

      SUBROUTINE IMMPY_MOD(MA,MB,MC,MD,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB,MC,MD
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPYM(MA,MB,MC,MD,QX)
      RETURN
      END SUBROUTINE IMMPY_MOD

      SUBROUTINE IMPOWER_MOD(MA,MB,MC,MD,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB,MC,MD
      TYPE(FM_SETTINGS) :: QX
      CALL IMPMOD(MA,MB,MC,MD,QX)
      RETURN
      END SUBROUTINE IMPOWER_MOD

      SUBROUTINE IMPRINT(MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMPRNT(MA,QX)
      RETURN
      END SUBROUTINE IMPRINT

      SUBROUTINE IMPOWER(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMPWR(MA,MB,MC,QX)
      RETURN
      END SUBROUTINE IMPOWER

      SUBROUTINE IMWRITE(KWRITE,MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      TYPE(MULTI) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMWRIT(KWRITE,MA,QX)
      RETURN
      END SUBROUTINE IMWRITE

      SUBROUTINE ZMCOSH_SINH(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCHSH(MA,MB,MC,QX)
      RETURN
      END SUBROUTINE ZMCOSH_SINH

      SUBROUTINE ZMCOMPLEX(MAFM,MBFM,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MAFM,MBFM,MC(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCMPX(MAFM,MBFM,MC,QX)
      RETURN
      END SUBROUTINE ZMCOMPLEX

      SUBROUTINE ZMCONJUGATE(MA,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2),MB(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCONJ(MA,MB,QX)
      RETURN
      END SUBROUTINE ZMCONJUGATE

      SUBROUTINE ZMCOS_SIN(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCSSN(MA,MB,MC,QX)
      RETURN
      END SUBROUTINE ZMCOS_SIN

      SUBROUTINE ZMFPRINT(FORM1,FORM2,MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM1,FORM2
      TYPE(MULTI) :: MA(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMFPRT(FORM1,FORM2,MA,QX)
      RETURN
      END SUBROUTINE ZMFPRINT

      SUBROUTINE ZMIPOWER(MA,IVAL,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2),MB(2)
      INTEGER :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMIPWR(MA,IVAL,MB,QX)
      RETURN
      END SUBROUTINE ZMIPOWER

      SUBROUTINE ZMLOG10(MA,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2),MB(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMLG10(MA,MB,QX)
      RETURN
      END SUBROUTINE ZMLOG10

      SUBROUTINE ZMPRINT(MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMPRNT(MA,QX)
      RETURN
      END SUBROUTINE ZMPRINT

      SUBROUTINE ZMPOWER(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2),MB(2),MC(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMPWR(MA,MB,MC,QX)
      RETURN
      END SUBROUTINE ZMPOWER

      SUBROUTINE ZMRATIONAL_POWER(MA,IVAL,JVAL,MB,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMRPWR(MA,IVAL,JVAL,MB,QX)
      RETURN
      END SUBROUTINE ZMRATIONAL_POWER

      SUBROUTINE ZMWRITE(KWRITE,MA,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      TYPE(MULTI) :: MA(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMWRIT(KWRITE,MA,QX)
      RETURN
      END SUBROUTINE ZMWRITE


!     FM exponential integral and related functions

!  Here is a list of the routines that are designed to be called by the user:


!  FMBESJ(N,MA,MB)      MB = J(N,MA)   Bessel function of the first kind.

!  FMBESY(N,MA,MB)      MB = Y(N,MA)   Bessel function of the second kind.

!  FMC(MA,MB)           MB = C(MA)     Fresnel Cosine Integral

!  FMCHI(MA,MB)         MB = Chi(MA)   Hyperbolic Cosine Integral

!  FMCI(MA,MB)          MB = Ci(MA)    Cosine Integral

!  FMEI(MA,MB)          MB = Ei(MA)    Exponential Integral

!  FMEN(N,MA,MB)        MB = E(N,MA)   Exponential Integral E_n

!  FMERF(MA,MB)         MB = Erf(MA)   Error function

!  FMERFC(MA,MB)        MB = Erfc(MA)  Complimentary Error function

!  FMERFCS(MA,MB)       MB = Erfc_Scaled(MA)  Scaled Complimentary Error function.

!  FMLERC(MA,MB)        MB = Ln(Erfc(MA))  Log Erfc

!  FMLI(MA,MB)          MB = Li(MA)    Logarithmic Integral

!  FMS(MA,MB)           MB = S(MA)     Fresnel Sine Integral

!  FMSHI(MA,MB)         MB = Shi(MA)   Hyperbolic Sine Integral

!  FMSI(MA,MB)          MB = Si(MA)    Sine Integral

!  For each of these routines there is also a version available for which the argument list is the
!  same but all FM numbers are in packed format.  The packed versions have the same names except
!  'FM' is replaced by 'FP' at the start of each name.

! --------------------------------------------------------------------------------------------------

      SUBROUTINE FMBESJ(N,MA,MB,QX)

!  MB = Bessel J(N,MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N
      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: CBIG,CKLOG,CRHS,DBIG,DKLOG,DRHS,ERR,X,XLOG
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS,FMDPLG
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KD,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE
      INTEGER :: NDGOAL,NDIG2,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY,N_ACC
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(17),MRETRY,MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX

      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. N >= 0 .AND. MA%MP(2) < -QX%NDIG) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMDIVI(MXY(1),2,MXY(3),QX)
          CALL FMIPWR(MXY(3),N,MXY(2),QX)
          CALL FMI2M(N,MXY(4),QX)
          CALL FMFACT(MXY(4),MXY(5),QX)
          CALL FMDIV(MXY(2),MXY(5),MXY(4),QX)
          CALL FMMPY(MXY(4),MXY(3),MXY(5),QX)
          CALL FMMPY(MXY(5),MXY(3),MXY(6),QX)
          CALL FMDIVI(MXY(6),N+1,MXY(5),QX)
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG+1 .AND.  &
              MXY(4)%MP(2) < QX%MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(10),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(4),MXY(8),MXY(6),QX)
              IF (MXY(6)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMSUB(MXY(6),MXY(7),MB,QX)
                  IF (MB%MP(2) >= QX%MEXPOV) THEN
                      IF (MXY(6)%MP(1) > 0) THEN
                          IF (MXY(7)%MP(1) > 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(7)%MP(1) < 0 .AND. QX%KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ELSE
                          IF (MXY(7)%MP(1) > 0 .AND. QX%KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(7)%MP(1) < 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMBESJ'
                  CALL FMNTRI(2,N,1,QX)
                  CALL FMNTR(2,MA,MA,1,0,QX)
                  CALL FMNTR(1,MB,MB,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (QX%NTRACE /= 0) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMBESJ'
          CALL FMNTRI(2,N,1,QX)
          QX%NCALL = QX%NCALL - 1
      ENDIF
      CALL FMENT2('FMBESJ   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      MXY(1)%MP(1) = 1
      NUMTRY = 0

!             Check for special cases.

  120 N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      IF (N < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12),QX)
          QX%KFLAG = -4
          GO TO 210
      ENDIF
      IF (MA%MP(3) == 0) THEN
          IF (N == 0) THEN
              CALL FMI2M(1,MXY(12),QX)
          ELSE
              CALL FMI2M(0,MXY(12),QX)
          ENDIF
          GO TO 210
      ENDIF
      IF (2*MXY(1)%MP(2) < -QX%NDIG-1) THEN
          CALL FMDIVI(MXY(1),2,MXY(12),QX)
          CALL FMIPWR(MXY(12),N,MXY(15),QX)
          CALL FMFCTI(N,MXY(14),QX)
          CALL FMDIV(MXY(15),MXY(14),MXY(12),QX)
          GO TO 190
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      NMETHD = 1
      CALL FMABS(MXY(1),MXY(15),QX)
      CKLOG = MXY(15)%MP(2)
      MXY(15)%MP(2) = 0
      CALL FMM2DP(MXY(15),XLOG,QX)
      XLOG = LOG(XLOG) + CKLOG*QX%DLOGMB

!             c(k) is the absolute value of the kth term of the convergent series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|c(k)|) < Log(|c(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      CRHS = N*(XLOG-QX%DLOGTW) - FMDPLG(DBLE(N+1),QX) - QX%NDIG*QX%DLOGMB - 20*QX%DLOGTN

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|d(k)|) < Log(|d(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      DRHS = N
      DRHS = MIN(0.0D0,LOG(ABS(4*DRHS*DRHS-1))-XLOG-3*QX%DLOGTW) - QX%NDIG*QX%DLOGMB - 20*QX%DLOGTN - 50

      CBIG = N*(XLOG-QX%DLOGTW) - FMDPLG(DBLE(N+1),QX)
      DBIG = 1
      K = 1
      DO J = 0, 50
         K = 2*K
         CKLOG = (2*K+N)*XLOG - (2*K+N)*QX%DLOGTW - FMDPLG(DBLE(K+1),QX) - FMDPLG(DBLE(N+K+1),QX)
         CBIG = MAX(CBIG,CKLOG)
         IF (CKLOG < CRHS) THEN
             NMETHD = 1
             CKLOG = MIN(0.0D0,N*XLOG - N*QX%DLOGTW - FMDPLG(DBLE(N+1),QX))
             IEXTRA = ((CBIG-CKLOG)/QX%DLOGMB + 3)*1.2 - 14/QX%ALOGMT
             QX%NDIG = QX%NDIG+MAX(0,IEXTRA)
             N_ACC = NINT(QX%NDIG*QX%ALOGM2)
             CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
             EXIT
         ENDIF
         KD = K/2
         IF (N-2*KD < 0) THEN
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5),QX) + FMDPLG(DBLE(2*KD-N+0.5),QX) -  &
                     2*KD*QX%DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1),QX)
         ELSE
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5),QX) - FMDPLG(DBLE(N-2*KD+0.5),QX) -  &
                     2*KD*QX%DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1),QX)
         ENDIF
         DBIG = MAX(DBIG,DKLOG)
         IF (DKLOG < DRHS) THEN
             NMETHD = 2
             IEXTRA = (DBIG/QX%DLOGMB + 3)*1.2 - 14/QX%ALOGMT
             QX%NDIG = QX%NDIG+MAX(0,IEXTRA)
             N_ACC = NINT(QX%NDIG*QX%ALOGM2)
             CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
             EXIT
         ENDIF
      ENDDO
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1 .AND. N <= 100) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-2)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      IF (NMETHD == 2) GO TO 160

!             Method 1.  Sum the convergent series.
!                        J(n,x) = Sum( (-1)^k (x/2)^(2k+n) / ( k! (n+k)! )

  130 CALL FMM2DP(MXY(1),X,QX)
      X = ABS(X)
      IF (QX%KFLAG == 0 .AND. X <= SQRT(HUGE(X))) THEN
          J2 = INT(0.63*SQRT(FMNTERMS(X*X/4,1,1,N,1,QX)) - 1)
      ELSE IF (MXY(1)%MP(2) < 0) THEN
          J2 = 2
      ELSE IF (MXY(1)%MP(2) > 0) THEN
          GO TO 160
      ENDIF
      J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))

!             MXY(1) is X
!             MXY(14) is X**2/4
!             MXY(15) is MXY(14)**J2
!             MXY(13) is the current term in the sum
!             MJSUMS holds the partial sums

      NDSAV1 = QX%NDIG
      CALL FMSQR(MXY(1),MXY(14),QX)
      CALL FMDIVI_R1(MXY(14),4,QX)
      CALL FMIPWR(MXY(14),J2,MXY(15),QX)
      CALL FMI2M(1,MXY(10),QX)
      CALL FMFCTI(N,MXY(11),QX)
      CALL FMDIV(MXY(10),MXY(11),MXY(13),QX)
      DO J = 1, J2
         NTERM = J
         CALL FMEQ(MXY(13),MJSUMS(J),QX)
         IF (J > 1) CALL FMCSDIVI_R1(MXY(13),J,QX)
         CALL FMCSDIVI_R1(MXY(13),N+J,QX)
      ENDDO

      NTERM = J2
      NDIG2 = QX%NDIG
  140 CALL FMCSMPY_R1(MXY(13),MXY(15),QX)
      QX%NDIG = NDIG2
      DO J = 1, J2
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(13),QX)
         IF (QX%KFLAG /= 0) THEN
             GO TO 150
         ELSE
             QX%NDIG = MAX(QX%NGRD22,NDSAV1-INT(MJSUMS(J)%MP(2)-MXY(13)%MP(2)))
             QX%NDIG = MIN(NDSAV1,QX%NDIG)
             NTERM = NTERM + 1
             CALL FMCSDIVI_R1(MXY(13),NTERM,QX)
             CALL FMCSDIVI_R1(MXY(13),N+NTERM,QX)
         ENDIF
      ENDDO
      GO TO 140

!             Put the J2 concurrent sums back together.

  150 QX%NDIG = NDSAV1
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(1),MXY(11),QX)
      MXY(14)%MP(1) = -1
      IF (MXY(11)%MP(1) > 0) THEN
          CALL FMEQ(MXY(11),MXY(16),QX)
          CALL FMI2M(0,MXY(17),QX)
      ELSE
          CALL FMEQ(MXY(11),MXY(17),QX)
          CALL FMI2M(0,MXY(16),QX)
      ENDIF
      CALL FMEQ(MXY(14),MXY(12),QX)
      DO J = 1, J2-1
         CALL FMMPY(MXY(12),MJSUMS(J+1),MXY(3),QX)
         IF (MXY(3)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(16),MXY(3),QX)
         ELSE
             CALL FMADD_R1(MXY(17),MXY(3),QX)
         ENDIF
         CALL FMMPY_R1(MXY(12),MXY(14),QX)
      ENDDO
      CALL FMADD(MXY(16),MXY(17),MJSUMS(1),QX)
      CALL FMCANCEL(MXY(16),MXY(17),MJSUMS(1),K,QX)
      N_ACC = N_ACC - K
      CALL FMCSDIVI(MXY(1),2,MXY(11),QX)
      CALL FMIPWR(MXY(11),N,MXY(12),QX)
      CALL FMMPY_R1(MXY(12),MJSUMS(1),QX)
      GO TO 190

!             Method 2.  Sum the asymptotic series.
!                        J(n,x) = Sqrt(2/(Pi*x)) * (Cos(c)*Sum(a(k)) - Sin(c)*Sum(b(k)))
!                        c = x - n*Pi/2 - Pi/4
!                        a(k) = (-1)^k * Gamma(2k+n+0.5) / ( (2x)^(2k) * (2k)! * Gamma(-2k+n+0.5) )
!                        b(k) = (-1)^k * Gamma(2k+n+1.5) /
!                               ( (2x)^(2k+1) * (2k+1)! * Gamma(-2k+n-0.5) )

!             MXY(1) is x
!             MXY(15) is the current term for the series
!             MXY(14) is 1/x^2
!             MXY(13) is MXY(14)^J2
!             MXY(12) is the sum of the a(k) series
!             MXY(11) is the sum of the b(k) series

  160 NDSAV1 = QX%NDIG
      CALL FMM2DP(MXY(1),X,QX)
      X = ABS(X)
      IF (QX%KFLAG == 0 .AND. X <= SQRT(HUGE(X))) THEN
          J2 = NINT(0.41*SQRT(FMNTERMS(2*X,2,1,N,0,QX)) + 0.02)
      ELSE IF (MXY(1)%MP(2) > 0) THEN
          J2 = 1
      ELSE IF (MXY(1)%MP(2) < 0) THEN
          GO TO 130
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))

!             Sum the A(k) series.

      CALL FMI2M(1,MXY(15),QX)
      CALL FMSQR(MXY(1),MXY(14),QX)
      CALL FMDIV_R2(MXY(15),MXY(14),QX)
      CALL FMIPWR(MXY(14),J2,MXY(13),QX)
      LARGE = SQRT(MXBASE+1.0D-3)
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(15),MJSUMS(J),QX)
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMCSMPYI_R1(MXY(15),1+4*NTERM-2*N,QX)
             CALL FMCSMPYI_R1(MXY(15),3+4*NTERM-2*N,QX)
             CALL FMCSMPYI_R1(MXY(15),1+4*NTERM+2*N,QX)
             CALL FMCSMPYI_R1(MXY(15),3+4*NTERM+2*N,QX)
             CALL FMCSDIVI_R1(MXY(15),-128,QX)
             CALL FMCSDIVI_R1(MXY(15),1+NTERM,QX)
             CALL FMCSDIVI_R1(MXY(15),1+2*NTERM,QX)
         ELSE
             CALL FMCSMPYI_R1(MXY(15),(1+4*NTERM-2*N)*(3+4*NTERM-2*N),QX)
             CALL FMCSMPYI_R1(MXY(15),(1+4*NTERM+2*N)*(3+4*NTERM+2*N),QX)
             CALL FMCSDIVI_R1(MXY(15),-128,QX)
             CALL FMCSDIVI_R1(MXY(15),(1+NTERM)*(1+2*NTERM),QX)
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMCSMPY_R1(MXY(15),MXY(13),QX)
         DO J = 1, J2
            QX%NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(15),QX)
            IF (QX%KFLAG /= 0) GO TO 170
            QX%NDIG = MAX(QX%NGRD22,NDSAV1-INT(MJSUMS(J)%MP(2)-MXY(15)%MP(2)))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMCSMPYI_R1(MXY(15),1+4*NTERM-2*N,QX)
                CALL FMCSMPYI_R1(MXY(15),3+4*NTERM-2*N,QX)
                CALL FMCSMPYI_R1(MXY(15),1+4*NTERM+2*N,QX)
                CALL FMCSMPYI_R1(MXY(15),3+4*NTERM+2*N,QX)
                CALL FMCSDIVI_R1(MXY(15),-128,QX)
                CALL FMCSDIVI_R1(MXY(15),1+NTERM,QX)
                CALL FMCSDIVI_R1(MXY(15),1+2*NTERM,QX)
            ELSE
                CALL FMCSMPYI_R1(MXY(15),(1+4*NTERM-2*N)*(3+4*NTERM-2*N),QX)
                CALL FMCSMPYI_R1(MXY(15),(1+4*NTERM+2*N)*(3+4*NTERM+2*N),QX)
                CALL FMCSDIVI_R1(MXY(15),-128,QX)
                CALL FMCSDIVI_R1(MXY(15),(1+NTERM)*(1+2*NTERM),QX)
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  170 QX%NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(11),QX)
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(11),MXY(14),QX)
             CALL FMADD_R1(MXY(11),MJSUMS(J),QX)
          ENDDO
          CALL FMEQ(MXY(11),MXY(12),QX)
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(12),QX)
      ENDIF

!             Sum the B(k) series.

      QX%NDIG = NDSAV1
      IF (N < LARGE) THEN
          CALL FMI2M(4*N*N-1,MXY(15),QX)
      ELSE
          CALL FMI2M(N,MXY(15),QX)
          CALL FMSQR_R1(MXY(15),QX)
          CALL FMMPYI_R1(MXY(15),4,QX)
          CALL FMADDI(MXY(15),-1,QX)
      ENDIF
      CALL FMCSDIVI_R1(MXY(15),8,QX)
      CALL FMDIV_R1(MXY(15),MXY(1),QX)
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(15),MJSUMS(J),QX)
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMCSMPYI_R1(MXY(15),3+4*NTERM-2*N,QX)
             CALL FMCSMPYI_R1(MXY(15),5+4*NTERM-2*N,QX)
             CALL FMCSMPYI_R1(MXY(15),3+4*NTERM+2*N,QX)
             CALL FMCSMPYI_R1(MXY(15),5+4*NTERM+2*N,QX)
             CALL FMCSDIVI_R1(MXY(15),-128,QX)
             CALL FMCSDIVI_R1(MXY(15),1+NTERM,QX)
             CALL FMCSDIVI_R1(MXY(15),3+2*NTERM,QX)
         ELSE
             CALL FMCSMPYI_R1(MXY(15),(3+4*NTERM-2*N)*(5+4*NTERM-2*N),QX)
             CALL FMCSMPYI_R1(MXY(15),(3+4*NTERM+2*N)*(5+4*NTERM+2*N),QX)
             CALL FMCSDIVI_R1(MXY(15),-128,QX)
             CALL FMCSDIVI_R1(MXY(15),(1+NTERM)*(3+2*NTERM),QX)
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMCSMPY_R1(MXY(15),MXY(13),QX)
         DO J = 1, J2
            QX%NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(15),QX)
            IF (QX%KFLAG /= 0) GO TO 180
            QX%NDIG = MAX(QX%NGRD22,NDSAV1-INT(MJSUMS(J)%MP(2)-MXY(15)%MP(2)))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMCSMPYI_R1(MXY(15),3+4*NTERM-2*N,QX)
                CALL FMCSMPYI_R1(MXY(15),5+4*NTERM-2*N,QX)
                CALL FMCSMPYI_R1(MXY(15),3+4*NTERM+2*N,QX)
                CALL FMCSMPYI_R1(MXY(15),5+4*NTERM+2*N,QX)
                CALL FMCSDIVI_R1(MXY(15),-128,QX)
                CALL FMCSDIVI_R1(MXY(15),1+NTERM,QX)
                CALL FMCSDIVI_R1(MXY(15),3+2*NTERM,QX)
            ELSE
                CALL FMCSMPYI_R1(MXY(15),(3+4*NTERM-2*N)*(5+4*NTERM-2*N),QX)
                CALL FMCSMPYI_R1(MXY(15),(3+4*NTERM+2*N)*(5+4*NTERM+2*N),QX)
                CALL FMCSDIVI_R1(MXY(15),-128,QX)
                CALL FMCSDIVI_R1(MXY(15),(1+NTERM)*(3+2*NTERM),QX)
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  180 QX%NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(11),QX)
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(11),MXY(14),QX)
             CALL FMADD_R1(MXY(11),MJSUMS(J),QX)
          ENDDO
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(11),QX)
      ENDIF

!             To minimize cancellation error for very large x, with c = x - n*Pi/2 - Pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*Pi/2) + sin(n*Pi/2)
!             k2 = cos(n*Pi/2) - sin(n*Pi/2)
!             This is equivalent to
!             Mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      KRSAVE = QX%KRAD
      QX%KRAD = 1
      CALL FMCSSN(MXY(1),MXY(7),MXY(8),QX)
      QX%KRAD = KRSAVE
      K = MOD(N,4)
      IF (K == 0) THEN
          CALL FMADD(MXY(8),MXY(7),MXY(9),QX)
          CALL FMSUB(MXY(8),MXY(7),MXY(10),QX)
      ELSE IF (K == 1) THEN
          CALL FMSUB(MXY(8),MXY(7),MXY(9),QX)
          CALL FMADD(MXY(8),MXY(7),MXY(10),QX)
          CALL FMMPYI_R1(MXY(10),-1,QX)
      ELSE IF (K == 2) THEN
          CALL FMADD(MXY(8),MXY(7),MXY(9),QX)
          CALL FMMPYI_R1(MXY(9),-1,QX)
          CALL FMSUB(MXY(7),MXY(8),MXY(10),QX)
      ELSE
          CALL FMSUB(MXY(7),MXY(8),MXY(9),QX)
          CALL FMADD(MXY(8),MXY(7),MXY(10),QX)
      ENDIF
      CALL FMI2M(2,MXY(5),QX)
      CALL FMSQRT(MXY(5),MXY(6),QX)
      CALL FMDIV(MXY(9),MXY(6),MXY(7),QX)
      CALL FMDIV(MXY(10),MXY(6),MXY(8),QX)

      CALL FMMPY_R2(MXY(7),MXY(12),QX)
      CALL FMMPY_R2(MXY(8),MXY(11),QX)
      CALL FMSUB(MXY(12),MXY(11),MXY(9),QX)
      CALL FMPI(MXY(10),QX)
      CALL FMMPY(MXY(10),MXY(1),MXY(8),QX)
      CALL FMI2M(2,MXY(7),QX)
      CALL FMDIV(MXY(7),MXY(8),MXY(6),QX)
      CALL FMSQRT(MXY(6),MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(9),MXY(12),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(12)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(12)%MP(J+1)) GO TO 200
              ENDDO
              GO TO 210
          ENDIF
  200     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          IF (N >= 1000) IEXTRA = MAX(QX%NDIG/2,IEXTRA)
          NDOLD = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+IEXTRA,QX%NDIG+QX%NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQ(MXY(1),MXY(15),QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(12),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  210 IF (MA%MP(1) == -1) THEN
          IF (MOD(N,2) == 1 .AND. MXY(12)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(12)%MP(3) /= 0) THEN
              MXY(12)%MP(1) = -MXY(12)%MP(1)
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(12),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMBESJ

      SUBROUTINE FMBESJ2(N1,N2,X,ARRAY,QX)

!  ARRAY = (/  J(n1,x) , ..., J(n2,x)  /)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: J,K,N,N1,N2,NDSAVE
      TYPE(MULTI) :: ARRAY(ABS(N2-N1)+1),X
      INTENT (IN) :: N1,N2,X
      INTENT (INOUT) :: ARRAY
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX

      N = ABS(N2-N1) + 1
      DO J = 1, N
      ENDDO
      NDSAVE = QX%NDIG

      IF (N1 < 0 .OR. N2 < 0) THEN
          DO J = 1, SIZE(ARRAY)
             CALL FMST2M('UNKNOWN',ARRAY(J),QX)
          ENDDO
          RETURN
      ENDIF

!             The last two entries in the array are done with calls to FMBESJ.
!             The rest use this recurrence:

!             J(k-1,x) = 2*k*J(k,x) / x  -  J(k+1,x)

      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL FMEQU(X,MXY(1),NDSAVE,QX%NDIG,QX)
      K = MAX(N1,N2)
      CALL FMBESJ(K,MXY(1),MXY(4),QX)
      CALL FMEQU(MXY(4),ARRAY(N),QX%NDIG,NDSAVE,QX)
      IF (N <= 1) GO TO 110
      CALL FMBESJ(K-1,MXY(1),MXY(3),QX)
      CALL FMEQU(MXY(3),ARRAY(N-1),QX%NDIG,NDSAVE,QX)
      IF (N <= 2) GO TO 110

      DO J = K-2, MIN(N1,N2), -1
         CALL FMMPYI(MXY(3),2*(J+1),MXY(2),QX)
         CALL FMDIV_R1(MXY(2),MXY(1),QX)
         CALL FMSUB_R1(MXY(2),MXY(4),QX)
         CALL FMEQU(MXY(2),ARRAY(J-MIN(N1,N2)+1),QX%NDIG,NDSAVE,QX)
         IF (J == MIN(N1,N2)) EXIT
         CALL FMEQ(MXY(3),MXY(4),QX)
         CALL FMEQ(MXY(2),MXY(3),QX)
      ENDDO

!             Reverse the list if N2 < N1.

      IF (N2 < N1) THEN
          QX%NDIG = NDSAVE
          DO J = 1, N/2
             CALL FMEQ(ARRAY(J),MXY(4),QX)
             CALL FMEQ(ARRAY(N+1-J),ARRAY(J),QX)
             CALL FMEQ(MXY(4),ARRAY(N+1-J),QX)
          ENDDO
      ENDIF

  110 QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE FMBESJ2

      SUBROUTINE FMBESY(N,MA,MB,QX)

!  MB = Bessel Y(N,MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: N
      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: CBIG,CKLOG,CRHS,DBIG,DKLOG,DRHS,ERR,X,XLOG
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS,FMDPLG
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KD,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NDGOAL,  &
                 NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY,N_ACC
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(17),MRETRY,MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      IF (QX%NTRACE /= 0) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMBESY'
          CALL FMNTRI(2,N,1,QX)
          QX%NCALL = QX%NCALL - 1
      ENDIF
      CALL FMENT2('FMBESY   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      MXY(1)%MP(1) = 1
      NUMTRY = 0

!             Check for special cases.

  120 IF (N < 0 .OR. MA%MP(3) == 0 .OR. MA%MP(1) == -1) THEN
          CALL FMST2M('UNKNOWN',MXY(9),QX)
          QX%KFLAG = -4
          GO TO 220
      ENDIF
      IF (N < 2 .AND. MA%MP(2) == QX%MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(9),QX)
          QX%KFLAG = -4
          GO TO 220
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      NMETHD = 1
      CALL FMABS(MXY(1),MXY(12),QX)
      CKLOG = MXY(12)%MP(2)
      MXY(12)%MP(2) = 0
      CALL FMM2DP(MXY(12),XLOG,QX)
      XLOG = LOG(XLOG) + CKLOG*QX%DLOGMB

!             c(k) is the absolute value of the kth term of the convergent series.  The psi terms
!                  grow logarithmically, so they are ignored for this estimate.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|c(k)|) < Log(|c(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      CRHS = N*(XLOG-QX%DLOGTW) - FMDPLG(DBLE(N+1),QX) - QX%NDIG*QX%DLOGMB - 20*QX%DLOGTN

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|d(k)|) < Log(|d(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      DRHS = N
      DRHS = MIN(0.0D0,LOG(ABS(4*DRHS*DRHS-1))-XLOG-3*QX%DLOGTW) - QX%NDIG*QX%DLOGMB - 20*QX%DLOGTN - 50

      CBIG = N*(XLOG-QX%DLOGTW) - FMDPLG(DBLE(N+1),QX)
      DBIG = 1
      K = 1
      DO J = 0, 50
         K = 2*K
         CKLOG = (2*K+N)*XLOG - (2*K+N)*QX%DLOGTW - FMDPLG(DBLE(K+1),QX) - FMDPLG(DBLE(N+K+1),QX)
         CBIG = MAX(CBIG,CKLOG)
         IF (CKLOG < CRHS) THEN
             NMETHD = 1
             CKLOG = MIN(0.0D0,N*XLOG - N*QX%DLOGTW - FMDPLG(DBLE(N+1),QX))
             IEXTRA = ((CBIG-CKLOG)/QX%DLOGMB + 3)*1.2 - 14/QX%ALOGMT
             QX%NDIG = QX%NDIG+MAX(0,IEXTRA)
             N_ACC = NINT(QX%NDIG*QX%ALOGM2)
             CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
             EXIT
         ENDIF
         KD = K
         IF (N-2*KD < 0) THEN
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5),QX) + FMDPLG(DBLE(2*KD-N+0.5),QX) -  &
                     2*KD*QX%DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1),QX)
         ELSE
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5),QX) - FMDPLG(DBLE(N-2*KD+0.5),QX) -  &
                     2*KD*QX%DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1),QX)
         ENDIF
         DBIG = MAX(DBIG,DKLOG)
         IF (DKLOG < DRHS) THEN
             NMETHD = 2
             IEXTRA = (DBIG/QX%DLOGMB + 3)*1.2 - 14/QX%ALOGMT
             QX%NDIG = QX%NDIG+MAX(0,IEXTRA)
             N_ACC = NINT(QX%NDIG*QX%ALOGM2)
             CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
             EXIT
         ENDIF
      ENDDO
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-2)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      IF (NMETHD == 2) GO TO 170

!             Method 1.  Sum the convergent series.
!                        Y(n,x) = (-1/pi)*
!                        Sum( (-1)^k (psi(k+1) + psi(n+k+1)) (x/2)^(2k+n) / ( k! (n+k)! )
!                        - (1/pi)*Sum( (n-k-1)! (x/2)^(2k-n) / k! ) + (2/pi)*ln(x/2)*J(n,x)

!                        The first sum above (involving psi) runs from k=0 to infinity, but the
!                        second sum is finite, for k=0 to k=n-1.

  130 CALL FMM2DP(MXY(1),X,QX)
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Sum( (-1)^k (psi(k+1) + psi(n+k+1)) (x/2)^(2k+n) / ( k! (n+k)! )

!             MXY(1) is X
!             MXY(11) is -X**2/4
!             MXY(13) is psi(k+1)
!             MXY(14) is psi(n+k+1)
!             MXY(10) is the current value of (-1)^k (x/2)^(2k+n) / ( k! (n+k)! )
!             MXY(12) holds the partial sum

      NDSAV1 = QX%NDIG
      CALL FMEULR(MXY(13),QX)
      MXY(13)%MP(1) = -1
      IF (N < 5000) THEN
          CALL FMEQ(MXY(13),MXY(14),QX)
          IF (N > 0) THEN
              CALL FMI2M(1,MXY(7),QX)
              DO J = 1, N
                 CALL FMCSDIVI(MXY(7),J,MXY(8),QX)
                 CALL FMADD_R1(MXY(14),MXY(8),QX)
              ENDDO
          ENDIF
      ELSE
          CALL FMI2M(N+1,MXY(12),QX)
          CALL FMPSI(MXY(12),MXY(14),QX)
      ENDIF
      CALL FMCSDIVI(MXY(1),2,MXY(8),QX)
      CALL FMIPWR(MXY(8),N,MXY(9),QX)
      CALL FMSQR(MXY(1),MXY(11),QX)
      CALL FMCSDIVI_R1(MXY(11),4,QX)
      MXY(11)%MP(1) = -1
      CALL FMI2M(1,MXY(7),QX)
      CALL FMFCTI(N,MXY(8),QX)
      CALL FMADD(MXY(13),MXY(14),MXY(6),QX)
      CALL FMDIV(MXY(6),MXY(8),MXY(2),QX)
      CALL FMMPY(MXY(2),MXY(9),MXY(3),QX)
      CALL FMEQ(MXY(3),MXY(12),QX)
      IF (MXY(12)%MP(1) > 0) THEN
          CALL FMEQ(MXY(12),MXY(16),QX)
          CALL FMI2M(0,MXY(17),QX)
      ELSE
          CALL FMEQ(MXY(12),MXY(17),QX)
          CALL FMI2M(0,MXY(16),QX)
      ENDIF
      IF (MXY(3)%MP(2) <= QX%MEXPUN) THEN
          CALL FMEQ(MXY(3),MXY(9),QX)
          IF (MXY(9)%MP(2) /= QX%MUNKNO) MXY(9)%MP(1) = -MXY(9)%MP(1)
          IF (MXY(9)%MP(1) > 0) THEN
              CALL FMEQ(MXY(9),MXY(16),QX)
              CALL FMI2M(0,MXY(17),QX)
          ELSE
              CALL FMADD_R1(MXY(9),MXY(17),QX)
              CALL FMI2M(0,MXY(16),QX)
          ENDIF
          GO TO 140
      ENDIF
      IF (MXY(1)%MP(2) < -QX%NDIG) THEN
          CALL FMPI(MXY(6),QX)
          MXY(6)%MP(1) = -1
          CALL FMDIV(MXY(3),MXY(6),MXY(9),QX)
          IF (MXY(9)%MP(1) > 0) THEN
              CALL FMEQ(MXY(9),MXY(16),QX)
              CALL FMI2M(0,MXY(17),QX)
          ELSE
              CALL FMADD_R1(MXY(9),MXY(17),QX)
              CALL FMI2M(0,MXY(16),QX)
          ENDIF
          GO TO 140
      ENDIF
      CALL FMDIV(MXY(9),MXY(8),MXY(10),QX)
      CALL FMI2M(1,MXY(4),QX)

      DO K = 1, 10**8
         CALL FMMPY_R1(MXY(10),MXY(11),QX)
         CALL FMDIVI_R1(MXY(10),K,QX)
         CALL FMDIVI_R1(MXY(10),N+K,QX)
         CALL FMDIVI(MXY(4),K,MXY(3),QX)
         CALL FMADD_R1(MXY(13),MXY(3),QX)
         CALL FMDIVI(MXY(4),N+K,MXY(3),QX)
         CALL FMADD_R1(MXY(14),MXY(3),QX)
         CALL FMADD(MXY(13),MXY(14),MXY(3),QX)
         CALL FMMPY_R1(MXY(3),MXY(10),QX)
         IF (MXY(3)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(16),MXY(3),QX)
         ELSE
             CALL FMADD_R1(MXY(17),MXY(3),QX)
         ENDIF
         CALL FMADD_R1(MXY(12),MXY(3),QX)
         IF (QX%KFLAG /= 0) EXIT
      ENDDO
      CALL FMPI(MXY(6),QX)
      MXY(6)%MP(1) = -1
      CALL FMDIV_R1(MXY(12),MXY(6),QX)
      CALL FMDIV_R1(MXY(16),MXY(6),QX)
      CALL FMDIV_R1(MXY(17),MXY(6),QX)

!             Sum( (n-k-1)! (x/2)^(2k-n) / k! )

  140 IF (N > 0) THEN
          MXY(11)%MP(1) = 1
          CALL FMCSDIVI(MXY(1),2,MXY(6),QX)
          CALL FMIPWR(MXY(6),-N,MXY(7),QX)
          CALL FMFCTI(N-1,MXY(6),QX)
          CALL FMCSMPY_R1(MXY(7),MXY(6),QX)
          CALL FMEQ(MXY(7),MXY(8),QX)
          IF (MXY(8)%MP(2) == QX%MEXPOV) THEN
              MXY(8)%MP(1) = -1
              GO TO 150
          ENDIF
          DO J = 1, N-1
             CALL FMCSMPY_R1(MXY(7),MXY(11),QX)
             CALL FMCSDIVI_R1(MXY(7),N-J,QX)
             CALL FMCSDIVI_R1(MXY(7),J,QX)
             CALL FMADD_R1(MXY(8),MXY(7),QX)
          ENDDO
          CALL FMPI(MXY(6),QX)
          MXY(6)%MP(1) = -1
          CALL FMDIV_R1(MXY(8),MXY(6),QX)

  150     IF (MXY(8)%MP(1) > 0) THEN
              CALL FMADD_R1(MXY(16),MXY(8),QX)
          ELSE
              CALL FMADD_R1(MXY(17),MXY(8),QX)
          ENDIF
      ENDIF

!             Add the J(n,x) term.

      CALL FMBESJ(N,MXY(1),MXY(15),QX)
      IF (MXY(15)%MP(2) == QX%MEXPUN) THEN
          MXY(15)%MP(1) = -1
          GO TO 160
      ENDIF
      CALL FMCSDIVI(MXY(1),2,MXY(6),QX)
      CALL FMLN(MXY(6),MXY(7),QX)
      CALL FMMPY(MXY(15),MXY(7),MXY(8),QX)
      CALL FMPI(MXY(6),QX)
      CALL FMDIV_R1(MXY(8),MXY(6),QX)
      CALL FMCSMPYI(MXY(8),2,MXY(15),QX)

  160 IF (MXY(15)%MP(1) > 0) THEN
          CALL FMADD_R1(MXY(16),MXY(15),QX)
      ELSE
          CALL FMADD_R1(MXY(17),MXY(15),QX)
      ENDIF
      CALL FMADD(MXY(16),MXY(17),MXY(9),QX)
      CALL FMCANCEL(MXY(16),MXY(17),MXY(9),K,QX)
      N_ACC = N_ACC - K
      GO TO 200

!             Method 2.  Sum the asymptotic series.
!                        Y(n,x) = Sqrt(2/(Pi*x))*(Sin(c)*Sum(a(k)) + Cos(c)*Sum(b(k)))
!                        c = x - n*Pi/2 - Pi/4
!                        a(k) = (-1)^k * Gamma(2k+n+0.5) / ( (2x)^(2k) * (2k)! * Gamma(-2k+n+0.5) )
!                        b(k) = (-1)^k * Gamma(2k+n+1.5) /
!                               ( (2x)^(2k+1) * (2k+1)! * Gamma(-2k+n-0.5) )

!             MXY(1) is x
!             MXY(12) is the current term for the series
!             MXY(11) is 1/x^2
!             MXY(10) is MXY(11)^J2
!             MXY(9) is the sum of the a(k) series
!             MXY(8) is the sum of the b(k) series

  170 NDSAV1 = QX%NDIG
      CALL FMM2DP(MXY(1),X,QX)
      X = ABS(X)
      IF (QX%KFLAG == 0 .AND. X <= SQRT(HUGE(X))) THEN
          J2 = NINT(0.41*SQRT(FMNTERMS(2*X,2,1,N,0,QX)) + 0.02)
      ELSE IF (MXY(1)%MP(2) > 0) THEN
          J2 = 1
      ELSE IF (MXY(1)%MP(2) < 0) THEN
          GO TO 130
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))

!             Sum the A(k) series.

      CALL FMI2M(1,MXY(12),QX)
      CALL FMSQR(MXY(1),MXY(11),QX)
      CALL FMDIV_R2(MXY(12),MXY(11),QX)
      CALL FMIPWR(MXY(11),J2,MXY(10),QX)
      LARGE = SQRT(MXBASE+1.0D-3)
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(12),MJSUMS(J),QX)
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMCSMPYI_R1(MXY(12),1+4*NTERM-2*N,QX)
             CALL FMCSMPYI_R1(MXY(12),3+4*NTERM-2*N,QX)
             CALL FMCSMPYI_R1(MXY(12),1+4*NTERM+2*N,QX)
             CALL FMCSMPYI_R1(MXY(12),3+4*NTERM+2*N,QX)
             CALL FMCSDIVI_R1(MXY(12),-128,QX)
             CALL FMCSDIVI_R1(MXY(12),1+NTERM,QX)
             CALL FMCSDIVI_R1(MXY(12),1+2*NTERM,QX)
         ELSE
             CALL FMCSMPYI_R1(MXY(12),(1+4*NTERM-2*N)*(3+4*NTERM-2*N),QX)
             CALL FMCSMPYI_R1(MXY(12),(1+4*NTERM+2*N)*(3+4*NTERM+2*N),QX)
             CALL FMCSDIVI_R1(MXY(12),-128,QX)
             CALL FMCSDIVI_R1(MXY(12),(1+NTERM)*(1+2*NTERM),QX)
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMCSMPY_R1(MXY(12),MXY(10),QX)
         DO J = 1, J2
            QX%NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(12),QX)
            IF (QX%KFLAG /= 0) GO TO 180
            QX%NDIG = MAX(QX%NGRD22,NDSAV1-INT(MJSUMS(J)%MP(2)-MXY(12)%MP(2)))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMCSMPYI_R1(MXY(12),1+4*NTERM-2*N,QX)
                CALL FMCSMPYI_R1(MXY(12),3+4*NTERM-2*N,QX)
                CALL FMCSMPYI_R1(MXY(12),1+4*NTERM+2*N,QX)
                CALL FMCSMPYI_R1(MXY(12),3+4*NTERM+2*N,QX)
                CALL FMCSDIVI_R1(MXY(12),-128,QX)
                CALL FMCSDIVI_R1(MXY(12),1+NTERM,QX)
                CALL FMCSDIVI_R1(MXY(12),1+2*NTERM,QX)
            ELSE
                CALL FMCSMPYI_R1(MXY(12),(1+4*NTERM-2*N)*(3+4*NTERM-2*N),QX)
                CALL FMCSMPYI_R1(MXY(12),(1+4*NTERM+2*N)*(3+4*NTERM+2*N),QX)
                CALL FMCSDIVI_R1(MXY(12),-128,QX)
                CALL FMCSDIVI_R1(MXY(12),(1+NTERM)*(1+2*NTERM),QX)
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  180 QX%NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(8),QX)
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(8),MXY(11),QX)
             CALL FMADD_R1(MXY(8),MJSUMS(J),QX)
          ENDDO
          CALL FMEQ(MXY(8),MXY(9),QX)
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(9),QX)
      ENDIF

!             Sum the B(k) series.

      QX%NDIG = NDSAV1
      IF (N < LARGE) THEN
          CALL FMI2M(4*N*N-1,MXY(12),QX)
      ELSE
          CALL FMI2M(N,MXY(12),QX)
          CALL FMSQR_R1(MXY(12),QX)
          CALL FMCSMPYI_R1(MXY(12),4,QX)
          CALL FMADDI(MXY(12),-1,QX)
      ENDIF
      CALL FMCSDIVI_R1(MXY(12),8,QX)
      CALL FMDIV_R1(MXY(12),MXY(1),QX)
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(12),MJSUMS(J),QX)
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMCSMPYI_R1(MXY(12),3+4*NTERM-2*N,QX)
             CALL FMCSMPYI_R1(MXY(12),5+4*NTERM-2*N,QX)
             CALL FMCSMPYI_R1(MXY(12),3+4*NTERM+2*N,QX)
             CALL FMCSMPYI_R1(MXY(12),5+4*NTERM+2*N,QX)
             CALL FMCSDIVI_R1(MXY(12),-128,QX)
             CALL FMCSDIVI_R1(MXY(12),1+NTERM,QX)
             CALL FMCSDIVI_R1(MXY(12),3+2*NTERM,QX)
         ELSE
             CALL FMCSMPYI_R1(MXY(12),(3+4*NTERM-2*N)*(5+4*NTERM-2*N),QX)
             CALL FMCSMPYI_R1(MXY(12),(3+4*NTERM+2*N)*(5+4*NTERM+2*N),QX)
             CALL FMCSDIVI_R1(MXY(12),-128,QX)
             CALL FMCSDIVI_R1(MXY(12),(1+NTERM)*(3+2*NTERM),QX)
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMCSMPY_R1(MXY(12),MXY(10),QX)
         DO J = 1, J2
            QX%NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(12),QX)
            IF (QX%KFLAG /= 0) GO TO 190
            QX%NDIG = MAX(QX%NGRD22,NDSAV1-INT(MJSUMS(J)%MP(2)-MXY(12)%MP(2)))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMCSMPYI_R1(MXY(12),3+4*NTERM-2*N,QX)
                CALL FMCSMPYI_R1(MXY(12),5+4*NTERM-2*N,QX)
                CALL FMCSMPYI_R1(MXY(12),3+4*NTERM+2*N,QX)
                CALL FMCSMPYI_R1(MXY(12),5+4*NTERM+2*N,QX)
                CALL FMCSDIVI_R1(MXY(12),-128,QX)
                CALL FMCSDIVI_R1(MXY(12),1+NTERM,QX)
                CALL FMCSDIVI_R1(MXY(12),3+2*NTERM,QX)
            ELSE
                CALL FMCSMPYI_R1(MXY(12),(3+4*NTERM-2*N)*(5+4*NTERM-2*N),QX)
                CALL FMCSMPYI_R1(MXY(12),(3+4*NTERM+2*N)*(5+4*NTERM+2*N),QX)
                CALL FMCSDIVI_R1(MXY(12),-128,QX)
                CALL FMCSDIVI_R1(MXY(12),(1+NTERM)*(3+2*NTERM),QX)
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  190 QX%NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(8),QX)
          DO J = J2-1, 1, -1
             CALL FMCSMPY_R1(MXY(8),MXY(11),QX)
             CALL FMADD_R1(MXY(8),MJSUMS(J),QX)
          ENDDO
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(8),QX)
      ENDIF

!             To minimize cancellation error for very large x, with c = x - n*Pi/2 - Pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*Pi/2) + sin(n*Pi/2)
!             k2 = cos(n*Pi/2) - sin(n*Pi/2)
!             This is equivalent to
!             Mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      KRSAVE = QX%KRAD
      QX%KRAD = 1
      CALL FMCSSN(MXY(1),MXY(4),MXY(5),QX)
      QX%KRAD = KRSAVE
      K = MOD(N,4)
      IF (K == 0) THEN
          CALL FMADD(MXY(5),MXY(4),MXY(6),QX)
          CALL FMSUB(MXY(5),MXY(4),MXY(7),QX)
      ELSE IF (K == 1) THEN
          CALL FMSUB(MXY(5),MXY(4),MXY(6),QX)
          CALL FMADD(MXY(5),MXY(4),MXY(7),QX)
          CALL FMMPYI_R1(MXY(7),-1,QX)
      ELSE IF (K == 2) THEN
          CALL FMADD(MXY(5),MXY(4),MXY(6),QX)
          CALL FMMPYI_R1(MXY(6),-1,QX)
          CALL FMSUB(MXY(4),MXY(5),MXY(7),QX)
      ELSE
          CALL FMSUB(MXY(4),MXY(5),MXY(6),QX)
          CALL FMADD(MXY(5),MXY(4),MXY(7),QX)
      ENDIF
      CALL FMI2M(2,MXY(2),QX)
      CALL FMSQRT(MXY(2),MXY(3),QX)
      CALL FMDIV(MXY(6),MXY(3),MXY(4),QX)
      CALL FMDIV(MXY(7),MXY(3),MXY(5),QX)

      CALL FMMPY_R2(MXY(5),MXY(9),QX)
      CALL FMMPY_R2(MXY(4),MXY(8),QX)
      CALL FMADD(MXY(9),MXY(8),MXY(6),QX)
      CALL FMPI(MXY(7),QX)
      CALL FMMPY(MXY(7),MXY(1),MXY(5),QX)
      CALL FMI2M(2,MXY(4),QX)
      CALL FMDIV(MXY(4),MXY(5),MXY(3),QX)
      CALL FMSQRT(MXY(3),MXY(4),QX)
      CALL FMMPY(MXY(4),MXY(6),MXY(9),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  200 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(9)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              IF (MRETRY%MP(3) == 0) GO TO 210
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(9)%MP(J+1)) GO TO 210
              ENDDO
              GO TO 220
          ENDIF
  210     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+IEXTRA,QX%NDIG+QX%NGRD52+2)
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMEQ(MXY(1),MXY(12),QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(9),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  220 IF (MA%MP(1) == -1) THEN
          IF (MOD(N,2) == 1 .AND. MXY(9)%MP(2) /= QX%MUNKNO .AND.  &
              MXY(9)%MP(3) /= 0) THEN
              MXY(9)%MP(1) = -MXY(9)%MP(1)
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(9),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMBESY

      SUBROUTINE FMBESY2(N1,N2,X,ARRAY,QX)

!  ARRAY = (/  Y(n1,x) , ..., Y(n2,x)  /)


      USE FMVALS_PARALLEL
      IMPLICIT NONE

      INTEGER :: J,K,N,N1,N2,NDSAVE
      TYPE(MULTI) :: ARRAY(ABS(N2-N1)+1),X
      INTENT (IN) :: N1,N2,X
      INTENT (INOUT) :: ARRAY
      TYPE(MULTI) :: MXY(4)
      TYPE(FM_SETTINGS) :: QX

      N = ABS(N2-N1) + 1
      DO J = 1, N
      ENDDO
      NDSAVE = QX%NDIG

      IF (N1 < 0 .OR. N2 < 0) THEN
          DO J = 1, SIZE(ARRAY)
             CALL FMST2M('UNKNOWN',ARRAY(J),QX)
          ENDDO
          RETURN
      ENDIF

!             The first two entries in the array are done with calls to FMBESY.
!             The rest use this recurrence:

!             Y(k+1,x) = 2*k*Y(k,x) / x  -  Y(k-1,x)

      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL FMEQU(X,MXY(1),NDSAVE,QX%NDIG,QX)
      K = MIN(N1,N2)
      CALL FMBESY(K,MXY(1),MXY(4),QX)
      CALL FMEQU(MXY(4),ARRAY(1),QX%NDIG,NDSAVE,QX)
      IF (N <= 1) GO TO 110
      CALL FMBESY(K+1,MXY(1),MXY(3),QX)
      CALL FMEQU(MXY(3),ARRAY(2),QX%NDIG,NDSAVE,QX)
      IF (N <= 2) GO TO 110

      DO J = K+2, MAX(N1,N2)
         CALL FMMPYI(MXY(3),2*(J-1),MXY(2),QX)
         CALL FMDIV_R1(MXY(2),MXY(1),QX)
         CALL FMSUB_R1(MXY(2),MXY(4),QX)
         CALL FMEQU(MXY(2),ARRAY(J-K+1),QX%NDIG,NDSAVE,QX)
         IF (J == MIN(N1,N2)) EXIT
         CALL FMEQ(MXY(3),MXY(4),QX)
         CALL FMEQ(MXY(2),MXY(3),QX)
      ENDDO

!             Reverse the list if N2 < N1.

      IF (N2 < N1) THEN
          QX%NDIG = NDSAVE
          DO J = 1, N/2
             CALL FMEQ(ARRAY(J),MXY(4),QX)
             CALL FMEQ(ARRAY(N+1-J),ARRAY(J),QX)
             CALL FMEQ(MXY(4),ARRAY(N+1-J),QX)
          ENDDO
      ENDIF

  110 QX%NDIG = NDSAVE
      RETURN
      END SUBROUTINE FMBESY2

      SUBROUTINE FMC(MA,MB,QX)

!  MB = C(MA)    Fresnel Cosine Integral.

!  Integral from 0 to MA of Cos(pi*t**2/2) dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY,N_ACC
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(16),MRETRY,MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX

      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      K_RETURN_CODE = 0
      K = 0
      QX%NCALL = QX%NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          KL = QX%KWARN
          QX%KWARN = 0
          CALL FMDP2M(1.0D-10,MXY(1),QX)
          CALL FMULP(MXY(1),MXY(2),QX)
          CALL FMSQRT(MXY(2),MXY(3),QX)
          CALL FMSQRT(MXY(3),MXY(2),QX)
          CALL FMABS(MA,MXY(3),QX)
          CALL FMSUB(MXY(3),MXY(2),MXY(4),QX)
          IF (MXY(4)%MP(1) < 0) K = 1
          QX%NTRACE = J
          QX%KWARN = KL
      ENDIF
      IF (QX%KROUND /= 1 .AND. K == 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMIPWR(MXY(1),5,MXY(2),QX)
          CALL FMPI(MXY(3),QX)
          CALL FMSQR(MXY(3),MXY(4),QX)
          CALL FMDIVI(MXY(4),40,MXY(3),QX)
          CALL FMMPY(MXY(2),MXY(3),MXY(5),QX)
          CALL FMEQ(MXY(1),MXY(4),QX)
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG .AND.  &
              MXY(4)%MP(2) > QX%MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(4),MXY(8),MXY(6),QX)
              IF (MXY(6)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMSUB(MXY(6),MXY(7),MB,QX)
                  IF (MB%MP(2) >= QX%MEXPOV) THEN
                      IF (MXY(6)%MP(1) > 0) THEN
                          IF (MXY(7)%MP(1) > 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(7)%MP(1) < 0 .AND. QX%KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ELSE
                          IF (MXY(7)%MP(1) > 0 .AND. QX%KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(7)%MP(1) < 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NAMEST(QX%NCALL) = 'FMC'
                  CALL FMNTR(2,MA,MA,1,1,QX)
              ENDIF
              IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
                  QX%NAMEST(QX%NCALL) = 'FMC'
                  QX%KFLAG = -4
                  CALL FMWRN2(QX)
              ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
                  QX%NAMEST(QX%NCALL) = 'FMC'
                  IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
                  IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
                  CALL FMWRN2(QX)
              ENDIF
              IF (QX%NTRACE /= 0) THEN
                  QX%NAMEST(QX%NCALL) = 'FMC'
                  CALL FMNTR(1,MB,MB,1,1,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMC      ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      MXY(1)%MP(1) = 1
      NUMTRY = 0

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(10),QX)
          GO TO 180
      ENDIF
      IF (4*MXY(1)%MP(2) < -QX%NDIG) THEN
          CALL FMEQ(MXY(1),MXY(10),QX)
          GO TO 180
      ENDIF
      CALL FMINT(MXY(1),MXY(8),QX)
      IF (3*MXY(1)%MP(2) > QX%NDIG .AND. FMCOMP(MXY(1),'==',MXY(8),QX) .AND.  &
          MXY(1)%MP(2) < QX%MEXPOV) THEN
          MXY(1)%MP(1) = MA%MP(1)
          IF (MOD(INT(QX%MBASE),2) == 0 .AND. MXY(1)%MP(2) > NDSAVE) THEN
              K = 0
          ELSE
              CALL FMI2M(2,MXY(8),QX)
              CALL FMMOD(MXY(1),MXY(8),MXY(7),QX)
              CALL FMM2I(MXY(7),K,QX)
          ENDIF
          CALL FMI2M(1,MXY(8),QX)
          IF (MXY(1)%MP(1) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(10),QX)
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(10),QX)
          ENDIF
          IF (K == 0) THEN
              CALL FMIPWR(MXY(1),3,MXY(7),QX)
              CALL FMPI(MXY(6),QX)
              CALL FMSQR_R1(MXY(6),QX)
              CALL FMMPY_R1(MXY(6),MXY(7),QX)
              CALL FMDIV_R2(MXY(8),MXY(6),QX)
              CALL FMSUB_R1(MXY(10),MXY(6),QX)
          ELSE
              CALL FMPI(MXY(6),QX)
              CALL FMMPY_R1(MXY(6),MXY(1),QX)
              CALL FMDIV_R2(MXY(8),MXY(6),QX)
              CALL FMADD_R1(MXY(10),MXY(6),QX)
          ENDIF
          IF (MA%MP(1) < 0) MXY(10)%MP(1) = -MXY(10)%MP(1)
          GO TO 180
      ENDIF
      IF (MXY(1)%MP(2) > QX%NDIG) THEN
          CALL FMI2M(1,MXY(8),QX)
          IF (MXY(1)%MP(1) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(10),QX)
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(10),QX)
          ENDIF
          GO TO 180
      ENDIF

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(1)%MP(2)),0) , INT(2.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      IF (KFLAGX == 0) THEN
          IF (ABS(X) < SQRT(HUGE(X)/(4*LOG(HUGE(X))))) THEN
              Y = (QX%DPPI*X*X-1)/2
              Y = (2*Y+1.5)*LOG(2*Y+2) - (2*Y+1) - Y*QX%DLOGTW - (Y+0.5)*LOG(Y+1) + Y - Y*LOG(QX%DPPI*X*X)
              IF (Y <= -(QX%NDIG+1)*QX%DLOGMB) THEN
                  NMETHD = 2
              ELSE
                  NMETHD = 1
              ENDIF
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MXY(1)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n)/((4*n+1)*(2*n)!).

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          IEXTRA = MAX(0.0D0,(0.096*X*X + 0.033*ABS(X) - 0.5)*LOG(1.0E7)/QX%ALOGMB)*1.02
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF

      IF (KFLAGX == 0) THEN
          J2 = INT(0.68*SQRT(FMNTERMS(3.14159D0*X*X/2,2,0,0,1,QX)) - 1.6)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(4),QX)
      CALL FMCSDIVI(MXY(4),2,MXY(9),QX)
      CALL FMPI(MXY(3),QX)
      CALL FMCSMPY_R1(MXY(9),MXY(3),QX)
      CALL FMI2M(1,MXY(6),QX)
      CALL FMI2M(1,MJSUMS(1),QX)
      NTERM = 0
      DO J = 2, J2
         NTERM = NTERM + 2
         NBOT = NTERM*(NTERM-1)
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             IF (NTERM > 2) CALL FMCSDIVI_R1(MXY(6),NTERM-1,QX)
             CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         ELSE
             CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(6),2*NTERM+1,MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 140
      CALL FMIPWR(MXY(9),2*J2,MXY(7),QX)

  130 CALL FMCSMPY_R1(MXY(6),MXY(7),QX)
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM-1,QX)
             CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(6),2*NTERM+1,MXY(2),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2),QX)
         IF (QX%KFLAG /= 0) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(6)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMSQR(MXY(9),MXY(8),QX)
      MXY(8)%MP(1) = -1
      IF (MJSUMS(1)%MP(1) > 0) THEN
          CALL FMEQ(MJSUMS(1),MXY(15),QX)
          CALL FMI2M(0,MXY(16),QX)
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(16),QX)
          CALL FMI2M(0,MXY(15),QX)
      ENDIF
      CALL FMEQ(MXY(8),MXY(12),QX)
      DO J = 1, J2-1
         CALL FMMPY(MXY(12),MJSUMS(J+1),MXY(3),QX)
         IF (MXY(3)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(15),MXY(3),QX)
         ELSE
             CALL FMADD_R1(MXY(16),MXY(3),QX)
         ENDIF
         CALL FMMPY_R1(MXY(12),MXY(8),QX)
      ENDDO
      CALL FMADD(MXY(15),MXY(16),MXY(10),QX)
      CALL FMCANCEL(MXY(15),MXY(16),MXY(10),K,QX)
      N_ACC = N_ACC - K
      CALL FMMPY_R1(MXY(10),MXY(1),QX)

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then C(x) = 0.5 + f(x)*sin(pi*x*x/2) - g(x)*cos(pi*x*x/2).

  150 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMFGFI(MXY(1),MXY(11),MXY(12),QX)
      CALL FMSQR(MXY(1),MXY(4),QX)
      KRSAVE = QX%KRAD
      QX%KRAD = 0
      CALL FMMPYI(MXY(4),90,MXY(7),QX)
      CALL FMCSSN(MXY(7),MXY(13),MXY(14),QX)
      QX%KRAD = KRSAVE
      CALL FMMPY(MXY(11),MXY(14),MXY(10),QX)
      CALL FMMPY(MXY(12),MXY(13),MXY(7),QX)
      CALL FMI2M(1,MXY(4),QX)
      CALL FMDIVI(MXY(4),2,MXY(5),QX)
      CALL FMADD(MXY(5),MXY(10),MXY(6),QX)
      CALL FMSUB(MXY(6),MXY(7),MXY(10),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(10)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(10)%MP(J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+IEXTRA,QX%NDIG+QX%NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  180 IF (MA%MP(1) == -1) THEN
          IF (MXY(10)%MP(3) /= 0 .AND. MXY(10)%MP(2) /= QX%MUNKNO)  &
              MXY(10)%MP(1) =-1
      ENDIF
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMC

      SUBROUTINE FMCHI(MA,MB,QX)

!  MB = Hyperbolic Cosine Integral(MA)

!  EulerGamma + Ln(MA) + Integral from 0 to MA of ( Cosh(t) - 1 ) / t  dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,J2,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,LARGE,NBOT,NDGOAL,  &
                 NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY,N_ACC

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(11),MRETRY,MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      CALL FMENT2('FMCHI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(1)%MP(2)),0) ,INT(2.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Check for special cases.

      IF (MXY(1)%MP(1) == -1 .OR. MXY(1)%MP(2) == QX%MEXPUN .OR.  &
          MXY(1)%MP(3) ==0) THEN
          CALL FMST2M('UNKNOWN',MXY(7),QX)
          QX%KFLAG = -4
          GO TO 180
      ENDIF
      IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(7),QX)
          QX%KFLAG = -5
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MXY(1)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (QX%NDIG+5)*QX%DLOGMB
          IF (ABS(X) > Y+(QX%DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the gamma + ln(X) + X**(2*N)/((2*N)*(2*N)!) series.

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      IF (KFLAGX == 0) THEN
          J2 = INT(0.62*SQRT(FMNTERMS(X,2,0,0,1,QX)) - 1.3)
          J2 = MAX(1,MIN(LJSUMS,J2))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(2),QX)
      CALL FMCSDIVI(MXY(2),2,MXY(6),QX)
      CALL FMCSDIVI(MXY(6),2,MJSUMS(1),QX)
      NTERM = 2
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         NTERM = NTERM + 1
         NBOT = NTERM
         CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         CALL FMCSDIVI(MXY(6),NTERM,MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(4),QX)

  130 CALL FMCSMPY_R1(MXY(6),MXY(4),QX)
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
             NBOT = (NTERM - 1)
             CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(6),NTERM,MXY(3),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(3),QX)
         IF (QX%KFLAG /= 0) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(3)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(7),QX)
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(1),MXY(5),QX)
          DO J = 2, J2
             CALL FMCSMPY_R1(MXY(7),MXY(5),QX)
             CALL FMADD_R1(MXY(7),MJSUMS(J2-J+1),QX)
          ENDDO
      ENDIF
      CALL FMEULR(MXY(9),QX)
      CALL FMADD(MXY(7),MXY(9),MXY(3),QX)
      CALL FMLN(MXY(1),MXY(2),QX)
      CALL FMADD(MXY(3),MXY(2),MXY(7),QX)
      CALL FMCANCEL(MXY(3),MXY(2),MXY(7),K,QX)
      N_ACC = N_ACC - K

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then CHI(x) = f(x)*sinh(x) + g(x)*cosh(x).

  150 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-2)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMFHGH(MXY(1),MXY(8),MXY(9),QX)
      CALL FMCHSH(MXY(1),MXY(10),MXY(11),QX)
      IF (MXY(10)%MP(2) < QX%MEXPOV) THEN
          CALL FMMPY(MXY(8),MXY(11),MXY(7),QX)
          CALL FMMPY(MXY(9),MXY(10),MXY(4),QX)
          CALL FMADD_R1(MXY(7),MXY(4),QX)
      ELSE
          CALL FMADD(MXY(8),MXY(9),MXY(4),QX)
          CALL FMDIVI_R1(MXY(4),2,QX)
          CALL FMLN(MXY(4),MXY(7),QX)
          CALL FMADD(MXY(1),MXY(7),MXY(4),QX)
          CALL FMEXP(MXY(4),MXY(7),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(7)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(7)%MP(J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+IEXTRA,QX%NDIG+QX%NGRD52+2)
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(7),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  180 CALL FMEXT2(MXY(7),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMCHI

      SUBROUTINE FMCI(MA,MB,QX)

!  MB = Cosine Integral(MA)

!  Integral from MA to Infinity of -Cos(t) / t  dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NBOT,  &
                 NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY,N_ACC

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(13),MRETRY,MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      CALL FMENT2('FMCI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(1)%MP(2)),0) ,INT(2.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Check for special cases.

      IF (MXY(1)%MP(1) == -1 .OR. MXY(1)%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(7),QX)
          QX%KFLAG = -4
          GO TO 180
      ENDIF
      IF (MXY(1)%MP(2) == QX%MEXPOV .OR. MXY(1)%MP(2) == QX%MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(7),QX)
          QX%KFLAG = -4
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MXY(1)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (QX%NDIG+5)*QX%DLOGMB
          IF (ABS(X) > Y+(QX%DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the  gamma + ln(X) + (-1)**N*X**(2*N)/((2*N)*(2*N)!) series.

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          Y = NINT(ABS(X)/2)
          Y = 2*Y*LOG(ABS(X)+1.0E-9) - LOG(2*Y+1.0E-9) - (2*Y+0.5)*LOG(2*Y+1) + 2*Y
          Y = 1.03*Y/QX%DLOGMB
          IEXTRA = MAX(0,INT(Y+1))
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      IF (ABS(X) < 5 .AND. KR_RETRY <= 0) THEN
          QX%NDIG = QX%NDIG - 2
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          IEXTRA = 0
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

      IF (KFLAGX == 0) THEN
          J2 = INT(0.64*SQRT(FMNTERMS(X,2,0,0,1,QX)) - 1.4)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG
      CALL FMI2M(0,MXY(12),QX)
      CALL FMI2M(0,MXY(13),QX)

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(2),QX)
      CALL FMCSDIVI(MXY(2),2,MXY(6),QX)
      CALL FMCSDIVI(MXY(6),2,MJSUMS(1),QX)
      NTERM = 2
      DO J = 2, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM-1,QX)
             CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         ELSE
             CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(6),NTERM,MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(4),QX)

  130 CALL FMCSMPY_R1(MXY(6),MXY(4),QX)
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM-1,QX)
             CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(6),NTERM,MXY(3),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(3),QX)
         IF (QX%KFLAG /= 0) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(3)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMSQR(MXY(1),MXY(5),QX)
      MXY(5)%MP(1) = -1
      IF (MJSUMS(1)%MP(1) > 0) THEN
          CALL FMEQ(MJSUMS(1),MXY(12),QX)
          CALL FMI2M(0,MXY(13),QX)
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(13),QX)
          CALL FMI2M(0,MXY(12),QX)
      ENDIF
      CALL FMEQ(MXY(5),MXY(7),QX)
      DO J = 1, J2-1
         CALL FMMPY(MXY(7),MJSUMS(J+1),MXY(3),QX)
         IF (MXY(3)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(12),MXY(3),QX)
         ELSE
             CALL FMADD_R1(MXY(13),MXY(3),QX)
         ENDIF
         CALL FMMPY_R1(MXY(7),MXY(5),QX)
      ENDDO
      CALL FMMPYI(MXY(12),-1,MXY(3),QX)
      CALL FMMPYI(MXY(13),-1,MXY(12),QX)
      CALL FMEQ(MXY(3),MXY(13),QX)
      CALL FMEULR(MXY(9),QX)
      CALL FMADD_R1(MXY(12),MXY(9),QX)
      CALL FMLN(MXY(1),MXY(2),QX)
      IF (MXY(2)%MP(1) > 0) THEN
          CALL FMADD_R1(MXY(12),MXY(2),QX)
      ELSE
          CALL FMADD_R1(MXY(13),MXY(2),QX)
      ENDIF
      CALL FMADD(MXY(12),MXY(13),MXY(7),QX)
      CALL FMCANCEL(MXY(12),MXY(13),MXY(7),K,QX)
      N_ACC = N_ACC - K

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then CI(x) = f(x)*sin(x) - g(x)*cos(x).

  150 CALL FMFXGX(MXY(1),MXY(8),MXY(9),QX)
      KRSAVE = QX%KRAD
      QX%KRAD = 1
      CALL FMCSSN(MXY(1),MXY(10),MXY(11),QX)
      QX%KRAD = KRSAVE
      CALL FMMPY(MXY(8),MXY(11),MXY(7),QX)
      CALL FMMPY(MXY(9),MXY(10),MXY(4),QX)
      CALL FMSUB_R1(MXY(7),MXY(4),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(7)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(7)%MP(J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+IEXTRA,QX%NDIG+QX%NGRD52+2)
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(7),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  180 CALL FMEXT2(MXY(7),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMCI

      SUBROUTINE FMEI(MA,MB,QX)

!  MB = Exponential Integral(MA)

!  Integral from -Infinity to MA of e**t / t  dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J2,JEXTRA,JTERMS,K,KFLAG1,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,  &
                 NDGOAL,NDOLD,NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY,N_ACC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(17),MRETRY,MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      CALL FMENT2('FMEI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      NUMTRY = 0

  120 NTERMS = INT(INTMAX/10)

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(1)%MP(2)),0),INT(2.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0 .OR. MXY(1)%MP(2) == QX%MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(10),QX)
          QX%KFLAG = -4
          GO TO 200
      ELSE IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMI2M(0,MXY(10),QX)
          IF (MXY(1)%MP(1) > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(10),QX)
              QX%KFLAG = -5
          ELSE
              CALL FMST2M('-UNDERFLOW',MXY(10),QX)
              QX%KFLAG = -6
          ENDIF
          GO TO 200
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MXY(1)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (QX%NDIG+3)*QX%DLOGMB
          IF (ABS(X) > Y+(QX%DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
          IF (X < 0.0D0 .AND. NMETHD == 1) THEN
              IF (X <= -14.3D0-0.275D0*Y) NMETHD = 3
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 170

!             Method 1.  Use the X**N/(N*N!) series.

      IF (KFLAGX == 0) THEN
          IF (X < 0) THEN
              IEXTRA = INT(2.0D0*ABS(X)/QX%DLOGMB)
          ELSE IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
              QX%NDIG = QX%NDIG - IEXTRA - 1
              IEXTRA = 0
          ELSE IF (KR_RETRY <= 0 .AND. QX%NCALL > 1) THEN
              QX%NDIG = QX%NDIG - IEXTRA
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

      IF (KFLAGX == 0) THEN
          J2 = INT(0.63*SQRT(FMNTERMS(ABS(X),1,0,0,1,QX)) - 1.4)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6),QX)
      CALL FMEQ(MXY(6),MJSUMS(1),QX)
      NTERM = 1
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         CALL FMCSDIVI(MXY(6),NTERM,MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 140
      CALL FMIPWR(MXY(1),J2,MXY(5),QX)

  130 CALL FMCSMPY_R1(MXY(6),MXY(5),QX)
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         CALL FMCSDIVI(MXY(6),NTERM,MXY(4),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMI2M(0,MXY(16),QX)
      CALL FMI2M(0,MXY(17),QX)
      CALL FMEQ(MXY(1),MXY(12),QX)
      DO J = 1, J2
         CALL FMMPY(MXY(12),MJSUMS(J),MXY(3),QX)
         IF (MXY(3)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(16),MXY(3),QX)
         ELSE
             CALL FMADD_R1(MXY(17),MXY(3),QX)
         ENDIF
         CALL FMMPY_R1(MXY(12),MXY(1),QX)
      ENDDO
      CALL FMEULR(MXY(3),QX)
      CALL FMADD_R1(MXY(16),MXY(3),QX)
      CALL FMABS(MXY(1),MXY(2),QX)
      CALL FMLN(MXY(2),MXY(11),QX)
      IF (MXY(11)%MP(1) > 0) THEN
          CALL FMADD_R1(MXY(16),MXY(11),QX)
      ELSE
          CALL FMADD_R1(MXY(17),MXY(11),QX)
      ENDIF
      CALL FMADD(MXY(16),MXY(17),MXY(10),QX)
      CALL FMCANCEL(MXY(16),MXY(17),MJSUMS(1),K,QX)
      N_ACC = N_ACC - K

      GO TO 180

!             Method 2.  Use the N!/X**N series.

  150 IF (KFLAGX == 0) THEN
          J2 = INT(0.38*SQRT(FMNTERMS(ABS(X),1,0,0,0,QX)) + 0.6)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      IF (KFLAGX == 0) THEN
          IF (X > 0 .AND. KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
              QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-2)
          ENDIF
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6),QX)
      CALL FMDIV(MXY(6),MXY(1),MXY(15),QX)
      CALL FMEQ(MXY(6),MJSUMS(1),QX)
      NTERM = 1
      DO J = 2, J2
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(6),NTERM,QX)
         CALL FMEQ(MXY(6),MJSUMS(J),QX)
         NTERM = NTERM + 1
      ENDDO
      IF (MXY(15)%MP(2)+MXY(6)%MP(2) < -QX%NDIG-3) GO TO 160
      CALL FMIPWR(MXY(15),J2,MXY(5),QX)

      DO JTERMS = 1, NTERMS
         CALL FMCSMPY_R1(MXY(6),MXY(5),QX)
         DO J = 1, J2
            CALL FMCSMPYI_R1(MXY(6),NTERM,QX)
            QX%NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J),MXY(6),QX)
            IF (QX%KFLAG /= 0) GO TO 160
            QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(6)%MP(2))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  160 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(5),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(15),QX)
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1),QX)
      ENDDO
      CALL FMMPY(MXY(15),MXY(5),MXY(13),QX)
      CALL FMEXP(MXY(1),MXY(11),QX)
      IF (MXY(11)%MP(2) == QX%MEXPOV .AND. MXY(1)%MP(1) > 0) THEN
          CALL FMEQ(MXY(11),MXY(10),QX)
          GO TO 180
      ELSE
          CALL FMMPY(MXY(11),MXY(13),MXY(10),QX)
      ENDIF

      QX%NDIG = NDSAV1
      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  170 NDSAV1 = QX%NDIG
      JEXTRA = INT(MAX(1.0,5.76/QX%ALOGMB + 1.0))
      IF (QX%NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + JEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQ(MXY(1),MXY(13),QX)
      IF (MXY(13)%MP(2) /= QX%MUNKNO .AND. MXY(13)%MP(3) /= 0)  &
          MXY(13)%MP(1) = -MXY(13)%MP(1)
      CALL FMI2M(1,MXY(8),QX)
      CALL FMEQU(MXY(13),MXY(9),NDSAV1,QX%NDIG,QX)
      CALL FMI2M(1,MXY(2),QX)
      CALL FMDIV(MXY(2),MXY(13),MXY(10),QX)
      CALL FMEQ(MXY(10),MXY(14),QX)

!             Method 3 continued fraction loop.

      NDSAV2 = QX%NDIG
      DO J = 1, NTERMS
         CALL FMCSMPYI(MXY(8),J,MXY(6),QX)
         CALL FMEQ(MXY(9),MXY(7),QX)
         CALL FMCSADD_R1(MXY(7),MXY(6),QX)
         CALL FMCSMPY_R1(MXY(10),MXY(6),QX)
         CALL FMCSDIV(MXY(10),MXY(7),MXY(11),QX)
         CALL FMEQ(MXY(11),MXY(10),QX)
         IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
             MXY(10)%MP(1) = -MXY(10)%MP(1)
         QX%NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10),QX)
         KFLAG1 = QX%KFLAG
         CALL FMEQ(MXY(9),MXY(8),QX)
         CALL FMEQ(MXY(7),MXY(9),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(14)%MP(2)-MXY(10)%MP(2))))
         CALL FMCSMPYI(MXY(8),J,MXY(6),QX)
         CALL FMEQ(MXY(9),MXY(3),QX)
         CALL FMCSMPY_R1(MXY(3),MXY(13),QX)
         CALL FMEQ(MXY(3),MXY(7),QX)
         CALL FMCSADD_R1(MXY(7),MXY(6),QX)
         CALL FMCSMPY_R1(MXY(10),MXY(6),QX)
         CALL FMCSDIV(MXY(10),MXY(7),MXY(11),QX)
         CALL FMEQ(MXY(11),MXY(10),QX)
         IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
             MXY(10)%MP(1) = -MXY(10)%MP(1)
         QX%NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10),QX)

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. QX%KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(9),MXY(8),QX)
         CALL FMEQ(MXY(7),MXY(9),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(14)%MP(2)-MXY(10)%MP(2))))
      ENDDO

      CALL FMEQU_R1(MXY(14),QX%NDIG,NDSAV1,QX)
      QX%NDIG = NDSAV1
      CALL FMEXP(MXY(1),MXY(15),QX)
      CALL FMMPY(MXY(14),MXY(15),MXY(10),QX)
      IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
          MXY(10)%MP(1) = -MXY(10)%MP(1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(10)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(10)%MP(J+1)) GO TO 190
              ENDDO
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+IEXTRA,QX%NDIG+QX%NGRD52+2)
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  200 CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMEI

      SUBROUTINE FMEN(IVAL,MA,MB,QX)

!  MB = Exponential Integral(IVAL,MA)

!  Integral from 1 to Infinity of e**(-MA*t) / t**IVAL  dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      INTEGER :: IVAL,N
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR,X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTEGER :: IEXTRA,J,J2,JS,JTERM,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,  &
                 K_RETURN_CODE,NDSAVE,NDSAV1,NDSAV2,NGOAL,NMETHD,NTERM,NTERMS,N_ACC
      TYPE(MULTI) :: M_EULER_HARMONIC
      INTEGER :: IVAL_E_H, NDIG_E_H
      REAL (KIND(1.0D0)) :: MBS_E_H
      TYPE(FM_SETTINGS) :: QX
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: IVAL,MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(14),MJSUMS(LJSUMS)

      IVAL_E_H = 0
      NDIG_E_H = 0
      MBS_E_H = 0
      IEXTRA = 0
      K_RETURN_CODE = 0
      K = 0
      N = IVAL

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1) THEN
          IF (N > 1 .AND. MA%MP(2) < -QX%NDIG) K = 1
          IF (N <= 0) THEN
              J = QX%NTRACE
              QX%NTRACE = 0
              KL = QX%KWARN
              QX%KWARN = 0
              KRSAVE = QX%KROUND
              QX%KROUND = 1
              NDSAVE = QX%NDIG
              QX%NDIG = QX%NDIG + QX%NGRD52
              CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
              CALL FMI2M(-N,MXY(2),QX)
              CALL FMFACT(MXY(2),MXY(3),QX)
              CALL FMIPWR(MXY(1),-N+1,MXY(5),QX)
              CALL FMDIV(MXY(3),MXY(5),MXY(4),QX)
              CALL FMI2M(-1,MXY(6),QX)
              CALL FMDIVI(MXY(6),-N+1,MXY(5),QX)
              IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG) K = 1
              QX%NTRACE = J
              QX%KWARN = KL
              QX%NDIG = NDSAVE
              QX%KROUND = KRSAVE
          ENDIF
          IF (MA%MP(1) < 0 .AND. N > 0) K = 0
      ENDIF
      IF (QX%KROUND /= 1 .AND. K == 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          IF (MA%MP(2) == QX%MEXPUN) CALL FMTINY(MXY(1),QX)
          IF (N == 2) THEN
              CALL FMI2M(1,MXY(4),QX)
              CALL FMLN(MXY(1),MXY(2),QX)
              CALL FMEULR(MXY(3),QX)
              CALL FMADD(MXY(2),MXY(3),MXY(5),QX)
              CALL FMMPY(MXY(5),MXY(1),MXY(6),QX)
              CALL FMSUB(MXY(6),MXY(1),MXY(5),QX)
          ELSE IF (N >= 3) THEN
              CALL FMI2M(1,MXY(2),QX)
              CALL FMDIVI(MXY(2),N-1,MXY(4),QX)
              CALL FMDIVI(MXY(1),-(N-2),MXY(5),QX)
          ENDIF
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG+1 .AND.  &
              MXY(4)%MP(2) < QX%MUNKNO) THEN
              CALL FMEQU(MXY(4),MXY(10),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(4),MXY(8),MXY(6),QX)
              IF (MXY(6)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB,QX)
                  IF (MB%MP(2) >= QX%MEXPOV) THEN
                      IF (MXY(6)%MP(1) > 0) THEN
                          IF (MXY(7)%MP(1) < 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(7)%MP(1) > 0 .AND. QX%KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ELSE
                          IF (MXY(7)%MP(1) < 0 .AND. QX%KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(7)%MP(1) > 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMEN'
                  CALL FMNTRI(2,N,1,QX)
                  CALL FMNTR(2,MA,MA,1,0,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMEN'
                  QX%KFLAG = -4
                  CALL FMWRN2(QX)
                  QX%NCALL = QX%NCALL - 1
              ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMEN'
                  IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
                  IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
                  CALL FMWRN2(QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMEN'
                  CALL FMNTR(1,MB,MB,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (QX%NTRACE /= 0) THEN
          QX%NCALL = QX%NCALL + 1
          QX%NAMEST(QX%NCALL) = 'FMEN'
          CALL FMNTRI(2,IVAL,1,QX)
          QX%NCALL = QX%NCALL - 1
      ENDIF
      CALL FMENT2('FMEN     ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

!             Special cases.

      IF (IVAL > 0 .AND. (MXY(1)%MP(1) < 0 .OR. MXY(1)%MP(3) == 0)) THEN
          IF (IVAL > 1 .AND. MXY(1)%MP(3) == 0) THEN
              CALL FMI2M(1,MXY(2),QX)
              CALL FMDIVI(MXY(2),IVAL-1,MXY(12),QX)
          ELSE
              CALL FMST2M('UNKNOWN',MXY(12),QX)
              QX%KFLAG = -4
          ENDIF
          GO TO 180
      ENDIF
      IF (IVAL <= 0 .AND. MXY(1)%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12),QX)
          QX%KFLAG = -4
          GO TO 180
      ENDIF
      IF (IVAL == 0) THEN
          CALL FMI2M(-1000,MXY(3),QX)
          IF (FMCOMP(MXY(1),'>=',MXY(3),QX)) THEN
              CALL FMEQ(MXY(1),MXY(3),QX)
              IF (MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(3)%MP(3) /= 0)  &
                  MXY(3)%MP(1) = -MXY(3)%MP(1)
              CALL FMEXP(MXY(3),MXY(4),QX)
              CALL FMDIV(MXY(4),MXY(1),MXY(12),QX)
          ELSE
              CALL FMEQ(MXY(1),MXY(3),QX)
              IF (MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(3)%MP(3) /= 0)  &
                  MXY(3)%MP(1) = -MXY(3)%MP(1)
              CALL FMLN(MXY(3),MXY(4),QX)
              CALL FMSUB(MXY(3),MXY(4),MXY(5),QX)
              CALL FMEXP(MXY(5),MXY(12),QX)
              IF (MXY(12)%MP(2) /= QX%MUNKNO .AND. MXY(12)%MP(3) /= 0)  &
                  MXY(12)%MP(1) = -MXY(12)%MP(1)
          ENDIF
          GO TO 180
      ELSE IF (IVAL == 1 .AND. MXY(1)%MP(2) < -QX%NDIG) THEN
          CALL FMEULR(MXY(11),QX)
          CALL FMLN(MXY(1),MXY(10),QX)
          CALL FMADD(MXY(10),MXY(11),MXY(4),QX)
          CALL FMSUB(MXY(1),MXY(4),MXY(12),QX)
          GO TO 180
      ELSE IF (IVAL == 2 .AND. (MXY(1)%MP(2) < -QX%NDIG .OR. MXY(1)%MP(3) == 0)) THEN
          IF (MXY(1)%MP(2) < -QX%NDIG*2 .OR. MXY(1)%MP(3) == 0) THEN
              CALL FMI2M(1,MXY(12),QX)
          ELSE
              CALL FMEULR(MXY(11),QX)
              CALL FMLN(MXY(1),MXY(10),QX)
              CALL FMADD(MXY(10),MXY(11),MXY(4),QX)
              CALL FMI2M(1,MXY(3),QX)
              CALL FMSUB(MXY(4),MXY(3),MXY(2),QX)
              CALL FMMPY(MXY(2),MXY(1),MXY(5),QX)
              CALL FMADD(MXY(3),MXY(5),MXY(12),QX)
          ENDIF
          GO TO 180
      ELSE IF (IVAL > 2 .AND. (MXY(1)%MP(2) < -QX%NDIG .OR. MXY(1)%MP(3) == 0)) THEN
          CALL FMI2M(1,MXY(3),QX)
          CALL FMDIVI(MXY(3),IVAL-1,MXY(4),QX)
          CALL FMDIVI(MXY(1),IVAL-2,MXY(5),QX)
          CALL FMSUB(MXY(4),MXY(5),MXY(12),QX)
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 use the convergent series,
!                    = 2 use the continued fraction expansion,
!                    = 3 for small positive IVAL use a recurrence involving ExponentialEi,
!                    = 4 for small negative IVAL use a recurrence involving exp,
!                    = 5 use incomplete gamma.

      CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) > 0) THEN
          X = DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF
      NMETHD = 5
      K = 0
      IF (N == 1 .AND. ABS(X) >= 1) K = 10
      IF (IVAL > 0) THEN
          IF (ABS(X) < (QX%NDIG*QX%ALOGMB)/(5.5 + 0.00095*IVAL) + K +                                  &
              (QX%NDIG*QX%ALOGMB)**2 * 1.0E-4 * (4.22 + LOG(REAL(IVAL)))/(24 + LOG(REAL(IVAL))) .AND.  &
              ABS(MXY(1)%MP(2)) < QX%MEXPOV .AND. MXY(1)%MP(3) /= 0) THEN
              NMETHD = 1
          ELSE IF (IVAL < MAX(2,INT((QX%NDIG+3)*QX%ALOGMB/32)) .AND.  &
                   ABS(X) > (QX%NDIG+5)*QX%ALOGMB + LOG(6.2832*(QX%NDIG+5)*QX%ALOGMB)/2) THEN
              NMETHD = 3
          ELSE
              NMETHD = 2
          ENDIF
      ELSE IF (IVAL < 0 .AND. IVAL >= -10 .AND. ABS(X) > 1 .AND.  &
               ABS(MXY(1)%MP(2)) < QX%MEXPOV .AND. MXY(1)%MP(3) /= 0) THEN
          NMETHD = 2
      ELSE IF (IVAL < 0 .AND. IVAL >= -10 .AND. ABS(X) <= 1 .AND.  &
               ABS(MXY(1)%MP(2)) < QX%MEXPOV .AND. MXY(1)%MP(3) /= 0) THEN
          NMETHD = 4
      ELSE IF (IVAL < 0 .AND. IVAL > -500 .AND.  &
               ABS(MXY(1)%MP(2)) < QX%MEXPOV .AND. MXY(1)%MP(3) /= 0) THEN
          NMETHD = 4
      ENDIF
      IF (N == 1 .AND. K == 10 .AND. NMETHD == 1) NMETHD = 3
      IF (NMETHD == 2) GO TO 140
      IF (NMETHD == 3) GO TO 150
      IF (NMETHD == 4) GO TO 160
      IF (NMETHD == 5) GO TO 170

!             Method 1.  Use the (-X)**N/((N-IVAL+1)*N!) series.

      IF (KFLAGX == 0) THEN
          IF (X > 0) THEN
              IEXTRA = INT(2.0D0*ABS(X)/QX%DLOGMB)
          ELSE IF (KR_RETRY <= 0) THEN
              QX%NDIG = QX%NDIG - IEXTRA - 1
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

      IF (KFLAGX == 0) THEN
          J2 = INT(0.68*SQRT(FMNTERMS(ABS(X),1,0,0,1,QX)) + 0.7)
          J2 = MAX(1,MIN(LJSUMS,J2))
      ELSE
          J2 = 1
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6),QX)
      JTERM = 0
      NTERM = IVAL - 1
      DO J = 1, J2
         IF (J > 2) CALL FMCSDIVI_R1(MXY(6),JTERM,QX)
         IF (NTERM /= 0) THEN
             CALL FMCSDIVI(MXY(6),NTERM,MJSUMS(J),QX)
         ELSE
             IF (IVAL == IVAL_E_H .AND. QX%NDIG <= NDIG_E_H .AND. MBS_E_H == QX%MBASE) THEN
                 CALL FMEQ(M_EULER_HARMONIC,MXY(2),QX)
                 CALL FMLN(MXY(1),MXY(3),QX)
                 CALL FMSUB_R1(MXY(2),MXY(3),QX)
                 CALL FMMPY(MXY(6),MXY(2),MJSUMS(J),QX)
             ELSE
                 CALL FMEULER(MXY(2),QX)
                 MXY(2)%MP(1) = -MXY(2)%MP(1)
                 CALL FMI2M(1,MXY(3),QX)
                 DO K = 1, IVAL-1
                    CALL FMCSDIVI(MXY(3),K,MXY(4),QX)
                    CALL FMADD_R1(MXY(2),MXY(4),QX)
                 ENDDO
                 IVAL_E_H = IVAL
                 NDIG_E_H = QX%NDIG
                 MBS_E_H = QX%MBASE
                 CALL FMEQ(MXY(2),M_EULER_HARMONIC,QX)
                 CALL FMLN(MXY(1),MXY(3),QX)
                 CALL FMSUB_R1(MXY(2),MXY(3),QX)
                 CALL FMMPY(MXY(6),MXY(2),MJSUMS(J),QX)
             ENDIF
         ENDIF
         JTERM = JTERM + 1
         NTERM = NTERM - 1
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 130
      CALL FMEQ(MXY(1),MXY(2),QX)
      IF (MXY(2)%MP(2) /= QX%MUNKNO .AND. MXY(2)%MP(3) /= 0)  &
          MXY(2)%MP(1) = -MXY(2)%MP(1)
      CALL FMIPWR(MXY(2),J2,MXY(5),QX)

  120 CALL FMCSMPY_R1(MXY(6),MXY(5),QX)
      DO J = 1, J2
         CALL FMCSDIVI_R1(MXY(6),JTERM,QX)
         IF (NTERM /= 0) THEN
             CALL FMCSDIVI(MXY(6),NTERM,MXY(4),QX)
         ELSE
             IF (IVAL == IVAL_E_H .AND. QX%NDIG <= NDIG_E_H .AND. MBS_E_H == QX%MBASE) THEN
                 CALL FMEQ(M_EULER_HARMONIC,MXY(7),QX)
                 CALL FMLN(MXY(1),MXY(3),QX)
                 CALL FMSUB_R1(MXY(7),MXY(3),QX)
                 CALL FMMPY(MXY(6),MXY(7),MXY(4),QX)
             ELSE
                 CALL FMEULER(MXY(7),QX)
                 MXY(7)%MP(1) = -MXY(7)%MP(1)
                 CALL FMI2M(1,MXY(3),QX)
                 DO K = 1, IVAL-1
                    CALL FMCSDIVI(MXY(3),K,MXY(4),QX)
                    CALL FMADD_R1(MXY(7),MXY(4),QX)
                 ENDDO
                 IVAL_E_H = IVAL
                 NDIG_E_H = QX%NDIG
                 MBS_E_H = QX%MBASE
                 CALL FMEQ(MXY(7),M_EULER_HARMONIC,QX)
                 CALL FMLN(MXY(1),MXY(3),QX)
                 CALL FMSUB_R1(MXY(7),MXY(3),QX)
                 CALL FMMPY(MXY(6),MXY(7),MXY(4),QX)
             ENDIF
         ENDIF
         QX%NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         JTERM = JTERM + 1
         NTERM = NTERM - 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(5),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(2),QX)
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1),QX)
      ENDDO
      CALL FMEQ(MXY(5),MXY(12),QX)
      GO TO 180

!             Method 2.  use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  140 IF (KFLAGX == 0) THEN
          IF (X > 0 .AND. IVAL > 0 .AND. KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
              QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
          ENDIF
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMI2M(-IVAL,MXY(2),QX)
      CALL FMSUB(MXY(2),MXY(1),MXY(3),QX)
      CALL FMNINT(MXY(3),MXY(2),QX)
      CALL FMSUB(MXY(3),MXY(2),MXY(4),QX)
      IF (MXY(4)%MP(3) == 0) THEN
          IF (IVAL <= 0) THEN
              IF (ABS(IVAL) <= 100) THEN
                  GO TO 160
              ELSE
                  GO TO 170
              ENDIF
          ENDIF
      ENDIF
      IEXTRA = 0
      IF (MXY(2)%MP(1) >= 0) THEN
          IF (MXY(4)%MP(2) < 0) IEXTRA = -MXY(4)%MP(2)
      ENDIF
      IF (IVAL < 0) THEN
          IF (ABS(X) > 1/SQRT(DPMAX) .AND. ABS(X) < SQRT(DPMAX)) THEN
              J = (LOG(6.2831853D0) + LOG(DBLE(-IVAL)) - IVAL*(LOG(DBLE(-IVAL))-1) -  &
                  (1-IVAL)*LOG(ABS(X))) / QX%DLOGMB + QX%NGRD21
          ELSE
              J = (LOG(6.2831853D0) + LOG(DBLE(-IVAL)) - IVAL*(LOG(DBLE(-IVAL))-1)) / QX%DLOGMB  &
                  - DBLE(1-IVAL)*(MXY(1)%MP(2)-1)
          ENDIF
          IEXTRA = MAX(IEXTRA,J)
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      NDSAV1 = QX%NDIG
      CALL FMI2M(0,MXY(8),QX)
      CALL FMI2M(1,MXY(9),QX)
      CALL FMI2M(0,MXY(10),QX)
      CALL FMI2M(0,MXY(14),QX)
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = QX%NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMEQ(MXY(1),MXY(11),QX)
             CALL FMCSMPY_R1(MXY(11),MXY(9),QX)
             CALL FMCSMPYI(MXY(8),(J-1)/2,MXY(12),QX)
         ELSE
             CALL FMEQ(MXY(9),MXY(11),QX)
             CALL FMCSMPYI(MXY(8),IVAL+(J-2)/2,MXY(12),QX)
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7),QX)
             CALL FMEXP(MXY(1),MXY(5),QX)
             IF (MXY(5)%MP(2) >= QX%MEXPOV) GO TO 170
             CALL FMMPY(MXY(1),MXY(5),MXY(6),QX)
             CALL FMI2M(1,MXY(2),QX)
             CALL FMDIV(MXY(2),MXY(6),MXY(10),QX)
         ELSE
             CALL FMADD(MXY(11),MXY(12),MXY(7),QX)
             CALL FMCSMPY_R1(MXY(10),MXY(12),QX)
             CALL FMCSDIV(MXY(10),MXY(7),MXY(3),QX)
             CALL FMEQ(MXY(3),MXY(10),QX)
             IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
                 MXY(10)%MP(1) = -MXY(10)%MP(1)
         ENDIF
         CALL FMEQ(MXY(9),MXY(8),QX)
         CALL FMEQ(MXY(7),MXY(9),QX)
         QX%NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(10),QX)

!             Check for convergence.

         IF (QX%KFLAG == 1 .AND. J > 1) THEN
             EXIT
         ENDIF
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(14)%MP(2)-MXY(10)%MP(2))))
      ENDDO

      CALL FMEQ(MXY(14),MXY(12),QX)
      QX%NDIG = NDSAV1
      IF (MXY(12)%MP(2) == QX%MUNKNO) GO TO 170
      GO TO 180

!             Method 3.  For small positive IVAL use a recurrence involving ExponentialEi.

  150 NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 27
      IF (MXY(1)%MP(1) < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12),QX)
          QX%KFLAG = -4
      ELSE IF (IVAL == 1) THEN
          CALL FMEQ(MXY(1),MXY(3),QX)
          IF (MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(3)%MP(3) /= 0)  &
              MXY(3)%MP(1) = -MXY(3)%MP(1)
          CALL FMEI(MXY(3),MXY(12),QX)
          IF (MXY((12))%MP(2) /= QX%MUNKNO .AND. MXY((12))%MP(3) /= 0)  &
              MXY((12))%MP(1) = -MXY((12))%MP(1)
      ELSE
          IEXTRA = 0
          IF (KFLAGX == 0) THEN
              IEXTRA = INT(IVAL/2.25D0*(LOG(ABS(X))-1.1D0*(LOG(DBLE(IVAL))-1.4D0))*QX%DLOGTN/QX%DLOGMB)
              IEXTRA = MAX(0,IEXTRA)
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
          QX%NDIG = QX%NDIG + IEXTRA
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQ(MXY(1),MXY(3),QX)
          IF (MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(3)%MP(3) /= 0)  &
              MXY(3)%MP(1) = -MXY(3)%MP(1)
          CALL FMEI(MXY(3),MXY(4),QX)
          CALL FMIPWR(MXY(3),IVAL-1,MXY(6),QX)
          CALL FMMPY_R1(MXY(4),MXY(6),QX)
          IF (MXY((4))%MP(2) /= QX%MUNKNO .AND. MXY((4))%MP(3) /= 0)  &
              MXY((4))%MP(1) = -MXY((4))%MP(1)
          IF (MXY(4)%MP(1) > 0) THEN
              CALL FMEQ(MXY(4),MXY(13),QX)
              CALL FMI2M(0,MXY(14),QX)
          ELSE
              CALL FMEQ(MXY(4),MXY(14),QX)
              CALL FMI2M(0,MXY(13),QX)
          ENDIF
          IF (MXY(4)%MP(2) == QX%MEXPUN) THEN
              CALL FMEQ(MXY(4),MXY(12),QX)
          ELSE
              CALL FMEXP(MXY(3),MXY(5),QX)
              CALL FMMPY_R1(MXY(6),MXY(5),QX)
              DO J = IVAL-2, 0, -1
                 CALL FMDIV_R1(MXY(6),MXY(3),QX)
                 IF (MXY(6)%MP(1) > 0) THEN
                     CALL FMADD_R1(MXY(13),MXY(6),QX)
                 ELSE
                     CALL FMADD_R1(MXY(14),MXY(6),QX)
                 ENDIF
                 CALL FMMPYI_R1(MXY(6),IVAL-1-J,QX)
              ENDDO
              CALL FMADD(MXY(13),MXY(14),MXY(12),QX)
              CALL FMCANCEL(MXY(13),MXY(14),MXY(12),K,QX)
              N_ACC = N_ACC - K
              CALL FMFCTI(IVAL-1,MXY(7),QX)
              CALL FMDIV_R1(MXY(12),MXY(7),QX)
          ENDIF
          IF (N_ACC <= NGOAL) THEN
              QX%NDIG = 2*QX%NDIG
              N_ACC = NINT(QX%NDIG*QX%ALOGM2)
              GO TO 110
          ENDIF
      ENDIF
      IF (MXY(12)%MP(2) == QX%MUNKNO) GO TO 170
      GO TO 180

!             Method 4.  For small negative IVAL use a recurrence involving exp.

  160 CALL FMEQ(MXY(1),MXY(3),QX)
      IF (MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(3)%MP(3) /= 0)  &
          MXY(3)%MP(1) = -MXY(3)%MP(1)
      CALL FMI2M(1,MXY(4),QX)
      CALL FMI2M(1,MXY(5),QX)
      DO J = 1, -IVAL
         CALL FMMPY_R1(MXY(5),MXY(1),QX)
         IF (J > 1) CALL FMDIVI_R1(MXY(5),J,QX)
         CALL FMADD_R1(MXY(4),MXY(5),QX)
      ENDDO
      CALL FMMPY_R1(MXY(5),MXY(1),QX)
      CALL FMDIV(MXY(4),MXY(5),MXY(6),QX)
      CALL FMABS(MXY(6),MXY(7),QX)
      CALL FMLN(MXY(7),MXY(8),QX)
      CALL FMSUB(MXY(8),MXY(1),MXY(5),QX)
      CALL FMEXP(MXY(5),MXY(12),QX)
      IF (MXY(12)%MP(2) /= QX%MUNKNO .AND. MXY(6)%MP(1) < 0)  &
          MXY(12)%MP(1) = -MXY(12)%MP(1)
      IF (MXY(12)%MP(2) == QX%MUNKNO) GO TO 170
      GO TO 180

!             Method 5.  use incomplete gamma.

  170 IF (MXY(1)%MP(1) < 0) THEN
          IF (IVAL > 0) THEN
              CALL FMST2M('UNKNOWN',MXY(12),QX)
              QX%KFLAG = -4
          ELSE
              CALL FMI2M(-1,MXY(12),QX)
              IF (IVAL == -1 .AND. FMCOMP(MXY(1),'==',MXY(12),QX)) THEN
                  CALL FMI2M(0,MXY(12),QX)
              ELSE
                  N = 1 - IVAL
                  CALL FMI2M(N,MXY(12),QX)
                  QX%RAISE_NDIG = 1
                  CALL FMIGM2(MXY(12),MXY(1),MXY(13),QX)
                  QX%RAISE_NDIG = 0
                  IF (MXY(13)%MP(2) == QX%MEXPOV) THEN
                      N = IVAL
                      CALL FMI2M(1,MXY(7),QX)
                      CALL FMI2M(1,MXY(8),QX)
                      CALL FMDIV(MXY(8),MXY(1),MXY(9),QX)
                      IF (MXY(9)%MP(2) /= QX%MUNKNO .AND. MXY(9)%MP(3) /= 0)  &
                          MXY(9)%MP(1) = -MXY(9)%MP(1)
                      JS = 0
                      DO J = 0, 10000
                         CALL FMMPYI_R1(MXY(7),N+J,QX)
                         CALL FMMPY_R1(MXY(7),MXY(9),QX)
                         CALL FMADD_R1(MXY(8),MXY(7),QX)
                         IF (QX%KFLAG == 1) THEN
                             JS = 1
                             EXIT
                         ENDIF
                      ENDDO
                      IF (JS == 1) THEN
                          CALL FMLN(MXY(8),MXY(9),QX)
                          CALL FMSUB(MXY(9),MXY(1),MXY(7),QX)
                          CALL FMI2M(0,MXY(6),QX)
                          CALL FMSUB(MXY(6),MXY(1),MXY(2),QX)
                          CALL FMLN(MXY(2),MXY(3),QX)
                          CALL FMSUB(MXY(7),MXY(3),MXY(2),QX)
                          CALL FMEXP(MXY(2),MXY(3),QX)
                          CALL FMSUB(MXY(6),MXY(3),MXY(12),QX)
                      ELSE
                          CALL FMST2M('UNKNOWN',MXY(12),QX)
                          QX%KFLAG = -4
                      ENDIF
                  ELSE
                      CALL FMEQ(MXY(13),MXY(12),QX)
                      N = IVAL - 1
                      CALL FMIPWR(MXY(1),N,MXY(3),QX)
                      CALL FMMPY_R2(MXY(3),MXY(12),QX)
                  ENDIF
              ENDIF
          ENDIF
      ELSE
          N = 1 - IVAL
          CALL FMI2M(N,MXY(12),QX)
          QX%RAISE_NDIG = 1
          CALL FMIGM2(MXY(12),MXY(1),MXY(13),QX)
          QX%RAISE_NDIG = 0
          IF (MXY(13)%MP(2) == QX%MEXPUN .AND. IVAL > 0) THEN
              CALL FMEQ(MXY(1),MXY(4),QX)
              IF (MXY(4)%MP(2) /= QX%MUNKNO .AND. MXY(4)%MP(3) /= 0)  &
                  MXY(4)%MP(1) = -MXY(4)%MP(1)
              CALL FMEXP(MXY(4),MXY(5),QX)
              CALL FMDIV(MXY(5),MXY(1),MXY(6),QX)
              IF (MXY(6)%MP(2) == QX%MEXPUN) THEN
                  CALL FMST2M('UNDERFLOW',MXY(12),QX)
                  QX%KFLAG = -6
              ELSE
                  CALL FMI2M(1,MXY(7),QX)
                  CALL FMI2M(1,MXY(8),QX)
                  CALL FMDIV(MXY(8),MXY(1),MXY(9),QX)
                  IF (MXY(9)%MP(2) /= QX%MUNKNO .AND. MXY(9)%MP(3) /= 0)  &
                      MXY(9)%MP(1) = -MXY(9)%MP(1)
                  JS = 0
                  DO J = 0, 10000
                     CALL FMMPYI_R1(MXY(7),N+J,QX)
                     CALL FMMPY_R1(MXY(7),MXY(9),QX)
                     CALL FMADD_R1(MXY(8),MXY(7),QX)
                     IF (QX%KFLAG == 1) THEN
                         JS = 1
                         EXIT
                     ENDIF
                  ENDDO
                  IF (JS == 1) THEN
                      CALL FMMPY(MXY(6),MXY(8),MXY(12),QX)
                  ELSE
                      CALL FMST2M('UNKNOWN',MXY(12),QX)
                      QX%KFLAG = -4
                  ENDIF
              ENDIF
          ELSE
              CALL FMEQ(MXY(13),MXY(12),QX)
              N = IVAL - 1
              CALL FMIPWR(MXY(1),N,MXY(3),QX)
              CALL FMMPY_R2(MXY(3),MXY(12),QX)
          ENDIF
      ENDIF

  180 QX%NAMEST(QX%NCALL) = 'FMEN'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(12)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(12),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMEN

      SUBROUTINE FMERF(MA,MB,QX)

!  MB = Erf(MA)    Error function.

!  2/Sqrt(pi) * Integral from 0 to MA of e**(-t**2) dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: C1,C2,ERR,X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTEGER :: IEXTRA,J,J2,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NDSAV1,NDSAV2,  &
                 NMETHD,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(13),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      CALL FMENT2('FMERF    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(3),QX)
          GO TO 180
      ENDIF
      IF (MXY(1)%MP(2) == QX%MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(3),QX)
          QX%KFLAG = -4
          GO TO 180
      ENDIF

!             X is a double precision approximation to the input argument to this function.

      MXY(1)%MP(1) = 1
      CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX**0.33D0
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) > 0) THEN
          X = DPMAX**0.33D0
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 use the convergent series,
!                    = 2 use a 2nd convergent series -- slower but no cancellation,
!                    = 3 use a continued fraction expansion.

      C1 = SQRT(QX%DLOGMB*(QX%NDIG+21))/5
      C2 = (QX%DLOGMB*(QX%NDIG+6))**0.6D0/4.1D0
      IF (MXY(1)%MP(2) < 1) THEN
          NMETHD = 1
      ELSE IF (ABS(X) <= C1) THEN
          NMETHD = 1
      ELSE IF (ABS(X) <= C2) THEN
          NMETHD = 2
      ELSE
          NMETHD = 3
      ENDIF
      IF (NMETHD /= 1) GO TO 140

!             Method 1.  Use the (-1)**n x**(2n+1) / n! / (2n+1) series.

!             If MA is large in magnitude, use more guard digits.

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      IF (KFLAGX == 0) THEN
          IF (ABS(X) > 2 .AND. ABS(X) < SQRT(HUGE(X))) THEN
              IEXTRA = MAX(INT((X*X-1.83-LOG(2*X*X+1))/QX%ALOGMB+1),0)
              IF (IEXTRA > 0) THEN
                  CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
              ENDIF
              QX%NDIG = QX%NDIG + IEXTRA
          ENDIF
      ENDIF
      IF (KFLAGX == 0) THEN
          J2 = INT(0.66*SQRT(FMNTERMS(X**2,1,0,0,1,QX)) - 0.8)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL FMI2M(1,MXY(6),QX)
      CALL FMI2M(1,MJSUMS(1),QX)
      DO J = 2, J2
         IF (NTERM > 1) CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         CALL FMCSDIVI(MXY(6),2*NTERM+1,MJSUMS(J),QX)
         NTERM = NTERM + 1
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 130
      CALL FMIPWR(MXY(1),2*J2,MXY(5),QX)

  120 CALL FMCSMPY_R1(MXY(6),MXY(5),QX)
      DO J = 1, J2
         CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
         CALL FMCSDIVI(MXY(6),2*NTERM+1,MXY(4),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMSQR(MXY(1),MXY(4),QX)
      IF (MXY(4)%MP(2) /= QX%MUNKNO .AND. MXY(4)%MP(3) /= 0)  &
          MXY(4)%MP(1) = -MXY(4)%MP(1)
      CALL FMEQ(MJSUMS(J2),MXY(5),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(4),QX)
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1),QX)
      ENDDO
      CALL FMCSMPY_R1(MXY(5),MXY(1),QX)

      CALL FMPI(MXY(4),QX)
      CALL FMSQRT(MXY(4),MXY(3),QX)
      CALL FMCSMPYI(MXY(5),2,MXY(4),QX)
      CALL FMDIV_R2(MXY(4),MXY(3),QX)
      GO TO 180

  140 IF (NMETHD /= 2) GO TO 170

!             Method 2.  Use the x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      MXY(1)%MP(1) = 1
      IF (KFLAGX == 0) THEN
          J2 = INT(0.51*SQRT(FMNTERMS(2*X,2,-1,0,1,QX)))
      ELSE
          J2 = 1
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL FMCSMPYI(MXY(1),2,MXY(6),QX)
      CALL FMEQ(MXY(6),MJSUMS(1),QX)
      DO J = 2, J2
         CALL FMCSMPYI_R1(MXY(6),2,QX)
         CALL FMCSDIVI_R1(MXY(6),2*NTERM+1,QX)
         CALL FMEQ(MXY(6),MJSUMS(J),QX)
         NTERM = NTERM + 1
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 160
      CALL FMIPWR(MXY(1),2*J2,MXY(5),QX)

  150 CALL FMCSMPY_R1(MXY(6),MXY(5),QX)
      DO J = 1, J2
         CALL FMCSMPYI_R1(MXY(6),2,QX)
         CALL FMCSDIVI_R1(MXY(6),2*NTERM+1,QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(6),QX)
         IF (QX%KFLAG /= 0) GO TO 160
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(6)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 150

!             Put the J2 separate sums back together.

  160 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMSQR(MXY(1),MXY(6),QX)
      CALL FMEQ(MJSUMS(J2),MXY(5),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(5),MXY(6),QX)
         CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1),QX)
      ENDDO

      CALL FMPI(MXY(4),QX)
      CALL FMSQRT(MXY(4),MXY(3),QX)
      CALL FMDIV_R2(MXY(5),MXY(3),QX)
      CALL FMEXP(MXY(6),MXY(4),QX)
      CALL FMDIV_R1(MXY(3),MXY(4),QX)

      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(2) is abs(x).
!             MXY(3) is abs(2x).
!             MXY(4) is -x*x.
!             MXY(13) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  170 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      NDSAV1 = QX%NDIG
      CALL FMABS(MXY(1),MXY(2),QX)
      CALL FMMPYI(MXY(2),2,MXY(3),QX)
      CALL FMSQR(MXY(2),MXY(4),QX)
      IF (MXY(4)%MP(2) /= QX%MUNKNO .AND. MXY(4)%MP(3) /= 0)  &
          MXY(4)%MP(1) = -MXY(4)%MP(1)
      CALL FMI2M(0,MXY(8),QX)
      CALL FMI2M(1,MXY(9),QX)
      CALL FMI2M(1,MXY(10),QX)
      CALL FMI2M(1,MXY(13),QX)
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = QX%NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMEQ(MXY(2),MXY(11),QX)
             CALL FMCSMPY_R1(MXY(11),MXY(9),QX)
         ELSE
             CALL FMEQ(MXY(3),MXY(11),QX)
             CALL FMCSMPY_R1(MXY(11),MXY(9),QX)
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7),QX)
             CALL FMEXP(MXY(4),MXY(5),QX)
             CALL FMPI(MXY(12),QX)
             CALL FMSQRT(MXY(12),MXY(6),QX)
             CALL FMDIV(MXY(5),MXY(6),MXY(10),QX)
             CALL FMDIV_R1(MXY(10),MXY(2),QX)
             IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
                 MXY(10)%MP(1) = -MXY(10)%MP(1)
         ELSE
             CALL FMCSMPYI(MXY(8),J-1,MXY(12),QX)
             CALL FMADD(MXY(11),MXY(12),MXY(7),QX)
             CALL FMCSMPY_R1(MXY(10),MXY(12),QX)
             CALL FMEQ(MXY(10),MXY(5),QX)
             CALL FMCSDIV(MXY(5),MXY(7),MXY(10),QX)
             IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
                 MXY(10)%MP(1) = -MXY(10)%MP(1)
         ENDIF
         CALL FMEQ(MXY(9),MXY(8),QX)
         CALL FMEQ(MXY(7),MXY(9),QX)
         QX%NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(13),MXY(10),QX)

!             Check for convergence.

         IF (QX%KFLAG == 1) THEN
             EXIT
         ENDIF
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(13)%MP(2)-MXY(10)%MP(2))))
      ENDDO

      CALL FMEQ(MXY(13),MXY(3),QX)
      QX%NDIG = NDSAV1
  180 IF (QX%KROUND /= 1) THEN
          IF (MXY(3)%MP(2) == 1 .AND. MA%MP(1) > 0 .AND.  &
              (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
              CALL FMTINY(MXY(1),QX)
              CALL FMSUB_R1(MXY(3),MXY(1),QX)
          ENDIF
          IF (MXY(3)%MP(2) == 1 .AND. MA%MP(1) < 0 .AND.  &
              (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
              KRSAVE = QX%KROUND
              QX%KROUND = 0
              CALL FMTINY(MXY(1),QX)
              CALL FMSUB_R1(MXY(3),MXY(1),QX)
              QX%KROUND = KRSAVE
          ENDIF
          IF (QX%KFLAG == 1) QX%KFLAG = 0
      ENDIF

      IF (MA%MP(1) < 0) THEN
          IF (MXY(3)%MP(2) /= QX%MUNKNO .AND. MXY(3)%MP(3) /= 0)  &
              MXY(3)%MP(1) = -MXY(3)%MP(1)
      ENDIF
      QX%NAMEST(QX%NCALL) = 'FMERF'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMERF

      SUBROUTINE FMERFC(MA,MB,QX)

!  MB = ERFC(MA)    Complimentary Error function.

!  2/Sqrt(pi) * Integral from MA to infinity of e**(-t**2) dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: C1,ERR,X
      TYPE(FM_SETTINGS) :: QX
      INTEGER :: IEXTRA,J,K,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,  &
                 NDSAVE,NDSAV1,NDSAV2,NMETHD,NTERMS
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(13)

      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMI2M(1,MXY(4),QX)
          IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMI2M(0,MXY(2),QX)
              CALL FMSUB(MXY(2),MXY(1),MXY(5),QX)
          ELSE
              CALL FMPI(MXY(2),QX)
              CALL FMSQRT(MXY(2),MXY(3),QX)
              CALL FMDIV(MXY(4),MXY(3),MXY(5),QX)
              CALL FMMPYI(MXY(5),-2,MXY(6),QX)
              CALL FMMPY(MXY(1),MXY(6),MXY(5),QX)
          ENDIF
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG) THEN
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
              QX%NDIG = NDSAVE
              QX%KROUND = KRSAVE
              CALL FMADD(MXY(6),MXY(7),MB,QX)
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMERFC'
                  CALL FMNTR(2,MA,MA,1,1,QX)
                  CALL FMNTR(1,MB,MB,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMERFC   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMI2M(1,MXY(3),QX)
      CALL FMDIVI_R1(MXY(3),2,QX)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0 .OR. MXY(1)%MP(2) == QX%MEXPUN) THEN
          CALL FMI2M(1,MXY(3),QX)
          GO TO 130
      ENDIF

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X,QX)
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
      ENDIF
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) > 0) THEN
          X = DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use 1 - erf(x),
!                    = 2 means use the continued fraction expansion.

      C1 = (QX%DLOGMB*(QX%NDIG+6))**0.7D0/9
      IF (MXY(1)%MP(2) < 1) THEN
          NMETHD = 1
      ELSE IF (X <= C1) THEN
          NMETHD = 1
      ELSE
          NMETHD = 2
      ENDIF
      IF (NMETHD /= 1) GO TO 120

!             Method 1.  Use ERF.

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1 .AND. QX%NDIG < 100) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      IF (X < 2) THEN
          CALL FMERF(MXY(1),MXY(4),QX)
          CALL FMI2M(1,MXY(2),QX)
          CALL FMSUB(MXY(2),MXY(4),MXY(3),QX)
          GO TO 130
      ENDIF

!             Raise precision to compensate for cancellation if x is large.

      IEXTRA = MAX(INT((X*X+LOG(2*X))/QX%ALOGMB+1),0)
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      QX%RAISE_NDIG = 1
      CALL FMERF(MXY(1),MXY(4),QX)
      QX%RAISE_NDIG = 0
      CALL FMI2M(1,MXY(2),QX)
      CALL FMSUB(MXY(2),MXY(4),MXY(3),QX)
      GO TO 130

  120 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      NDSAV1 = QX%NDIG

!             Method 2.  Use the continued fraction expansion.

!             MXY(2) is abs(x).
!             MXY(3) is abs(2x).
!             MXY(4) is -x*x.
!             MXY(13) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

      CALL FMABS(MXY(1),MXY(2),QX)
      CALL FMMPYI(MXY(2),2,MXY(3),QX)
      CALL FMSQR(MXY(2),MXY(4),QX)
      IF (MXY(4)%MP(2) /= QX%MUNKNO .AND. MXY(4)%MP(3) /= 0)  &
          MXY(4)%MP(1) = -MXY(4)%MP(1)
      CALL FMI2M(0,MXY(8),QX)
      CALL FMI2M(1,MXY(9),QX)
      CALL FMI2M(1,MXY(10),QX)
      CALL FMI2M(0,MXY(13),QX)
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = QX%NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMEQ(MXY(2),MXY(11),QX)
             CALL FMCSMPY_R1(MXY(11),MXY(9),QX)
         ELSE
             CALL FMEQ(MXY(3),MXY(11),QX)
             CALL FMCSMPY_R1(MXY(11),MXY(9),QX)
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7),QX)
             CALL FMEXP(MXY(4),MXY(5),QX)
             CALL FMPI(MXY(12),QX)
             CALL FMSQRT(MXY(12),MXY(6),QX)
             CALL FMDIV(MXY(5),MXY(6),MXY(10),QX)
             CALL FMDIV_R1(MXY(10),MXY(2),QX)
             IF (MXY(10)%MP(2) == QX%MEXPUN) THEN
                 CALL FMEQ(MXY(10),MXY(3),QX)
                 GO TO 130
             ENDIF
         ELSE
             CALL FMCSMPYI(MXY(8),J-1,MXY(12),QX)
             CALL FMADD(MXY(11),MXY(12),MXY(7),QX)
             CALL FMCSMPY_R1(MXY(10),MXY(12),QX)
             CALL FMEQ(MXY(10),MXY(5),QX)
             CALL FMCSDIV(MXY(5),MXY(7),MXY(10),QX)
             IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
                 MXY(10)%MP(1) = -MXY(10)%MP(1)
         ENDIF
         CALL FMEQ(MXY(9),MXY(8),QX)
         CALL FMEQ(MXY(7),MXY(9),QX)
         QX%NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(13),MXY(10),QX)

!             Check for convergence.

         IF (J > 1 .AND. QX%KFLAG == 1) THEN
             EXIT
         ENDIF
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(13)%MP(2)-MXY(10)%MP(2))))
      ENDDO

      CALL FMEQ(MXY(13),MXY(3),QX)
      QX%NDIG = NDSAV1

  130 QX%NAMEST(QX%NCALL) = 'FMERFC'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (QX%KROUND == -1 .OR. QX%KROUND == 0) THEN
          CALL FMI2M(2,MXY(1),QX)
          IF (FMCOMP(MXY(3),'==',MXY(1),QX)) THEN
              CALL FMDP2M(1.9999D0,MXY(2),QX)
              CALL FMULP(MXY(2),MXY(4),QX)
              CALL FMSUB(MXY(1),MXY(4),MXY(3),QX)
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMERFC

      SUBROUTINE FMERFCS(MA,MB,QX)

!  MB = ERFC_SCALED(MA)    Scaled Complimentary Error function.

!     = exp(x^2) * erfc(x)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: C1,ERR,X
      TYPE(FM_SETTINGS) :: QX
      INTEGER :: IEXTRA,J,K,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,  &
                 NDSAVE,NDSAV1,NDSAV2,NMETHD,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(13)

      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1 .AND. MA%MP(2) < -QX%NDIG) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMI2M(1,MXY(4),QX)
          IF (MA%MP(2) == QX%MEXPUN) THEN
              CALL FMI2M(0,MXY(2),QX)
              CALL FMSUB(MXY(2),MXY(1),MXY(5),QX)
          ELSE
              CALL FMPI(MXY(2),QX)
              CALL FMSQRT(MXY(2),MXY(3),QX)
              CALL FMDIV(MXY(4),MXY(3),MXY(5),QX)
              CALL FMMPYI(MXY(5),-2,MXY(6),QX)
              CALL FMMPY(MXY(1),MXY(6),MXY(5),QX)
          ENDIF
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG) THEN
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
              QX%NDIG = NDSAVE
              QX%KROUND = KRSAVE
              CALL FMADD(MXY(6),MXY(7),MB,QX)
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NCALL = QX%NCALL + 1
                  QX%NAMEST(QX%NCALL) = 'FMERFCS'
                  CALL FMNTR(2,MA,MA,1,1,QX)
                  CALL FMNTR(1,MB,MB,1,1,QX)
                  QX%NCALL = QX%NCALL - 1
              ENDIF
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMERFCS  ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMI2M(1,MXY(3),QX)
      CALL FMDIVI_R1(MXY(3),2,QX)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0 .OR. MXY(1)%MP(2) == QX%MEXPUN) THEN
          CALL FMI2M(1,MXY(3),QX)
          GO TO 130
      ENDIF

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X,QX)
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
      ENDIF
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) > 0) THEN
          X = DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use exp(x^2) * (1 - erf(x)),
!                    = 2 means use the continued fraction expansion.

      C1 = (QX%DLOGMB*(QX%NDIG+6))**0.7D0/9
      IF (MXY(1)%MP(2) < 1) THEN
          NMETHD = 1
      ELSE IF (X <= C1) THEN
          NMETHD = 1
      ELSE
          NMETHD = 2
      ENDIF
      IF (NMETHD /= 1) GO TO 120

!             Method 1.  Use ERF.

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1 .AND. QX%NDIG < 100) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      IF (X < 2) THEN
          QX%RAISE_NDIG = 1
          CALL FMERF(MXY(1),MXY(4),QX)
          QX%RAISE_NDIG = 0
          CALL FMI2M(1,MXY(2),QX)
          CALL FMSUB(MXY(2),MXY(4),MXY(3),QX)
          CALL FMSQR(MXY(1),MXY(2),QX)
          CALL FMEXP(MXY(2),MXY(4),QX)
          CALL FMMPY_R1(MXY(3),MXY(4),QX)
          GO TO 130
      ENDIF

!             Raise precision to compensate for cancellation if x is large.

      IEXTRA = MAX(INT((X*X+LOG(2*X))/QX%ALOGMB+1),0)
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      QX%RAISE_NDIG = 1
      CALL FMERF(MXY(1),MXY(4),QX)
      QX%RAISE_NDIG = 0
      CALL FMI2M(1,MXY(2),QX)
      CALL FMSUB(MXY(2),MXY(4),MXY(3),QX)
      CALL FMSQR(MXY(1),MXY(2),QX)
      CALL FMEXP(MXY(2),MXY(4),QX)
      CALL FMMPY_R1(MXY(3),MXY(4),QX)
      GO TO 130

  120 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      NDSAV1 = QX%NDIG

!             Method 2.  Use the continued fraction expansion.

!             MXY(2) is abs(x).
!             MXY(3) is abs(2x).
!             MXY(13) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

      CALL FMABS(MXY(1),MXY(2),QX)
      CALL FMMPYI(MXY(2),2,MXY(3),QX)
      CALL FMI2M(0,MXY(8),QX)
      CALL FMI2M(1,MXY(9),QX)
      CALL FMI2M(1,MXY(10),QX)
      CALL FMI2M(0,MXY(13),QX)
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = QX%NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMEQ(MXY(2),MXY(11),QX)
             CALL FMCSMPY_R1(MXY(11),MXY(9),QX)
         ELSE
             CALL FMEQ(MXY(3),MXY(11),QX)
             CALL FMCSMPY_R1(MXY(11),MXY(9),QX)
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7),QX)
             CALL FMI2M(1,MXY(5),QX)
             CALL FMPI(MXY(12),QX)
             CALL FMSQRT(MXY(12),MXY(6),QX)
             CALL FMDIV(MXY(5),MXY(6),MXY(10),QX)
             CALL FMDIV_R1(MXY(10),MXY(2),QX)
             IF (MXY(10)%MP(2) == QX%MEXPUN) THEN
                 CALL FMEQ(MXY(10),MXY(3),QX)
                 GO TO 130
             ENDIF
         ELSE
             CALL FMCSMPYI(MXY(8),J-1,MXY(12),QX)
             CALL FMADD(MXY(11),MXY(12),MXY(7),QX)
             CALL FMCSMPY_R1(MXY(10),MXY(12),QX)
             CALL FMEQ(MXY(10),MXY(5),QX)
             CALL FMCSDIV(MXY(5),MXY(7),MXY(10),QX)
             IF (MXY(10)%MP(2) /= QX%MUNKNO .AND. MXY(10)%MP(3) /= 0)  &
                 MXY(10)%MP(1) = -MXY(10)%MP(1)
         ENDIF
         CALL FMEQ(MXY(9),MXY(8),QX)
         CALL FMEQ(MXY(7),MXY(9),QX)
         QX%NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(13),MXY(10),QX)

!             Check for convergence.

         IF (J > 1 .AND. QX%KFLAG == 1) THEN
             EXIT
         ENDIF
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(13)%MP(2)-MXY(10)%MP(2))))
      ENDDO

      CALL FMEQ(MXY(13),MXY(3),QX)
      QX%NDIG = NDSAV1

  130 QX%NAMEST(QX%NCALL) = 'FMERFCS'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      CALL FMEXT2(MXY(3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMERFCS

      SUBROUTINE FMFGFI(MA,MB,MC,QX)

!  Internal routine for the two auxiliary asymptotic series used in the sine and cosine
!  Fresnel integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 - 1*3/(pi*x*x)**2 + 1*3*5*7/(pi*x*x)**4 - ...) / (pi*x)
!  MC = g(x) = (1 - 1*3*5/(pi*x*x)**2 + 1*3*5*7*9/(pi*x*x)**4 - ...) / (pi**2*x**3)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NBOT,NDSAV1,NTERM,NTERMS
      DOUBLE PRECISION :: X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(MULTI) :: MXY(6),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      NTERMS = INT(INTMAX/10)
      CALL FMM2DP(MA,X,QX)
      IF (QX%KFLAG == 0) THEN
          J2 = INT(0.35*SQRT(FMNTERMS(3.14159D0*X*X/2,2,0,0,0,QX)) - 0.2)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS/2))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      CALL FMI2M(1,MXY(4),QX)
      CALL FMDIV(MXY(4),MA,MXY(2),QX)
      CALL FMSQR(MXY(2),MXY(6),QX)
      CALL FMPI(MXY(1),QX)
      CALL FMDIV(MXY(6),MXY(1),MXY(2),QX)
      CALL FMSQR(MXY(2),MXY(6),QX)
      NTERM = 0
      DO J = 1, J2
         NBOT = 2*NTERM - 1
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(4),NBOT,QX)
         CALL FMEQ(MXY(4),MJSUMS(J),QX)
         NTERM = NTERM + 1

         NBOT = 2*NTERM - 1
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(4),NBOT,QX)
         CALL FMEQ(MXY(4),MJSUMS(J2+J),QX)
         NTERM = NTERM + 1
      ENDDO
      IF (MXY(6)%MP(2)+MXY(4)%MP(2) < -QX%NDIG-3) GO TO 110
      CALL FMIPWR(MXY(6),J2,MXY(3),QX)

      DO JTERMS = 1, NTERMS
         CALL FMCSMPY_R1(MXY(4),MXY(3),QX)
         DO J = 1, J2
            NBOT = 2*NTERM - 1
            CALL FMCSMPYI_R1(MXY(4),NBOT,QX)
            QX%NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
            IF (QX%KFLAG /= 0) GO TO 110
            QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
            NTERM = NTERM + 1

            NBOT = 2*NTERM - 1
            CALL FMCSMPYI_R1(MXY(4),NBOT,QX)
            QX%NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J2+J),MXY(4),QX)
            IF (QX%KFLAG /= 0) GO TO 110
            QX%NDIG = NDSAV1 - INT(MJSUMS(J2+J)%MP(2)-MXY(4)%MP(2))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 QX%KFLAG = 0
      CALL FMCSNSUMS(2*J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(3),QX)
      CALL FMEQ(MJSUMS(J2+J2),MXY(5),QX)
      IF( MXY(6)%MP(2) /= QX%MUNKNO .AND. MXY(6)%MP(3) /= 0) MXY(6)%MP(1) = -1
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(3),MXY(6),QX)
         CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1),QX)

         CALL FMCSMPY_R1(MXY(5),MXY(6),QX)
         CALL FMADD_R1(MXY(5),MJSUMS(J2+J2-J+1),QX)
      ENDDO
      CALL FMMPY(MA,MXY(1),MXY(2),QX)
      CALL FMDIV(MXY(3),MXY(2),MB,QX)

      CALL FMSQR(MXY(2),MXY(3),QX)
      CALL FMMPY(MXY(3),MA,MXY(2),QX)
      CALL FMDIV(MXY(5),MXY(2),MC,QX)

      QX%NDIG = NDSAV1
      RETURN
      END SUBROUTINE FMFGFI

      SUBROUTINE FMFHGH(MA,MB,MC,QX)

!  Internal routine for the two auxiliary asymptotic series used in the hyperbolic sine and
!  cosine integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 + 2!/x**2 + 4!/x**4 + ...) / x
!  MC = g(x) = (1 + 3!/x**2 + 5!/x**4 + ...) / x**2

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NBOT,NDSAV1,NTERM,NTERMS
      DOUBLE PRECISION :: X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(MULTI) :: MXY(5),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      NTERMS = INT(INTMAX/10)
      CALL FMM2DP(MA,X,QX)
      IF (QX%KFLAG == 0) THEN
          J2 = INT(0.30*SQRT(FMNTERMS(X,2,0,0,0,QX)) + 0.8)
          J2 = MAX(1,MIN(LJSUMS/2,J2))
      ELSE
          J2 = 1
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      CALL FMI2M(1,MXY(3),QX)
      CALL FMDIV(MXY(3),MA,MXY(1),QX)
      CALL FMSQR(MXY(1),MXY(5),QX)
      NTERM = 0
      DO J = 1, J2
         NBOT = NTERM
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(3),NBOT,QX)
         CALL FMEQ(MXY(3),MJSUMS(J),QX)
         NTERM = NTERM + 1

         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(3),NTERM,QX)
         CALL FMEQ(MXY(3),MJSUMS(J2+J),QX)
         NTERM = NTERM + 1
      ENDDO
      IF (MXY(5)%MP(2)+MXY(3)%MP(2) < -QX%NDIG-3) GO TO 110
      CALL FMIPWR(MXY(5),J2,MXY(2),QX)

      DO JTERMS = 1, NTERMS
         CALL FMCSMPY_R1(MXY(3),MXY(2),QX)
         DO J = 1, J2
            NBOT = NTERM
            CALL FMCSMPYI_R1(MXY(3),NBOT,QX)
            QX%NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J),MXY(3),QX)
            IF (QX%KFLAG /= 0) GO TO 110
            QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(3)%MP(2))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
            NTERM = NTERM + 1

            CALL FMCSMPYI_R1(MXY(3),NTERM,QX)
            QX%NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J2+J),MXY(3),QX)
            IF (QX%KFLAG /= 0) GO TO 110
            QX%NDIG = NDSAV1 - INT(MJSUMS(J2+J)%MP(2)-MXY(3)%MP(2))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 QX%KFLAG = 0
      CALL FMCSNSUMS(2*J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(2),QX)
      CALL FMEQ(MJSUMS(2*J2),MXY(4),QX)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(2),MXY(5),QX)
         CALL FMADD_R1(MXY(2),MJSUMS(J2-J+1),QX)

         CALL FMCSMPY_R1(MXY(4),MXY(5),QX)
         CALL FMADD_R1(MXY(4),MJSUMS(J2+J2-J+1),QX)
      ENDDO
      CALL FMDIV(MXY(2),MA,MB,QX)
      CALL FMMPY(MXY(4),MXY(5),MC,QX)

      QX%NDIG = NDSAV1
      RETURN
      END SUBROUTINE FMFHGH

      SUBROUTINE FMFXGX(MA,MB,MC,QX)

!  Internal routine for the two auxiliary asymptotic series used in the sine and
!  cosine integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 - 2!/x**2 + 4!/x**4 - ...) / x
!  MC = g(x) = (1 - 3!/x**2 + 5!/x**4 - ...) / x**2

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NDSAV1,NTERM,NTERMS
      DOUBLE PRECISION :: X
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(MULTI) :: MXY(5),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX


      NTERMS = INT(INTMAX/10)
      CALL FMM2DP(MA,X,QX)
      IF (QX%KFLAG == 0) THEN
          J2 = INT(0.38*SQRT(FMNTERMS(X,2,0,0,0,QX)) - 0.2)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS/2))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      CALL FMI2M(1,MXY(3),QX)
      CALL FMDIV(MXY(3),MA,MXY(1),QX)
      CALL FMSQR(MXY(1),MXY(5),QX)
      NTERM = 0
      DO J = 1, J2
         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(3),NTERM,QX)
         CALL FMEQ(MXY(3),MJSUMS(J),QX)
         NTERM = NTERM + 1

         IF (NTERM >= 2) CALL FMCSMPYI_R1(MXY(3),NTERM,QX)
         CALL FMEQ(MXY(3),MJSUMS(J2+J),QX)
         NTERM = NTERM + 1
      ENDDO
      IF (MXY(5)%MP(2)+MXY(3)%MP(2) < -QX%NDIG-3) GO TO 110
      CALL FMIPWR(MXY(5),J2,MXY(2),QX)

      DO JTERMS = 1, NTERMS
         CALL FMCSMPY_R1(MXY(3),MXY(2),QX)
         DO J = 1, J2
            CALL FMCSMPYI_R1(MXY(3),NTERM,QX)
            QX%NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J),MXY(3),QX)
            IF (QX%KFLAG /= 0) GO TO 110
            QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(3)%MP(2))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
            NTERM = NTERM + 1

            CALL FMCSMPYI_R1(MXY(3),NTERM,QX)
            QX%NDIG = NDSAV1
            CALL FMCSADDNN_R1(MJSUMS(J2+J),MXY(3),QX)
            IF (QX%KFLAG /= 0) GO TO 110
            QX%NDIG = NDSAV1 - INT(MJSUMS(J2+J)%MP(2)-MXY(3)%MP(2))
            QX%NDIG = MIN(NDSAV1,QX%NDIG)
            IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 QX%KFLAG = 0
      CALL FMCSNSUMS(2*J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(2),QX)
      CALL FMEQ(MJSUMS(J2+J2),MXY(4),QX)
      IF (MXY(5)%MP(2) /= QX%MUNKNO .AND. MXY(5)%MP(3) /= 0)  &
          MXY(5)%MP(1) = -MXY(5)%MP(1)
      DO J = 2, J2
         CALL FMCSMPY_R1(MXY(2),MXY(5),QX)
         CALL FMADD_R1(MXY(2),MJSUMS(J2-J+1),QX)

         CALL FMCSMPY_R1(MXY(4),MXY(5),QX)
         CALL FMADD_R1(MXY(4),MJSUMS(J2+J2-J+1),QX)
      ENDDO
      CALL FMDIV(MXY(2),MA,MB,QX)
      MXY(5)%MP(1) = 1
      CALL FMMPY(MXY(4),MXY(5),MC,QX)

      QX%NDIG = NDSAV1
      RETURN
      END SUBROUTINE FMFXGX

      SUBROUTINE FMLERC(MA,MB,QX)

!  MB = Ln(erfc(MA))

!  MA must be positive, and is assumed to be large enough that erfc(MA) might underflow.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JEXTRA,KL,KOVUN,KR_RETRY,KRESLT,NDSAV1,NDSAV2,NDSAVE,NMETHD,NTERMS
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(16)
      TYPE(FM_SETTINGS) :: QX


      CALL FMENT2('FMLERC   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

      NTERMS = INT(INTMAX/10)

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(11),QX)
          GO TO 140
      ENDIF
      IF (MXY(1)%MP(2) == QX%MEXPUN) THEN
          QX%KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(11),QX)
          GO TO 140
      ENDIF
      IF (MXY(1)%MP(2) == QX%MEXPOV .AND. MXY(1)%MP(1) > 0) THEN
              CALL FMST2M('-OVERFLOW',MXY(11),QX)
              QX%KFLAG = -5
          GO TO 140
      ENDIF

!             Close to zero use the series for Ln(1-erf(x)).

      IF (LOG(MXY(1)%MP(3)+1.0D0)+(MXY(1)%MP(2)-1)*QX%DLOGMB < -10.0D0*QX%DLOGTN) THEN
          CALL FMERF(MXY(1),MXY(10),QX)
          CALL FMEQ(MXY(10),MXY(11),QX)
          CALL FMEQ(MXY(10),MXY(6),QX)
          IF (MXY(11)%MP(2) /= QX%MUNKNO .AND. MXY(11)%MP(3) /= 0)  &
              MXY(11)%MP(1) = -MXY(11)%MP(1)
          DO J = 2, NTERMS
             CALL FMMPY_R1(MXY(6),MXY(10),QX)
             CALL FMDIVI(MXY(6),J,MXY(3),QX)
             CALL FMSUB_R1(MXY(11),MXY(3),QX)
             IF (QX%KFLAG == 1) EXIT
          ENDDO
          GO TO 140
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use FMERFC,
!                    = 2 means use the asymptotic value,
!                    = 3 means use the continued fraction expansion.

      NMETHD = 1
      CALL FMI2M(1000,MXY(3),QX)
      IF (MXY(1)%MP(2) >= QX%NDIG) THEN
          NMETHD = 2
      ELSE IF(FMCOMP(MXY(1),'>',MXY(3),QX)) THEN
          NMETHD = 3
      ENDIF

      IF (NMETHD == 2) GO TO 120
      IF (NMETHD == 3) GO TO 130

!             Method 1.  Use FMERFC.

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      CALL FMERFC(MXY(1),MXY(15),QX)
      CALL FMLN(MXY(15),MXY(11),QX)

      QX%NAMEST(QX%NCALL) = 'FMLERC'

      GO TO 140

!             Method 2.  Use the asymptotic value.

  120 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      IF (MXY(1)%MP(1) == 1) THEN
          CALL FMPI(MXY(16),QX)
          CALL FMSQRT(MXY(16),MXY(3),QX)
          CALL FMMPY_R1(MXY(3),MXY(1),QX)
          CALL FMI2M(1,MXY(2),QX)
          CALL FMDIV(MXY(2),MXY(3),MXY(11),QX)
          CALL FMLN(MXY(11),MXY(4),QX)
          CALL FMSQR(MXY(1),MXY(5),QX)
          CALL FMSUB(MXY(4),MXY(5),MXY(11),QX)
      ELSE
          CALL FMI2M(2,MXY(3),QX)
          CALL FMLN(MXY(3),MXY(11),QX)
      ENDIF

      GO TO 140

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(11) is the term in the sum, S(k).
!             MXY(9), MXY(10) are the latest denominators, Q(k-1) and Q(k).

  130 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      NDSAV1 = QX%NDIG
      JEXTRA = INT(MAX(1.0,5.76/QX%ALOGMB + 1.0))
      IF (QX%NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + JEXTRA
      CALL FMI2M(1,MXY(9),QX)
      CALL FMEQ(MXY(1),MXY(10),QX)
      CALL FMI2M(1,MXY(11),QX)
      CALL FMI2M(1,MXY(14),QX)

!             Method 3 continued fraction loop.

      NDSAV2 = QX%NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 0) THEN
             CALL FMCSMPYI(MXY(9),J/2,MXY(7),QX)
             CALL FMEQ(MXY(1),MXY(3),QX)
             CALL FMCSMPY_R1(MXY(3),MXY(10),QX)
             CALL FMADD(MXY(3),MXY(7),MXY(8),QX)
         ELSE
             CALL FMCSMPYI(MXY(9),J,MXY(3),QX)
             CALL FMCSDIVI(MXY(3),2,MXY(7),QX)
             CALL FMEQ(MXY(1),MXY(3),QX)
             CALL FMCSMPY_R1(MXY(3),MXY(10),QX)
             CALL FMADD(MXY(3),MXY(7),MXY(8),QX)
         ENDIF
         CALL FMEQ(MXY(7),MXY(3),QX)
         CALL FMCSMPY_R1(MXY(3),MXY(11),QX)
         CALL FMDIV(MXY(3),MXY(8),MXY(11),QX)
         IF (MXY(11)%MP(2) /= QX%MUNKNO .AND. MXY(11)%MP(3) /= 0)  &
             MXY(11)%MP(1) = -MXY(11)%MP(1)
         QX%NDIG = NDSAV2
         CALL FMCSADD_R1(MXY(14),MXY(11),QX)

!             Check for convergence.

         IF (QX%KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(10),MXY(9),QX)
         CALL FMEQ(MXY(8),MXY(10),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(MXY(14)%MP(2)-MXY(11)%MP(2))))
      ENDDO

      CALL FMEQU_R1(MXY(14),QX%NDIG,NDSAV1,QX)
      QX%NDIG = NDSAV1
      CALL FMPI(MXY(16),QX)
      CALL FMSQRT(MXY(16),MXY(3),QX)
      CALL FMDIV(MXY(14),MXY(3),MXY(11),QX)
      CALL FMDIV(MXY(11),MXY(1),MXY(12),QX)
      CALL FMLN(MXY(12),MXY(13),QX)
      CALL FMSQR(MXY(1),MXY(12),QX)
      IF (MXY(12)%MP(2) < QX%MEXPOV) THEN
          CALL FMSUB(MXY(13),MXY(12),MXY(11),QX)
      ELSE
          CALL FMEQ(MXY(12),MXY(11),QX)
          IF (MXY(11)%MP(2) /= QX%MUNKNO .AND. MXY(11)%MP(3) /= 0)  &
              MXY(11)%MP(1) = -MXY(11)%MP(1)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  140 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(11)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMLERC

      SUBROUTINE FMLI(MA,MB,QX)

!  MB = Logarithmic Integral(MA)

!  Integral from 0 to MA of 1 / Ln(t)  dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR,X
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(3)
      TYPE(FM_SETTINGS) :: QX


      CALL FMENT2('FMLI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(2),QX)
      ELSE IF (MXY(1)%MP(2) == QX%MEXPUN .AND. MXY(1)%MP(1) == 1) THEN
          CALL FMST2M('-UNDERFLOW',MXY(2),QX)
          QX%KFLAG = -6
      ELSE
          CALL FMLN(MXY(1),MXY(3),QX)
          CALL FMEI(MXY(3),MXY(2),QX)
      ENDIF

      QX%NAMEST(QX%NCALL) = 'FMLI'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(2)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      KL = QX%KFLAG
      CALL FMM2DP(MXY(1),X,QX)
      IF (QX%KFLAG == 0 .AND. KL == 0) THEN
          IF (X > 1.44 .AND. X < 1.46) THEN
              IF (MXY(2)%MP(2) < 0) THEN
                  IF (KR_RETRY <= 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
                      KR_RETRY = 2
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
      ENDIF
      QX%KFLAG = KL
      CALL FMEXT2(MXY(2),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMLI

      SUBROUTINE FMS(MA,MB,QX)

!  MB = S(MA)    Fresnel Sine Integral.

!  Integral from 0 to MA of Sin(pi*t**2/2) dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J2,JR,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NBOT,  &
                 NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY,N_ACC

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(16),MRETRY,MJSUMS(LJSUMS)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX


      CALL FMENT2('FMS      ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      MXY(1)%MP(1) = 1
      NUMTRY = 0

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(11),QX)
          GO TO 180
      ENDIF
      IF (4*MXY(1)%MP(2) < -QX%NDIG) THEN
          CALL FMSQR(MXY(1),MXY(11),QX)
          CALL FMMPY_R2(MXY(1),MXY(11),QX)
          CALL FMPI(MXY(3),QX)
          CALL FMDIVI(MXY(3),6,MXY(4),QX)
          CALL FMMPY_R1(MXY(11),MXY(4),QX)
          GO TO 160
      ENDIF
      CALL FMINT(MXY(1),MXY(8),QX)
      IF (MXY(1)%MP(2) > QX%NDIG .AND. FMCOMP(MXY(1),'==',MXY(8),QX) .AND.  &
          MXY(1)%MP(2) < QX%MEXPOV) THEN
          CALL FMI2M(1,MXY(8),QX)
          IF (MXY(1)%MP(1) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(11),QX)
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(11),QX)
          ENDIF
          CALL FMPI(MXY(6),QX)
          CALL FMMPY_R1(MXY(6),MXY(1),QX)
          CALL FMDIV_R2(MXY(8),MXY(6),QX)
          JR = QX%KROUND
          IF (QX%KROUND == -1 .AND. MA%MP(1) < 0) QX%KROUND =  2
          IF (QX%KROUND ==  2 .AND. MA%MP(1) < 0) QX%KROUND = -1
          CALL FMSUB_R1(MXY(11),MXY(6),QX)
          QX%KROUND = JR
          GO TO 180
      ENDIF
      IF (MXY(1)%MP(2) > QX%NDIG) THEN
          CALL FMI2M(1,MXY(8),QX)
          IF (MXY(1)%MP(1) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(11),QX)
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(11),QX)
          ENDIF
          GO TO 160
      ENDIF

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(1)%MP(2)),0) ,INT(2.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      IF (KFLAGX == 0) THEN
          IF (ABS(X) < SQRT(HUGE(X)/(4*LOG(HUGE(X))))) THEN
              Y = (QX%DPPI*X*X-1)/2
              Y = (2*Y+1.5)*LOG(2*Y+2) - (2*Y+1) - Y*QX%DLOGTW - (Y+0.5)*LOG(Y+1) + Y - Y*LOG(QX%DPPI*X*X)
              IF (Y <= -(QX%NDIG+1)*QX%DLOGMB) THEN
                  NMETHD = 2
              ELSE
                  NMETHD = 1
              ENDIF
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MXY(1)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n+1)/((4*n+3)*(2*n+1)!).

!             MXY(6) is the current term
!             MXY(9) is pi*x*x/2

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          IEXTRA = MAX(0.0D0,(0.096*X*X + 0.033*ABS(X) - 0.5)*LOG(1.0E7)/QX%ALOGMB)*1.02
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
          ENDIF
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

      IF (KFLAGX == 0) THEN
          J2 = INT(0.68*SQRT(FMNTERMS(3.14159D0*X*X/2,2,0,0,1,QX)) - 1.6)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(4),QX)
      CALL FMCSDIVI(MXY(4),2,MXY(9),QX)
      CALL FMPI(MXY(3),QX)
      CALL FMCSMPY_R1(MXY(9),MXY(3),QX)
      CALL FMI2M(1,MXY(6),QX)
      CALL FMCSDIVI(MXY(6),3,MJSUMS(1),QX)
      NTERM = 0
      DO J = 2, J2
         NTERM = NTERM + 2
         NBOT = NTERM*(NTERM+1)
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
             CALL FMCSDIVI_R1(MXY(6),NTERM+1,QX)
         ELSE
             CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(6),2*NTERM+3,MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 140
      CALL FMIPWR(MXY(9),2*J2,MXY(7),QX)

  130 CALL FMCSMPY_R1(MXY(6),MXY(7),QX)
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(6),NTERM,QX)
             CALL FMCSDIVI_R1(MXY(6),NTERM+1,QX)
         ELSE
             NBOT = NTERM*(NTERM+1)
             CALL FMCSDIVI_R1(MXY(6),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(6),2*NTERM+3,MXY(2),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(2),QX)
         IF (QX%KFLAG /= 0) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(6)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMSQR(MXY(9),MXY(8),QX)
      MXY(8)%MP(1) = -1
      IF (MJSUMS(1)%MP(1) > 0) THEN
          CALL FMEQ(MJSUMS(1),MXY(15),QX)
          CALL FMI2M(0,MXY(16),QX)
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(16),QX)
          CALL FMI2M(0,MXY(15),QX)
      ENDIF
      CALL FMEQ(MXY(8),MXY(12),QX)
      DO J = 1, J2-1
         CALL FMMPY(MXY(12),MJSUMS(J+1),MXY(3),QX)
         IF (MXY(3)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(15),MXY(3),QX)
         ELSE
             CALL FMADD_R1(MXY(16),MXY(3),QX)
         ENDIF
         CALL FMMPY_R1(MXY(12),MXY(8),QX)
      ENDDO
      CALL FMADD(MXY(15),MXY(16),MXY(11),QX)
      CALL FMCANCEL(MXY(15),MXY(16),MXY(11),K,QX)
      N_ACC = N_ACC - K
      CALL FMCSMPY_R1(MXY(11),MXY(1),QX)
      CALL FMCSMPY_R1(MXY(11),MXY(9),QX)

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then S(x) = 0.5 - f(x)*cos(pi*x*x/2) - g(x)*sin(pi*x*x/2).

  150 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMFGFI(MXY(1),MXY(12),MXY(13),QX)
      CALL FMSQR(MXY(1),MXY(4),QX)
      KRSAVE = QX%KRAD
      QX%KRAD = 0
      CALL FMMPYI(MXY(4),90,MXY(7),QX)
      CALL FMCSSN(MXY(7),MXY(14),MXY(10),QX)
      QX%KRAD = KRSAVE
      CALL FMMPY(MXY(12),MXY(14),MXY(11),QX)
      CALL FMMPY(MXY(13),MXY(10),MXY(7),QX)
      CALL FMI2M(1,MXY(4),QX)
      CALL FMDIVI(MXY(4),2,MXY(5),QX)
      CALL FMSUB(MXY(5),MXY(11),MXY(6),QX)
      CALL FMSUB(MXY(6),MXY(7),MXY(11),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(11)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(11)%MP(J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+IEXTRA,QX%NDIG+QX%NGRD52+2)
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(11),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  180 IF (MA%MP(1) == -1) THEN
          IF(MXY(11)%MP(3) /= 0 .AND. MXY(11)%MP(2) /= QX%MUNKNO)  &
             MXY(11)%MP(1) =-1
      ENDIF
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMS

      SUBROUTINE FMSHI(MA,MB,QX)

!  MB = Hyperbolic Sine Integral(MA)

!  Integral from 0 to MA of sinh(t) / t  dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDSAV1,NDSAVE,NMETHD,NTERM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(12),MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX

      K_RETURN_CODE = 0
      K = 0
      QX%NCALL = QX%NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          KL = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMDIVI(MXY(1),18,MXY(2),QX)
          IF (MXY(2)%MP(2) < -QX%NDIG) K = 1
          QX%NTRACE = J
          QX%KWARN = KL
      ENDIF
      IF (QX%KROUND /= 1 .AND. K == 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMSQR(MXY(1),MXY(2),QX)
          CALL FMMPY(MXY(1),MXY(2),MXY(3),QX)
          CALL FMDIVI(MXY(3),18,MXY(5),QX)
          CALL FMEQ(MXY(1),MXY(4),QX)
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG .AND.  &
              MXY(4)%MP(2) > QX%MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(4),MXY(8),MXY(6),QX)
              IF (MXY(6)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MXY(9),QX)
                  IF (MXY(9)%MP(2) >= QX%MEXPOV) THEN
                      IF (MXY(6)%MP(1) > 0) THEN
                          IF (MXY(7)%MP(1) < 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MXY(9),QX)
                          ELSE IF (MXY(7)%MP(1) > 0 .AND. QX%KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MXY(9),QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9),QX)
                          ENDIF
                      ELSE
                          IF (MXY(7)%MP(1) < 0 .AND. QX%KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MXY(9),QX)
                          ELSE IF (MXY(7)%MP(1) > 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MXY(9),QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9),QX)
                          ENDIF
                      ENDIF
                  ENDIF
                  CALL FMEQU(MXY(9),MB,QX%NDIG,NDSAVE,QX)
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ELSE IF (MXY(4)%MP(2) == QX%MEXPUN) THEN
              IF (KRSAVE == 2 .AND. MA%MP(1) == 1) THEN
                  CALL FMTINY(MXY(9),QX)
                  CALL FMEQU(MXY(9),MB,QX%NDIG,NDSAVE,QX)
                  K_RETURN_CODE = 1
              ENDIF
              IF (KRSAVE == -1 .AND. MA%MP(1) == -1) THEN
                  CALL FMTINY(MXY(9),QX)
                  MXY(9)%MP(1) = -1
                  CALL FMEQU(MXY(9),MB,QX%NDIG,NDSAVE,QX)
                  K_RETURN_CODE = 1
              ENDIF
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NAMEST(QX%NCALL) = 'FMSHI'
                  CALL FMNTR(2,MA,MA,1,1,QX)
                  CALL FMNTR(1,MB,MB,1,1,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMSHI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      MXY(1)%MP(1) = 1

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(8),QX)
          GO TO 160
      ELSE IF (MXY(1)%MP(2) == QX%MEXPUN) THEN
          CALL FMEQ(MXY(1),MXY(8),QX)
          GO TO 160
      ELSE IF (MXY(1)%MP(2) == QX%MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(8),QX)
          QX%KFLAG = -5
          GO TO 160
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(1)%MP(2)),0) ,INT(2.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MXY(1)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (QX%NDIG+5)*QX%DLOGMB
          IF (ABS(X) > Y+(QX%DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 140

!             Method 1.  Use the X**(2*N+1)/((2*N+1)*(2*N+1)!) series.

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      IF (KFLAGX == 0) THEN
          J2 = INT(0.62*SQRT(FMNTERMS(X,2,0,0,1,QX)) - 1.3)
          J2 = MAX(1,MIN(LJSUMS,J2))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL FMEQ(MXY(1),MXY(7),QX)
      CALL FMEQ(MXY(1),MJSUMS(1),QX)
      NTERM = 1
      DO J = 2, J2
         NTERM = NTERM + 2
         NBOT = NTERM*(NTERM-1)
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMCSDIVI_R1(MXY(7),NTERM,QX)
             CALL FMCSDIVI_R1(MXY(7),NTERM-1,QX)
         ELSE
             CALL FMCSDIVI_R1(MXY(7),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(7),NTERM,MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 130
      CALL FMIPWR(MXY(1),2*J2,MXY(5),QX)

  120 CALL FMCSMPY_R1(MXY(7),MXY(5),QX)
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(7),NTERM,QX)
             CALL FMCSDIVI_R1(MXY(7),NTERM-1,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(7),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(7),NTERM,MXY(4),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMEQ(MJSUMS(J2),MXY(8),QX)
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(1),MXY(6),QX)
          DO J = 2, J2
             CALL FMCSMPY_R1(MXY(8),MXY(6),QX)
             CALL FMADD_R1(MXY(8),MJSUMS(J2-J+1),QX)
          ENDDO
      ENDIF

      GO TO 150

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then Shi(x) = f(x)*cosh(x) + g(x)*sinh(x).

  140 IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-2)
      ENDIF
      CALL FMFHGH(MXY(1),MXY(9),MXY(10),QX)
      CALL FMCHSH(MXY(1),MXY(11),MXY(12),QX)
      IF (MXY(11)%MP(2) < QX%MEXPOV) THEN
          CALL FMMPY(MXY(9),MXY(11),MXY(2),QX)
          CALL FMMPY(MXY(10),MXY(12),MXY(3),QX)
          CALL FMADD(MXY(2),MXY(3),MXY(8),QX)
      ELSE
          CALL FMADD(MXY(9),MXY(10),MXY(5),QX)
          CALL FMDIVI_R1(MXY(5),2,QX)
          CALL FMLN(MXY(5),MXY(8),QX)
          CALL FMADD(MXY(1),MXY(8),MXY(5),QX)
          CALL FMEXP(MXY(5),MXY(8),QX)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  150 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(8)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

  160 IF (MA%MP(1) < 0 .AND. MXY(8)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(8)%MP(3) /= 0) THEN
          MXY(8)%MP(1) = -MXY(8)%MP(1)
      ENDIF
      CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMSHI

      SUBROUTINE FMSI(MA,MB,QX)

!  MB = Sine Integral(MA)

!  Integral from 0 to MA of sin(t) / t  dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY,N_ACC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MXY(13),MRETRY,MJSUMS(LJSUMS)
      TYPE(FM_SETTINGS) :: QX

      K_RETURN_CODE = 0
      K = 0
      QX%NCALL = QX%NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (QX%KROUND /= 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          KL = QX%KWARN
          QX%KWARN = 0
          CALL FMSQR(MA,MXY(1),QX)
          CALL FMDIVI(MXY(1),18,MXY(2),QX)
          IF (MXY(2)%MP(2) < -QX%NDIG) K = 1
          QX%NTRACE = J
          QX%KWARN = KL
      ENDIF
      IF (QX%KROUND /= 1 .AND. K == 1) THEN
          J = QX%NTRACE
          QX%NTRACE = 0
          K = QX%KWARN
          QX%KWARN = 0
          KRSAVE = QX%KROUND
          QX%KROUND = 1
          NDSAVE = QX%NDIG
          QX%NDIG = QX%NDIG + QX%NGRD52
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
          CALL FMSQR(MXY(1),MXY(2),QX)
          CALL FMMPY(MXY(1),MXY(2),MXY(3),QX)
          CALL FMDIVI(MXY(3),-18,MXY(5),QX)
          CALL FMEQ(MXY(1),MXY(4),QX)
          IF (MXY(4)%MP(2) - MXY(5)%MP(2) > QX%NDIG .AND.  &
              MXY(4)%MP(2) > QX%MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,QX%NDIG,QX)
              CALL FMSUB(MXY(4),MXY(8),MXY(6),QX)
              IF (MXY(6)%MP(3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),QX%NDIG,NDSAVE,QX)
                  CALL FMEQU(MXY(5),MXY(7),QX%NDIG,NDSAVE,QX)
                  QX%NDIG = NDSAVE
                  QX%KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB,QX)
                  IF (MB%MP(2) >= QX%MEXPOV) THEN
                      IF (MXY(6)%MP(1) > 0) THEN
                          IF (MXY(7)%MP(1) < 0 .AND. (QX%KROUND == -1 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(7)%MP(1) > 0 .AND. QX%KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ELSE
                          IF (MXY(7)%MP(1) < 0 .AND. QX%KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMADD(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE IF (MXY(7)%MP(1) > 0 .AND. (QX%KROUND == 2 .OR. QX%KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1),QX)
                              MXY(1)%MP(2) = 0
                              CALL FMULP(MXY(1),MXY(2),QX)
                              CALL FMSUB(MXY(1),MXY(2),MXY(3),QX)
                              MXY(3)%MP(2) = MXY(6)%MP(2) + MXY(3)%MP(2)
                              CALL FMEQ(MXY(3),MB,QX)
                          ELSE
                              QX%KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB,QX)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  QX%KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,QX%NDIG,NDSAVE,QX)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          QX%KFLAG = 0
          QX%NTRACE = J
          QX%KWARN = K
          QX%NDIG = NDSAVE
          QX%KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (QX%NTRACE /= 0) THEN
                  QX%NAMEST(QX%NCALL) = 'FMSI'
                  CALL FMNTR(2,MA,MA,1,1,QX)
              ENDIF
              IF (MB%MP(2) == QX%MUNKNO .AND. MA%MP(2) /= QX%MUNKNO) THEN
                  QX%NAMEST(QX%NCALL) = 'FMSI'
                  QX%KFLAG = -4
                  CALL FMWRN2(QX)
              ELSE IF (ABS(MB%MP(2)) == QX%MEXPOV .AND. ABS(MA%MP(2)) < QX%MEXPOV) THEN
                  QX%NAMEST(QX%NCALL) = 'FMSI'
                  IF (MB%MP(2) == QX%MEXPOV) QX%KFLAG = -5
                  IF (MB%MP(2) == QX%MEXPUN) QX%KFLAG = -6
                  CALL FMWRN2(QX)
              ENDIF
              IF (QX%NTRACE /= 0) THEN
                  QX%NAMEST(QX%NCALL) = 'FMSI'
                  CALL FMNTR(1,MB,MB,1,1,QX)
              ENDIF
          ENDIF
      ENDIF
      QX%NCALL = QX%NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMSI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      CALL FMEQU(MA,MXY(1),NDSAVE,QX%NDIG,QX)
      MXY(1)%MP(1) = 1
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MXY(1)%MP(1) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             Check for special cases.

      IF (MXY(1)%MP(3) == 0) THEN
          CALL FMI2M(0,MXY(8),QX)
          GO TO 180
      ELSE IF (MXY(1)%MP(2) == QX%MEXPUN) THEN
          CALL FMEQ(MXY(1),MXY(8),QX)
          GO TO 180
      ELSE IF (MXY(1)%MP(2) > QX%NDIG) THEN
          CALL FMPI(MXY(8),QX)
          CALL FMDIVI_R1(MXY(8),2,QX)
          GO TO 160
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MXY(1)%MP(2)),0) ,INT(2.0+QX%ALOGMX/QX%ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MXY(1)%MP(2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (QX%NDIG+5)*QX%DLOGMB
          IF (ABS(X) > Y+(QX%DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the (-1)**N*X**(2*N+1)/((2*N+1)*(2*N+1)!) series.

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          Y = NINT(ABS(X)/2)
          Y = 2*Y*LOG(ABS(X)+1.0E-9) - LOG(2*Y+1.0E-9) - (2*Y+0.5)*LOG(2*Y+1) + 2*Y
          Y = 1.03*Y/QX%DLOGMB - 7/QX%ALOGMT
          IEXTRA = MAX(0,INT(Y+1))
          IF (ABS(X) < 5 .AND. KR_RETRY <= 0) THEN
              QX%NDIG = QX%NDIG - 2
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)

      IF (KFLAGX == 0) THEN
          J2 = INT(0.64*SQRT(FMNTERMS(X,2,0,0,1,QX)) - 1.4)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL FMEQ(MXY(1),MXY(7),QX)
      CALL FMEQ(MXY(1),MJSUMS(1),QX)
      NTERM = 1
      DO J = 2, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMCSDIVI_R1(MXY(7),NTERM,QX)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(7),NBOT,QX)
         ELSE
             CALL FMCSDIVI_R1(MXY(7),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(7),NTERM,MJSUMS(J),QX)
      ENDDO
      IF (MXY(1)%MP(2) < -QX%NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(5),QX)

  130 CALL FMCSMPY_R1(MXY(7),MXY(5),QX)
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         IF (NTERM > LARGE .OR. NTERM > MXBASE/(NTERM-1)) THEN
             CALL FMCSDIVI_R1(MXY(7),NTERM,QX)
             NBOT = NTERM - 1
             CALL FMCSDIVI_R1(MXY(7),NBOT,QX)
         ELSE
             NBOT = NTERM*(NTERM-1)
             CALL FMCSDIVI_R1(MXY(7),NBOT,QX)
         ENDIF
         CALL FMCSDIVI(MXY(7),NTERM,MXY(4),QX)
         QX%NDIG = NDSAV1
         CALL FMCSADDNN_R1(MJSUMS(J),MXY(4),QX)
         IF (QX%KFLAG /= 0) GO TO 140
         QX%NDIG = NDSAV1 - INT(MJSUMS(J)%MP(2)-MXY(4)%MP(2))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 QX%KFLAG = 0
      CALL FMCSNSUMS(J2,MJSUMS,QX)
      CALL FMSQR(MXY(1),MXY(5),QX)
      MXY(5)%MP(1) = -1
      CALL FMSQR(MXY(1),MXY(5),QX)
      MXY(5)%MP(1) = -1
      IF (MJSUMS(1)%MP(1) > 0) THEN
          CALL FMEQ(MJSUMS(1),MXY(12),QX)
          CALL FMI2M(0,MXY(13),QX)
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(13),QX)
          CALL FMI2M(0,MXY(12),QX)
      ENDIF
      CALL FMEQ(MXY(5),MXY(7),QX)
      DO J = 1, J2-1
         CALL FMMPY(MXY(7),MJSUMS(J+1),MXY(3),QX)
         IF (MXY(3)%MP(1) > 0) THEN
             CALL FMADD_R1(MXY(12),MXY(3),QX)
         ELSE
             CALL FMADD_R1(MXY(13),MXY(3),QX)
         ENDIF
         CALL FMMPY_R1(MXY(7),MXY(5),QX)
      ENDDO
      CALL FMADD(MXY(12),MXY(13),MXY(8),QX)
      CALL FMCANCEL(MXY(12),MXY(13),MXY(8),K,QX)
      N_ACC = N_ACC - K

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then Si(x) = pi/2 - f(x)*cos(x) - g(x)*sin(x).

  150 CALL FMFXGX(MXY(1),MXY(10),MXY(11),QX)
      N_ACC = NINT(QX%NDIG*QX%ALOGM2)
      KRSAVE = QX%KRAD
      QX%KRAD = 1
      CALL FMCSSN(MXY(1),MXY(12),MXY(13),QX)
      QX%KRAD = KRSAVE
      CALL FMPI(MXY(9),QX)
      IF (MXY(12)%MP(2) == QX%MUNKNO .OR. MXY(13)%MP(2) == QX%MUNKNO) THEN
          CALL FMMPYI(MXY(9),2,MXY(8),QX)
          CALL FMDIV(MXY(1),MXY(8),MXY(3),QX)
          CALL FMINT(MXY(3),MXY(2),QX)
          CALL FMMPY(MXY(2),MXY(8),MXY(3),QX)
          CALL FMSUB(MXY(1),MXY(3),MXY(8),QX)
          KRSAVE = QX%KRAD
          QX%KRAD = 1
          CALL FMCSSN(MXY(8),MXY(12),MXY(13),QX)
          QX%KRAD = KRSAVE
      ENDIF
      CALL FMDIVI(MXY(9),2,MXY(2),QX)
      CALL FMMPY(MXY(10),MXY(12),MXY(3),QX)
      CALL FMSUB_R1(MXY(2),MXY(3),QX)
      CALL FMMPY(MXY(11),MXY(13),MXY(3),QX)
      CALL FMSUB(MXY(2),MXY(3),MXY(8),QX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (QX%NCALL >= 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(8)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (QX%NCALL >= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*QX%ALOGM2) + 17
      ELSE
          NGOAL = INT(-QX%MXEXP2)
      ENDIF
      IF (N_ACC <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/QX%ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MRETRY%MP(J+1) /= MXY(8)%MP(J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-N_ACC)/QX%ALOGM2 + 23.03/QX%ALOGMB) + 1
          NDOLD = QX%NDIG
          QX%NDIG = MAX(QX%NDIG+IEXTRA,QX%NDIG+QX%NGRD52+2)
          N_ACC = NINT(QX%NDIG*QX%ALOGM2)
          CALL FMEQU_R1(MXY(1),NDSAVE,QX%NDIG,QX)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(8),MRETRY,NDOLD,QX%NDIG,QX)
          GO TO 120
      ENDIF

  180 IF (MA%MP(1) < 0 .AND. MXY(8)%MP(2) /= QX%MUNKNO .AND.  &
          MXY(8)%MP(3) /= 0) THEN
          MXY(8)%MP(1) = -MXY(8)%MP(1)
      ENDIF
      CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE FMSI




!     ZM complex special functions

!  Here is a list of the routines that are designed to be called by the user.
!  All arguments are zm complex numbers.


!  ZMERF(MA,MB)         MB = Erf(MA)          Error function

!  ZMERFC(MA,MB)        MB = Erfc(MA)         Complimentary Error function

!  ZMERFC_SC(MA,MB)     MB = Erfc_scaled(MA)  Scaled complimentary Error function

!  ZMLNGM(MA,MB)        MB = Log_Gamma(MA)    Log_Gamma function

!  ZMGAM(MA,MB)         MB = Gamma(MA)        Gamma function

!  ZMFACT(MA,MB)        MB = MA!              Factorial function


      SUBROUTINE ZMERF(MA,MB,QX)

!  MB = Erf(MA)    Error function.

!  2/Sqrt(pi) * Integral from 0 to MA of e**(-t**2) dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: C1,C2,C4,ERR,ERR2,X,XK
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTEGER :: IEXTRA,J,J2,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,  &
                 NDSAVE,NDSAV1,NDSAV2,NMETHD,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MXY(2,15), MJSUMS(2,LJSUMS)
      LOGICAL, EXTERNAL :: FMCOMP

!             If MA is real, use FMERF.

      IF (MA(2)%MP(3) == 0) THEN
          CALL FMERF(MA(1),MB(1),QX)
          CALL FMI2M(0,MB(2),QX)
          RETURN
      ENDIF


      CALL ZMENTR('ZMERF    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMEQ(MXY(1:2,1),MXY(1:2,3),QX)
          GO TO 210
      ENDIF
      IF (MXY(1,1)%MP(2) == QX%MEXPUN .OR. MXY(2,1)%MP(2) == QX%MEXPUN) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
          QX%KFLAG = -4
          GO TO 210
      ENDIF

!             X is a double precision approximation to the size of input argument to this function.

      CALL ZMABS(MXY(1:2,1),MXY(1,4),QX)
      CALL FMM2DP(MXY(1,4),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1,4)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX**0.33D0
          KFLAGX = 0
      ELSE IF (QX%KFLAG == 0 .AND. X < 1.0D0/DPMAX**0.33D0) THEN
          X = 1.0D0/DPMAX**0.33D0
      ENDIF
      IF (QX%KFLAG /= 0 .AND. MXY(1,4)%MP(2) > 0) THEN
          X = DPMAX**0.33D0
          KFLAGX = 0
      ELSE IF (QX%KFLAG == 0 .AND. X > DPMAX**0.33D0) THEN
          X = DPMAX**0.33D0
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      XK = MAX(3.0D0,(2*X**2 + 1)/2)
      XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
           LOG(X)*(2*XK+1)
      IF (-XK/QX%DLOGMB > QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52) THEN
          NMETHD = 4
      ELSE
          C4 = 5.0
          XK = 0.0
          DO WHILE (-XK/QX%DLOGMB <= QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52)
             C4 = 2 * C4
             XK = MAX(3.0D0,(2*C4**2 + 1)/2)
             XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
                  LOG(C4)*(2*XK+1)
          ENDDO
          C1 = C4/2
          DO WHILE (C4-C1 > 0.1)
             C2 = (C1 + C4) / 2
             XK = MAX(3.0D0,(2*C2**2 + 1)/2)
             XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
                  LOG(C2)*(2*XK+1)
             IF (-XK/QX%DLOGMB > QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52) THEN
                 C4 = C2
             ELSE
                 C1 = C2
             ENDIF
          ENDDO
          IF (X > 0.75*C4 .AND. X > C4 - 5) THEN
              NMETHD = 3
          ELSE
              CALL FMDIV(MXY(2,1),MXY(1,1),MXY(1,15),QX)
              CALL FMABS(MXY(1,15),MXY(2,15),QX)
              CALL FMDP2M(1.5D0,MXY(1,15),QX)
              IF (FMCOMP(MXY(2,15),'>',MXY(1,15),QX)) THEN
                  IF (X > 0.70*C4) THEN
                      NMETHD = 2
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE
                  IF (X > 6.0) THEN
                      NMETHD = 2
                  ELSE
                      NMETHD = 1
                  ENDIF
              ENDIF
          ENDIF
      ENDIF
      IF (NMETHD /= 1) GO TO 140


!             Method 1.  Use the (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        = ( 2 / sqrt(pi) ) * ( x - x^3/1! + x^5/2! - x^7/3! + ... )

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG+QX%NGRD52)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             If MA is large in magnitude or close to the real line, use more guard digits.

      CALL FMSQR(MXY(1,1),MXY(1,15),QX)
      CALL FMSQR(MXY(2,1),MXY(2,15),QX)
      CALL FMMPY(MXY(1,1),MXY(2,1),MXY(1,14),QX)
      CALL FMST2M('-4.409869',MXY(1,13),QX)

      CALL FMST2M(' 0.000918',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.002513',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.124040',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M('-0.000288',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,14),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.001638',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMM2I(MXY(1,13),IEXTRA,QX)
      IEXTRA = MAX(0,NINT((IEXTRA+3) * 16.11809565D0 / QX%DLOGMB)+1)
      IF (IEXTRA > 0) THEN
          CALL ZMEQU_R1(MXY(1:2,1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KFLAGX == 0) THEN
          J2 = INT(0.66*SQRT(FMNTERMS(X**2,1,0,0,1,QX)) - 0.8)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMI2M(1,MXY(1:2,6),QX)
      CALL ZMI2M(1,MJSUMS(1:2,1),QX)

      DO J = 2, J2
         IF (NTERM > 1) THEN
             CALL ZMDIVI_R1(MXY(1:2,6),NTERM,QX)
         ENDIF
         CALL ZMDIVI(MXY(1:2,6),2*NTERM+1,MJSUMS(1:2,J),QX)
         NTERM = NTERM + 1
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 130
      CALL ZMIPWR(MXY(1:2,1),2*J2,MXY(1:2,5),QX)

  120 CALL ZMMPY_R1(MXY(1:2,6),MXY(1:2,5),QX)
      DO J = 1, J2
         CALL ZMDIVI_R1(MXY(1:2,6),NTERM,QX)
         CALL ZMDIVI(MXY(1:2,6),2*NTERM+1,MXY(1:2,4),QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,4),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,4)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,4)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,4),QX)
      CALL ZMMPYI_R1(MXY(1:2,4),-1,QX)
      CALL ZMEQ(MJSUMS(1:2,J2),MXY(1:2,5),QX)

      DO J = 2, J2
         CALL ZMMPY(MXY(1:2,5),MXY(1:2,4),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,J2-J+1),MXY(1:2,5),QX)
      ENDDO

      CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,1),QX)

      CALL FMPI(MXY(1,4),QX)
      CALL FMI2M(0,MXY(2,4),QX)
      CALL ZMSQRT(MXY(1:2,4),MXY(1:2,3),QX)
      CALL ZMMPYI(MXY(1:2,5),2,MXY(1:2,4),QX)
      CALL ZMDIV_R2(MXY(1:2,4),MXY(1:2,3),QX)

      GO TO 210

  140 IF (NMETHD /= 2) GO TO 170


!             Method 2.  Use the x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      IEXTRA = 0
      CALL FMSQR(MXY(1,1),MXY(1,15),QX)
      CALL FMSQR(MXY(2,1),MXY(2,15),QX)
      CALL FMMPY(MXY(1,1),MXY(2,1),MXY(1,14),QX)
      CALL FMST2M('-2.156685',MXY(1,13),QX)

      CALL FMST2M('-0.000490',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M('-0.000013',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.062094',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.000027',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,14),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.062030',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMM2I(MXY(1,13),IEXTRA,QX)
      IEXTRA = MAX(0,NINT((IEXTRA+3) * 16.11809565D0 / QX%DLOGMB)+1)
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG) + 1
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      IF (KFLAGX == 0) THEN
          J2 = INT(0.51*SQRT(FMNTERMS(2*X,2,-1,0,1,QX)))
      ELSE
          J2 = 1
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMMPYI(MXY(1:2,1),2,MXY(1:2,6),QX)
      CALL ZMEQ(MXY(1:2,6),MJSUMS(1:2,1),QX)
      DO J = 2, J2
         CALL ZMMPYI_R1(MXY(1:2,6),2,QX)
         CALL ZMDIVI_R1(MXY(1:2,6),2*NTERM+1,QX)
         CALL ZMEQ(MXY(1:2,6),MJSUMS(1:2,J),QX)
         NTERM = NTERM + 1
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 160
      CALL ZMIPWR(MXY(1:2,1),2*J2,MXY(1:2,5),QX)

  150 CALL ZMMPY_R1(MXY(1:2,6),MXY(1:2,5),QX)
      DO J = 1, J2
         CALL ZMMPYI(MXY(1:2,6),2,MXY(1:2,15),QX)
         CALL ZMDIVI(MXY(1:2,15),2*NTERM+1,MXY(1:2,6),QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,6),QX)
         IF (QX%KFLAG /= 0) GO TO 160
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,6)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,6)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 150

!             Put the J2 separate sums back together.

  160 QX%KFLAG = 0
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,6),QX)
      CALL ZMEQ(MJSUMS(1:2,J2),MXY(1:2,5),QX)
      DO J = 2, J2
         CALL ZMMPY(MXY(1:2,5),MXY(1:2,6),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,J2-J+1),MXY(1:2,5),QX)
      ENDDO

      CALL FMPI(MXY(1,4),QX)
      CALL FMI2M(0,MXY(2,4),QX)
      CALL ZMSQRT(MXY(1:2,4),MXY(1:2,3),QX)
      CALL ZMDIV_R2(MXY(1:2,5),MXY(1:2,3),QX)
      CALL ZMEXP(MXY(1:2,6),MXY(1:2,4),QX)
      CALL ZMDIV_R1(MXY(1:2,3),MXY(1:2,4),QX)

      GO TO 210


  170 IF (NMETHD /= 3) GO TO 180


!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0, erf(x) = -erf(-x) otherwise.

!                                  erf(x) = 1 + (-exp(-x^2)/sqrt(pi)) /
!                                                                   x + 1 /
!                                                                     2*x + 2 /
!                                                                           x + 3 /
!                                                                             2*x + 4 /
!                                                                                   x + 5 ...

      IEXTRA = 0
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG) + 1
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      NDSAV1 = QX%NDIG
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMMPYI_R1(MXY(1:2,1),-1,QX)
      ENDIF

      CALL ZMEQ(MXY(1:2,1),MXY(1:2,2),QX)

      CALL ZMSQR(MXY(1:2,2),MXY(1:2,4),QX)
      CALL ZMMPYI(MXY(1:2,4),-1,MXY(1:2,15),QX)
      CALL ZMEXP(MXY(1:2,15),MXY(1:2,10),QX)
      CALL ZMMPYI(MXY(1:2,10),-1,MXY(1:2,15),QX)
      CALL FMPI(MXY(1,10),QX)
      CALL FMSQRT_R1(MXY(1,10),QX)
      CALL FMI2M(0,MXY(2,10),QX)
      CALL ZMDIV_R2(MXY(1:2,15),MXY(1:2,10),QX)
      CALL ZMDIV_R1(MXY(1:2,10),MXY(1:2,2),QX)
      CALL ZMI2M(-31,MXY(1:2,13),QX)

      CALL FMI2M(1,MXY(1,15),QX)
      CALL FMULP(MXY(1,15),MXY(2,15),QX)
      CALL FMDIV(MXY(1,1),MXY(2,1),MXY(1,15),QX)
      CALL FMSQR_R1(MXY(1,15),QX)
      IF (FMCOMP(MXY(1,15),'<',MXY(2,15),QX)) THEN
          CALL ZMI2M(0,MXY(1:2,15),QX)
      ELSE
          CALL ZMI2M(1,MXY(1:2,15),QX)
      ENDIF
      CALL ZMADD(MXY(1:2,15),MXY(1:2,10),MXY(1:2,14),QX)
      CALL ZMI2M(1,MXY(1:2,8),QX)
      CALL ZMEQ(MXY(1:2,2),MXY(1:2,9),QX)
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = QX%NDIG
      DO K = 3, NTERMS
         CALL ZMMPYI(MXY(1:2,2),1+MOD(K,2),MXY(1:2,11),QX)
         CALL ZMMPY_R1(MXY(1:2,11),MXY(1:2,9),QX)
         CALL ZMMPYI(MXY(1:2,8),K-2,MXY(1:2,12),QX)
         CALL ZMADD(MXY(1:2,11),MXY(1:2,12),MXY(1:2,7),QX)
         CALL ZMMPY_R1(MXY(1:2,10),MXY(1:2,12),QX)
         CALL ZMDIV_R1(MXY(1:2,10),MXY(1:2,7),QX)
         CALL ZMMPYI_R1(MXY(1:2,10),-1,QX)
         CALL ZMEQ(MXY(1:2,9),MXY(1:2,8),QX)
         CALL ZMEQ(MXY(1:2,7),MXY(1:2,9),QX)
         QX%NDIG = NDSAV2
         CALL ZMADD_R1(MXY(1:2,14),MXY(1:2,10),QX)

!             Check for convergence.

         IF (QX%KFLAG == 1 .AND. K > 2) THEN
             EXIT
         ENDIF
         KL = MAX( 1000.0, 2 * QX%ALOGMT * NDSAVE )
         IF (K > KL) THEN
             NMETHD = 2
             GO TO 140
         ENDIF
         CALL ZMEQ(MXY(1:2,10),MXY(1:2,13),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(                     &
                                      MIN(MXY(1,14)%MP(2)-MXY(1,10)%MP(2),  &
                                          MXY(2,14)%MP(2)-MXY(2,10)%MP(2)))))
      ENDDO

      CALL ZMEQ(MXY(1:2,14),MXY(1:2,3),QX)
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMMPYI_R1(MXY(1:2,3),-1,QX)
      ENDIF
      QX%NDIG = NDSAV1
      GO TO 210


!             Method 4.  Asymptotic series
!                        1 - ( Exp(-x^2) / Sqrt(Pi) ) *
!                            Sum_{k=0}^Infinity (  (-1)^k * poch(1/2,k) / x^(2*k+1) )

!             The series is  1/x - (1/2) / x^3  +  ( 1*3 )/(2^2) / x^5 - ( 1*3*5 )/(2^3) / x^7
!                            + ...

  180 IEXTRA = 0
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMMPYI_R1(MXY(1:2,1),-1,QX)
      ENDIF
      IF (KFLAGX == 0) THEN
          J2 = INT(0.66*SQRT(FMNTERMS(X**2,1,0,0,0,QX)) - 0.8)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,15),QX)
      CALL ZMMPYI(MXY(1:2,15),2,MXY(1:2,7),QX)
      CALL ZMI2M(1,MXY(1:2,8),QX)
      CALL ZMDIV(MXY(1:2,8),MXY(1:2,7),MXY(1:2,6),QX)
      CALL ZMI2M(1,MJSUMS(1:2,1),QX)
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL ZMMPYI_R1(MXY(1:2,8),2*NTERM-3,QX)
         CALL ZMEQ(MXY(1:2,8),MJSUMS(1:2,J),QX)
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 130
      CALL ZMIPWR(MXY(1:2,6),J2,MXY(1:2,7),QX)
      CALL ZMI2M(-31,MXY(1:2,13),QX)

  190 CALL ZMMPY_R2(MXY(1:2,7),MXY(1:2,8),QX)
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL ZMMPYI_R1(MXY(1:2,8),2*NTERM-3,QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,8),QX)
         IF (QX%KFLAG /= 0) GO TO 200
         KL = MAX( 19000.0, 6 * QX%ALOGMT * NDSAVE )
         IF (NTERM > KL) THEN
             CALL ZMABS(MXY(1:2,8),MXY(1,15),QX)
             CALL ZMABS(MXY(1:2,13),MXY(2,15),QX)
             IF (FMCOMP(MXY(1,15),'>',MXY(2,15),QX)) THEN
                 NMETHD = 2
                 GO TO 140
             ENDIF
         ENDIF
         CALL ZMEQ(MXY(1:2,8),MXY(1:2,13),QX)
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,8)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,8)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 190

!             Put the J2 separate sums back together.

  200 QX%KFLAG = 0
      CALL ZMMPYI(MXY(1:2,6),-1,MXY(1:2,4),QX)
      CALL ZMI2M(1,MXY(1:2,5),QX)
      DO J = 2, J2
         CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,4),QX)
         CALL ZMMPY(MXY(1:2,5),MJSUMS(1:2,J),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,1),MXY(1:2,8),QX)
         CALL ZMEQ(MXY(1:2,8),MJSUMS(1:2,1),QX)
      ENDDO
      CALL FMMPY(MXY(1,1),MXY(2,1),MXY(2,15),QX)
      CALL FMMPYI_R1(MXY(2,15),-2,QX)
      CALL FMI2M(0,MXY(1,15),QX)
      CALL ZMEXP(MXY(1:2,15),MXY(1:2,14),QX)
      CALL ZMMPY(MJSUMS(1:2,1),MXY(1:2,14),MXY(1:2,15),QX)
      CALL FMPI(MXY(1,4),QX)
      CALL FMSQRT(MXY(1,4),MXY(1,8),QX)
      CALL FMI2M(0,MXY(2,8),QX)
      CALL ZMMPY(MXY(1:2,8),MXY(1:2,1),MXY(1:2,14),QX)
      CALL ZMDIV(MXY(1:2,15),MXY(1:2,14),MXY(1:2,13),QX)
      CALL FMADD(MXY(2,1),MXY(1,1),MXY(1,12),QX)
      CALL FMSUB(MXY(2,1),MXY(1,1),MXY(1,11),QX)
      CALL FMMPY(MXY(1,12),MXY(1,11),MXY(1,10),QX)
      CALL FMEXP(MXY(1,10),MXY(1,12),QX)
      CALL FMMPY(MXY(1,13),MXY(1,12),MXY(1,4),QX)
      CALL FMMPY(MXY(2,13),MXY(1,12),MXY(2,4),QX)

      IF (MXY(1,4)%MP(2) == QX%MUNKNO) THEN
          CALL FMABS(MXY(1,13),MXY(1,14),QX)
          CALL FMLN(MXY(1,14),MXY(1,15),QX)
          CALL FMADD(MXY(1,10),MXY(1,15),MXY(1,14),QX)
          CALL FMEXP(MXY(1,14),MXY(1,4),QX)
          MXY(1,4)%MP(1) = MXY(1,13)%MP(1)
      ENDIF
      IF (MXY(2,4)%MP(2) == QX%MUNKNO) THEN
          CALL FMABS(MXY(2,13),MXY(1,14),QX)
          CALL FMLN(MXY(1,14),MXY(1,15),QX)
          CALL FMADD(MXY(1,10),MXY(1,15),MXY(1,14),QX)
          CALL FMEXP(MXY(1,14),MXY(2,4),QX)
          MXY(2,4)%MP(1) = MXY(2,13)%MP(1)
      ENDIF
      CALL FMI2M(1,MXY(1,15),QX)
      CALL FMULP(MXY(1,15),MXY(2,15),QX)
      CALL FMDIV(MXY(1,1),MXY(2,1),MXY(1,15),QX)
      CALL FMSQR_R1(MXY(1,15),QX)
      IF (FMCOMP(MXY(1,15),'<',MXY(2,15),QX)) THEN
          CALL ZMI2M(0,MXY(1:2,15),QX)
          CALL ZMSUB(MXY(1:2,15),MXY(1:2,4),MXY(1:2,3),QX)
      ELSE
          CALL ZMI2M(1,MXY(1:2,15),QX)
          CALL ZMSUB(MXY(1:2,15),MXY(1:2,4),MXY(1:2,3),QX)
      ENDIF

      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMMPYI_R1(MXY(1:2,3),-1,QX)
      ENDIF

  210 QX%NAMEST(QX%NCALL) = 'ZMERF'

      IF (MA(1)%MP(3) == 0) THEN
          IF (MXY(2,3)%MP(2) /= QX%MUNKNO) THEN
              CALL FMI2M(0,MXY(1,3),QX)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL == 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(1,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          ERR2 = 0
          DO J = KL, 1, -1
             ERR2 = (ERR2 + MXY(2,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR   > 0.498 .AND. ERR  < 0.502) .OR.  &
               (QX%KROUND == 1 .AND. ERR2  > 0.498 .AND. ERR2 < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR  > 0.998 .OR. ERR  < 0.002)) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR2 > 0.998 .OR. ERR2 < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (MXY(1,3)%MP(2) == QX%MUNKNO .OR. MXY(2,3)%MP(2) == QX%MUNKNO) THEN
          CALL ZMST2M('UNKNOWN + UNKNOWN i',MXY(1:2,3),QX)
      ENDIF

      CALL ZMEXIT(MXY(1:2,3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMERF

      SUBROUTINE ZMERFC(MA,MB,QX)

!  MB = Erfc(MA)    Complimentary error function.

!  1 - 2/Sqrt(pi) * Integral from 0 to MA of e**(-t**2) dt.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: C1,C2,C4,ERR,ERR2,X,XK
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTEGER :: IEXTRA,J,J2,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,  &
                 NDSAVE,NDSAV1,NDSAV2,NMETHD,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MXY(2,15), MJSUMS(2,LJSUMS)
      LOGICAL, EXTERNAL :: FMCOMP

!             If MA is real, use FMERFC.

      IF (MA(2)%MP(3) == 0) THEN
          CALL FMERFC(MA(1),MB(1),QX)
          CALL FMI2M(0,MB(2),QX)
          RETURN
      ENDIF


      CALL ZMENTR('ZMERFC   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMEQ(MXY(1:2,1),MXY(1:2,3),QX)
          GO TO 210
      ENDIF
      IF (MXY(1,1)%MP(2) == QX%MEXPUN .OR. MXY(2,1)%MP(2) == QX%MEXPUN) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
          QX%KFLAG = -4
          GO TO 210
      ENDIF

!             X is a double precision approximation to the size of input argument to this function.

      CALL ZMABS(MXY(1:2,1),MXY(1,4),QX)
      CALL FMM2DP(MXY(1,4),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1,4)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX**0.33D0
          KFLAGX = 0
      ELSE IF (QX%KFLAG == 0 .AND. X < 1.0D0/DPMAX**0.33D0) THEN
          X = 1.0D0/DPMAX**0.33D0
      ENDIF
      IF (QX%KFLAG /= 0 .AND. MXY(1,4)%MP(2) > 0) THEN
          X = DPMAX**0.33D0
          KFLAGX = 0
      ELSE IF (QX%KFLAG == 0 .AND. X > DPMAX**0.33D0) THEN
          X = DPMAX**0.33D0
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      XK = MAX(3.0D0,(2*X**2 + 1)/2)
      XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
           LOG(X)*(2*XK+1)
      IF (-XK/QX%DLOGMB > QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52) THEN
          NMETHD = 4
      ELSE
          C4 = 5.0
          XK = 0.0
          DO WHILE (-XK/QX%DLOGMB <= QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52)
             C4 = 2 * C4
             XK = MAX(3.0D0,(2*C4**2 + 1)/2)
             XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
                  LOG(C4)*(2*XK+1)
          ENDDO
          C1 = C4/2
          DO WHILE (C4-C1 > 0.1)
             C2 = (C1 + C4) / 2
             XK = MAX(3.0D0,(2*C2**2 + 1)/2)
             XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
                  LOG(C2)*(2*XK+1)
             IF (-XK/QX%DLOGMB > QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52) THEN
                 C4 = C2
             ELSE
                 C1 = C2
             ENDIF
          ENDDO
          CALL FMDIV(MXY(2,1),MXY(1,1),MXY(1,15),QX)
          CALL FMABS(MXY(1,15),MXY(2,15),QX)
          CALL FMDP2M(1.5D0,MXY(1,15),QX)
          IF (FMCOMP(MXY(2,15),'>',MXY(1,15),QX) .OR. MXY(1,1)%MP(3) == 0) THEN
              IF (X > 0.8*C4) THEN
                  NMETHD = 3
              ELSE
                  NMETHD = 1
              ENDIF
          ELSE
              IF (X > 0.6*C4) THEN
                  NMETHD = 3
              ELSE IF (X > 6.0) THEN
                  NMETHD = 2
              ELSE
                  NMETHD = 1
              ENDIF
          ENDIF
      ENDIF
      IF (NMETHD /= 1) GO TO 140


!             Method 1.  Use the 1 - (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        = 1 - ( 2 / sqrt(pi) ) * ( x - x^3/1! + x^5/2! - x^7/3! + ... )

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG+QX%NGRD52)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             If MA is large in magnitude or close to the real line, use more guard digits.

      CALL FMSQR(MXY(1,1),MXY(1,15),QX)
      CALL FMSQR(MXY(2,1),MXY(2,15),QX)
      CALL FMMPY(MXY(1,1),MXY(2,1),MXY(1,14),QX)
      CALL FMST2M('-4.408443',MXY(1,13),QX)

      CALL FMST2M(' 0.000832',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.002632',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.124034',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M('-0.000291',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,14),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.001637',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMM2I(MXY(1,13),IEXTRA,QX)
      IEXTRA = MAX(0,NINT((IEXTRA+3) * 16.11809565D0 / QX%DLOGMB)+1)
      IF (IEXTRA > 0) THEN
          CALL ZMEQU_R1(MXY(1:2,1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KFLAGX == 0) THEN
          J2 = INT(0.66*SQRT(FMNTERMS(X**2,1,0,0,1,QX)) - 0.8)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMI2M(1,MXY(1:2,6),QX)
      CALL ZMI2M(1,MJSUMS(1:2,1),QX)

      DO J = 2, J2
         IF (NTERM > 1) THEN
             CALL ZMDIVI_R1(MXY(1:2,6),NTERM,QX)
         ENDIF
         CALL ZMDIVI(MXY(1:2,6),2*NTERM+1,MJSUMS(1:2,J),QX)
         NTERM = NTERM + 1
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 130
      CALL ZMIPWR(MXY(1:2,1),2*J2,MXY(1:2,5),QX)

  120 CALL ZMMPY_R1(MXY(1:2,6),MXY(1:2,5),QX)
      DO J = 1, J2
         CALL ZMDIVI_R1(MXY(1:2,6),NTERM,QX)
         CALL ZMDIVI(MXY(1:2,6),2*NTERM+1,MXY(1:2,4),QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,4),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,4)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,4)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,4),QX)
      CALL ZMMPYI_R1(MXY(1:2,4),-1,QX)
      CALL ZMEQ(MJSUMS(1:2,J2),MXY(1:2,5),QX)

      DO J = 2, J2
         CALL ZMMPY(MXY(1:2,5),MXY(1:2,4),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,J2-J+1),MXY(1:2,5),QX)
      ENDDO

      CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,1),QX)

      CALL FMPI(MXY(1,4),QX)
      CALL FMI2M(0,MXY(2,4),QX)
      CALL ZMSQRT(MXY(1:2,4),MXY(1:2,3),QX)
      CALL ZMMPYI(MXY(1:2,5),2,MXY(1:2,4),QX)
      CALL ZMDIV_R2(MXY(1:2,4),MXY(1:2,3),QX)

      CALL ZMI2M(1,MXY(1:2,15),QX)
      CALL ZMSUB_R2(MXY(1:2,15),MXY(1:2,3),QX)

      GO TO 210

  140 IF (NMETHD /= 2) GO TO 170


!             Method 2.  Use the 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      IEXTRA = 0
      CALL FMSQR(MXY(1,1),MXY(1,15),QX)
      CALL FMSQR(MXY(2,1),MXY(2,15),QX)
      CALL FMMPY(MXY(1,1),MXY(2,1),MXY(1,14),QX)
      CALL FMST2M('-1.966130',MXY(1,13),QX)

      CALL FMST2M(' 0.002853',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M('-0.001447',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.062040',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M('-0.000063',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,14),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.061968',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMM2I(MXY(1,13),IEXTRA,QX)
      IEXTRA = MAX(0,NINT((IEXTRA+3) * 16.11809565D0 / QX%DLOGMB)+1)
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG) + 1
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      IF (KFLAGX == 0) THEN
          J2 = INT(0.51*SQRT(FMNTERMS(2*X,2,-1,0,1,QX)))
      ELSE
          J2 = 1
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMMPYI(MXY(1:2,1),2,MXY(1:2,6),QX)
      CALL ZMEQ(MXY(1:2,6),MJSUMS(1:2,1),QX)
      DO J = 2, J2
         CALL ZMMPYI_R1(MXY(1:2,6),2,QX)
         CALL ZMDIVI_R1(MXY(1:2,6),2*NTERM+1,QX)
         CALL ZMEQ(MXY(1:2,6),MJSUMS(1:2,J),QX)
         NTERM = NTERM + 1
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 160
      CALL ZMIPWR(MXY(1:2,1),2*J2,MXY(1:2,5),QX)

  150 CALL ZMMPY_R1(MXY(1:2,6),MXY(1:2,5),QX)
      DO J = 1, J2
         CALL ZMMPYI(MXY(1:2,6),2,MXY(1:2,15),QX)
         CALL ZMDIVI(MXY(1:2,15),2*NTERM+1,MXY(1:2,6),QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,6),QX)
         IF (QX%KFLAG /= 0) GO TO 160
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,6)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,6)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 150

!             Put the J2 separate sums back together.

  160 QX%KFLAG = 0
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,6),QX)
      CALL ZMEQ(MJSUMS(1:2,J2),MXY(1:2,5),QX)
      DO J = 2, J2
         CALL ZMMPY(MXY(1:2,5),MXY(1:2,6),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,J2-J+1),MXY(1:2,5),QX)
      ENDDO

      CALL FMPI(MXY(1,4),QX)
      CALL FMI2M(0,MXY(2,4),QX)
      CALL ZMSQRT(MXY(1:2,4),MXY(1:2,3),QX)
      CALL ZMDIV_R2(MXY(1:2,5),MXY(1:2,3),QX)
      CALL ZMEXP(MXY(1:2,6),MXY(1:2,4),QX)
      CALL ZMDIV_R1(MXY(1:2,3),MXY(1:2,4),QX)

      CALL ZMI2M(1,MXY(1:2,15),QX)
      CALL ZMSUB_R2(MXY(1:2,15),MXY(1:2,3),QX)

      GO TO 210


  170 IF (NMETHD /= 3) GO TO 180


!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0.
!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).

!                                  erfc(x) = 0 + exp(-x^2)/sqrt(pi) /
!                                                                 x + 1 /
!                                                                   2*x + 2 /
!                                                                         x + 3 /
!                                                                           2*x + 4 /
!                                                                                 x + 5 ...

      IEXTRA = 0
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG) + 1
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      NDSAV1 = QX%NDIG
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMMPYI_R1(MXY(1:2,1),-1,QX)
      ENDIF

      CALL ZMEQ(MXY(1:2,1),MXY(1:2,2),QX)

      CALL ZMSQR(MXY(1:2,2),MXY(1:2,4),QX)
      CALL ZMMPYI(MXY(1:2,4),-1,MXY(1:2,15),QX)
      CALL ZMEXP(MXY(1:2,15),MXY(1:2,10),QX)
      CALL ZMEQ(MXY(1:2,10),MXY(1:2,15),QX)
      CALL FMPI(MXY(1,10),QX)
      CALL FMSQRT_R1(MXY(1,10),QX)
      CALL FMI2M(0,MXY(2,10),QX)
      CALL ZMDIV_R2(MXY(1:2,15),MXY(1:2,10),QX)
      CALL ZMDIV_R1(MXY(1:2,10),MXY(1:2,2),QX)
      CALL ZMI2M(-31,MXY(1:2,13),QX)

      CALL ZMEQ(MXY(1:2,10),MXY(1:2,14),QX)
      CALL ZMI2M(1,MXY(1:2,8),QX)
      CALL ZMEQ(MXY(1:2,2),MXY(1:2,9),QX)
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = QX%NDIG
      DO K = 3, NTERMS
         CALL ZMMPYI(MXY(1:2,2),1+MOD(K,2),MXY(1:2,11),QX)
         CALL ZMMPY_R1(MXY(1:2,11),MXY(1:2,9),QX)
         CALL ZMMPYI(MXY(1:2,8),K-2,MXY(1:2,12),QX)
         CALL ZMADD(MXY(1:2,11),MXY(1:2,12),MXY(1:2,7),QX)
         CALL ZMMPY_R1(MXY(1:2,10),MXY(1:2,12),QX)
         CALL ZMDIV_R1(MXY(1:2,10),MXY(1:2,7),QX)
         CALL ZMMPYI_R1(MXY(1:2,10),-1,QX)
         CALL ZMEQ(MXY(1:2,9),MXY(1:2,8),QX)
         CALL ZMEQ(MXY(1:2,7),MXY(1:2,9),QX)
         QX%NDIG = NDSAV2
         CALL ZMADD_R1(MXY(1:2,14),MXY(1:2,10),QX)

!             Check for convergence.

         IF (QX%KFLAG == 1 .AND. K > 2) THEN
             EXIT
         ENDIF
         KL = MAX( 1000.0, 5 * QX%ALOGMT * NDSAVE )
         IF (K > KL) THEN
             NMETHD = 2
             GO TO 140
         ENDIF
         CALL ZMEQ(MXY(1:2,10),MXY(1:2,13),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(                     &
                                      MIN(MXY(1,14)%MP(2)-MXY(1,10)%MP(2),  &
                                          MXY(2,14)%MP(2)-MXY(2,10)%MP(2)))))
      ENDDO

      CALL FMI2M(1,MXY(1,15),QX)
      CALL FMULP(MXY(1,15),MXY(2,15),QX)
      CALL FMDIV(MXY(1,1),MXY(2,1),MXY(1,15),QX)
      CALL FMSQR_R1(MXY(1,15),QX)
      IF (FMCOMP(MXY(1,15),'<',MXY(2,15),QX)) THEN
          CALL FMI2M(1,MXY(1,15),QX)
          CALL FMADD_R2(MXY(1,15),MXY(1,14),QX)
      ENDIF
      CALL ZMEQ(MXY(1:2,14),MXY(1:2,3),QX)
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMI2M(2,MXY(1:2,15),QX)
          CALL ZMSUB_R2(MXY(1:2,15),MXY(1:2,3),QX)
      ENDIF
      QX%NDIG = NDSAV1
      GO TO 210


!             Method 4.  Asymptotic series
!
!                        For Re(x) >= 0,
!                        erfc(x) = ( Exp(-x^2) / Sqrt(Pi) ) *
!                                  Sum_{k=0}^Infinity (  (-1)^k * poch(1/2,k) / x^(2*k+1) )

!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).

!             The series is  1/x - (1/2) / x^3  +  ( 1*3 )/(2^2) / x^5 - ( 1*3*5 )/(2^3) / x^7
!                            + ...

  180 IEXTRA = 0
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMMPYI_R1(MXY(1:2,1),-1,QX)
      ENDIF
      IF (KFLAGX == 0) THEN
          J2 = INT(0.66*SQRT(FMNTERMS(X**2,1,0,0,0,QX)) - 0.8)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,15),QX)
      CALL ZMMPYI(MXY(1:2,15),2,MXY(1:2,7),QX)
      CALL ZMI2M(1,MXY(1:2,8),QX)
      CALL ZMDIV(MXY(1:2,8),MXY(1:2,7),MXY(1:2,6),QX)
      CALL ZMI2M(1,MJSUMS(1:2,1),QX)
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL ZMMPYI_R1(MXY(1:2,8),2*NTERM-3,QX)
         CALL ZMEQ(MXY(1:2,8),MJSUMS(1:2,J),QX)
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 130
      CALL ZMIPWR(MXY(1:2,6),J2,MXY(1:2,7),QX)
      CALL ZMI2M(-31,MXY(1:2,13),QX)

  190 CALL ZMMPY_R2(MXY(1:2,7),MXY(1:2,8),QX)
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL ZMMPYI_R1(MXY(1:2,8),2*NTERM-3,QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,8),QX)
         IF (QX%KFLAG /= 0) GO TO 200
         KL = MAX( 19000.0, 6 * QX%ALOGMT * NDSAVE )
         IF (NTERM > KL) THEN
             CALL ZMABS(MXY(1:2,8),MXY(1,15),QX)
             CALL ZMABS(MXY(1:2,13),MXY(2,15),QX)
             IF (FMCOMP(MXY(1,15),'>',MXY(2,15),QX)) THEN
                 NMETHD = 2
                 GO TO 140
             ENDIF
         ENDIF
         CALL ZMEQ(MXY(1:2,8),MXY(1:2,13),QX)
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,8)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,8)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 190

!             Put the J2 separate sums back together.

  200 QX%KFLAG = 0
      CALL ZMMPYI(MXY(1:2,6),-1,MXY(1:2,4),QX)
      CALL ZMI2M(1,MXY(1:2,5),QX)
      DO J = 2, J2
         CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,4),QX)
         CALL ZMMPY(MXY(1:2,5),MJSUMS(1:2,J),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,1),MXY(1:2,8),QX)
         CALL ZMEQ(MXY(1:2,8),MJSUMS(1:2,1),QX)
      ENDDO
      CALL FMMPY(MXY(1,1),MXY(2,1),MXY(2,15),QX)
      CALL FMMPYI_R1(MXY(2,15),-2,QX)
      CALL FMI2M(0,MXY(1,15),QX)
      CALL ZMEXP(MXY(1:2,15),MXY(1:2,14),QX)
      CALL ZMMPY(MJSUMS(1:2,1),MXY(1:2,14),MXY(1:2,15),QX)
      CALL FMPI(MXY(1,4),QX)
      CALL FMSQRT(MXY(1,4),MXY(1,8),QX)
      CALL FMI2M(0,MXY(2,8),QX)
      CALL ZMMPY(MXY(1:2,8),MXY(1:2,1),MXY(1:2,14),QX)
      CALL ZMDIV(MXY(1:2,15),MXY(1:2,14),MXY(1:2,13),QX)
      CALL FMADD(MXY(2,1),MXY(1,1),MXY(1,12),QX)
      CALL FMSUB(MXY(2,1),MXY(1,1),MXY(1,11),QX)
      CALL FMMPY(MXY(1,12),MXY(1,11),MXY(1,10),QX)
      CALL FMEXP(MXY(1,10),MXY(1,12),QX)
      CALL FMMPY(MXY(1,13),MXY(1,12),MXY(1,4),QX)
      CALL FMMPY(MXY(2,13),MXY(1,12),MXY(2,4),QX)
      IF (MXY(1,4)%MP(2) == QX%MUNKNO) THEN
          CALL FMABS(MXY(1,13),MXY(1,14),QX)
          CALL FMLN(MXY(1,14),MXY(1,15),QX)
          CALL FMADD(MXY(1,10),MXY(1,15),MXY(1,14),QX)
          CALL FMEXP(MXY(1,14),MXY(1,4),QX)
          MXY(1,4)%MP(1) = MXY(1,13)%MP(1)
      ENDIF
      IF (MXY(2,4)%MP(2) == QX%MUNKNO) THEN
          CALL FMABS(MXY(2,13),MXY(1,14),QX)
          CALL FMLN(MXY(1,14),MXY(1,15),QX)
          CALL FMADD(MXY(1,10),MXY(1,15),MXY(1,14),QX)
          CALL FMEXP(MXY(1,14),MXY(2,4),QX)
          MXY(2,4)%MP(1) = MXY(2,13)%MP(1)
      ENDIF

      CALL FMI2M(1,MXY(1,15),QX)
      CALL FMULP(MXY(1,15),MXY(2,15),QX)
      CALL FMDIV(MXY(1,1),MXY(2,1),MXY(1,15),QX)
      CALL FMSQR_R1(MXY(1,15),QX)
      IF (FMCOMP(MXY(1,15),'<',MXY(2,15),QX)) THEN
          CALL FMI2M(1,MXY(1,15),QX)
          CALL FMADD_R2(MXY(1,15),MXY(1,4),QX)
      ENDIF

      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMI2M(2,MXY(1:2,15),QX)
          CALL ZMSUB(MXY(1:2,15),MXY(1:2,4),MXY(1:2,3),QX)
      ELSE
          CALL ZMEQ(MXY(1:2,4),MXY(1:2,3),QX)
      ENDIF

  210 QX%NAMEST(QX%NCALL) = 'ZMERFC'
      IF (MA(1)%MP(3) == 0) THEN
          IF (MXY(2,3)%MP(2) /= QX%MUNKNO) THEN
              CALL FMI2M(1,MXY(1,3),QX)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL == 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(1,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          ERR2 = 0
          DO J = KL, 1, -1
             ERR2 = (ERR2 + MXY(2,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR   > 0.498 .AND. ERR  < 0.502) .OR.  &
               (QX%KROUND == 1 .AND. ERR2  > 0.498 .AND. ERR2 < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR  > 0.998 .OR. ERR  < 0.002)) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR2 > 0.998 .OR. ERR2 < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (MXY(1,3)%MP(2) == QX%MUNKNO .OR. MXY(2,3)%MP(2) == QX%MUNKNO) THEN
          CALL ZMST2M('UNKNOWN + UNKNOWN i',MXY(1:2,3),QX)
      ENDIF

      CALL ZMEXIT(MXY(1:2,3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMERFC

      SUBROUTINE ZMERFC_SC(MA,MB,QX)

!  MB = Exp(MA**2) * Erfc(MA)    Scaled complimentary error function.

!  Erfc(z) underflows for relatively small magnitude |z| in the right half-plane (Re(z) >= 0).
!  Multiplying by Exp(z**2) allows the scaled complimentary error function to be computed even
!  when |z| is large and Re(z) >= 0.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: C1,C2,C4,ERR,ERR2,X,XK
      DOUBLE PRECISION, EXTERNAL :: FMNTERMS
      INTEGER :: IEXTRA,J,J2,K,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,  &
                 NDSAVE,NDSAV1,NDSAV2,NMETHD,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MXY(2,15), MJSUMS(2,LJSUMS)
      LOGICAL, EXTERNAL :: FMCOMP


      CALL ZMENTR('ZMERFC_SC',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(1)%MP(3) == 0 .AND. MA(2)%MP(3) == 0) THEN
          CALL ZMEQ(MXY(1:2,1),MXY(1:2,3),QX)
          GO TO 210
      ENDIF
      IF (MXY(1,1)%MP(2) == QX%MEXPUN .OR. MXY(2,1)%MP(2) == QX%MEXPUN) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
          QX%KFLAG = -4
          GO TO 210
      ENDIF

!             X is a double precision approximation to the size of input argument to this function.

      CALL ZMABS(MXY(1:2,1),MXY(1,4),QX)
      CALL FMM2DP(MXY(1,4),X,QX)
      KFLAGX = QX%KFLAG
      IF (QX%KFLAG /= 0 .AND. MXY(1,4)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX**0.33D0
          KFLAGX = 0
      ELSE IF (QX%KFLAG == 0 .AND. X < 1.0D0/DPMAX**0.33D0) THEN
          X = 1.0D0/DPMAX**0.33D0
      ENDIF
      IF (QX%KFLAG /= 0 .AND. MXY(1,4)%MP(2) > 0) THEN
          X = DPMAX**0.33D0
          KFLAGX = 0
      ELSE IF (QX%KFLAG == 0 .AND. X > DPMAX**0.33D0) THEN
          X = DPMAX**0.33D0
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      XK = MAX(3.0D0,(2*X**2 + 1)/2)
      XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
           LOG(X)*(2*XK+1)
      IF (-XK/QX%DLOGMB > QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52) THEN
          NMETHD = 4
      ELSE
          C4 = 5.0
          XK = 0.0
          DO WHILE (-XK/QX%DLOGMB <= QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52)
             C4 = 2 * C4
             XK = MAX(3.0D0,(2*C4**2 + 1)/2)
             XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
                  LOG(C4)*(2*XK+1)
          ENDDO
          C1 = C4/2
          DO WHILE (C4-C1 > 0.1)
             C2 = (C1 + C4) / 2
             XK = MAX(3.0D0,(2*C2**2 + 1)/2)
             XK = -XK + LOG(2*XK-1)*(2*XK-0.5D0) + LOG(XK-1)*(-XK+0.5D0) - LOG(2.0D0)*(2*XK-1) -  &
                  LOG(C2)*(2*XK+1)
             IF (-XK/QX%DLOGMB > QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52) THEN
                 C4 = C2
             ELSE
                 C1 = C2
             ENDIF
          ENDDO
          CALL FMDIV(MXY(2,1),MXY(1,1),MXY(1,15),QX)
          CALL FMABS(MXY(1,15),MXY(2,15),QX)
          CALL FMDP2M(1.5D0,MXY(1,15),QX)
          IF (FMCOMP(MXY(2,15),'>',MXY(1,15),QX) .OR. MXY(1,1)%MP(3) == 0) THEN
              IF (X > 0.8*C4) THEN
                  NMETHD = 3
              ELSE
                  NMETHD = 1
              ENDIF
          ELSE
              IF (X > 0.6*C4) THEN
                  NMETHD = 3
              ELSE IF (X > 6.0) THEN
                  NMETHD = 2
              ELSE
                  NMETHD = 1
              ENDIF
          ENDIF
      ENDIF
      IF (NMETHD /= 1) GO TO 140


!             Method 1.  Use the 1 - (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        exp(x^2) * ( 1 - (2/sqrt(pi))*( x - x^3/1! + x^5/2! - x^7/3! + ... ) )

      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG+QX%NGRD52)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             If MA is large in magnitude or close to the real line, use more guard digits.

      CALL FMSQR(MXY(1,1),MXY(1,15),QX)
      CALL FMSQR(MXY(2,1),MXY(2,15),QX)
      CALL FMMPY(MXY(1,1),MXY(2,1),MXY(1,14),QX)
      CALL FMST2M('-4.408443',MXY(1,13),QX)

      CALL FMST2M(' 0.000832',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.002632',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.124034',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M('-0.000291',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,14),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.001637',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMM2I(MXY(1,13),IEXTRA,QX)
      IEXTRA = MAX(0,NINT((IEXTRA+3) * 16.11809565D0 / QX%DLOGMB)+1)
      IF (IEXTRA > 0) THEN
          CALL ZMEQU_R1(MXY(1:2,1),QX%NDIG,QX%NDIG+IEXTRA,QX)
      ENDIF
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KFLAGX == 0) THEN
          J2 = INT(0.66*SQRT(FMNTERMS(X**2,1,0,0,1,QX)) - 0.8)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMI2M(1,MXY(1:2,6),QX)
      CALL ZMI2M(1,MJSUMS(1:2,1),QX)

      DO J = 2, J2
         IF (NTERM > 1) THEN
             CALL ZMDIVI_R1(MXY(1:2,6),NTERM,QX)
         ENDIF
         CALL ZMDIVI(MXY(1:2,6),2*NTERM+1,MJSUMS(1:2,J),QX)
         NTERM = NTERM + 1
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 130
      CALL ZMIPWR(MXY(1:2,1),2*J2,MXY(1:2,5),QX)

  120 CALL ZMMPY_R1(MXY(1:2,6),MXY(1:2,5),QX)
      DO J = 1, J2
         CALL ZMDIVI_R1(MXY(1:2,6),NTERM,QX)
         CALL ZMDIVI(MXY(1:2,6),2*NTERM+1,MXY(1:2,4),QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,4),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,4)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,4)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,4),QX)
      CALL ZMMPYI_R1(MXY(1:2,4),-1,QX)
      CALL ZMEQ(MJSUMS(1:2,J2),MXY(1:2,5),QX)

      DO J = 2, J2
         CALL ZMMPY(MXY(1:2,5),MXY(1:2,4),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,J2-J+1),MXY(1:2,5),QX)
      ENDDO

      CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,1),QX)

      CALL FMPI(MXY(1,4),QX)
      CALL FMI2M(0,MXY(2,4),QX)
      CALL ZMSQRT(MXY(1:2,4),MXY(1:2,3),QX)
      CALL ZMMPYI(MXY(1:2,5),2,MXY(1:2,4),QX)
      CALL ZMDIV_R2(MXY(1:2,4),MXY(1:2,3),QX)

      CALL ZMI2M(1,MXY(1:2,15),QX)
      CALL ZMSUB_R2(MXY(1:2,15),MXY(1:2,3),QX)
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,15),QX)
      CALL ZMEXP(MXY(1:2,15),MXY(1:2,14),QX)
      CALL ZMMPY_R1(MXY(1:2,3),MXY(1:2,14),QX)
      GO TO 210

  140 IF (NMETHD /= 2) GO TO 170


!             Method 2.  Use the 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

!                        exp(x^2) * ( 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) )

      IEXTRA = 0
      CALL FMSQR(MXY(1,1),MXY(1,15),QX)
      CALL FMSQR(MXY(2,1),MXY(2,15),QX)
      CALL FMMPY(MXY(1,1),MXY(2,1),MXY(1,14),QX)
      CALL FMST2M('-1.966130',MXY(1,13),QX)

      CALL FMST2M(' 0.002853',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M('-0.001447',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,1),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.062040',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M('-0.000063',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(1,14),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMST2M(' 0.061968',MXY(2,13),QX)
      CALL FMMPY_R1(MXY(2,13),MXY(2,15),QX)
      CALL FMADD_R1(MXY(1,13),MXY(2,13),QX)

      CALL FMM2I(MXY(1,13),IEXTRA,QX)
      IEXTRA = MAX(0,NINT((IEXTRA+3) * 16.11809565D0 / QX%DLOGMB)+1)
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG) + 1
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      IF (KFLAGX == 0) THEN
          J2 = INT(0.51*SQRT(FMNTERMS(2*X,2,-1,0,1,QX)))
      ELSE
          J2 = 1
      ENDIF
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMMPYI(MXY(1:2,1),2,MXY(1:2,6),QX)
      CALL ZMEQ(MXY(1:2,6),MJSUMS(1:2,1),QX)
      DO J = 2, J2
         CALL ZMMPYI_R1(MXY(1:2,6),2,QX)
         CALL ZMDIVI_R1(MXY(1:2,6),2*NTERM+1,QX)
         CALL ZMEQ(MXY(1:2,6),MJSUMS(1:2,J),QX)
         NTERM = NTERM + 1
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 160
      CALL ZMIPWR(MXY(1:2,1),2*J2,MXY(1:2,5),QX)

  150 CALL ZMMPY_R1(MXY(1:2,6),MXY(1:2,5),QX)
      DO J = 1, J2
         CALL ZMMPYI(MXY(1:2,6),2,MXY(1:2,15),QX)
         CALL ZMDIVI(MXY(1:2,15),2*NTERM+1,MXY(1:2,6),QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,6),QX)
         IF (QX%KFLAG /= 0) GO TO 160
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,6)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,6)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 150

!             Put the J2 separate sums back together.

  160 QX%KFLAG = 0
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,6),QX)
      CALL ZMEQ(MJSUMS(1:2,J2),MXY(1:2,5),QX)
      DO J = 2, J2
         CALL ZMMPY(MXY(1:2,5),MXY(1:2,6),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,J2-J+1),MXY(1:2,5),QX)
      ENDDO

      CALL FMPI(MXY(1,4),QX)
      CALL FMI2M(0,MXY(2,4),QX)
      CALL ZMSQRT(MXY(1:2,4),MXY(1:2,3),QX)
      CALL ZMDIV_R2(MXY(1:2,5),MXY(1:2,3),QX)
      CALL ZMEXP(MXY(1:2,6),MXY(1:2,4),QX)
      CALL ZMDIV_R1(MXY(1:2,3),MXY(1:2,4),QX)

      CALL ZMI2M(1,MXY(1:2,15),QX)
      CALL ZMSUB_R2(MXY(1:2,15),MXY(1:2,3),QX)

      CALL ZMSQR(MXY(1:2,1),MXY(1:2,15),QX)
      CALL ZMEXP(MXY(1:2,15),MXY(1:2,14),QX)
      CALL ZMMPY_R1(MXY(1:2,3),MXY(1:2,14),QX)
      GO TO 210


  170 IF (NMETHD /= 3) GO TO 180


!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0.

!                               erfc_sc(x) = 0 + 1/sqrt(pi) /
!                                                         x + 1 /
!                                                           2*x + 2 /
!                                                                 x + 3 /
!                                                                   2*x + 4 /
!                                                                         x + 5 ...
!
!                        For Re(x) < 0, use   erfc_sc(x) = exp(x**2) * (1 - erf(x))
!                                                        = exp(x**2) * (1 + erf(-x))
!                                                        = exp(x**2) * (2 - erfc(-x))
!                                                        = 2*exp(x**2) - erfc_sc(-x)

      IEXTRA = 0
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG) + 1
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      NDSAV1 = QX%NDIG
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMMPYI_R1(MXY(1:2,1),-1,QX)
      ENDIF

      CALL ZMEQ(MXY(1:2,1),MXY(1:2,2),QX)

      CALL ZMI2M(1,MXY(1:2,15),QX)
      CALL FMPI(MXY(1,10),QX)
      CALL FMSQRT_R1(MXY(1,10),QX)
      CALL FMI2M(0,MXY(2,10),QX)
      CALL ZMDIV_R2(MXY(1:2,15),MXY(1:2,10),QX)
      CALL ZMDIV_R1(MXY(1:2,10),MXY(1:2,2),QX)
      CALL ZMI2M(-31,MXY(1:2,13),QX)

      CALL ZMEQ(MXY(1:2,10),MXY(1:2,14),QX)
      CALL ZMI2M(1,MXY(1:2,8),QX)
      CALL ZMEQ(MXY(1:2,2),MXY(1:2,9),QX)
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = QX%NDIG
      DO K = 3, NTERMS
         CALL ZMMPYI(MXY(1:2,2),1+MOD(K,2),MXY(1:2,11),QX)
         CALL ZMMPY_R1(MXY(1:2,11),MXY(1:2,9),QX)
         CALL ZMMPYI(MXY(1:2,8),K-2,MXY(1:2,12),QX)
         CALL ZMADD(MXY(1:2,11),MXY(1:2,12),MXY(1:2,7),QX)
         CALL ZMMPY_R1(MXY(1:2,10),MXY(1:2,12),QX)
         CALL ZMDIV_R1(MXY(1:2,10),MXY(1:2,7),QX)
         CALL ZMMPYI_R1(MXY(1:2,10),-1,QX)
         CALL ZMEQ(MXY(1:2,9),MXY(1:2,8),QX)
         CALL ZMEQ(MXY(1:2,7),MXY(1:2,9),QX)
         QX%NDIG = NDSAV2
         CALL ZMADD_R1(MXY(1:2,14),MXY(1:2,10),QX)

!             Check for convergence.

         IF (QX%KFLAG == 1 .AND. K > 2) THEN
             EXIT
         ENDIF
         KL = MAX( 1000.0, 5 * QX%ALOGMT * NDSAVE )
         IF (K > KL) THEN
             NMETHD = 2
             GO TO 140
         ENDIF
         CALL ZMEQ(MXY(1:2,10),MXY(1:2,13),QX)
         QX%NDIG = MIN(NDSAV2,MAX(QX%NGRD22,NDSAV2-INT(                     &
                                      MIN(MXY(1,14)%MP(2)-MXY(1,10)%MP(2),  &
                                          MXY(2,14)%MP(2)-MXY(2,10)%MP(2)))))
      ENDDO

      CALL FMI2M(1,MXY(1,15),QX)
      CALL FMULP(MXY(1,15),MXY(2,15),QX)
      CALL FMDIV(MXY(1,1),MXY(2,1),MXY(1,15),QX)
      CALL FMSQR_R1(MXY(1,15),QX)
      IF (FMCOMP(MXY(1,15),'<',MXY(2,15),QX)) THEN
          CALL ZMSQR(MXY(1:2,1),MXY(1:2,13),QX)
          CALL ZMEXP(MXY(1:2,13),MXY(1:2,15),QX)
          CALL ZMADD_R2(MXY(1:2,15),MXY(1,14),QX)
      ENDIF
      CALL ZMEQ(MXY(1:2,14),MXY(1:2,3),QX)
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMSQR(MXY(1:2,1),MXY(1:2,15),QX)
          CALL ZMEXP(MXY(1:2,15),MXY(1:2,14),QX)
          CALL ZMMPYI(MXY(1:2,14),2,MXY(1:2,15),QX)
          CALL ZMSUB_R2(MXY(1:2,15),MXY(1:2,3),QX)
      ENDIF
      QX%NDIG = NDSAV1
      GO TO 210


!             Method 4.  Asymptotic series
!
!                        For Re(x) >= 0,
!                        erfc_sc(x) = ( 1 / Sqrt(Pi) ) *
!                                  Sum_{k=0}^Infinity (  (-1)^k * poch(1/2,k) / x^(2*k+1) )

!                        The series is  1/x - (1/2) / x^3  +  ( 1*3 )/(2^2) / x^5 -
!                                       ( 1*3*5 )/(2^3) / x^7 + ...

!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).
!                                       erfc_sc(x) = Exp(x^2) * (2 - erfc(-x))
!                                                  = 2*Exp(x^2) - erfc_sc(-x)

  180 IEXTRA = 0
      QX%NDIG = QX%NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMMPYI_R1(MXY(1:2,1),-1,QX)
      ENDIF
      IF (KFLAGX == 0) THEN
          J2 = INT(0.66*SQRT(FMNTERMS(X**2,1,0,0,0,QX)) - 0.8)
          J2 = MAX(2,MIN(J2+MOD(J2,2),LJSUMS))
      ELSE
          J2 = 2
      ENDIF
      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL ZMSQR(MXY(1:2,1),MXY(1:2,15),QX)
      CALL ZMMPYI(MXY(1:2,15),2,MXY(1:2,7),QX)
      CALL ZMI2M(1,MXY(1:2,8),QX)
      CALL ZMDIV(MXY(1:2,8),MXY(1:2,7),MXY(1:2,6),QX)
      CALL ZMI2M(1,MJSUMS(1:2,1),QX)
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL ZMMPYI_R1(MXY(1:2,8),2*NTERM-3,QX)
         CALL ZMEQ(MXY(1:2,8),MJSUMS(1:2,J),QX)
      ENDDO
      CALL ZMABS(MXY(1:2,1),MXY(1,15),QX)
      IF (MXY(1,15)%MP(2) < -QX%NDIG) GO TO 130
      CALL ZMIPWR(MXY(1:2,6),J2,MXY(1:2,7),QX)
      CALL ZMI2M(-31,MXY(1:2,13),QX)

  190 CALL ZMMPY_R2(MXY(1:2,7),MXY(1:2,8),QX)
      DO J = 1, J2
         NTERM = NTERM + 1
         CALL ZMMPYI_R1(MXY(1:2,8),2*NTERM-3,QX)
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,8),QX)
         IF (QX%KFLAG /= 0) GO TO 200
         KL = MAX( 19000.0, 6 * QX%ALOGMT * NDSAVE )
         IF (NTERM > KL) THEN
             CALL ZMABS(MXY(1:2,8),MXY(1,15),QX)
             CALL ZMABS(MXY(1:2,13),MXY(2,15),QX)
             IF (FMCOMP(MXY(1,15),'>',MXY(2,15),QX)) THEN
                 NMETHD = 2
                 GO TO 140
             ENDIF
         ENDIF
         CALL ZMEQ(MXY(1:2,8),MXY(1:2,13),QX)
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,8)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,8)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 190

!             Put the J2 separate sums back together.

  200 QX%KFLAG = 0
      CALL ZMMPYI(MXY(1:2,6),-1,MXY(1:2,4),QX)
      CALL ZMI2M(1,MXY(1:2,5),QX)
      DO J = 2, J2
         CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,4),QX)
         CALL ZMMPY(MXY(1:2,5),MJSUMS(1:2,J),MXY(1:2,15),QX)
         CALL ZMADD(MXY(1:2,15),MJSUMS(1:2,1),MXY(1:2,8),QX)
         CALL ZMEQ(MXY(1:2,8),MJSUMS(1:2,1),QX)
      ENDDO

      CALL FMPI(MXY(1,4),QX)
      CALL FMSQRT(MXY(1,4),MXY(1,8),QX)
      CALL FMI2M(0,MXY(2,8),QX)
      CALL ZMDIV(MJSUMS(1:2,1),MXY(1:2,8),MXY(1:2,4),QX)
      CALL ZMDIV_R1(MXY(1:2,4),MXY(1:2,1),QX)

      CALL FMI2M(1,MXY(1,15),QX)
      CALL FMULP(MXY(1,15),MXY(2,15),QX)
      CALL FMDIV(MXY(1,1),MXY(2,1),MXY(1,15),QX)
      CALL FMSQR_R1(MXY(1,15),QX)
      IF (FMCOMP(MXY(1,15),'<',MXY(2,15),QX)) THEN
          CALL ZMSQR(MXY(1:2,1),MXY(1:2,13),QX)
          CALL ZMEXP(MXY(1:2,13),MXY(1:2,15),QX)
          CALL ZMADD_R2(MXY(1:2,15),MXY(1:2,4),QX)
      ENDIF
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMSQR(MXY(1:2,1),MXY(1:2,15),QX)
          CALL FMI2M(2,MXY(1,14),QX)
          CALL FMLN(MXY(1,14),MXY(1,13),QX)
          CALL FMADD_R1(MXY(1,15),MXY(1,13),QX)
          CALL ZMEXP(MXY(1:2,15),MXY(1:2,14),QX)
          CALL ZMSUB(MXY(1:2,14),MXY(1:2,4),MXY(1:2,3),QX)
      ELSE
          CALL ZMEQ(MXY(1:2,4),MXY(1:2,3),QX)
      ENDIF

  210 QX%NAMEST(QX%NCALL) = 'ZMERFC_SC'

      IF (MA(1)%MP(3) == 0) THEN
          IF (MXY(2,3)%MP(2) /= QX%MUNKNO) THEN
              CALL FMSQR(MXY(2,1),MXY(1,4),QX)
              CALL FMMPYI_R1(MXY(1,4),-1,QX)
              CALL FMEXP(MXY(1,4),MXY(1,3),QX)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL == 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(1,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          ERR2 = 0
          DO J = KL, 1, -1
             ERR2 = (ERR2 + MXY(2,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR   > 0.498 .AND. ERR  < 0.502) .OR.  &
               (QX%KROUND == 1 .AND. ERR2  > 0.498 .AND. ERR2 < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR  > 0.998 .OR. ERR  < 0.002)) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR2 > 0.998 .OR. ERR2 < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (MXY(1,3)%MP(2) == QX%MUNKNO .OR. MXY(2,3)%MP(2) == QX%MUNKNO) THEN
          CALL ZMST2M('UNKNOWN + UNKNOWN i',MXY(1:2,3),QX)
      ENDIF

      CALL ZMEXIT(MXY(1:2,3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMERFC_SC

      SUBROUTINE ZMLNGM(MA,MB,QX)

!  MB = LogGamma(MA)

!  In the complex plane this Log Gamma function is not identical to Ln(Gamma(MA)), because of
!  branch points in the complex log function.

!  This function returns the function value of the principal branch of the log gamma function.
!  It is the same as Ln(Gamma(MA)) when MA is a positive real number, but it can differ from
!  Ln(Gamma(MA)) by an integer multiple of 2*pi*i elsewhere.  Note that we still have
!  Gamma(z) = exp(LogGamma(z)) = exp(Ln(Gamma(z))) even when they differ.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MBSBRN
      INTEGER :: NUMBRN
      TYPE(MULTI) :: MBERN(LMBERN)
      INTEGER :: NDBERN(LMBERN)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR,ERR2,X,XK,XS
      INTEGER :: J,J1,J2,JC,JS,KL,KOVUN,KR_RETRY,KRESLT,KZ,LARGE,  &
                 NDSAVE,NDSAV1,NTERM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MXY(2,15), MJSUMS(2,LJSUMS)
      LOGICAL, EXTERNAL :: FMCOMP

      MBSBRN = 0
      NUMBRN = 0
      NDBERN = 0

!             If MA is real and positive, use FMLNGM.

      IF (MA(2)%MP(3) == 0) THEN
          IF (MA(1)%MP(1) > 0 .AND. MA(1)%MP(3) > 0) THEN
              CALL FMLNGM(MA(1),MB(1),QX)
              CALL FMI2M(0,MB(2),QX)
              IF (MB(1)%MP(2) == QX%MUNKNO) THEN
                  CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB,QX)
              ENDIF
              RETURN
          ENDIF
      ENDIF


      CALL ZMENTR('ZMLNGM   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(2)%MP(3) == 0) THEN
          CALL FMINT(MXY(1,1),MXY(1,15),QX)
          IF (FMCOMP(MXY(1,1),'==',MXY(1,15),QX)) THEN
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
              QX%KFLAG = -4
              GO TO 140
          ENDIF
      ENDIF
      IF (MXY(1,1)%MP(2) == QX%MEXPUN .OR. MXY(2,1)%MP(2) == QX%MEXPUN) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
          QX%KFLAG = -4
          GO TO 140
      ENDIF
      CALL ZMABS(MXY(1:2,1),MXY(1,2),QX)
      CALL FMI2M(1,MXY(1,4),QX)
      IF (FMCOMP(MXY(1,2),'<',MXY(1,4),QX)) THEN
          CALL ZMLN(MXY(1:2,1),MXY(1:2,4),QX)
          CALL ZMMPYI_R1(MXY(1:2,4),-1,QX)
          CALL FMEULER(MXY(1,5),QX)
          CALL FMI2M(0,MXY(2,5),QX)
          CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,1),QX)
          CALL ZMSUB_R1(MXY(1:2,4),MXY(1:2,5),QX)
          CALL FMPI(MXY(1,3),QX)
          CALL FMSQR_R1(MXY(1,3),QX)
          CALL FMDIVI_R1(MXY(1,3),12,QX)
          CALL FMI2M(0,MXY(2,3),QX)
          CALL ZMSQR(MXY(1:2,1),MXY(1:2,5),QX)
          CALL ZMMPY(MXY(1:2,3),MXY(1:2,5),MXY(1:2,6),QX)
          CALL ZMADD_R1(MXY(1:2,4),MXY(1:2,6),QX)
          CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,1),QX)
          CALL ZMMPYI(MXY(1:2,5),4,MXY(1:2,6),QX)
          CALL ZMDIVI_R1(MXY(1:2,6),10,QX)
          CALL ZMSUB(MXY(1,4),MXY(1,6),MXY(1,3),QX)
          IF (QX%KFLAG == 1) THEN
              GO TO 140
          ENDIF
      ENDIF

!             X is a double precision approximation to the size of input argument to this function.

      CALL ZMABS(MXY(1:2,1),MXY(1,4),QX)
      CALL FMM2DP(MXY(1,4),X,QX)
      IF (QX%KFLAG /= 0 .AND. MXY(1,4)%MP(2) < 0) THEN
          X = 1.0D0/DPMAX**0.33D0
      ELSE IF (QX%KFLAG == 0 .AND. X < 1.0D0/DPMAX**0.33D0) THEN
          X = 1.0D0/DPMAX**0.33D0
      ENDIF
      IF (QX%KFLAG /= 0 .AND. MXY(1,4)%MP(2) > 0) THEN
          X = DPMAX**0.33D0
      ELSE IF (QX%KFLAG == 0 .AND. X > DPMAX**0.33D0) THEN
          X = DPMAX**0.33D0
      ENDIF

!             Determine the smallest shift JS for which the asymptotic series for ln(gamma(x+js))
!             converges for the current precison.

      CALL ZMEQ(MXY(1:2,1),MXY(1:2,2),QX)
      MXY(1,2)%MP(1) = 1
      XK = 1.5D0*LOG(ABS(X)) - 2*3.14159*ABS(X)
      IF (ABS(X) < 2) XK = 0
      IF (-XK/QX%DLOGMB > QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52) THEN
          JS = 0
      ELSE
          J1 = 1
          J2 = J1
          DO WHILE (-XK/QX%DLOGMB <= QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52)
             J2 = 2*J2
             CALL ZMI2M(J2,MXY(1:2,5),QX)
             CALL ZMADD(MXY(1:2,2),MXY(1:2,5),MXY(1:2,6),QX)
             CALL ZMABS(MXY(1:2,6),MXY(1,4),QX)
             CALL FMM2DP(MXY(1,4),XS,QX)
             XK = 1.5D0*LOG(XS) - 2*3.14159*XS
          ENDDO
          JS = J2
          DO WHILE (ABS(J2-J1) > 1)
             JS = (J1 + J2) / 2
             CALL ZMI2M(JS,MXY(1:2,5),QX)
             CALL ZMADD(MXY(1:2,2),MXY(1:2,5),MXY(1:2,6),QX)
             CALL ZMABS(MXY(1:2,6),MXY(1,4),QX)
             CALL FMM2DP(MXY(1,4),XS,QX)
             XK = 1.5D0*LOG(XS) - 2*3.14159*XS
             IF (-XK/QX%DLOGMB > QX%NDIG+(3+QX%NDIG/20)*QX%NGRD52) THEN
                 J2 = JS
             ELSE
                 J1 = JS
             ENDIF
          ENDDO
      ENDIF

!             Use the asymptotic series after replacing input z by 1-z via the reflection formula
!             if re(z) < 0, by conjugate(z) if im(z) < 0, and by z+js if needed for enough accuracy.

      CALL ZMEQ(MXY(1:2,1),MXY(1:2,2),QX)
      IF (MA(1)%MP(1) < 0) THEN
          CALL ZMI2M(1,MXY(1:2,15),QX)
          CALL ZMSUB_R2(MXY(1:2,15),MXY(1:2,2),QX)
      ENDIF
      JC = 0
      IF (MXY(2,2)%MP(1) < 0) THEN
          JC = 1
          CALL FMMPYI_R1(MXY(2,2),-1,QX)
      ENDIF
      CALL ZMI2M(JS,MXY(1:2,5),QX)
      CALL ZMADD_R1(MXY(1:2,2),MXY(1:2,5),QX)
      IF (KR_RETRY <= 0 .AND. QX%NCALL <= 1) THEN
          QX%NDIG = MAX(NDSAVE+QX%NGRD52,QX%NDIG-1)
      ENDIF
      J2 = INT(0.3*QX%ALOGMB + 0.2*SQRT(REAL(QX%NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

      NDSAV1 = QX%NDIG

!             Split into J2 concurrent sums.

      CALL ZMSQR(MXY(1:2,2),MXY(1:2,6),QX)
      CALL ZMI2M(1,MXY(1:2,15),QX)
      CALL ZMDIV_R2(MXY(1:2,15),MXY(1:2,6),QX)
      CALL ZMIPWR(MXY(1:2,6),J2,MXY(1:2,7),QX)
      CALL ZMEQ(MXY(1:2,2),MXY(1:2,8),QX)

      NTERM = 0
      CALL ZMLN(MXY(1:2,2),MXY(1:2,10),QX)
      CALL ZMI2M(1,MXY(1:2,11),QX)
      CALL ZMDIVI_R1(MXY(1:2,11),2,QX)
      CALL ZMSUB(MXY(1:2,2),MXY(1:2,11),MXY(1:2,12),QX)
      CALL ZMMPY(MXY(1:2,10),MXY(1:2,12),MXY(1:2,11),QX)
      CALL ZMSUB(MXY(1:2,11),MXY(1:2,2),MXY(1:2,10),QX)
      CALL FMPI(MXY(1,11),QX)
      CALL FMMPYI_R1(MXY(1,11),2,QX)
      CALL FMLN(MXY(1,11),MXY(1,12),QX)
      CALL FMDIVI_R1(MXY(1,12),2,QX)
      CALL FMI2M(0,MXY(2,12),QX)
      CALL ZMADD(MXY(1:2,10),MXY(1:2,12),MJSUMS(1:2,1),QX)
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMBERN(2*NTERM,MXY(1,8),MXY(1,15),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         CALL FMBERN(2*NTERM,MXY(2,8),MXY(2,15),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         CALL ZMDIVI(MXY(1:2,15),(2*NTERM-1)*2*NTERM,MJSUMS(1:2,J),QX)
      ENDDO

      CALL ZMI2M(0,MXY(1:2,9),QX)
      CALL ZMI2M(0,MXY(1:2,13),QX)
      CALL ZMEQ(MJSUMS(1:2,J2),MXY(1:2,13),QX)

  120 CALL ZMMPY_R2(MXY(1:2,7),MXY(1:2,8),QX)
      DO J = 1, J2
         NTERM = NTERM + 1
         LARGE = INT(INTMAX/(2*NTERM))/(2*NTERM)
         CALL FMBERN(2*NTERM,MXY(1,8),MXY(1,15),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         CALL FMBERN(2*NTERM,MXY(2,8),MXY(2,15),MBSBRN,NUMBRN,MBERN,NDBERN,QX)
         IF (NTERM < LARGE) THEN
             CALL ZMDIVI_R1(MXY(1:2,15),(2*NTERM-1)*2*NTERM,QX)
         ELSE
             CALL ZMDIVI_R1(MXY(1:2,15),2*NTERM-1,QX)
             CALL ZMDIVI_R1(MXY(1:2,15),2*NTERM,QX)
         ENDIF
         QX%NDIG = NDSAV1
         CALL ZMADD_R1(MJSUMS(1:2,J),MXY(1:2,15),QX)
         IF (QX%KFLAG /= 0) GO TO 130
         IF (J == J2) THEN
             CALL ZMEQ(MXY(1:2,9),MXY(1:2,13),QX)
             CALL ZMEQ(MXY(1:2,15),MXY(1:2,9),QX)
         ENDIF
         KL = MAX( 19000.0, 6 * QX%ALOGMT * NDSAVE )
         IF (NTERM > KL) THEN
             CALL ZMABS(MXY(1:2,9),MXY(1,15),QX)
             CALL ZMABS(MXY(1:2,13),MXY(2,15),QX)
             IF (FMCOMP(MXY(1,15),'>',MXY(2,15),QX)) THEN
                 CALL ZMST2M('UNKNOWN + UNKNOWN i',MXY(1:2,3),QX)
                 GO TO 140
             ENDIF
         ENDIF
         QX%NDIG = NDSAV1 - INT(MIN(MJSUMS(1,J)%MP(2)-MXY(1,15)%MP(2),  &
                                 MJSUMS(2,J)%MP(2)-MXY(2,15)%MP(2)))
         QX%NDIG = MIN(NDSAV1,QX%NDIG)
         IF (QX%NDIG < QX%NGRD22) QX%NDIG = QX%NGRD22
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 QX%KFLAG = 0
      CALL ZMI2M(1,MXY(1:2,5),QX)
      DO J = 2, J2
         CALL ZMMPY_R1(MXY(1:2,5),MXY(1:2,6),QX)
         CALL ZMMPY(MXY(1:2,5),MJSUMS(1:2,J),MXY(1:2,15),QX)
         CALL ZMADD_R2(MXY(1:2,15),MJSUMS(1:2,1),QX)
      ENDDO
      CALL ZMEQ(MJSUMS(1:2,1),MXY(1:2,3),QX)

!             Reverse the effects of modifying the original argument.

      KZ = 0
      KL = 1
      IF (JS /= 0) THEN
          CALL ZMEQ(MXY(1:2,1),MXY(1:2,14),QX)
          IF (MA(1)%MP(1) < 0) THEN
              CALL ZMI2M(1,MXY(1:2,15),QX)
              CALL ZMSUB_R2(MXY(1:2,15),MXY(1:2,14),QX)
          ENDIF
          IF (MXY(2,14)%MP(1) < 0) THEN
              CALL FMMPYI_R1(MXY(2,14),-1,QX)
          ENDIF
          CALL ZMI2M(1,MXY(1:2,15),QX)
          DO J = 1, JS
             CALL ZMMPY_R1(MXY(1:2,15),MXY(1:2,14),QX)
             IF (MXY(2,15)%MP(1) < 0 .AND. KL == 1) KZ = KZ + 1
             KL = MXY(2,15)%MP(1)
             CALL FMADDI(MXY(1,14),1,QX)
          ENDDO
          CALL ZMLN(MXY(1:2,15),MXY(1:2,14),QX)
          CALL ZMSUB_R1(MXY(1:2,3),MXY(1:2,14),QX)
          CALL FMPI(MXY(2,14),QX)
          CALL FMMPYI_R1(MXY(2,14),2*KZ,QX)
          CALL FMSUB_R1(MXY(2,3),MXY(2,14),QX)
      ENDIF

      IF (JC == 1) THEN
          CALL FMMPYI_R1(MXY(2,3),-1,QX)
      ENDIF
      IF (MA(1)%MP(1) < 0) THEN
          CALL FMPI(MXY(1,14),QX)
          CALL FMI2M(0,MXY(2,14),QX)
          CALL ZMMPY(MXY(1:2,14),MXY(1:2,1),MXY(1:2,15),QX)
          CALL ZMSIN(MXY(1:2,15),MXY(1:2,13),QX)
          IF (ABS(MXY(1,13)%MP(2)) >= QX%MEXPOV .OR. ABS(MXY(2,13)%MP(2)) >= QX%MEXPOV) THEN
              CALL FMCOS_SIN(MXY(1,15),MXY(2,10),MXY(1,10),QX)
              IF (MXY(2,15)%MP(1) < 0) CALL FMMPYI_R1(MXY(2,10),-1,QX)
              CALL ZMARG(MXY(1:2,10),MXY(2,13),QX)
              CALL FMMPYI_R1(MXY(2,13),-1,QX)
              CALL FMMPYI(MXY(1,14),2,MXY(1,12),QX)
              CALL FMLN(MXY(1,12),MXY(1,13),QX)
              CALL FMABS(MXY(2,15),MXY(1,12),QX)
              CALL FMSUB_R1(MXY(1,13),MXY(1,12),QX)
          ELSE
              CALL ZMDIV(MXY(1:2,14),MXY(1:2,13),MXY(1:2,15),QX)
              CALL ZMLN(MXY(1:2,15),MXY(1:2,13),QX)
          ENDIF
          CALL ZMSUB_R2(MXY(1:2,13),MXY(1:2,3),QX)
          CALL FMDIVI(MXY(1,1),2,MXY(1,15),QX)
          IF (MA(2)%MP(3) == 0) THEN
              CALL FMI2M(4,MXY(1,13),QX)
          ELSE
              CALL FMI2M(3,MXY(1,13),QX)
          ENDIF
          CALL FMDIVI_R1(MXY(1,13),4,QX)
          CALL FMSUB_R1(MXY(1,15),MXY(1,13),QX)
          CALL FMINT(MXY(1,15),MXY(1,11),QX)
          CALL FMSUB(MXY(1,15),MXY(1,11),MXY(1,12),QX)
          IF (MXY(1,12)%MP(3) == 0) THEN
              CALL FMEQ(MXY(1,15),MXY(1,13),QX)
          ELSE IF (MXY(1,15)%MP(1) > 0) THEN
              CALL FMADDI(MXY(1,11),1,QX)
              CALL FMEQ(MXY(1,11),MXY(1,13),QX)
          ELSE
              CALL FMEQ(MXY(1,11),MXY(1,13),QX)
          ENDIF
          CALL FMMPY(MXY(1,13),MXY(1,14),MXY(1,11),QX)
          IF (MA(2)%MP(1) < 0) THEN
              CALL FMMPYI_R1(MXY(1,11),-2,QX)
          ELSE
              CALL FMMPYI_R1(MXY(1,11),2,QX)
          ENDIF
          CALL FMADD_R1(MXY(2,3),MXY(1,11),QX)
      ENDIF

  140 QX%NAMEST(QX%NCALL) = 'ZMLNGM'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL == 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(1,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          ERR2 = 0
          DO J = KL, 1, -1
             ERR2 = (ERR2 + MXY(2,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR   > 0.498 .AND. ERR  < 0.502) .OR.  &
               (QX%KROUND == 1 .AND. ERR2  > 0.498 .AND. ERR2 < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR  > 0.998 .OR. ERR  < 0.002)) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR2 > 0.998 .OR. ERR2 < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (MXY(1,3)%MP(2) == QX%MUNKNO .OR. MXY(2,3)%MP(2) == QX%MUNKNO) THEN
          CALL ZMST2M('UNKNOWN + UNKNOWN i',MXY(1:2,3),QX)
      ENDIF

      CALL ZMEXIT(MXY(1:2,3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMLNGM

      SUBROUTINE ZMGAM(MA,MB,QX)

!  MB = Gamma(MA)

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR,ERR2
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MXY(2,15)
      LOGICAL, EXTERNAL :: FMCOMP

!             If MA is real, use FMGAM.

      IF (MA(2)%MP(3) == 0) THEN
          CALL FMGAM(MA(1),MB(1),QX)
          CALL FMI2M(0,MB(2),QX)
          IF (MB(1)%MP(2) == QX%MUNKNO) THEN
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB,QX)
          ENDIF
          RETURN
      ENDIF


      CALL ZMENTR('ZMGAM    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(2)%MP(3) == 0) THEN
          CALL FMINT(MXY(1,1),MXY(1,15),QX)
          IF (FMCOMP(MXY(1,1),'==',MXY(1,15),QX)) THEN
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
              QX%KFLAG = -4
              GO TO 120
          ENDIF
      ENDIF
      IF (MXY(1,1)%MP(2) == QX%MEXPUN .OR. MXY(2,1)%MP(2) == QX%MEXPUN) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
          QX%KFLAG = -4
          GO TO 120
      ENDIF
      CALL ZMABS(MXY(1:2,1),MXY(1,2),QX)
      CALL FMIPWR(MXY(1,2),3,MXY(1,3),QX)
      CALL FMI2M(1,MXY(1,4),QX)
      CALL FMULP(MXY(1,4),MXY(1,5),QX)
      IF (FMCOMP(MXY(1,3),'<=',MXY(1,5),QX)) THEN
          CALL FMI2M(0,MXY(2,4),QX)
          CALL ZMDIV(MXY(1:2,4),MXY(1:2,1),MXY(1:2,5),QX)
          CALL FMEULER(MXY(1,4),QX)
          CALL FMSUB_R1(MXY(1,5),MXY(1,4),QX)
          CALL FMSQR_R1(MXY(1,4),QX)
          CALL FMMPYI_R1(MXY(1,4),6,QX)
          CALL FMPI(MXY(1,3),QX)
          CALL FMSQR_R1(MXY(1,3),QX)
          CALL FMADD_R1(MXY(1,4),MXY(1,3),QX)
          CALL FMDIVI_R1(MXY(1,4),12,QX)
          CALL ZMMPY(MXY(1:2,1),MXY(1:2,4),MXY(1:2,3),QX)
          CALL ZMADD_R2(MXY(1:2,5),MXY(1:2,3),QX)
      ELSE
          CALL ZMLNGM(MXY(1:2,1),MXY(1:2,2),QX)
          CALL ZMEXP(MXY(1:2,2),MXY(1:2,3),QX)
      ENDIF

  120 QX%NAMEST(QX%NCALL) = 'ZMGAM'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL == 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(1,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          ERR2 = 0
          DO J = KL, 1, -1
             ERR2 = (ERR2 + MXY(2,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR   > 0.498 .AND. ERR  < 0.502) .OR.  &
               (QX%KROUND == 1 .AND. ERR2  > 0.498 .AND. ERR2 < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR  > 0.998 .OR. ERR  < 0.002)) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR2 > 0.998 .OR. ERR2 < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (MXY(1,3)%MP(2) == QX%MUNKNO .OR. MXY(2,3)%MP(2) == QX%MUNKNO) THEN
          CALL ZMST2M('UNKNOWN + UNKNOWN i',MXY(1:2,3),QX)
      ENDIF

      CALL ZMEXIT(MXY(1:2,3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMGAM

      SUBROUTINE ZMFACT(MA,MB,QX)

!  MB = MA!     Factorial for complex input.

      USE FMVALS_PARALLEL
      IMPLICIT NONE

      TYPE(MULTI) :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR,ERR2
      INTEGER :: J,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      TYPE(MULTI) :: MXY(2,15)
      LOGICAL, EXTERNAL :: FMCOMP

!             If MA is real, use FMFACT.

      IF (MA(2)%MP(3) == 0) THEN
          CALL FMFACT(MA(1),MB(1),QX)
          CALL FMI2M(0,MB(2),QX)
          IF (MB(1)%MP(2) == QX%MUNKNO) THEN
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB,QX)
          ENDIF
          RETURN
      ENDIF


      CALL ZMENTR('ZMFACT   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KOVUN,QX)
      IF (KRESLT /= 0) THEN
          RETURN
      ENDIF

      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (QX%NCALL == 1) QX%NDIG = MAX(QX%NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MXY(1:2,1),NDSAVE,QX%NDIG,QX)

!             Check for special cases.

      IF (MA(2)%MP(3) == 0) THEN
          CALL FMINT(MXY(1,1),MXY(1,15),QX)
          IF (FMCOMP(MXY(1,1),'==',MXY(1,15),QX)) THEN
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
              QX%KFLAG = -4
              GO TO 120
          ENDIF
      ENDIF
      IF (MXY(1,1)%MP(2) == QX%MEXPUN .OR. MXY(2,1)%MP(2) == QX%MEXPUN) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MXY(1:2,3),QX)
          QX%KFLAG = -4
          GO TO 120
      ENDIF

!             Use  x! = gamma(x+1).

      CALL ZMI2M(1,MXY(1:2,2),QX)
      CALL ZMADD_R2(MXY(1:2,1),MXY(1:2,2),QX)
      CALL ZMGAM(MXY(1:2,2),MXY(1:2,3),QX)

  120 QX%NAMEST(QX%NCALL) = 'ZMFACT'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (QX%NCALL == 1) THEN
          KL = MIN(QX%NDIG-NDSAVE,INT(3*QX%DLOGTN/QX%DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MXY(1,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          ERR2 = 0
          DO J = KL, 1, -1
             ERR2 = (ERR2 + MXY(2,3)%MP(J+NDSAVE+2)) / QX%MBASE
          ENDDO
          IF ( (QX%KROUND == 1 .AND. ERR   > 0.498 .AND. ERR  < 0.502) .OR.  &
               (QX%KROUND == 1 .AND. ERR2  > 0.498 .AND. ERR2 < 0.502) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR  > 0.998 .OR. ERR  < 0.002)) .OR.  &
               (QX%KROUND /= 1 .AND. (ERR2 > 0.998 .OR. ERR2 < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. QX%NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (MXY(1,3)%MP(2) == QX%MUNKNO .OR. MXY(2,3)%MP(2) == QX%MUNKNO) THEN
          CALL ZMST2M('UNKNOWN + UNKNOWN i',MXY(1:2,3),QX)
      ENDIF

      CALL ZMEXIT(MXY(1:2,3),MB,NDSAVE,MXSAVE,KOVUN,QX)
      RETURN
      END SUBROUTINE ZMFACT


      MODULE FMZM_1_PARALLEL
      USE FMVALS_PARALLEL, ONLY : MULTI, FM, IM, ZM


!  FMZM 1.4                        David M. Smith

!  This module extends the definition of the basic Fortran arithmetic and function operations so
!  they also apply to multiple precision numbers, using version 1.3 of FM.
!  There are three multiple precision data types:
!     FM  (multiple precision real)
!     IM  (multiple precision integer)
!     ZM  (multiple precision complex)

!  For some examples and general advice about using these multiple-precision data types, see the
!  program SampleFM.f95.

!  Most of the functions defined in this module are multiple precision versions of standard Fortran
!  functions.  In addition, there are functions for direct conversion, formatting, and some
!  mathematical special functions.

!  TO_FM is a function for converting other types of numbers to type FM.  Note that TO_FM(3.12)
!  converts the REAL constant to FM, but it is accurate only to single precision, since the number
!  3.12 cannot be represented exactly in binary and has already been rounded to single precision.
!  Similarly, TO_FM(3.12D0) agrees with 3.12 to double precision accuracy, and TO_FM('3.12') or
!  TO_FM(312)/TO_FM(100) agrees to full FM accuracy.

!  TO_IM converts to type IM, and TO_ZM converts to type ZM.

!  Functions are also supplied for converting the three multiple precision types to the other
!  numeric data types:
!     TO_INT   converts to machine precision integer
!     TO_SP    converts to single precision
!     TO_DP    converts to double precision
!     TO_SPZ   converts to single precision complex
!     TO_DPZ   converts to double precision complex

!  WARNING:   When multiple precision type declarations are inserted in an existing program, take
!             care in converting functions like DBLE(X), where X has been declared as a multiple
!             precision type.  If X was single precision in the original program, then replacing
!             the DBLE(X) by TO_DP(X) in the new version could lose accuracy. For this reason, the
!             Fortran type-conversion functions defined in this module assume that results should
!             be multiple precision whenever inputs are.  Examples:
!             DBLE(TO_FM('1.23E+123456'))         is type FM
!             REAL(TO_FM('1.23E+123456'))         is type FM
!             REAL(TO_ZM('3.12+4.56i'))           is type FM   = TO_FM('3.12')
!             INT(TO_FM('1.23'))                  is type IM   = TO_IM(1)
!             INT(TO_IM('1E+23'))                 is type IM
!             CMPLX(TO_FM('1.23'),TO_FM('4.56'))  is type ZM

!  IS_OVERFLOW, IS_UNDERFLOW, and IS_UNKNOWN are logical functions for checking whether a multiple
!  precision number is in one of the exception categories.  Testing to see if a type FM number is
!  in the +overflow category by directly using an IF can be tricky.  When MAFM is +overflow, the
!  statement
!             IF (MAFM == TO_FM(' +OVERFLOW ')) THEN
!  will return false, since the comparison routine cannot be sure that two different overflowed
!  results would have been equal if the overflow threshold had been higher.  Instead, use
!             IF (IS_OVERFLOW(MAFM)) THEN
!  which will be true if MAFM is + or - overflow.

!  Programs using this module may sometimes need to call FM, IM, or ZM routines directly.  This
!  is normally the case when routines are needed that are not Fortran intrinsics, such as the
!  formatting subroutine FM_FORM.  In a program using this module, suppose MAFM has been declared
!  with TYPE (FM) :: MAFM.  To convert the number to a character string with F65.60 format, use
!     CALL FM_FORM('F65.60',MAFM,ST1)

!  WARNING:   To be safe, all multiple precision variables in a user's program should be declared
!             as type (FM), (IM), or (ZM), and any direct calls to subroutines should be the kind
!             with the underscore.  Subroutines that define one or more multiple precision output
!             values, such as computing pi using
!                 CALL FM_PI(PI)
!             automatically cause PI to be put into the FM saved variable area of storage.  Calling
!             the low-level routine ( CALL FMPI(PI%MFM) ) would cause PI to be treated as an FM
!             temporary variable if PI had not been previously defined in the program.  Then the
!             value of PI could be discarded before the program is finished using it.

!  In subroutine or function subprograms all multiple precision variables that are local to that
!  routine should be declared with the SAVE attribute.  It is not an error to omit SAVE, but if
!  the compiler creates new copies of the variables for each call to the routine, then the program
!  will leak memory.

!  Type (FM), (IM), or (ZM) variables cannot have their multiple precision values initialized in
!  the declaration statement, as can ordinary variables.  If the original program had
!      DOUBLE PRECISION :: X = 2.3D0
!  then the corresponding FM version would have
!      TYPE (FM), SAVE :: X
!      ... (other declarations) ...
!      X = TO_FM( '2.3' )
!
!  An attempt to use a multiple precision variable that has not been defined will be detected by
!  the routines in this module and an error message printed.
!
!  For each of the operations =,  == ,  /= ,  < ,  <= ,  > ,  >= , +, -, *, /, and **, the interface
!  module defines all mixed mode variations involving one of the three multiple precision derived
!  types and another argument having one of the types: { integer, real, double, complex, complex
!  double, FM, IM, ZM }.  So mixed mode expressions such as
!        MAFM = 12
!        MAFM = MAFM + 1
!        IF (ABS(MAFM) > 1.0D-23) THEN
!  are handled correctly.

!  Not all the named functions are defined for all three multiple precision derived types, so the
!  list below shows which can be used.  The labels "real", "integer", and "complex" refer to types
!  FM, IM, and ZM respectively, "string" means the function accepts character strings (e.g.,
!  TO_FM('3.45')), and "other" means the function can accept any of the machine precision data
!  types integer, real, double, complex, or complex double.  For functions that accept two or more
!  arguments, like ATAN2 or MAX, all the arguments must be of the same type.

!  Note that TO_ZM also has a 2-argument form:  TO_ZM(2,3) for getting 2 + 3*i.
!  CMPLX can be used for that, as in CMPLX( TO_FM(2) , TO_FM(3) ), but the 2-argument form is
!  more concise.  The 2-argument form is available for machine precision integer, single and
!  double precision real pairs.  For others, such as X and Y being type(fm), just use CMPLX(X,Y).

!  Fortran's 2-argument version of atan(x,y) is also provided.  It is the same as the older atan2.
!  Functions in this list that are not provided by standard Fortran, such as special functions,
!  have more information about their arguments farther down.


!  AVAILABLE FUNCTIONS:

!     =
!     +
!     -
!     *
!     /
!     **
!     ==
!     /=
!     <
!     <=
!     >
!     >=
!     ABS                  real    integer    complex
!     ACOS                 real               complex
!     ACOSH                real               complex
!     AIMAG                                   complex
!     AINT                 real               complex
!     ANINT                real               complex
!     ASIN                 real               complex
!     ASINH                real               complex
!     ATAN                 real               complex
!     ATAN2                real
!     ATANH                real               complex
!     BERNOULLI            real
!     BESSEL_J             real
!     BESSEL_Y             real
!     BETA                 real
!     BINOMIAL             real    integer
!     BTEST                        integer
!     CEILING              real    integer    complex
!     CMPLX                real    integer
!     CONJG                                   complex
!     COS                  real               complex
!     COSH                 real               complex
!     COS_INTEGRAL         real
!     COSH_INTEGRAL        real
!     DBLE                 real    integer    complex
!     DIGITS               real    integer    complex
!     DIM                  real    integer
!     DINT                 real               complex
!     EPSILON              real
!     ERF                  real               complex
!     ERFC                 real               complex
!     ERFC_SCALED          real               complex
!     EXP                  real               complex
!     EXPONENT             real
!     EXP_INTEGRAL_EI      real
!     EXP_INTEGRAL_EN      real
!     FACTORIAL            real    integer    complex
!     FLOOR                real    integer    complex
!     FRACTION             real               complex
!     FRESNEL_C            real
!     FRESNEL_S            real
!     GAMMA                real               complex
!     GCD                          integer
!     HUGE                 real    integer    complex
!     HYPOT                real
!     INCOMPLETE_BETA      real
!     INCOMPLETE_GAMMA1    real
!     INCOMPLETE_GAMMA2    real
!     INT                  real    integer    complex
!     LOG                  real               complex
!     LOG10                real               complex
!     LOG_ERFC             real
!     LOG_GAMMA            real               complex
!     LOG_INTEGRAL         real
!     MAX                  real    integer
!     MAXEXPONENT          real
!     MIN                  real    integer
!     MINEXPONENT          real
!     MOD                  real    integer
!     MODULO               real    integer
!     MULTIPLY_MOD                 integer
!     NEAREST              real
!     NINT                 real    integer    complex
!     NORM2                real
!     POCHHAMMER           real
!     POLYGAMMA            real
!     POWER_MOD                    integer
!     PRECISION            real               complex
!     PSI                  real
!     RADIX                real    integer    complex
!     RANGE                real    integer    complex
!     REAL                 real    integer    complex
!     RRSPACING            real
!     SCALE                real               complex
!     SETEXPONENT          real
!     SIGN                 real    integer
!     SIN                  real               complex
!     SINH                 real               complex
!     SIN_INTEGRAL         real
!     SINH_INTEGRAL        real
!     SPACING              real
!     SQRT                 real               complex
!     TAN                  real               complex
!     TANH                 real               complex
!     TINY                 real    integer    complex
!     TO_FM                real    integer    complex    string    other
!     TO_IM                real    integer    complex    string    other
!     TO_ZM                real    integer    complex    string    other
!     TO_INT               real    integer    complex
!     TO_SP                real    integer    complex
!     TO_DP                real    integer    complex
!     TO_SPZ               real    integer    complex
!     TO_DPZ               real    integer    complex
!     IS_OVERFLOW          real    integer    complex
!     IS_UNDERFLOW         real    integer    complex
!     IS_UNKNOWN           real    integer    complex


!  SUBROUTINES THAT DO NOT CORRESPOND TO ANY FUNCTION ABOVE:

!  1. Type (FM).  MA, MB, MC refer to type (FM) numbers.

!     FM_COSH_SINH(MA,MB,MC)     MB = COSH(MA),  MC = SINH(MA)
!                                Faster than making two separate calls.

!     FM_COS_SIN(MA,MB,MC)       MB = COS(MA),  MC = SIN(MA)
!                                Faster than making two separate calls.

!     FM_EULER(MA)               MA = Euler's constant ( 0.5772156649... )

!     FM_FLAG(K)                 K = KFLAG  get the value of the FM condition flag.
!                                           It is stored in the internal FM variable KFLAG
!                                           in module FMVALS_PARALLEL.

!     FM_FORM(FORM,MA,STRING)    MA is converted to a character string using format FORM and
!                                   returned in STRING.  FORM can represent I, F, E, or ES formats.
!                                   Example:
!                                   CALL FMFORM('F60.40',MA,STRING)

!     FM_FPRINT(FORM,MA)         Print MA on unit KW using FORM format.

!     FM_PI(MA)                  MA = pi

!     FM_PRINT(MA)               Print MA on unit KW using current format.

!     FM_RANDOM_NUMBER(X)        X is returned as a double precision random number, uniformly
!                                distributed on the open interval (0,1).  It is a high-quality,
!                                long-period generator based on 49-digit prime numbers.
!                                Note that X is double precision, unlike the similar Fortran
!                                intrinsic random number routine, which can return a single
!                                or double precision result.
!                                A default initial seed is used if FM_RANDOM_NUMBER is called
!                                without calling FM_RANDOM_SEED_PUT first.

!     FM_RANDOM_SEED_GET(SEED)   returns the seven integers SEED(1) through SEED(7) as the current
!                                seed for the FM_RANDOM_NUMBER generator.

!     FM_RANDOM_SEED_PUT(SEED)   initializes the FM_RANDOM_NUMBER generator using the seven integers
!                                SEED(1) through SEED(7). These get and put functions are slower
!                                than FM_RANDOM_NUMBER, so FM_RANDOM_NUMBER should be called many
!                                times between FM_RANDOM_SEED_PUT calls.  Also, some generators that
!                                used a 9-digit modulus have failed randomness tests when used with
!                                only a few numbers being generated between calls to re-start with
!                                a new seed.

!     FM_RANDOM_SEED_SIZE(SIZE)  returns integer SIZE as the size of the SEED array used by the
!                                FM_RANDOM_NUMBER generator.  Currently, SIZE = 7.

!     FM_RATIONAL_POWER(MA,K,J,MB)
!                                MB = MA**(K/J)  Rational power.
!                                Faster than MB = MA**(TO_FM(K)/J) for functions like the cube root.

!     FM_READ(KREAD,MA)          MA is returned after reading one (possibly multi-line) FM number
!                                   on unit KREAD.  This routine reads numbers written by FM_WRITE.

!     FM_SET(NPREC)              Set the internal FM variables so that the precision is at least
!                                NPREC base 10 digits plus three base 10 guard digits.

!     FM_SETVAR(STRING)          Define a new value for one of the internal FM variables in module
!                                FMVALS that controls one of the FM options.  STRING has the form
!                                      variable = value.
!                                Example:  To change the screen width for FM output:
!                                      CALL FM_SETVAR(' KSWIDE = 120 ')
!                                The variables that can be changed and the options they control are
!                                listed in sections 2 through 6 of the comments at the top of the
!                                FM.f95 file.  Only one variable can be set per call.  The variable
!                                name in STRING must have no embedded blanks.  The value part of
!                                STRING can be in any numerical format, except in the case of
!                                variable CMCHAR, which is character type.  To set CMCHAR to 'E',
!                                don't use any quotes in STRING:
!                                      CALL FM_SETVAR(' CMCHAR = E ')

!     FM_ULP(MA,MB)              MB = One Unit in the Last Place of MA.  For positive MA this is the
!                                     same as the Fortran function SPACING, but MB < 0 if MA < 0.
!                                     Examples:  If MBASE = 10 and NDIG = 30, then ulp(1.0) =
!                                                1.0E-29,  ulp(-4.5E+67) = -1.0E+38.
!

!     FM_VARS                    Write the current values of the internal FM variables on unit KW.

!     FM_WRITE(KWRITE,MA)        Write MA on unit KWRITE.
!                                Multi-line numbers will have '&' as the last nonblank character
!                                on all but the last line.  These numbers can then be read easily
!                                using FM_READ.


!  2. Type (IM).    MA, MB, MC refer to type (IM) numbers.

!     IM_DIVR(MA,MB,MC,MD)       MC = int(MA/MB),   MD = MA mod MB
!                                     When both the quotient and remainder are needed, this routine
!                                     is twice as fast as doing MC = MA/MB and MD = MOD(MA,MB)
!                                     separately.

!     IM_DVIR(MA,IVAL,MB,IREM)   MB = int(MA/IVAL),   IREM = MA mod IVAL
!                                IVAL and IREM are one word integers.  Faster than doing separately.

!     IM_FORM(FORM,MA,STRING)    MA is converted to a character string using format FORM and
!                                   returned in STRING.  FORM can represent I, F, E, or ES formats.
!                                   Example: CALL IMFORM('I70',MA,STRING)

!     IM_FPRINT(FORM,MA)         Print MA on unit KW using FORM format.

!     IM_PRINT(MA)               Print MA on unit KW.

!     IM_READ(KREAD,MA)          MA is returned after reading one (possibly multi-line) IM number
!                                   on unit KREAD.  This routine reads numbers written by IM_WRITE.

!     IM_WRITE(KWRITE,MA)        Write MA on unit KWRITE.  Multi-line numbers will have '&' as the
!                                last nonblank character on all but the last line.
!                                These numbers can then be read easily using IM_READ.


!  3. Type (ZM).    MA, MB, MC refer to type (ZM) numbers.  MBFM is type (FM).

!     ZM_ARG(MA,MBFM)              MBFM = complex argument of MA.  MBFM is the (real) angle in the
!                                         interval ( -pi , pi ] from the positive real axis to the
!                                         point (x,y) when MA = x + y*i.

!     ZM_COSH_SINH(MA,MB,MC)     MB = COSH(MA),  MC = SINH(MA).
!                                     Faster than 2 calls.

!     ZM_COS_SIN(MA,MB,MC)       MB = COS(MA),  MC = SIN(MA).
!                                     Faster than 2 calls.

!     ZM_FORM(FORM1,FORM2,MA,STRING)
!                                STRING = MA
!                                MA is converted to a character string using format FORM1 for the
!                                real part and FORM2 for the imaginary part.  The result is returned
!                                in STRING.  FORM1 and FORM2 can represent I, F, E, or ES formats.
!                                Example:
!                                      CALL ZMFORM('F20.10','F15.10',MA,STRING)

!     ZM_FPRINT(FORM1,FORM2,MA)  Print MA on unit KW using formats FORM1 and FORM2.

!     ZM_PRINT(MA)               Print MA on unit KW using current format.

!     ZM_READ(KREAD,MA)          MA is returned after reading one (possibly multi-line) ZM number
!                                   on unit KREAD.  This routine reads numbers written by ZMWRITE.

!     ZM_RATIONAL_POWER(MA,IVAL,JVAL,MB)
!                                MB = MA ** (IVAL/JVAL)
!                                Faster than MB = MA**(TO_FM(K)/J) for functions like the cube root.

!     ZM_WRITE(KWRITE,MA)        Write MA on unit KWRITE.  Multi-line numbers are formatted for
!                                automatic reading with ZMREAD.


!  Some other functions are defined that do not correspond to machine precision intrinsic
!  functions. These include formatting functions, integer modular functions and GCD, and some
!  mathematical special functions.
!  N, K below are machine precision integers, J1, J2, J3 are TYPE (IM), FMT, FMTR, FMTI are
!  character strings, A, B, X are TYPE (FM), and Z is TYPE (ZM).
!  The three formatting functions return a character string containing the formatted number, the
!  three TYPE (IM) functions return a TYPE (IM) result, and the 12 special functions return
!  TYPE (FM) results.

!  Formatting functions:

!     FM_FORMAT(FMT,A)        Put A into FMT (real) format
!     IM_FORMAT(FMT,J1)       Put J1 into FMT (integer) format
!     ZM_FORMAT(FMTR,FMTI,Z)  Put Z into (complex) format, FMTR for the real
!                             part and FMTI for the imaginary part

!     Examples:
!        ST = FM_FORMAT('F65.60',A)
!        WRITE (*,*) ' A = ',TRIM(ST)
!        ST = FM_FORMAT('E75.60',B)
!        WRITE (*,*) ' B = ',ST(1:75)
!        ST = IM_FORMAT('I50',J1)
!        WRITE (*,*) ' J1 = ',ST(1:50)
!        ST = ZM_FORMAT('F35.30','F30.25',Z)
!        WRITE (*,*) ' Z = ',ST(1:70)

!     These functions are used for one-line output.  The returned character strings are of
!     length 200.

!     For higher precision numbers, the output can be broken onto multiple lines automatically by
!     calling subroutines FM_PRINT, IM_PRINT, ZM_PRINT, or the line breaks can be done by hand after
!     calling one of the subroutines FM_FORM, IM_FORM, ZM_FORM.

!     For ZM_FORMAT the length of the output is 5 more than the sum of the two field widths.

!  Integer functions:

!     BINOMIAL(N,K)           Binomial coefficient N choose K.  Returns the exact result as a
!                                  type IM value.
!     BINOMIAL(J1,J2)         Binomial coefficient J1 choose J2.  Like factorial below, the result
!                                  might be too large unless min(J2,J1-J2) is fairly small,
!     FACTORIAL(N)            N!   Returns the exact result as a type IM value.
!     FACTORIAL(J1)           J1!  Note that the factorial function grows so rapidly that if type IM
!                                  variable J1 is larger than the largest machine precision integer,
!                                  then J1! has over 10 billion digits and the calculation would
!                                  likely fail due to memory or time constraints.  This version is
!                                  provided for convenience, and will return UNKNOWN if J1 cannot
!                                  be represented as a machine precision integer.
!     GCD(J1,J2)              Greatest Common Divisor of J1 and J2.
!     MULTIPLY_MOD(J1,J2,J3)  J1 * J2 mod J3
!     POWER_MOD(J1,J2,J3)     J1 ** J2 mod J3

!  Special functions:

!     BERNOULLI(N)            Nth Bernoulli number
!     BESSEL_J(N,X)           Bessel function of the first kind J_n(x)
!     BESSEL_J0(X)            Fortran-08 name for J_0(x)
!     BESSEL_J1(X)            Fortran-08 name for J_1(x)
!     BESSEL_JN(N,X)          Fortran-08 name for J_n(x)
!     BESSEL_JN(N1,N2,X)      Returns array (/ J_n1(x) , ... , J_n2(x) /)
!     BESSEL_Y(N,X)           Bessel function of the second kind Y_n(x)
!     BESSEL_Y0(X)            Fortran-08 name for Y_0(x)
!     BESSEL_Y1(X)            Fortran-08 name for Y_1(x)
!     BESSEL_YN(N,X)          Fortran-08 name for Y_n(x)
!     BESSEL_YN(N1,N2,X)      Returns array (/ Y_n1(x) , ... , Y_n2(x) /)
!     BETA(A,B)               Integral (0 to 1)  t**(a-1) * (1-t)**(b-1)  dt
!     BINOMIAL(A,B)           Binomial Coefficient  a! / ( b! (a-b)! )
!     COS_INTEGRAL(X)         Cosine Integral Ci(x)
!     COSH_INTEGRAL(X)        Hyperbolic Cosine Integral Chi(x)
!     ERF(X)                  Error function Erf(x)
!     ERFC(X)                 Complimentary error function Erfc(x)
!     ERFC_SCALED(X)          Exp(x^2) * Erfc(x)
!     EXP_INTEGRAL_EI(X)      Exponential Integral Ei(x)
!     EXP_INTEGRAL_EN(N,X)    Exponential Integral E_n(x)
!     FACTORIAL(X)            x!   = Gamma(x+1)
!     FRESNEL_C(X)            Fresnel Cosine Integral C(x)
!     FRESNEL_S(X)            Fresnel Sine Integral S(x)
!     GAMMA(X)                Integral (0 to infinity)  t**(x-1) * exp(-t)  dt
!     INCOMPLETE_BETA(X,A,B)  Integral (0 to x)  t**(a-1) * (1-t)**(b-1)  dt
!     INCOMPLETE_GAMMA1(A,X)  Integral (0 to x)  t**(a-1) * exp(-t)  dt
!     INCOMPLETE_GAMMA2(A,X)  Integral (x to infinity)  t**(a-1) * exp(-t)  dt
!     LOG_ERFC(X)             Ln( Erfc(x) )
!     LOG_GAMMA(X)            Analytic continuation of real Ln( Gamma(x) ).  May differ from complex
!                             Ln( Gamma(x) ) by an integer multiple of 2*pi*i.
!     LOG_INTEGRAL(X)         Logarithmic Integral Li(x)
!     POCHHAMMER(X,N)         x*(x+1)*(x+2)*...*(x+n-1)
!     POLYGAMMA(N,X)          Nth derivative of Psi(x)
!     PSI(X)                  Derivative of Ln(Gamma(x))
!     SIN_INTEGRAL(X)         Sine Integral Si(x)
!     SINH_INTEGRAL(X)        Hyperbolic Sine Integral Shi(x)


!  Array operations:

!  Arithmetic operations and functions on arrays of dimension (rank) one or two are supported for
!  each of the three multiple-precision types.  Binary operations (+-*/) require both arguments to
!  have the same rank and shape.

!     Examples:
!        TYPE (FM), SAVE, DIMENSION(10)  :: A, B
!        TYPE (FM), SAVE, DIMENSION(3,3) :: C
!        TYPE (IM), SAVE, DIMENSION(10)  :: J, K
!        TYPE (IM), SAVE, DIMENSION(3,3) :: L
!        ...
!        A = 0                           ! Set the whole array to zero
!        J = J * K                       ! Set J(i) = J(i) * K(i) for i = 1, ..., 10
!        B = A - K                       ! Mixed-mode operations are ok
!        C = 7.3D0 * C - ( C + 2*L )/3

!     Array functions:

!        DOT_PRODUCT(X,Y)     Dot product of rank 1 vectors of the same type.
!                             Note that when X and Y are complex, the result is not just the sum
!                             of the products of the corresponding array elements, as it is for
!                             types FM and IM.  For ZM the formula is the sum of
!                             conjg(X(j)) * Y(j).
!        IS_OVERFLOW(X)       Returns true if any element is + or - overflow.
!        IS_UNDERFLOW(X)      Returns true if any element is + or - underflow.
!        IS_UNKNOWN(X)        Returns true if any element is unknown.
!        MATMUL(X,Y)          Matrix multiplication of arrays of the same type
!                             Cases for valid argument shapes:
!                             (1)  (n,m) * (m,k) --> (n,k)
!                             (2)    (m) * (m,k) --> (k)
!                             (3)  (n,m) * (m)   --> (n)
!        MAXLOC(X)            Location of the maximum value in the array
!        MAXVAL(X)            Maximum value in the array
!        MINLOC(X)            Location of the minimum value in the array
!        MINVAL(X)            Minimum value in the array
!        PRODUCT(X)           Product of all values in the array
!        SUM(X)               Sum of all values in the array
!        TRANSPOSE(X)         Matrix transposition.  If X is a rank 2 array with shape (n,m), then
!                             Y = TRANSPOSE(X) has shape (m,n) with Y(i,j) = X(j,i).
!        TO_FM(X)             Rank 1 or 2 arrays are converted to similar type (fm) arrays.
!        TO_IM(X)             Rank 1 or 2 arrays are converted to similar type (im) arrays.
!        TO_ZM(X)             Rank 1 or 2 arrays are converted to similar type (zm) arrays.
!        TO_INT(X)            Rank 1 or 2 arrays are converted to similar integer arrays.
!        TO_SP(X)             Rank 1 or 2 arrays are converted to similar single precision arrays.
!        TO_DP(X)             Rank 1 or 2 arrays are converted to similar double precision arrays.
!        TO_SPZ(X)            Rank 1 or 2 arrays are converted to similar single complex arrays.
!        TO_DPZ(X)            Rank 1 or 2 arrays are converted to similar double complex arrays.

!     The arithmetic array functions DOT_PRODUCT, MATMUL, PRODUCT, and SUM work like the other
!     functions in the FM package in that they raise precision and compute the sums and/or products
!     at the higher precision, then round the final result back to the user's precision to provide
!     a more accurate result.

!     Fortran's optional [,mask] argument for these functions is not provided.

!     Many of the 1-argument functions can be used with array arguments, with the result being an
!     array of the same size and shape where the function has been applied to each element.

!     Examples:
!        TYPE (FM), SAVE, DIMENSION(10) :: A, B, C
!        ...
!        A = ABS(B)                ! Set A(i) = ABS(B(i)) for i = 1, ..., 10
!        C = SQRT(A+4+B*B)         ! Set C(i) = SQRT(A(i)+4+B(i)*B(i)) for i = 1, ..., 10

!     Functions that can have array arguments.  As above, "real", "integer", and "complex" refer
!     to types FM, IM, and ZM respectively.

!     ABS              real    integer    complex
!     ACOS             real               complex
!     ACOSH            real               complex
!     AIMAG                               complex
!     AINT             real               complex
!     ANINT            real               complex
!     ASIN             real               complex
!     ASINH            real               complex
!     ATAN             real               complex
!     ATANH            real               complex
!     CEILING          real    integer    complex
!     CONJG                               complex
!     COS              real               complex
!     COSH             real               complex
!     EXP              real               complex
!     FLOOR            real    integer    complex
!     FRACTION         real               complex
!     INT              real    integer    complex
!     LOG              real               complex
!     LOG10            real               complex
!     NINT             real    integer    complex
!     SIN              real               complex
!     SINH             real               complex
!     SQRT             real               complex
!     TAN              real               complex
!     TANH             real               complex
!     COS_INTEGRAL     real
!     COSH_INTEGRAL    real
!     ERF              real               complex
!     ERFC             real               complex
!     ERFC_SCALED      real               complex
!     EXP_INTEGRAL_EI  real
!     FACTORIAL        real    integer    complex    machine-precision integer
!     FRESNEL_C        real
!     FRESNEL_S        real
!     GAMMA            real               complex
!     LOG_ERFC         real
!     LOG_GAMMA        real               complex
!     LOG_INTEGRAL     real
!     PSI              real
!     SIN_INTEGRAL     real
!     SINH_INTEGRAL    real


   INTERFACE TO_FM
      MODULE PROCEDURE FM_I
      MODULE PROCEDURE FM_R
      MODULE PROCEDURE FM_D
      MODULE PROCEDURE FM_Z
      MODULE PROCEDURE FM_ZD
      MODULE PROCEDURE FM_FM
      MODULE PROCEDURE FM_IM
      MODULE PROCEDURE FM_ZM
      MODULE PROCEDURE FM_ST
      MODULE PROCEDURE FM_I1
      MODULE PROCEDURE FM_R1
      MODULE PROCEDURE FM_D1
      MODULE PROCEDURE FM_Z1
      MODULE PROCEDURE FM_ZD1
      MODULE PROCEDURE FM_FM1
      MODULE PROCEDURE FM_IM1
      MODULE PROCEDURE FM_ZM1
      MODULE PROCEDURE FM_ST1
      MODULE PROCEDURE FM_I2
      MODULE PROCEDURE FM_R2
      MODULE PROCEDURE FM_D2
      MODULE PROCEDURE FM_Z2
      MODULE PROCEDURE FM_ZD2
      MODULE PROCEDURE FM_FM2
      MODULE PROCEDURE FM_IM2
      MODULE PROCEDURE FM_ZM2
      MODULE PROCEDURE FM_ST2
   END INTERFACE

   INTERFACE TO_IM
      MODULE PROCEDURE IM_I
      MODULE PROCEDURE IM_R
      MODULE PROCEDURE IM_D
      MODULE PROCEDURE IM_Z
      MODULE PROCEDURE IM_C
      MODULE PROCEDURE IM_FM
      MODULE PROCEDURE IM_IM
      MODULE PROCEDURE IM_ZM
      MODULE PROCEDURE IM_ST
      MODULE PROCEDURE IM_I1
      MODULE PROCEDURE IM_R1
      MODULE PROCEDURE IM_D1
      MODULE PROCEDURE IM_Z1
      MODULE PROCEDURE IM_C1
      MODULE PROCEDURE IM_FM1
      MODULE PROCEDURE IM_IM1
      MODULE PROCEDURE IM_ZM1
      MODULE PROCEDURE IM_ST1
      MODULE PROCEDURE IM_I2
      MODULE PROCEDURE IM_R2
      MODULE PROCEDURE IM_D2
      MODULE PROCEDURE IM_Z2
      MODULE PROCEDURE IM_C2
      MODULE PROCEDURE IM_FM2
      MODULE PROCEDURE IM_IM2
      MODULE PROCEDURE IM_ZM2
      MODULE PROCEDURE IM_ST2
   END INTERFACE

   INTERFACE TO_ZM
      MODULE PROCEDURE ZM_I
      MODULE PROCEDURE ZM2_I
      MODULE PROCEDURE ZM_R
      MODULE PROCEDURE ZM2_R
      MODULE PROCEDURE ZM_D
      MODULE PROCEDURE ZM2_D
      MODULE PROCEDURE ZM_Z
      MODULE PROCEDURE ZM_C
      MODULE PROCEDURE ZM_FM
      MODULE PROCEDURE ZM_IM
      MODULE PROCEDURE ZM_ZM
      MODULE PROCEDURE ZM_ST
      MODULE PROCEDURE ZM_I1
      MODULE PROCEDURE ZM_R1
      MODULE PROCEDURE ZM_D1
      MODULE PROCEDURE ZM_Z1
      MODULE PROCEDURE ZM_C1
      MODULE PROCEDURE ZM_FM1
      MODULE PROCEDURE ZM_IM1
      MODULE PROCEDURE ZM_ZM1
      MODULE PROCEDURE ZM_ST1
      MODULE PROCEDURE ZM_I2
      MODULE PROCEDURE ZM_R2
      MODULE PROCEDURE ZM_D2
      MODULE PROCEDURE ZM_Z2
      MODULE PROCEDURE ZM_C2
      MODULE PROCEDURE ZM_FM2
      MODULE PROCEDURE ZM_IM2
      MODULE PROCEDURE ZM_ZM2
      MODULE PROCEDURE ZM_ST2
   END INTERFACE

   INTERFACE TO_INT
      MODULE PROCEDURE FM_2INT
      MODULE PROCEDURE IM_2INT
      MODULE PROCEDURE ZM_2INT
      MODULE PROCEDURE FM_2INT1
      MODULE PROCEDURE IM_2INT1
      MODULE PROCEDURE ZM_2INT1
      MODULE PROCEDURE FM_2INT2
      MODULE PROCEDURE IM_2INT2
      MODULE PROCEDURE ZM_2INT2
   END INTERFACE

   INTERFACE TO_SP
      MODULE PROCEDURE FM_2SP
      MODULE PROCEDURE IM_2SP
      MODULE PROCEDURE ZM_2SP
      MODULE PROCEDURE FM_2SP1
      MODULE PROCEDURE IM_2SP1
      MODULE PROCEDURE ZM_2SP1
      MODULE PROCEDURE FM_2SP2
      MODULE PROCEDURE IM_2SP2
      MODULE PROCEDURE ZM_2SP2
   END INTERFACE

   INTERFACE TO_DP
      MODULE PROCEDURE FM_2DP
      MODULE PROCEDURE IM_2DP
      MODULE PROCEDURE ZM_2DP
      MODULE PROCEDURE FM_2DP1
      MODULE PROCEDURE IM_2DP1
      MODULE PROCEDURE ZM_2DP1
      MODULE PROCEDURE FM_2DP2
      MODULE PROCEDURE IM_2DP2
      MODULE PROCEDURE ZM_2DP2
   END INTERFACE

   INTERFACE TO_SPZ
      MODULE PROCEDURE FM_2SPZ
      MODULE PROCEDURE IM_2SPZ
      MODULE PROCEDURE ZM_2SPZ
      MODULE PROCEDURE FM_2SPZ1
      MODULE PROCEDURE IM_2SPZ1
      MODULE PROCEDURE ZM_2SPZ1
      MODULE PROCEDURE FM_2SPZ2
      MODULE PROCEDURE IM_2SPZ2
      MODULE PROCEDURE ZM_2SPZ2
   END INTERFACE

   INTERFACE TO_DPZ
      MODULE PROCEDURE FM_2DPZ
      MODULE PROCEDURE IM_2DPZ
      MODULE PROCEDURE ZM_2DPZ
      MODULE PROCEDURE FM_2DPZ1
      MODULE PROCEDURE IM_2DPZ1
      MODULE PROCEDURE ZM_2DPZ1
      MODULE PROCEDURE FM_2DPZ2
      MODULE PROCEDURE IM_2DPZ2
      MODULE PROCEDURE ZM_2DPZ2
   END INTERFACE

   INTERFACE IS_OVERFLOW
      MODULE PROCEDURE FM_IS_OVERFLOW
      MODULE PROCEDURE IM_IS_OVERFLOW
      MODULE PROCEDURE ZM_IS_OVERFLOW
      MODULE PROCEDURE FM_IS_OVERFLOW1
      MODULE PROCEDURE IM_IS_OVERFLOW1
      MODULE PROCEDURE ZM_IS_OVERFLOW1
      MODULE PROCEDURE FM_IS_OVERFLOW2
      MODULE PROCEDURE IM_IS_OVERFLOW2
      MODULE PROCEDURE ZM_IS_OVERFLOW2
   END INTERFACE

   INTERFACE IS_UNDERFLOW
      MODULE PROCEDURE FM_IS_UNDERFLOW
      MODULE PROCEDURE IM_IS_UNDERFLOW
      MODULE PROCEDURE ZM_IS_UNDERFLOW
      MODULE PROCEDURE FM_IS_UNDERFLOW1
      MODULE PROCEDURE IM_IS_UNDERFLOW1
      MODULE PROCEDURE ZM_IS_UNDERFLOW1
      MODULE PROCEDURE FM_IS_UNDERFLOW2
      MODULE PROCEDURE IM_IS_UNDERFLOW2
      MODULE PROCEDURE ZM_IS_UNDERFLOW2
   END INTERFACE

   INTERFACE IS_UNKNOWN
      MODULE PROCEDURE FM_IS_UNKNOWN
      MODULE PROCEDURE IM_IS_UNKNOWN
      MODULE PROCEDURE ZM_IS_UNKNOWN
      MODULE PROCEDURE FM_IS_UNKNOWN1
      MODULE PROCEDURE IM_IS_UNKNOWN1
      MODULE PROCEDURE ZM_IS_UNKNOWN1
      MODULE PROCEDURE FM_IS_UNKNOWN2
      MODULE PROCEDURE IM_IS_UNKNOWN2
      MODULE PROCEDURE ZM_IS_UNKNOWN2
   END INTERFACE

!  The next function is no longer needed in version 1.4.
!  Dummy versions of the individual procedures are included for compatibility with version 1.3.

   INTERFACE FM_DEALLOCATE
      MODULE PROCEDURE FM_DEALLOCATE_FM1
      MODULE PROCEDURE FM_DEALLOCATE_IM1
      MODULE PROCEDURE FM_DEALLOCATE_ZM1
      MODULE PROCEDURE FM_DEALLOCATE_FM2
      MODULE PROCEDURE FM_DEALLOCATE_IM2
      MODULE PROCEDURE FM_DEALLOCATE_ZM2
   END INTERFACE


 CONTAINS

!                                                               TO_FM

   FUNCTION FM_I(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,RETURN_VALUE%MFM,QX)
   END FUNCTION FM_I

   FUNCTION FM_R(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,RETURN_VALUE%MFM,QX)
   END FUNCTION FM_R

   FUNCTION FM_D(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,RETURN_VALUE%MFM,QX)
   END FUNCTION FM_D

   FUNCTION FM_Z(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(REAL(Z),RETURN_VALUE%MFM,QX)
   END FUNCTION FM_Z

   FUNCTION FM_ZD(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),RETURN_VALUE%MFM,QX)
   END FUNCTION FM_ZD

   FUNCTION FM_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE,MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FM_FM

   FUNCTION FM_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,RETURN_VALUE%MFM,QX)
   END FUNCTION FM_IM

   FUNCTION FM_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,RETURN_VALUE%MFM,QX)
   END FUNCTION FM_ZM

   FUNCTION FM_ST(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      CHARACTER(*) :: ST
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(ST,RETURN_VALUE%MFM,QX)
   END FUNCTION FM_ST

   FUNCTION FM_I1(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_I1

   FUNCTION FM_R1(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_R1

   FUNCTION FM_D1(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: D
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_D1

   FUNCTION FM_Z1(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX, DIMENSION(:) :: Z
      TYPE (FM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL FMSP2M(REAL(Z(J)),RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_Z1

   FUNCTION FM_ZD1(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (FM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: C
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_ZD1

   FUNCTION FM_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEQ(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_FM1

   FUNCTION FM_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_IM1

   FUNCTION FM_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMREAL(MA(J)%MZM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_ZM1

   FUNCTION FM_ST1(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*), DIMENSION(:) :: ST
      TYPE (FM), DIMENSION(SIZE(ST)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(ST)
      DO J = 1, N
         CALL FMST2M(ST(J),RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FM_ST1

   FUNCTION FM_I2(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_I2

   FUNCTION FM_R2(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_R2

   FUNCTION FM_D2(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: D
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_D2

   FUNCTION FM_Z2(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (FM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL FMSP2M(REAL(Z(J,K)),RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_Z2

   FUNCTION FM_ZD2(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (FM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: C
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_ZD2

   FUNCTION FM_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_FM2

   FUNCTION FM_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_IM2

   FUNCTION FM_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL(MA(J,K)%MZM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_ZM2

   FUNCTION FM_ST2(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*), DIMENSION(:,:) :: ST
      TYPE (FM), DIMENSION(SIZE(ST,DIM=1),SIZE(ST,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(ST,DIM=1)
         DO K = 1, SIZE(ST,DIM=2)
            CALL FMST2M(ST(J,K),RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FM_ST2

!                                                               TO_IM

   FUNCTION IM_I(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,RETURN_VALUE%MIM,QX)
   END FUNCTION IM_I

   FUNCTION IM_R(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      REAL :: R
      CHARACTER(25) :: ST
      INTEGER :: IVAL
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      IF (ABS(R) < HUGE(1)) THEN
          IVAL = INT(R)
          CALL IMI2M(IVAL,RETURN_VALUE%MIM,QX)
      ELSE
          WRITE (ST,'(E25.16)') R
          CALL IMST2M(ST,RETURN_VALUE%MIM,QX)
      ENDIF
   END FUNCTION IM_R

   FUNCTION IM_D(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      CHARACTER(25) :: ST
      INTEGER :: IVAL
      INTENT (IN) :: D
      TYPE(FM_SETTINGS) :: QX
      IF (ABS(D) < HUGE(1)) THEN
          IVAL = INT(D)
          CALL IMI2M(IVAL,RETURN_VALUE%MIM,QX)
      ELSE
          WRITE (ST,'(E25.16)') D
          CALL IMST2M(ST,RETURN_VALUE%MIM,QX)
      ENDIF
   END FUNCTION IM_D

   FUNCTION IM_Z(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      COMPLEX :: Z
      REAL :: R
      CHARACTER(25) :: ST
      INTEGER :: IVAL
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      R = REAL(Z)
      IF (ABS(R) < HUGE(1)) THEN
          IVAL = INT(R)
          CALL IMI2M(IVAL,RETURN_VALUE%MIM,QX)
      ELSE
          WRITE (ST,'(E25.16)') R
          CALL IMST2M(ST,RETURN_VALUE%MIM,QX)
      ENDIF
   END FUNCTION IM_Z

   FUNCTION IM_C(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      CHARACTER(25) :: ST
      INTEGER :: IVAL
      INTENT (IN) :: C
      TYPE(FM_SETTINGS) :: QX
      D = REAL(C,KIND(0.0D0))
      IF (ABS(D) < HUGE(1)) THEN
          IVAL = INT(D)
          CALL IMI2M(IVAL,RETURN_VALUE%MIM,QX)
      ELSE
          WRITE (ST,'(E25.16)') D
          CALL IMST2M(ST,RETURN_VALUE%MIM,QX)
      ENDIF
   END FUNCTION IM_C

   FUNCTION IM_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMFM2I(MA%MFM,RETURN_VALUE%MIM,QX)
   END FUNCTION IM_FM

   FUNCTION IM_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE,MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION IM_IM

   FUNCTION IM_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,RETURN_VALUE%MIM,QX)
   END FUNCTION IM_ZM

   FUNCTION IM_ST(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      CHARACTER(*) :: ST
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(ST,RETURN_VALUE%MIM,QX)
   END FUNCTION IM_ST

   FUNCTION IM_I1(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION IM_I1

   FUNCTION IM_R1(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      REAL, DIMENSION(:) :: R
      TYPE (IM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      CHARACTER(25) :: ST
      INTEGER :: IVAL,J,N
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         IF (ABS(R(J)) < HUGE(1)) THEN
             IVAL = INT(R(J))
             CALL IMI2M(IVAL,RETURN_VALUE(J)%MIM,QX)
         ELSE
             WRITE (ST,'(E25.16)') R(J)
             CALL IMST2M(ST,RETURN_VALUE(J)%MIM,QX)
         ENDIF
      ENDDO
   END FUNCTION IM_R1

   FUNCTION IM_D1(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (IM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      CHARACTER(25) :: ST
      INTEGER :: IVAL,J,N
      INTENT (IN) :: D
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         IF (ABS(D(J)) < HUGE(1)) THEN
             IVAL = INT(D(J))
             CALL IMI2M(IVAL,RETURN_VALUE(J)%MIM,QX)
         ELSE
             WRITE (ST,'(E25.16)') D(J)
             CALL IMST2M(ST,RETURN_VALUE(J)%MIM,QX)
         ENDIF
      ENDDO
   END FUNCTION IM_D1

   FUNCTION IM_Z1(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX, DIMENSION(:) :: Z
      TYPE (IM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      REAL :: R
      CHARACTER(25) :: ST
      INTEGER :: IVAL,J,N
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         R = REAL(Z(J))
         IF (ABS(R) < HUGE(1)) THEN
             IVAL = INT(R)
             CALL IMI2M(IVAL,RETURN_VALUE(J)%MIM,QX)
         ELSE
             WRITE (ST,'(E25.16)') R
             CALL IMST2M(ST,RETURN_VALUE(J)%MIM,QX)
         ENDIF
      ENDDO
   END FUNCTION IM_Z1

   FUNCTION IM_C1(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (IM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      CHARACTER(25) :: ST
      INTEGER :: IVAL,J,N
      INTENT (IN) :: C
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         D = REAL(C(J),KIND(0.0D0))
         IF (ABS(D) < HUGE(1)) THEN
             IVAL = INT(D)
             CALL IMI2M(IVAL,RETURN_VALUE(J)%MIM,QX)
         ELSE
             WRITE (ST,'(E25.16)') D
             CALL IMST2M(ST,RETURN_VALUE(J)%MIM,QX)
         ENDIF
      ENDDO
   END FUNCTION IM_C1

   FUNCTION IM_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMFM2I(MA(J)%MFM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION IM_FM1

   FUNCTION IM_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMEQ(MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION IM_IM1

   FUNCTION IM_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMREAL(MA(J)%MZM,MTLVFM,QX)
         CALL IMFM2I(MTLVFM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION IM_ZM1

   FUNCTION IM_ST1(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*), DIMENSION(:) :: ST
      TYPE (IM), DIMENSION(SIZE(ST)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(ST)
      DO J = 1, N
         CALL IMST2M(ST(J),RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION IM_ST1

   FUNCTION IM_I2(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION IM_I2

   FUNCTION IM_R2(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      REAL, DIMENSION(:,:) :: R
      TYPE (IM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      CHARACTER(25) :: ST
      INTEGER :: IVAL,J,K
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            IF (ABS(R(J,K)) < HUGE(1)) THEN
                IVAL = INT(R(J,K))
                CALL IMI2M(IVAL,RETURN_VALUE(J,K)%MIM,QX)
            ELSE
                WRITE (ST,'(E25.16)') R(J,K)
                CALL IMST2M(ST,RETURN_VALUE(J,K)%MIM,QX)
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION IM_R2

   FUNCTION IM_D2(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (IM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      CHARACTER(25) :: ST
      INTEGER :: IVAL,J,K
      INTENT (IN) :: D
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            IF (ABS(D(J,K)) < HUGE(1)) THEN
                IVAL = INT(D(J,K))
                CALL IMI2M(IVAL,RETURN_VALUE(J,K)%MIM,QX)
            ELSE
                WRITE (ST,'(E25.16)') D(J,K)
                CALL IMST2M(ST,RETURN_VALUE(J,K)%MIM,QX)
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION IM_D2

   FUNCTION IM_Z2(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (IM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      REAL :: R
      CHARACTER(25) :: ST
      INTEGER :: IVAL,J,K
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            R = REAL(Z(J,K))
            IF (ABS(R) < HUGE(1)) THEN
                IVAL = INT(R)
                CALL IMI2M(IVAL,RETURN_VALUE(J,K)%MIM,QX)
            ELSE
                WRITE (ST,'(E25.16)') R
                CALL IMST2M(ST,RETURN_VALUE(J,K)%MIM,QX)
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION IM_Z2

   FUNCTION IM_C2(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (IM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      CHARACTER(25) :: ST
      INTEGER :: IVAL,J,K
      INTENT (IN) :: C
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            D = REAL(C(J,K),KIND(0.0D0))
            IF (ABS(D) < HUGE(1)) THEN
                IVAL = INT(D)
                CALL IMI2M(IVAL,RETURN_VALUE(J,K)%MIM,QX)
            ELSE
                WRITE (ST,'(E25.16)') D
                CALL IMST2M(ST,RETURN_VALUE(J,K)%MIM,QX)
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION IM_C2

   FUNCTION IM_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMFM2I(MA(J,K)%MFM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION IM_FM2

   FUNCTION IM_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION IM_IM2

   FUNCTION IM_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL(MA(J,K)%MZM,MTLVFM,QX)
            CALL IMFM2I(MTLVFM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION IM_ZM2

   FUNCTION IM_ST2(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*), DIMENSION(:,:) :: ST
      TYPE (IM), DIMENSION(SIZE(ST,DIM=1),SIZE(ST,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(ST,DIM=1)
         DO K = 1, SIZE(ST,DIM=2)
            CALL IMST2M(ST(J,K),RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION IM_ST2

!                                                               TO_ZM

   FUNCTION ZM_I(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(IVAL,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_I

   FUNCTION ZM2_I(I1,I2)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      INTEGER :: I1,I2
      INTENT (IN) :: I1,I2
      TYPE(FM_SETTINGS) :: QX
      CALL ZM2I2M(I1,I2,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM2_I

   FUNCTION ZM_R(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_R

   FUNCTION ZM2_R(R1,R2)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      REAL :: R1,R2
      INTENT (IN) :: R1,R2
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R1,MTLVFM,QX)
      CALL FMSP2M(R2,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM2_R

   FUNCTION ZM_D(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_D

   FUNCTION ZM2_D(D1,D2)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      DOUBLE PRECISION :: D1,D2
      INTENT (IN) :: D1,D2
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D1,MTLVFM,QX)
      CALL FMDP2M(D2,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM2_D

   FUNCTION ZM_Z(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_Z

   FUNCTION ZM_C(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_C

   FUNCTION ZM_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE(MULTI) :: MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_FM

   FUNCTION ZM_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_IM

   FUNCTION ZM_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE,MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQ(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_ZM

   FUNCTION ZM_ST(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      CHARACTER(*) :: ST
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      CALL ZMST2M(ST,RETURN_VALUE%MZM,QX)
   END FUNCTION ZM_ST

   FUNCTION ZM_I1(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_I1

   FUNCTION ZM_R1(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_R1

   FUNCTION ZM_D1(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_D1

   FUNCTION ZM_Z1(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_Z1

   FUNCTION ZM_C1(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_C1

   FUNCTION ZM_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(MULTI) :: MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_FM1

   FUNCTION ZM_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_IM1

   FUNCTION ZM_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMEQ(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_ZM1

   FUNCTION ZM_ST1(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*), DIMENSION(:) :: ST
      TYPE (ZM), DIMENSION(SIZE(ST)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(ST)
      DO J = 1, N
         CALL ZMST2M(ST(J),RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION ZM_ST1

   FUNCTION ZM_I2(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_I2

   FUNCTION ZM_R2(R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_R2

   FUNCTION ZM_D2(D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_D2

   FUNCTION ZM_Z2(Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_Z2

   FUNCTION ZM_C2(C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_C2

   FUNCTION ZM_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(MULTI) :: MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_FM2

   FUNCTION ZM_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_IM2

   FUNCTION ZM_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_ZM2

   FUNCTION ZM_ST2(ST)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*), DIMENSION(:,:) :: ST
      TYPE (ZM), DIMENSION(SIZE(ST,DIM=1),SIZE(ST,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: ST
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(ST,DIM=1)
         DO K = 1, SIZE(ST,DIM=2)
            CALL ZMST2M(ST(J,K),RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_ST2

!                                                              TO_INT

   FUNCTION FM_2INT(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2I(MA%MFM,RETURN_VALUE,QX)
   END FUNCTION FM_2INT

   FUNCTION IM_2INT(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2I(MA%MIM,RETURN_VALUE,QX)
   END FUNCTION IM_2INT

   FUNCTION ZM_2INT(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMM2I(MA%MZM,RETURN_VALUE,QX)
   END FUNCTION ZM_2INT

   FUNCTION FM_2INT1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2I(MA(J)%MFM,RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION FM_2INT1

   FUNCTION IM_2INT1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMM2I(MA(J)%MIM,RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION IM_2INT1

   FUNCTION ZM_2INT1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2I(MA(J)%MZM(1),RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION ZM_2INT1

   FUNCTION FM_2INT2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2I(MA(J,K)%MFM,RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION FM_2INT2

   FUNCTION IM_2INT2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMM2I(MA(J,K)%MIM,RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION IM_2INT2

   FUNCTION ZM_2INT2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2I(MA(J,K)%MZM(1),RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_2INT2

!                                                               TO_SP

   FUNCTION FM_2SP(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2SP(MA%MFM,RETURN_VALUE,QX)
   END FUNCTION FM_2SP

   FUNCTION IM_2SP(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,RETURN_VALUE,QX)
   END FUNCTION IM_2SP

   FUNCTION ZM_2SP(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,RETURN_VALUE,QX)
   END FUNCTION ZM_2SP

   FUNCTION FM_2SP1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      REAL, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2SP(MA(J)%MFM,RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION FM_2SP1

   FUNCTION IM_2SP1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      REAL, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMM2SP(MA(J)%MIM,RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION IM_2SP1

   FUNCTION ZM_2SP1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      REAL, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2SP(MA(J)%MZM(1),RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION ZM_2SP1

   FUNCTION FM_2SP2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP(MA(J,K)%MFM,RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION FM_2SP2

   FUNCTION IM_2SP2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMM2SP(MA(J,K)%MIM,RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION IM_2SP2

   FUNCTION ZM_2SP2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP(MA(J,K)%MZM(1),RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_2SP2

!                                                               TO_DP

   FUNCTION FM_2DP(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2DP(MA%MFM,RETURN_VALUE,QX)
   END FUNCTION FM_2DP

   FUNCTION IM_2DP(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,RETURN_VALUE,QX)
   END FUNCTION IM_2DP

   FUNCTION ZM_2DP(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,RETURN_VALUE,QX)
   END FUNCTION ZM_2DP

   FUNCTION FM_2DP1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2DP(MA(J)%MFM,RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION FM_2DP1

   FUNCTION IM_2DP1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMM2DP(MA(J)%MIM,RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION IM_2DP1

   FUNCTION ZM_2DP1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2DP(MA(J)%MZM(1),RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION ZM_2DP1

   FUNCTION FM_2DP2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP(MA(J,K)%MFM,RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION FM_2DP2

   FUNCTION IM_2DP2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMM2DP(MA(J,K)%MIM,RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION IM_2DP2

   FUNCTION ZM_2DP2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP(MA(J,K)%MZM(1),RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_2DP2

!                                                              TO_SPZ

   FUNCTION FM_2SPZ(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX :: RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2SP(MA%MFM,R,QX)
      RETURN_VALUE = CMPLX( R , 0.0 )
   END FUNCTION FM_2SPZ

   FUNCTION IM_2SPZ(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX :: RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R,QX)
      RETURN_VALUE = CMPLX( R , 0.0 )
   END FUNCTION IM_2SPZ

   FUNCTION ZM_2SPZ(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMM2Z(MA%MZM,RETURN_VALUE,QX)
   END FUNCTION ZM_2SPZ

   FUNCTION FM_2SPZ1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2SP(MA(J)%MFM,R,QX)
         RETURN_VALUE(J) = CMPLX( R , 0.0 )
      ENDDO
   END FUNCTION FM_2SPZ1

   FUNCTION IM_2SPZ1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMM2SP(MTLVFM,R,QX)
         RETURN_VALUE(J) = CMPLX( R , 0.0 )
      ENDDO
   END FUNCTION IM_2SPZ1

   FUNCTION ZM_2SPZ1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMM2Z(MA(J)%MZM,RETURN_VALUE(J),QX)
      ENDDO
   END FUNCTION ZM_2SPZ1

   FUNCTION FM_2SPZ2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP(MA(J,K)%MFM,R,QX)
            RETURN_VALUE(J,K) = CMPLX( R , 0.0 )
         ENDDO
      ENDDO
   END FUNCTION FM_2SPZ2

   FUNCTION IM_2SPZ2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMM2SP(MTLVFM,R,QX)
            RETURN_VALUE(J,K) = CMPLX( R , 0.0 )
         ENDDO
      ENDDO
   END FUNCTION IM_2SPZ2

   FUNCTION ZM_2SPZ2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMM2Z(MA(J,K)%MZM,RETURN_VALUE(J,K),QX)
         ENDDO
      ENDDO
   END FUNCTION ZM_2SPZ2

!                                                              TO_DPZ

   FUNCTION FM_2DPZ(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2DP(MA%MFM,D,QX)
      RETURN_VALUE = CMPLX( D , 0.0D0 , KIND(0.0D0) )
   END FUNCTION FM_2DPZ

   FUNCTION IM_2DPZ(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2DP(MA%MIM,D,QX)
      RETURN_VALUE = CMPLX( D , 0.0D0 , KIND(0.0D0) )
   END FUNCTION IM_2DPZ

   FUNCTION ZM_2DPZ(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)) :: RETURN_VALUE
      DOUBLE PRECISION :: D1,D2
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D1,QX)
      CALL ZMIMAG(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      RETURN_VALUE = CMPLX( D1 , D2 , KIND(0.0D0) )
   END FUNCTION ZM_2DPZ

   FUNCTION FM_2DPZ1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2DP(MA(J)%MFM,D,QX)
         RETURN_VALUE(J) = CMPLX( D , 0.0D0 , KIND(0.0D0) )
      ENDDO
   END FUNCTION FM_2DPZ1

   FUNCTION IM_2DPZ1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMM2DP(MTLVFM,D,QX)
         RETURN_VALUE(J) = CMPLX( D , 0.0D0 , KIND(0.0D0) )
      ENDDO
   END FUNCTION IM_2DPZ1

   FUNCTION ZM_2DPZ1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D1,D2
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMREAL(MA(J)%MZM,MTLVFM,QX)
         CALL FMM2DP(MTLVFM,D1,QX)
         CALL ZMIMAG(MA(J)%MZM,MTLVFM,QX)
         CALL FMM2DP(MTLVFM,D2,QX)
         RETURN_VALUE(J) = CMPLX( D1 , D2 , KIND(0.0D0) )
      ENDDO
   END FUNCTION ZM_2DPZ1

   FUNCTION FM_2DPZ2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP(MA(J,K)%MFM,D,QX)
            RETURN_VALUE(J,K) = CMPLX( D , 0.0D0 , KIND(0.0D0) )
         ENDDO
      ENDDO
   END FUNCTION FM_2DPZ2

   FUNCTION IM_2DPZ2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMM2DP(MTLVFM,D,QX)
            RETURN_VALUE(J,K) = CMPLX( D , 0.0D0 , KIND(0.0D0) )
         ENDDO
      ENDDO
   END FUNCTION IM_2DPZ2

   FUNCTION ZM_2DPZ2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D1,D2
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL(MA(J,K)%MZM,MTLVFM,QX)
            CALL FMM2DP(MTLVFM,D1,QX)
            CALL ZMIMAG(MA(J,K)%MZM,MTLVFM,QX)
            CALL FMM2DP(MTLVFM,D2,QX)
            RETURN_VALUE(J,K) = CMPLX( D1 , D2 , KIND(0.0D0) )
         ENDDO
      ENDDO
   END FUNCTION ZM_2DPZ2

   SUBROUTINE FM_EQ(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_EQ

   SUBROUTINE IM_EQ(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MA%MIM,MB%MIM,QX)
   END SUBROUTINE IM_EQ

   SUBROUTINE ZM_EQ(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQ(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_EQ

!                                                         IS_OVERFLOW

   FUNCTION FM_IS_OVERFLOW(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MFM%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
   END FUNCTION FM_IS_OVERFLOW

   FUNCTION IM_IS_OVERFLOW(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MIM%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
   END FUNCTION IM_IS_OVERFLOW

   FUNCTION ZM_IS_OVERFLOW(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MZM(1)%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
      IF (MA%MZM(2)%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
   END FUNCTION ZM_IS_OVERFLOW

   FUNCTION FM_IS_OVERFLOW1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MFM%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION FM_IS_OVERFLOW1

   FUNCTION IM_IS_OVERFLOW1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MIM%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION IM_IS_OVERFLOW1

   FUNCTION ZM_IS_OVERFLOW1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MZM(1)%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
         IF (MA(J)%MZM(2)%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION ZM_IS_OVERFLOW1

   FUNCTION FM_IS_OVERFLOW2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MFM%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION FM_IS_OVERFLOW2

   FUNCTION IM_IS_OVERFLOW2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MIM%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION IM_IS_OVERFLOW2

   FUNCTION ZM_IS_OVERFLOW2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MZM(1)%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
            IF (MA(J,K)%MZM(2)%MP(2) == QX%MEXPOV) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION ZM_IS_OVERFLOW2

!                                                        IS_UNDERFLOW

   FUNCTION FM_IS_UNDERFLOW(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MFM%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
   END FUNCTION FM_IS_UNDERFLOW

!  The integer versions are included for completeness, but type (im) numbers can't underflow.

   FUNCTION IM_IS_UNDERFLOW(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MIM%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
   END FUNCTION IM_IS_UNDERFLOW

   FUNCTION ZM_IS_UNDERFLOW(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MZM(1)%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
      IF (MA%MZM(2)%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
   END FUNCTION ZM_IS_UNDERFLOW

   FUNCTION FM_IS_UNDERFLOW1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MFM%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION FM_IS_UNDERFLOW1

   FUNCTION IM_IS_UNDERFLOW1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MIM%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION IM_IS_UNDERFLOW1

   FUNCTION ZM_IS_UNDERFLOW1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MZM(1)%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
         IF (MA(J)%MZM(2)%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION ZM_IS_UNDERFLOW1

   FUNCTION FM_IS_UNDERFLOW2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MFM%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION FM_IS_UNDERFLOW2

   FUNCTION IM_IS_UNDERFLOW2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MIM%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION IM_IS_UNDERFLOW2

   FUNCTION ZM_IS_UNDERFLOW2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MZM(1)%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
            IF (MA(J,K)%MZM(2)%MP(2) == QX%MEXPUN) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION ZM_IS_UNDERFLOW2

!                                                          IS_UNKNOWN

   FUNCTION FM_IS_UNKNOWN(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MFM%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
   END FUNCTION FM_IS_UNKNOWN

   FUNCTION IM_IS_UNKNOWN(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MIM%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
   END FUNCTION IM_IS_UNKNOWN

   FUNCTION ZM_IS_UNKNOWN(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      IF (MA%MZM(1)%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
      IF (MA%MZM(2)%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
   END FUNCTION ZM_IS_UNKNOWN

   FUNCTION FM_IS_UNKNOWN1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MFM%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION FM_IS_UNKNOWN1

   FUNCTION IM_IS_UNKNOWN1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MIM%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION IM_IS_UNKNOWN1

   FUNCTION ZM_IS_UNKNOWN1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%MZM(1)%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
         IF (MA(J)%MZM(2)%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION ZM_IS_UNKNOWN1

   FUNCTION FM_IS_UNKNOWN2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MFM%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION FM_IS_UNKNOWN2

   FUNCTION IM_IS_UNKNOWN2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MIM%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION IM_IS_UNKNOWN2

   FUNCTION ZM_IS_UNKNOWN2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%MZM(1)%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
            IF (MA(J,K)%MZM(2)%MP(2) == QX%MUNKNO) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION ZM_IS_UNKNOWN2


   SUBROUTINE FM_DEALLOCATE_FM1(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) < 0 .AND. QX%NDIG < 0) WRITE (*,*) ' Invalid NDIG = ', QX%NDIG
   END SUBROUTINE FM_DEALLOCATE_FM1

   SUBROUTINE FM_DEALLOCATE_IM1(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) < 0 .AND. QX%NDIG < 0) WRITE (*,*) ' Invalid NDIG = ', QX%NDIG
   END SUBROUTINE FM_DEALLOCATE_IM1

   SUBROUTINE FM_DEALLOCATE_ZM1(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) < 0 .AND. QX%NDIG < 0) WRITE (*,*) ' Invalid NDIG = ', QX%NDIG
   END SUBROUTINE FM_DEALLOCATE_ZM1

   SUBROUTINE FM_DEALLOCATE_FM2(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) < 0 .AND. QX%NDIG < 0) WRITE (*,*) ' Invalid NDIG = ', QX%NDIG
   END SUBROUTINE FM_DEALLOCATE_FM2

   SUBROUTINE FM_DEALLOCATE_IM2(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) < 0 .AND. QX%NDIG < 0) WRITE (*,*) ' Invalid NDIG = ', QX%NDIG
   END SUBROUTINE FM_DEALLOCATE_IM2

   SUBROUTINE FM_DEALLOCATE_ZM2(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) < 0 .AND. QX%NDIG < 0) WRITE (*,*) ' Invalid NDIG = ', QX%NDIG
   END SUBROUTINE FM_DEALLOCATE_ZM2

 END MODULE FMZM_1_PARALLEL

 MODULE FMZM_2_PARALLEL
    USE FMZM_1_PARALLEL

!   These abbreviations are used for operations on the various data types.

!   I    Integer
!   R    Real
!   D    Double Precision
!   Z    Complex
!   C    Complex Double Precision
!   FM   Multiple precision real
!   IM   Multiple precision integer
!   ZM   Multiple precision complex

!   For example, the "=" procedure FMEQ_FMD is for statements like X = A, where X is type FM
!   and A is type Double Precision.

!   Digits refer to the number of dimensions (rank) for an array.
!   FMEQ_FM1R handles statements like A = 1.0, where A is a 1-dimensional array of type FM and the
!   right side (1.0) is real.  Like the ordinary Fortran array syntax, this sets all the elements
!   of array A to 1.0.

    INTERFACE ASSIGNMENT (=)
       MODULE PROCEDURE FMEQ_IFM
       MODULE PROCEDURE FMEQ_IIM
       MODULE PROCEDURE FMEQ_IZM
       MODULE PROCEDURE FMEQ_RFM
       MODULE PROCEDURE FMEQ_RIM
       MODULE PROCEDURE FMEQ_RZM
       MODULE PROCEDURE FMEQ_DFM
       MODULE PROCEDURE FMEQ_DIM
       MODULE PROCEDURE FMEQ_DZM
       MODULE PROCEDURE FMEQ_ZFM
       MODULE PROCEDURE FMEQ_ZIM
       MODULE PROCEDURE FMEQ_ZZM
       MODULE PROCEDURE FMEQ_CFM
       MODULE PROCEDURE FMEQ_CIM
       MODULE PROCEDURE FMEQ_CZM
       MODULE PROCEDURE FMEQ_FMI
       MODULE PROCEDURE FMEQ_FMR
       MODULE PROCEDURE FMEQ_FMD
       MODULE PROCEDURE FMEQ_FMZ
       MODULE PROCEDURE FMEQ_FMC
       MODULE PROCEDURE FMEQ_FMFM
       MODULE PROCEDURE FMEQ_FMIM
       MODULE PROCEDURE FMEQ_FMZM
       MODULE PROCEDURE FMEQ_IMI
       MODULE PROCEDURE FMEQ_IMR
       MODULE PROCEDURE FMEQ_IMD
       MODULE PROCEDURE FMEQ_IMZ
       MODULE PROCEDURE FMEQ_IMC
       MODULE PROCEDURE FMEQ_IMFM
       MODULE PROCEDURE FMEQ_IMIM
       MODULE PROCEDURE FMEQ_IMZM
       MODULE PROCEDURE FMEQ_ZMI
       MODULE PROCEDURE FMEQ_ZMR
       MODULE PROCEDURE FMEQ_ZMD
       MODULE PROCEDURE FMEQ_ZMZ
       MODULE PROCEDURE FMEQ_ZMC
       MODULE PROCEDURE FMEQ_ZMFM
       MODULE PROCEDURE FMEQ_ZMIM
       MODULE PROCEDURE FMEQ_ZMZM
       MODULE PROCEDURE FMEQ_FM1I
       MODULE PROCEDURE FMEQ_FM1R
       MODULE PROCEDURE FMEQ_FM1D
       MODULE PROCEDURE FMEQ_FM1Z
       MODULE PROCEDURE FMEQ_FM1C
       MODULE PROCEDURE FMEQ_I1FM
       MODULE PROCEDURE FMEQ_R1FM
       MODULE PROCEDURE FMEQ_D1FM
       MODULE PROCEDURE FMEQ_Z1FM
       MODULE PROCEDURE FMEQ_C1FM
       MODULE PROCEDURE FMEQ_FM1FM
       MODULE PROCEDURE FMEQ_FM1IM
       MODULE PROCEDURE FMEQ_FM1ZM
       MODULE PROCEDURE FMEQ_IM1FM
       MODULE PROCEDURE FMEQ_ZM1FM
       MODULE PROCEDURE FMEQ_FM1I1
       MODULE PROCEDURE FMEQ_FM1R1
       MODULE PROCEDURE FMEQ_FM1D1
       MODULE PROCEDURE FMEQ_FM1Z1
       MODULE PROCEDURE FMEQ_FM1C1
       MODULE PROCEDURE FMEQ_I1FM1
       MODULE PROCEDURE FMEQ_R1FM1
       MODULE PROCEDURE FMEQ_D1FM1
       MODULE PROCEDURE FMEQ_Z1FM1
       MODULE PROCEDURE FMEQ_C1FM1
       MODULE PROCEDURE FMEQ_FM1FM1
       MODULE PROCEDURE FMEQ_FM1IM1
       MODULE PROCEDURE FMEQ_FM1ZM1
       MODULE PROCEDURE FMEQ_IM1FM1
       MODULE PROCEDURE FMEQ_ZM1FM1
       MODULE PROCEDURE FMEQ_IM1I
       MODULE PROCEDURE FMEQ_IM1R
       MODULE PROCEDURE FMEQ_IM1D
       MODULE PROCEDURE FMEQ_IM1Z
       MODULE PROCEDURE FMEQ_IM1C
       MODULE PROCEDURE FMEQ_I1IM
       MODULE PROCEDURE FMEQ_R1IM
       MODULE PROCEDURE FMEQ_D1IM
       MODULE PROCEDURE FMEQ_Z1IM
       MODULE PROCEDURE FMEQ_C1IM
       MODULE PROCEDURE FMEQ_IM1IM
       MODULE PROCEDURE FMEQ_IM1ZM
       MODULE PROCEDURE FMEQ_ZM1IM
       MODULE PROCEDURE FMEQ_IM1I1
       MODULE PROCEDURE FMEQ_IM1R1
       MODULE PROCEDURE FMEQ_IM1D1
       MODULE PROCEDURE FMEQ_IM1Z1
       MODULE PROCEDURE FMEQ_IM1C1
       MODULE PROCEDURE FMEQ_I1IM1
       MODULE PROCEDURE FMEQ_R1IM1
       MODULE PROCEDURE FMEQ_D1IM1
       MODULE PROCEDURE FMEQ_Z1IM1
       MODULE PROCEDURE FMEQ_C1IM1
       MODULE PROCEDURE FMEQ_IM1IM1
       MODULE PROCEDURE FMEQ_IM1ZM1
       MODULE PROCEDURE FMEQ_ZM1IM1
       MODULE PROCEDURE FMEQ_ZM1I
       MODULE PROCEDURE FMEQ_ZM1R
       MODULE PROCEDURE FMEQ_ZM1D
       MODULE PROCEDURE FMEQ_ZM1Z
       MODULE PROCEDURE FMEQ_ZM1C
       MODULE PROCEDURE FMEQ_I1ZM
       MODULE PROCEDURE FMEQ_R1ZM
       MODULE PROCEDURE FMEQ_D1ZM
       MODULE PROCEDURE FMEQ_Z1ZM
       MODULE PROCEDURE FMEQ_C1ZM
       MODULE PROCEDURE FMEQ_ZM1ZM
       MODULE PROCEDURE FMEQ_ZM1I1
       MODULE PROCEDURE FMEQ_ZM1R1
       MODULE PROCEDURE FMEQ_ZM1D1
       MODULE PROCEDURE FMEQ_ZM1Z1
       MODULE PROCEDURE FMEQ_ZM1C1
       MODULE PROCEDURE FMEQ_I1ZM1
       MODULE PROCEDURE FMEQ_R1ZM1
       MODULE PROCEDURE FMEQ_D1ZM1
       MODULE PROCEDURE FMEQ_Z1ZM1
       MODULE PROCEDURE FMEQ_C1ZM1
       MODULE PROCEDURE FMEQ_ZM1ZM1
       MODULE PROCEDURE FMEQ_FM2I
       MODULE PROCEDURE FMEQ_FM2R
       MODULE PROCEDURE FMEQ_FM2D
       MODULE PROCEDURE FMEQ_FM2Z
       MODULE PROCEDURE FMEQ_FM2C
       MODULE PROCEDURE FMEQ_I2FM
       MODULE PROCEDURE FMEQ_R2FM
       MODULE PROCEDURE FMEQ_D2FM
       MODULE PROCEDURE FMEQ_Z2FM
       MODULE PROCEDURE FMEQ_C2FM
       MODULE PROCEDURE FMEQ_FM2FM
       MODULE PROCEDURE FMEQ_FM2IM
       MODULE PROCEDURE FMEQ_FM2ZM
       MODULE PROCEDURE FMEQ_IM2FM
       MODULE PROCEDURE FMEQ_ZM2FM
       MODULE PROCEDURE FMEQ_FM2I2
       MODULE PROCEDURE FMEQ_FM2R2
       MODULE PROCEDURE FMEQ_FM2D2
       MODULE PROCEDURE FMEQ_FM2Z2
       MODULE PROCEDURE FMEQ_FM2C2
       MODULE PROCEDURE FMEQ_I2FM2
       MODULE PROCEDURE FMEQ_R2FM2
       MODULE PROCEDURE FMEQ_D2FM2
       MODULE PROCEDURE FMEQ_Z2FM2
       MODULE PROCEDURE FMEQ_C2FM2
       MODULE PROCEDURE FMEQ_FM2FM2
       MODULE PROCEDURE FMEQ_FM2IM2
       MODULE PROCEDURE FMEQ_FM2ZM2
       MODULE PROCEDURE FMEQ_IM2FM2
       MODULE PROCEDURE FMEQ_ZM2FM2
       MODULE PROCEDURE FMEQ_IM2I
       MODULE PROCEDURE FMEQ_IM2R
       MODULE PROCEDURE FMEQ_IM2D
       MODULE PROCEDURE FMEQ_IM2Z
       MODULE PROCEDURE FMEQ_IM2C
       MODULE PROCEDURE FMEQ_I2IM
       MODULE PROCEDURE FMEQ_R2IM
       MODULE PROCEDURE FMEQ_D2IM
       MODULE PROCEDURE FMEQ_Z2IM
       MODULE PROCEDURE FMEQ_C2IM
       MODULE PROCEDURE FMEQ_IM2IM
       MODULE PROCEDURE FMEQ_IM2ZM
       MODULE PROCEDURE FMEQ_ZM2IM
       MODULE PROCEDURE FMEQ_IM2I2
       MODULE PROCEDURE FMEQ_IM2R2
       MODULE PROCEDURE FMEQ_IM2D2
       MODULE PROCEDURE FMEQ_IM2Z2
       MODULE PROCEDURE FMEQ_IM2C2
       MODULE PROCEDURE FMEQ_I2IM2
       MODULE PROCEDURE FMEQ_R2IM2
       MODULE PROCEDURE FMEQ_D2IM2
       MODULE PROCEDURE FMEQ_Z2IM2
       MODULE PROCEDURE FMEQ_C2IM2
       MODULE PROCEDURE FMEQ_IM2IM2
       MODULE PROCEDURE FMEQ_IM2ZM2
       MODULE PROCEDURE FMEQ_ZM2IM2
       MODULE PROCEDURE FMEQ_ZM2I
       MODULE PROCEDURE FMEQ_ZM2R
       MODULE PROCEDURE FMEQ_ZM2D
       MODULE PROCEDURE FMEQ_ZM2Z
       MODULE PROCEDURE FMEQ_ZM2C
       MODULE PROCEDURE FMEQ_I2ZM
       MODULE PROCEDURE FMEQ_R2ZM
       MODULE PROCEDURE FMEQ_D2ZM
       MODULE PROCEDURE FMEQ_Z2ZM
       MODULE PROCEDURE FMEQ_C2ZM
       MODULE PROCEDURE FMEQ_ZM2ZM
       MODULE PROCEDURE FMEQ_ZM2I2
       MODULE PROCEDURE FMEQ_ZM2R2
       MODULE PROCEDURE FMEQ_ZM2D2
       MODULE PROCEDURE FMEQ_ZM2Z2
       MODULE PROCEDURE FMEQ_ZM2C2
       MODULE PROCEDURE FMEQ_I2ZM2
       MODULE PROCEDURE FMEQ_R2ZM2
       MODULE PROCEDURE FMEQ_D2ZM2
       MODULE PROCEDURE FMEQ_Z2ZM2
       MODULE PROCEDURE FMEQ_C2ZM2
       MODULE PROCEDURE FMEQ_ZM2ZM2
    END INTERFACE

    INTERFACE OPERATOR (==)
       MODULE PROCEDURE FMLEQ_IFM
       MODULE PROCEDURE FMLEQ_IIM
       MODULE PROCEDURE FMLEQ_IZM
       MODULE PROCEDURE FMLEQ_RFM
       MODULE PROCEDURE FMLEQ_RIM
       MODULE PROCEDURE FMLEQ_RZM
       MODULE PROCEDURE FMLEQ_DFM
       MODULE PROCEDURE FMLEQ_DIM
       MODULE PROCEDURE FMLEQ_DZM
       MODULE PROCEDURE FMLEQ_ZFM
       MODULE PROCEDURE FMLEQ_ZIM
       MODULE PROCEDURE FMLEQ_ZZM
       MODULE PROCEDURE FMLEQ_CFM
       MODULE PROCEDURE FMLEQ_CIM
       MODULE PROCEDURE FMLEQ_CZM
       MODULE PROCEDURE FMLEQ_FMI
       MODULE PROCEDURE FMLEQ_FMR
       MODULE PROCEDURE FMLEQ_FMD
       MODULE PROCEDURE FMLEQ_FMZ
       MODULE PROCEDURE FMLEQ_FMC
       MODULE PROCEDURE FMLEQ_FMFM
       MODULE PROCEDURE FMLEQ_FMIM
       MODULE PROCEDURE FMLEQ_FMZM
       MODULE PROCEDURE FMLEQ_IMI
       MODULE PROCEDURE FMLEQ_IMR
       MODULE PROCEDURE FMLEQ_IMD
       MODULE PROCEDURE FMLEQ_IMZ
       MODULE PROCEDURE FMLEQ_IMC
       MODULE PROCEDURE FMLEQ_IMFM
       MODULE PROCEDURE FMLEQ_IMIM
       MODULE PROCEDURE FMLEQ_IMZM
       MODULE PROCEDURE FMLEQ_ZMI
       MODULE PROCEDURE FMLEQ_ZMR
       MODULE PROCEDURE FMLEQ_ZMD
       MODULE PROCEDURE FMLEQ_ZMZ
       MODULE PROCEDURE FMLEQ_ZMC
       MODULE PROCEDURE FMLEQ_ZMFM
       MODULE PROCEDURE FMLEQ_ZMIM
       MODULE PROCEDURE FMLEQ_ZMZM
    END INTERFACE


 CONTAINS



!                                                                   =

   SUBROUTINE FMEQ_IFM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2I(MA%MFM,IVAL,QX)
   END SUBROUTINE FMEQ_IFM

   SUBROUTINE FMEQ_IIM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2I(MA%MIM,IVAL,QX)
   END SUBROUTINE FMEQ_IIM

   SUBROUTINE FMEQ_IZM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMM2I(MA%MZM,IVAL,QX)
   END SUBROUTINE FMEQ_IZM

   SUBROUTINE FMEQ_RFM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL :: R
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2SP(MA%MFM,R,QX)
   END SUBROUTINE FMEQ_RFM

   SUBROUTINE FMEQ_RIM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R,QX)
   END SUBROUTINE FMEQ_RIM

   SUBROUTINE FMEQ_RZM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL :: R
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R,QX)
   END SUBROUTINE FMEQ_RZM

   SUBROUTINE FMEQ_DFM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2DP(MA%MFM,D,QX)
   END SUBROUTINE FMEQ_DFM

   SUBROUTINE FMEQ_DIM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2DP(MA%MIM,D,QX)
   END SUBROUTINE FMEQ_DIM

   SUBROUTINE FMEQ_DZM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D,QX)
   END SUBROUTINE FMEQ_DZM

   SUBROUTINE FMEQ_ZFM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX :: Z
      REAL :: R
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2SP(MA%MFM,R,QX)
      Z = CMPLX( R , 0.0 )
   END SUBROUTINE FMEQ_ZFM

   SUBROUTINE FMEQ_ZIM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX :: Z
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2DP(MA%MIM,D,QX)
      Z = CMPLX( REAL(D) , 0.0 )
   END SUBROUTINE FMEQ_ZIM

   SUBROUTINE FMEQ_ZZM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX :: Z
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMM2Z(MA%MZM,Z,QX)
   END SUBROUTINE FMEQ_ZZM

   SUBROUTINE FMEQ_CFM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2DP(MA%MFM,D,QX)
      C = CMPLX( D , 0.0D0 , KIND(0.0D0) )
   END SUBROUTINE FMEQ_CFM

   SUBROUTINE FMEQ_CIM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2DP(MA%MIM,D,QX)
      C = CMPLX( D , 0.0D0 , KIND(0.0D0) )
   END SUBROUTINE FMEQ_CIM

   SUBROUTINE FMEQ_CZM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D1,D2
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D1,QX)
      CALL ZMIMAG(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      C = CMPLX( D1 , D2 , KIND(0.0D0) )
   END SUBROUTINE FMEQ_CZM

   SUBROUTINE FMEQ_FMI(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MA%MFM,QX)
   END SUBROUTINE FMEQ_FMI

   SUBROUTINE FMEQ_FMR(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MA%MFM,QX)
   END SUBROUTINE FMEQ_FMR

   SUBROUTINE FMEQ_FMD(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MA%MFM,QX)
   END SUBROUTINE FMEQ_FMD

   SUBROUTINE FMEQ_FMZ(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX :: Z
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      R = REAL(Z)
      CALL FMSP2M(R,MA%MFM,QX)
   END SUBROUTINE FMEQ_FMZ

   SUBROUTINE FMEQ_FMC(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(FM_SETTINGS) :: QX
      D = REAL(C,KIND(0.0D0))
      CALL FMDP2M(D,MA%MFM,QX)
   END SUBROUTINE FMEQ_FMC

   SUBROUTINE FMEQ_FMFM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MB%MFM,MA%MFM,QX)
   END SUBROUTINE FMEQ_FMFM

   SUBROUTINE FMEQ_FMIM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM) :: MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MA%MFM,QX)
   END SUBROUTINE FMEQ_FMIM

   SUBROUTINE FMEQ_FMZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM) :: MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MB%MZM,MA%MFM,QX)
   END SUBROUTINE FMEQ_FMZM

   SUBROUTINE FMEQ_IMI(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MA%MIM,QX)
   END SUBROUTINE FMEQ_IMI

   SUBROUTINE FMEQ_IMR(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: IVAL
      REAL :: R
      CHARACTER(25) :: ST
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      IF (ABS(R) < HUGE(1)) THEN
          IVAL = INT(R)
          CALL IMI2M(IVAL,MA%MIM,QX)
      ELSE
          WRITE (ST,'(E25.16)') R
          CALL IMST2M(ST,MA%MIM,QX)
      ENDIF
   END SUBROUTINE FMEQ_IMR

   SUBROUTINE FMEQ_IMD(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: IVAL
      DOUBLE PRECISION :: D
      CHARACTER(25) :: ST
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(FM_SETTINGS) :: QX
      IF (ABS(D) < HUGE(1)) THEN
          IVAL = INT(D)
          CALL IMI2M(IVAL,MA%MIM,QX)
      ELSE
          WRITE (ST,'(E25.16)') D
          CALL IMST2M(ST,MA%MIM,QX)
      ENDIF
   END SUBROUTINE FMEQ_IMD

   SUBROUTINE FMEQ_IMZ(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX :: Z
      REAL :: R
      CHARACTER(25) :: ST
      TYPE(FM_SETTINGS) :: QX
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      R = REAL(Z)
      IF (ABS(R) < HUGE(1)) THEN
          IVAL = INT(R)
          CALL IMI2M(IVAL,MA%MIM,QX)
      ELSE
          WRITE (ST,'(E25.16)') R
          CALL IMST2M(ST,MA%MIM,QX)
      ENDIF
   END SUBROUTINE FMEQ_IMZ

   SUBROUTINE FMEQ_IMC(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      CHARACTER(25) :: ST
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(FM_SETTINGS) :: QX
      D = REAL(C,KIND(0.0D0))
      IF (ABS(D) < HUGE(1)) THEN
          IVAL = INT(D)
          CALL IMI2M(IVAL,MA%MIM,QX)
      ELSE
          WRITE (ST,'(E25.16)') D
          CALL IMST2M(ST,MA%MIM,QX)
      ENDIF
   END SUBROUTINE FMEQ_IMC

   SUBROUTINE FMEQ_IMFM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM) :: MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMFM2I(MB%MFM,MA%MIM,QX)
   END SUBROUTINE FMEQ_IMFM

   SUBROUTINE FMEQ_IMIM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MB%MIM,MA%MIM,QX)
   END SUBROUTINE FMEQ_IMIM

   SUBROUTINE FMEQ_IMZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM) :: MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MA%MIM,QX)
   END SUBROUTINE FMEQ_IMZM

   SUBROUTINE FMEQ_ZMI(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(IVAL,MA%MZM,QX)
   END SUBROUTINE FMEQ_ZMI

   SUBROUTINE FMEQ_ZMR(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL :: R
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(FM_SETTINGS) :: QX
      Z = CMPLX(R,0.0)
      CALL ZMZ2M(Z,MA%MZM,QX)
   END SUBROUTINE FMEQ_ZMR

   SUBROUTINE FMEQ_ZMD(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMDP2M(0.0D0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MA%MZM,QX)
   END SUBROUTINE FMEQ_ZMD

   SUBROUTINE FMEQ_ZMZ(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MA%MZM,QX)
   END SUBROUTINE FMEQ_ZMZ

   SUBROUTINE FMEQ_ZMC(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      D = REAL(C,KIND(0.0D0))
      CALL FMDP2M(D,MTLVFM,QX)
      D = AIMAG(C)
      CALL FMDP2M(D,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MA%MZM,QX)
   END SUBROUTINE FMEQ_ZMC

   SUBROUTINE FMEQ_ZMFM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MB
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MB%MFM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MA%MZM,QX)
   END SUBROUTINE FMEQ_ZMFM

   SUBROUTINE FMEQ_ZMIM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MB
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MA%MZM,QX)
   END SUBROUTINE FMEQ_ZMIM

   SUBROUTINE FMEQ_ZMZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQ(MB%MZM,MTLVZM,QX)
      CALL ZMEQ(MTLVZM,MA%MZM,QX)
   END SUBROUTINE FMEQ_ZMZM

!             Array equal assignments for FM.

!             (1) rank 1  =  rank 0

   SUBROUTINE FMEQ_FM1I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: IVAL,J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1I

   SUBROUTINE FMEQ_FM1R(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: J,N
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1R

   SUBROUTINE FMEQ_FM1D(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1D

   SUBROUTINE FMEQ_FM1Z(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      DO J = 1, N
         CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1Z

   SUBROUTINE FMEQ_FM1C(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      DO J = 1, N
         CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1C

   SUBROUTINE FMEQ_I1FM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,K,N
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      CALL FMM2I(MA%MFM,K,QX)
      DO J = 1, N
         IVAL(J) = K
      ENDDO
   END SUBROUTINE FMEQ_I1FM

   SUBROUTINE FMEQ_R1FM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      REAL :: R2
      INTEGER :: J,N
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMM2SP(MA%MFM,R2,QX)
      DO J = 1, N
         R(J) = R2
      ENDDO
   END SUBROUTINE FMEQ_R1FM

   SUBROUTINE FMEQ_D1FM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      DOUBLE PRECISION :: D2
      INTEGER :: J,N
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMM2DP(MA%MFM,D2,QX)
      DO J = 1, N
         D(J) = D2
      ENDDO
   END SUBROUTINE FMEQ_D1FM

   SUBROUTINE FMEQ_Z1FM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      REAL :: R2
      INTEGER :: J,N
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMM2SP(MA%MFM,R2,QX)
      DO J = 1, N
         Z(J) = R2
      ENDDO
   END SUBROUTINE FMEQ_Z1FM

   SUBROUTINE FMEQ_C1FM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      DOUBLE PRECISION :: D2
      INTEGER :: J,N
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL FMM2DP(MA%MFM,D2,QX)
      DO J = 1, N
         C(J) = D2
      ENDDO
   END SUBROUTINE FMEQ_C1FM

   SUBROUTINE FMEQ_FM1FM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMEQ(MB%MFM,MTLVFM,QX)
      DO J = 1, N
         CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1FM

   SUBROUTINE FMEQ_FM1IM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1IM

   SUBROUTINE FMEQ_FM1ZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      DO J = 1, N
         CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1ZM

   SUBROUTINE FMEQ_IM1FM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMFM2I(MB%MFM,MTLVIM,QX)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1FM

   SUBROUTINE FMEQ_ZM1FM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1FM

!             (2) rank 1  =  rank 1

   SUBROUTINE FMEQ_FM1I1(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1I1

   SUBROUTINE FMEQ_FM1R1(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1R1

   SUBROUTINE FMEQ_FM1D1(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1D1

   SUBROUTINE FMEQ_FM1Z1(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(REAL(Z(J)),MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1Z1

   SUBROUTINE FMEQ_FM1C1(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1C1

   SUBROUTINE FMEQ_I1FM1(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(IVAL)
             IVAL(J) = QX%IUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMM2I(MA(J)%MFM,IVAL(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_I1FM1

   SUBROUTINE FMEQ_R1FM1(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      INTEGER :: J,N
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(R)
             R(J) = QX%RUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMM2SP(MA(J)%MFM,R(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_R1FM1

   SUBROUTINE FMEQ_D1FM1(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTEGER :: J,N
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(D)
             D(J) = QX%RUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMM2DP(MA(J)%MFM,D(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_D1FM1

   SUBROUTINE FMEQ_Z1FM1(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      REAL :: R
      INTEGER :: J,N
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(Z)
             Z(J) = CMPLX(QX%RUNKNO,QX%RUNKNO)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      DO J = 1, N
         CALL FMM2SP(MA(J)%MFM,R,QX)
         Z(J) = CMPLX(R,0.0)
      ENDDO
   END SUBROUTINE FMEQ_Z1FM1

   SUBROUTINE FMEQ_C1FM1(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      REAL (KIND(0.0D0)) :: D
      INTEGER :: J,N
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(C)
             D = QX%RUNKNO
             C(J) = CMPLX(D,D , KIND(0.0D0))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMM2DP(MA(J)%MFM,D,QX)
         C(J) = CMPLX(D,0.0D0 , KIND(0.0D0))
      ENDDO
   END SUBROUTINE FMEQ_C1FM1

   SUBROUTINE FMEQ_FM1FM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), ALLOCATABLE, DIMENSION(:) :: TEMP
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move MB
!             to a temporary array before re-defining any of MA.

      ALLOCATE(TEMP(N))
      DO J = 1, N
         CALL FMEQ(MB(J)%MFM,TEMP(J)%MFM,QX)
      ENDDO
      DO J = 1, N
         CALL FMEQ(TEMP(J)%MFM,MA(J)%MFM,QX)
      ENDDO
      DEALLOCATE(TEMP)
   END SUBROUTINE FMEQ_FM1FM1

   SUBROUTINE FMEQ_FM1IM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1IM1

   SUBROUTINE FMEQ_FM1ZM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMREAL(MB(J)%MZM,MA(J)%MFM,QX)
      ENDDO
   END SUBROUTINE FMEQ_FM1ZM1

   SUBROUTINE FMEQ_IM1FM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMFM2I(MB(J)%MFM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1FM1

   SUBROUTINE FMEQ_ZM1FM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1FM1

!             (3) rank 2  =  rank 0

   SUBROUTINE FMEQ_FM2I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: IVAL,J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2I

   SUBROUTINE FMEQ_FM2R(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2R

   SUBROUTINE FMEQ_FM2D(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2D

   SUBROUTINE FMEQ_FM2Z(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2Z

   SUBROUTINE FMEQ_FM2C(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2C

   SUBROUTINE FMEQ_I2FM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K,L
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2I(MA%MFM,L,QX)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            IVAL(J,K) = L
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_I2FM

   SUBROUTINE FMEQ_R2FM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      REAL :: R2
      INTEGER :: J,K
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2SP(MA%MFM,R2,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            R(J,K) = R2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_R2FM

   SUBROUTINE FMEQ_D2FM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      DOUBLE PRECISION :: D2
      INTEGER :: J,K
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2DP(MA%MFM,D2,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            D(J,K) = D2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_D2FM

   SUBROUTINE FMEQ_Z2FM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      REAL :: R2
      INTEGER :: J,K
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2SP(MA%MFM,R2,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            Z(J,K) = R2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_Z2FM

   SUBROUTINE FMEQ_C2FM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      DOUBLE PRECISION :: D2
      INTEGER :: J,K
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2DP(MA%MFM,D2,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            C(J,K) = D2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_C2FM

   SUBROUTINE FMEQ_FM2FM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MB%MFM,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2FM

   SUBROUTINE FMEQ_FM2IM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2IM

   SUBROUTINE FMEQ_FM2ZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2ZM

   SUBROUTINE FMEQ_IM2FM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMFM2I(MB%MFM,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2FM

   SUBROUTINE FMEQ_ZM2FM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2FM

!             (4) rank 2  =  rank 2

   SUBROUTINE FMEQ_FM2I2(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2I2

   SUBROUTINE FMEQ_FM2R2(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2R2

   SUBROUTINE FMEQ_FM2D2(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2D2

   SUBROUTINE FMEQ_FM2Z2(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(REAL(Z(J,K)),MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2Z2

   SUBROUTINE FMEQ_FM2C2(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2C2

   SUBROUTINE FMEQ_I2FM2(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(IVAL,DIM=1)
             DO K = 1, SIZE(IVAL,DIM=2)
                IVAL(J,K) = QX%IUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2I(MA(J,K)%MFM,IVAL(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_I2FM2

   SUBROUTINE FMEQ_R2FM2(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      INTEGER :: J,K
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(R,DIM=1)
             DO K = 1, SIZE(R,DIM=2)
                R(J,K) = QX%RUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP(MA(J,K)%MFM,R(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_R2FM2

   SUBROUTINE FMEQ_D2FM2(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTEGER :: J,K
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(D,DIM=1)
             DO K = 1, SIZE(D,DIM=2)
                D(J,K) = QX%RUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP(MA(J,K)%MFM,D(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_D2FM2

   SUBROUTINE FMEQ_Z2FM2(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      REAL :: R
      INTEGER :: J,K
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(Z,DIM=1)
             DO K = 1, SIZE(Z,DIM=2)
                Z(J,K) = CMPLX(QX%RUNKNO,QX%RUNKNO)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP(MA(J,K)%MFM,R,QX)
            Z(J,K) = CMPLX(R,0.0)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_Z2FM2

   SUBROUTINE FMEQ_C2FM2(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      REAL (KIND(0.0D0)) :: D
      INTEGER :: J,K
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(C,DIM=1)
             DO K = 1, SIZE(C,DIM=2)
                D = QX%RUNKNO
                C(J,K) = CMPLX(D,D , KIND(0.0D0))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP(MA(J,K)%MFM,D,QX)
            C(J,K) = CMPLX(D,0.0D0 , KIND(0.0D0))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_C2FM2

   SUBROUTINE FMEQ_FM2FM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), ALLOCATABLE, DIMENSION(:,:) :: TEMP
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move MB
!             to a temporary array before re-defining any of MA.

      ALLOCATE(TEMP(SIZE(MA,DIM=1),SIZE(MA,DIM=2)))
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MB(J,K)%MFM,TEMP(J,K)%MFM,QX)
         ENDDO
      ENDDO
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(TEMP(J,K)%MFM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
      DEALLOCATE(TEMP)
   END SUBROUTINE FMEQ_FM2FM2

   SUBROUTINE FMEQ_FM2IM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2IM2

   SUBROUTINE FMEQ_FM2ZM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL(MB(J,K)%MZM,MA(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_FM2ZM2

   SUBROUTINE FMEQ_IM2FM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMFM2I(MB(J,K)%MFM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2FM2

   SUBROUTINE FMEQ_ZM2FM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2FM2

!             Array equal assignments for IM.

!             (1) rank 1  =  rank 0

   SUBROUTINE FMEQ_IM1I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: IVAL,J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1I

   SUBROUTINE FMEQ_IM1R(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: J,N
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1R

   SUBROUTINE FMEQ_IM1D(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1D

   SUBROUTINE FMEQ_IM1Z(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1Z

   SUBROUTINE FMEQ_IM1C(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1C

   SUBROUTINE FMEQ_I1IM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,K,N
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      CALL IMM2I(MA%MIM,K,QX)
      DO J = 1, N
         IVAL(J) = K
      ENDDO
   END SUBROUTINE FMEQ_I1IM

   SUBROUTINE FMEQ_R1IM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      REAL :: R2
      INTEGER :: J,N
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R2,QX)
      DO J = 1, N
         R(J) = R2
      ENDDO
   END SUBROUTINE FMEQ_R1IM

   SUBROUTINE FMEQ_D1IM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      DOUBLE PRECISION :: D2
      INTEGER :: J,N
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      DO J = 1, N
         D(J) = D2
      ENDDO
   END SUBROUTINE FMEQ_D1IM

   SUBROUTINE FMEQ_Z1IM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      REAL :: R2
      INTEGER :: J,N
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R2,QX)
      DO J = 1, N
         Z(J) = R2
      ENDDO
   END SUBROUTINE FMEQ_Z1IM

   SUBROUTINE FMEQ_C1IM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      DOUBLE PRECISION :: D2
      INTEGER :: J,N
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      DO J = 1, N
         C(J) = D2
      ENDDO
   END SUBROUTINE FMEQ_C1IM

   SUBROUTINE FMEQ_IM1IM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMEQ(MB%MIM,MTLVIM,QX)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1IM

   SUBROUTINE FMEQ_IM1ZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1ZM

   SUBROUTINE FMEQ_ZM1IM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MULVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1IM

!             (2) rank 1  =  rank 1

   SUBROUTINE FMEQ_IM1I1(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1I1

   SUBROUTINE FMEQ_IM1R1(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL IMFM2I(MTLVFM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1R1

   SUBROUTINE FMEQ_IM1D1(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL IMFM2I(MTLVFM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1D1

   SUBROUTINE FMEQ_IM1Z1(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(REAL(Z(J)),MTLVFM,QX)
         CALL IMFM2I(MTLVFM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1Z1

   SUBROUTINE FMEQ_IM1C1(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL IMFM2I(MTLVFM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1C1

   SUBROUTINE FMEQ_I1IM1(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             IVAL(J) = QX%IUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMM2I(MA(J)%MIM,IVAL(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_I1IM1

   SUBROUTINE FMEQ_R1IM1(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      INTEGER :: J,N
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             R(J) = QX%RUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMM2SP(MTLVFM,R(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_R1IM1

   SUBROUTINE FMEQ_D1IM1(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTEGER :: J,N
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             D(J) = QX%RUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMM2DP(MTLVFM,D(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_D1IM1

   SUBROUTINE FMEQ_Z1IM1(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      REAL :: R
      INTEGER :: J,N
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             Z(J) = CMPLX(QX%RUNKNO,QX%RUNKNO)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMM2SP(MTLVFM,R,QX)
         Z(J) = CMPLX(R,0.0)
      ENDDO
   END SUBROUTINE FMEQ_Z1IM1

   SUBROUTINE FMEQ_C1IM1(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      REAL (KIND(0.0D0)) :: D
      INTEGER :: J,N
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             D = QX%RUNKNO
             C(J) = CMPLX(D,D , KIND(0.0D0))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMM2DP(MTLVFM,D,QX)
         C(J) = CMPLX(D,0.0D0 , KIND(0.0D0))
      ENDDO
   END SUBROUTINE FMEQ_C1IM1

   SUBROUTINE FMEQ_IM1IM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), ALLOCATABLE, DIMENSION(:) :: TEMP
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move MB
!             to a temporary array before re-defining any of MA.

      ALLOCATE(TEMP(N))
      DO J = 1, N
         CALL IMEQ(MB(J)%MIM,TEMP(J)%MIM,QX)
      ENDDO
      DO J = 1, N
         CALL IMEQ(TEMP(J)%MIM,MA(J)%MIM,QX)
      ENDDO
      DEALLOCATE(TEMP)
   END SUBROUTINE FMEQ_IM1IM1

   SUBROUTINE FMEQ_IM1ZM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMREAL(MB(J)%MZM,MTLVFM,QX)
         CALL IMFM2I(MTLVFM,MA(J)%MIM,QX)
      ENDDO
   END SUBROUTINE FMEQ_IM1ZM1

   SUBROUTINE FMEQ_ZM1IM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MULVFM,QX)
         CALL ZMCMPX(MULVFM,MTLVFM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1IM1

!             (3) rank 2  =  rank 0

   SUBROUTINE FMEQ_IM2I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: IVAL,J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2I

   SUBROUTINE FMEQ_IM2R(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2R

   SUBROUTINE FMEQ_IM2D(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2D

   SUBROUTINE FMEQ_IM2Z(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2Z

   SUBROUTINE FMEQ_IM2C(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2C

   SUBROUTINE FMEQ_I2IM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K,L
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2I(MA%MIM,L,QX)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            IVAL(J,K) = L
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_I2IM

   SUBROUTINE FMEQ_R2IM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      REAL :: R2
      INTEGER :: J,K
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R2,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            R(J,K) = R2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_R2IM

   SUBROUTINE FMEQ_D2IM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      DOUBLE PRECISION :: D2
      INTEGER :: J,K
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            D(J,K) = D2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_D2IM

   SUBROUTINE FMEQ_Z2IM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      REAL :: R2
      INTEGER :: J,K
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R2,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            Z(J,K) = R2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_Z2IM

   SUBROUTINE FMEQ_C2IM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      DOUBLE PRECISION :: D2
      INTEGER :: J,K
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            C(J,K) = D2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_C2IM

   SUBROUTINE FMEQ_IM2IM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MB%MIM,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2IM

   SUBROUTINE FMEQ_IM2ZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2ZM

   SUBROUTINE FMEQ_ZM2IM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MULVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2IM

!             (4) rank 2  =  rank 2

   SUBROUTINE FMEQ_IM2I2(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2I2

   SUBROUTINE FMEQ_IM2R2(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL IMFM2I(MTLVFM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2R2

   SUBROUTINE FMEQ_IM2D2(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL IMFM2I(MTLVFM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2D2

   SUBROUTINE FMEQ_IM2Z2(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(REAL(Z(J,K)),MTLVFM,QX)
            CALL IMFM2I(MTLVFM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2Z2

   SUBROUTINE FMEQ_IM2C2(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL IMFM2I(MTLVFM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2C2

   SUBROUTINE FMEQ_I2IM2(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                IVAL(J,K) = QX%IUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMM2I(MA(J,K)%MIM,IVAL(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_I2IM2

   SUBROUTINE FMEQ_R2IM2(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      INTEGER :: J,K
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                R(J,K) = QX%RUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMM2SP(MTLVFM,R(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_R2IM2

   SUBROUTINE FMEQ_D2IM2(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTEGER :: J,K
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                D(J,K) = QX%RUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMM2DP(MTLVFM,D(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_D2IM2

   SUBROUTINE FMEQ_Z2IM2(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      REAL :: R
      INTEGER :: J,K
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                Z(J,K) = CMPLX(QX%RUNKNO,QX%RUNKNO)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMM2SP(MTLVFM,R,QX)
            Z(J,K) = CMPLX(R,0.0)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_Z2IM2

   SUBROUTINE FMEQ_C2IM2(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      REAL (KIND(0.0D0)) :: D
      INTEGER :: J,K
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                D = QX%RUNKNO
                C(J,K) = CMPLX(D,D , KIND(0.0D0))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMM2DP(MTLVFM,D,QX)
            C(J,K) = CMPLX(D,0.0D0 , KIND(0.0D0))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_C2IM2

   SUBROUTINE FMEQ_IM2IM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), ALLOCATABLE, DIMENSION(:,:) :: TEMP
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move MB
!             to a temporary array before re-defining any of MA.

      ALLOCATE(TEMP(SIZE(MA,DIM=1),SIZE(MA,DIM=2)))
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MB(J,K)%MIM,TEMP(J,K)%MIM,QX)
         ENDDO
      ENDDO
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(TEMP(J,K)%MIM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
      DEALLOCATE(TEMP)
   END SUBROUTINE FMEQ_IM2IM2

   SUBROUTINE FMEQ_IM2ZM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTLVIM,MA(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL(MB(J,K)%MZM,MTLVFM,QX)
            CALL IMFM2I(MTLVFM,MA(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_IM2ZM2

   SUBROUTINE FMEQ_ZM2IM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MULVFM,QX)
            CALL ZMCMPX(MULVFM,MTLVFM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2IM2

!             Array equal assignments for ZM.

!             (1) rank 1  =  rank 0

   SUBROUTINE FMEQ_ZM1I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: IVAL,J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, N
         CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1I

   SUBROUTINE FMEQ_ZM1R(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: J,N
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1R

   SUBROUTINE FMEQ_ZM1D(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1D

   SUBROUTINE FMEQ_ZM1Z(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1Z

   SUBROUTINE FMEQ_ZM1C(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      D = AIMAG(C)
      CALL FMDP2M(D,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1C

   SUBROUTINE FMEQ_I1ZM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,K,N
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      CALL ZMM2I(MA%MZM,K,QX)
      DO J = 1, N
         IVAL(J) = K
      ENDDO
   END SUBROUTINE FMEQ_I1ZM

   SUBROUTINE FMEQ_R1ZM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      REAL :: R2
      INTEGER :: J,N
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R2,QX)
      DO J = 1, N
         R(J) = R2
      ENDDO
   END SUBROUTINE FMEQ_R1ZM

   SUBROUTINE FMEQ_D1ZM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      DOUBLE PRECISION :: D2
      INTEGER :: J,N
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      DO J = 1, N
         D(J) = D2
      ENDDO
   END SUBROUTINE FMEQ_D1ZM

   SUBROUTINE FMEQ_Z1ZM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      COMPLEX :: Z2
      INTEGER :: J,N
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL ZMM2Z(MA%MZM,Z2,QX)
      DO J = 1, N
         Z(J) = Z2
      ENDDO
   END SUBROUTINE FMEQ_Z1ZM

   SUBROUTINE FMEQ_C1ZM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      DOUBLE PRECISION :: D2,D3
      INTEGER :: J,N
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      CALL ZMIMAG(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D3,QX)
      DO J = 1, N
         C(J) = CMPLX(D2,D3, KIND(0.0D0))
      ENDDO
   END SUBROUTINE FMEQ_C1ZM

   SUBROUTINE FMEQ_ZM1ZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMEQ(MB%MZM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1ZM

!             (2) rank 1  =  rank 1

   SUBROUTINE FMEQ_ZM1I1(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1I1

   SUBROUTINE FMEQ_ZM1R1(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1R1

   SUBROUTINE FMEQ_ZM1D1(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1D1

   SUBROUTINE FMEQ_ZM1Z1(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1Z1

   SUBROUTINE FMEQ_ZM1C1(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         D = AIMAG(C(J))
         CALL FMDP2M(D,MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MA(J)%MZM,QX)
      ENDDO
   END SUBROUTINE FMEQ_ZM1C1

   SUBROUTINE FMEQ_I1ZM1(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             IVAL(J) = QX%IUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMM2I(MA(J)%MZM,IVAL(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_I1ZM1

   SUBROUTINE FMEQ_R1ZM1(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      INTEGER :: J,N
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             R(J) = QX%RUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL ZMREAL(MA(J)%MZM,MTLVFM,QX)
         CALL FMM2SP(MTLVFM,R(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_R1ZM1

   SUBROUTINE FMEQ_D1ZM1(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTEGER :: J,N
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             D(J) = QX%RUNKNO
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL ZMREAL(MA(J)%MZM,MTLVFM,QX)
         CALL FMM2DP(MTLVFM,D(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_D1ZM1

   SUBROUTINE FMEQ_Z1ZM1(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      INTEGER :: J,N
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             Z(J) = CMPLX(QX%RUNKNO,QX%RUNKNO)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMM2Z(MA(J)%MZM,Z(J),QX)
      ENDDO
   END SUBROUTINE FMEQ_Z1ZM1

   SUBROUTINE FMEQ_C1ZM1(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      REAL (KIND(0.0D0)) :: D,D1,D2
      INTEGER :: J,N
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             D = QX%RUNKNO
             C(J) = CMPLX(D,D , KIND(0.0D0))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL ZMREAL(MA(J)%MZM,MTLVFM,QX)
         CALL FMM2DP(MTLVFM,D1,QX)
         CALL ZMIMAG(MA(J)%MZM,MTLVFM,QX)
         CALL FMM2DP(MTLVFM,D2,QX)
         C(J) = CMPLX(D1,D2 , KIND(0.0D0))
      ENDDO
   END SUBROUTINE FMEQ_C1ZM1

   SUBROUTINE FMEQ_ZM1ZM1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), ALLOCATABLE, DIMENSION(:) :: TEMP
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTLVZM,MA(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move MB
!             to a temporary array before re-defining any of MA.

      ALLOCATE(TEMP(N))
      DO J = 1, N
         CALL ZMEQ(MB(J)%MZM,TEMP(J)%MZM,QX)
      ENDDO
      DO J = 1, N
         CALL ZMEQ(TEMP(J)%MZM,MA(J)%MZM,QX)
      ENDDO
      DEALLOCATE(TEMP)
   END SUBROUTINE FMEQ_ZM1ZM1

!             (3) rank 2  =  rank 0

   SUBROUTINE FMEQ_ZM2I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: IVAL,J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2I

   SUBROUTINE FMEQ_ZM2R(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2R

   SUBROUTINE FMEQ_ZM2D(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2D

   SUBROUTINE FMEQ_ZM2Z(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2Z

   SUBROUTINE FMEQ_ZM2C(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      D = AIMAG(C)
      CALL FMDP2M(D,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2C

   SUBROUTINE FMEQ_I2ZM(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K,L
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMM2I(MA%MZM,L,QX)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            IVAL(J,K) = L
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_I2ZM

   SUBROUTINE FMEQ_R2ZM(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      REAL :: R2
      INTEGER :: J,K
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2SP(MTLVFM,R2,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            R(J,K) = R2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_R2ZM

   SUBROUTINE FMEQ_D2ZM(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      DOUBLE PRECISION :: D2
      INTEGER :: J,K
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            D(J,K) = D2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_D2ZM

   SUBROUTINE FMEQ_Z2ZM(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      COMPLEX :: Z2
      INTEGER :: J,K
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMM2Z(MA%MZM,Z2,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            Z(J,K) = Z2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_Z2ZM

   SUBROUTINE FMEQ_C2ZM(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      DOUBLE PRECISION :: D2,D3
      INTEGER :: J,K
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D2,QX)
      CALL ZMIMAG(MA%MZM,MTLVFM,QX)
      CALL FMM2DP(MTLVFM,D3,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            C(J,K) = CMPLX(D2,D3, KIND(0.0D0))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_C2ZM

   SUBROUTINE FMEQ_ZM2ZM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQ(MB%MZM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2ZM

!             (4) rank 2  =  rank 2

   SUBROUTINE FMEQ_ZM2I2(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMI2M(IVAL(J,K),MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2I2

   SUBROUTINE FMEQ_ZM2R2(MA,R)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2R2

   SUBROUTINE FMEQ_ZM2D2(MA,D)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2D2

   SUBROUTINE FMEQ_ZM2Z2(MA,Z)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2Z2

   SUBROUTINE FMEQ_ZM2C2(MA,C)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            D = AIMAG(C(J,K))
            CALL FMDP2M(D,MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_ZM2C2

   SUBROUTINE FMEQ_I2ZM2(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                IVAL(J,K) = QX%IUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMM2I(MA(J,K)%MZM,IVAL(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_I2ZM2

   SUBROUTINE FMEQ_R2ZM2(R,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      INTEGER :: J,K
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                R(J,K) = QX%RUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL(MA(J,K)%MZM,MTLVFM,QX)
            CALL FMM2SP(MTLVFM,R(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_R2ZM2

   SUBROUTINE FMEQ_D2ZM2(D,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTEGER :: J,K
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                D(J,K) = QX%RUNKNO
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL(MA(J,K)%MZM,MTLVFM,QX)
            CALL FMM2DP(MTLVFM,D(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_D2ZM2

   SUBROUTINE FMEQ_Z2ZM2(Z,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      INTEGER :: J,K
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                Z(J,K) = CMPLX(QX%RUNKNO,QX%RUNKNO)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMM2Z(MA(J,K)%MZM,Z(J,K),QX)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_Z2ZM2

   SUBROUTINE FMEQ_C2ZM2(C,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      REAL (KIND(0.0D0)) :: D,D1,D2
      INTEGER :: J,K
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                D = QX%RUNKNO
                C(J,K) = CMPLX(D,D , KIND(0.0D0))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL(MA(J,K)%MZM,MTLVFM,QX)
            CALL FMM2DP(MTLVFM,D1,QX)
            CALL ZMIMAG(MA(J,K)%MZM,MTLVFM,QX)
            CALL FMM2DP(MTLVFM,D2,QX)
            C(J,K) = CMPLX(D1,D2 , KIND(0.0D0))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_C2ZM2

   SUBROUTINE FMEQ_ZM2ZM2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), ALLOCATABLE, DIMENSION(:,:) :: TEMP
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTLVZM,MA(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move MB
!             to a temporary array before re-defining any of MA.

      ALLOCATE(TEMP(SIZE(MA,DIM=1),SIZE(MA,DIM=2)))
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MB(J,K)%MZM,TEMP(J,K)%MZM,QX)
         ENDDO
      ENDDO
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(TEMP(J,K)%MZM,MA(J,K)%MZM,QX)
         ENDDO
      ENDDO
      DEALLOCATE(TEMP)
   END SUBROUTINE FMEQ_ZM2ZM2

!                                                                  ==

   FUNCTION FMLEQ_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'EQ',MA%MFM,QX)
   END FUNCTION FMLEQ_IFM

   FUNCTION FMLEQ_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MTLVIM,'EQ',MA%MIM,QX)
   END FUNCTION FMLEQ_IIM

   FUNCTION FMLEQ_IZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_IZM

   FUNCTION FMLEQ_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'EQ',MA%MFM,QX)
   END FUNCTION FMLEQ_RFM

   FUNCTION FMLEQ_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLEQ_RIM

   FUNCTION FMLEQ_RZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_RZM

   FUNCTION FMLEQ_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'EQ',MA%MFM,QX)
   END FUNCTION FMLEQ_DFM

   FUNCTION FMLEQ_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLEQ_DIM

   FUNCTION FMLEQ_DZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_DZM

   FUNCTION FMLEQ_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MA%MFM,QX)
      L2 = .TRUE.
      IF (AIMAG(Z) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZFM

   FUNCTION FMLEQ_ZIM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      QX%NDIG = NDSAVE
      L2 = .TRUE.
      IF (AIMAG(Z) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZIM

   FUNCTION FMLEQ_ZZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMREAL(MTLVZM,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL ZMIMAG(MTLVZM,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZZM

   FUNCTION FMLEQ_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MA%MFM,QX)
      L2 = .TRUE.
      IF (AIMAG(C) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_CFM

   FUNCTION FMLEQ_CIM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      QX%NDIG = NDSAVE
      L2 = .TRUE.
      IF (AIMAG(C) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_CIM

   FUNCTION FMLEQ_CZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL FMDP2M(AIMAG(C),MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_CZM

   FUNCTION FMLEQ_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'EQ',MTLVFM,QX)
   END FUNCTION FMLEQ_FMI

   FUNCTION FMLEQ_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'EQ',MTLVFM,QX)
   END FUNCTION FMLEQ_FMR

   FUNCTION FMLEQ_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'EQ',MTLVFM,QX)
   END FUNCTION FMLEQ_FMD

   FUNCTION FMLEQ_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      L1 = FMCOMP(MA%MFM,'EQ',MTLVFM,QX)
      L2 = .TRUE.
      IF (AIMAG(Z) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_FMZ

   FUNCTION FMLEQ_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      L1 = FMCOMP(MA%MFM,'EQ',MTLVFM,QX)
      L2 = .TRUE.
      IF (AIMAG(C) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_FMC

   FUNCTION FMLEQ_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = FMCOMP(MA%MFM,'EQ',MB%MFM,QX)
   END FUNCTION FMLEQ_FMFM

   FUNCTION FMLEQ_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,MTLVFM,QX)
      IF (FMCOMP(MA%MFM,'EQ',MTLVFM,QX)) THEN
          CALL IMI2FM(MB%MIM,MTLVFM,QX)
          RETURN_VALUE = FMCOMP(MA%MFM,'EQ',MTLVFM,QX)
      ELSE
          RETURN_VALUE = .FALSE.
      ENDIF
   END FUNCTION FMLEQ_FMIM

   FUNCTION FMLEQ_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      TYPE (ZM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      L1 = FMCOMP(MA%MFM,'EQ',MTLVFM,QX)
      L2 = .TRUE.
      IF (MB%MZM(2)%MP(3) /= 0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_FMZM

   FUNCTION FMLEQ_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MA%MIM,'EQ',MTLVIM,QX)
   END FUNCTION FMLEQ_IMI

   FUNCTION FMLEQ_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'EQ',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLEQ_IMR

   FUNCTION FMLEQ_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'EQ',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLEQ_IMD

   FUNCTION FMLEQ_IMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      L1 = FMCOMP(MULVFM,'EQ',MTLVFM,QX)
      QX%NDIG = NDSAVE
      L2 = .TRUE.
      IF (AIMAG(Z) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_IMZ

   FUNCTION FMLEQ_IMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      L1 = FMCOMP(MULVFM,'EQ',MTLVFM,QX)
      QX%NDIG = NDSAVE
      L2 = .TRUE.
      IF (AIMAG(C) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_IMC

   FUNCTION FMLEQ_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MB%MFM,MTLVFM,QX)
      IF (FMCOMP(MB%MFM,'EQ',MTLVFM,QX)) THEN
          CALL IMI2FM(MA%MIM,MTLVFM,QX)
          RETURN_VALUE = FMCOMP(MB%MFM,'EQ',MTLVFM,QX)
      ELSE
          RETURN_VALUE = .FALSE.
      ENDIF
   END FUNCTION FMLEQ_IMFM

   FUNCTION FMLEQ_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = IMCOMP(MA%MIM,'EQ',MB%MIM,QX)
   END FUNCTION FMLEQ_IMIM

   FUNCTION FMLEQ_IMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      TYPE (ZM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      CALL FMINT(MTLVFM,MULVFM,QX)
      IF (FMCOMP(MULVFM,'EQ',MTLVFM,QX).AND.MB%MZM(2)%MP(3) == 0) THEN
          CALL IMI2FM(MA%MIM,MULVFM,QX)
          RETURN_VALUE = FMCOMP(MULVFM,'EQ',MTLVFM,QX)
      ELSE
          RETURN_VALUE = .FALSE.
      ENDIF
   END FUNCTION FMLEQ_IMZM

   FUNCTION FMLEQ_ZMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMINT(MTLVFM,MULVFM,QX)
      IF (FMCOMP(MULVFM,'EQ',MTLVFM,QX).AND.MA%MZM(2)%MP(3) == 0) THEN
          CALL FMI2M(IVAL,MULVFM,QX)
          RETURN_VALUE = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      ELSE
          RETURN_VALUE = .FALSE.
      ENDIF
   END FUNCTION FMLEQ_ZMI

   FUNCTION FMLEQ_ZMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZMR

   FUNCTION FMLEQ_ZMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZMD

   FUNCTION FMLEQ_ZMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMREAL(MTLVZM,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL ZMIMAG(MTLVZM,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZMZ

   FUNCTION FMLEQ_ZMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL FMDP2M(AIMAG(C),MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZMC

   FUNCTION FMLEQ_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MB
      TYPE (ZM) :: MA
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      L1 = FMCOMP(MB%MFM,'EQ',MTLVFM,QX)
      L2 = .TRUE.
      IF (MA%MZM(2)%MP(3) /= 0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZMFM

   FUNCTION FMLEQ_ZMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MB
      TYPE (ZM) :: MA
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMINT(MTLVFM,MULVFM,QX)
      IF (FMCOMP(MULVFM,'EQ',MTLVFM,QX).AND.MA%MZM(2)%MP(3) == 0) THEN
          CALL IMI2FM(MB%MIM,MULVFM,QX)
          RETURN_VALUE = FMCOMP(MULVFM,'EQ',MTLVFM,QX)
      ELSE
          RETURN_VALUE = .FALSE.
      ENDIF
   END FUNCTION FMLEQ_ZMIM

   FUNCTION FMLEQ_ZMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL ZMREAL(MB%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      CALL ZMIMAG(MA%MZM,MTLVFM,QX)
      CALL ZMIMAG(MB%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'EQ',MULVFM,QX)
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_ZMZM

 END MODULE FMZM_2_PARALLEL

 MODULE FMZM_3_PARALLEL
    USE FMZM_1_PARALLEL

    INTERFACE OPERATOR (/=)
       MODULE PROCEDURE FMLNE_IFM
       MODULE PROCEDURE FMLNE_IIM
       MODULE PROCEDURE FMLNE_IZM
       MODULE PROCEDURE FMLNE_RFM
       MODULE PROCEDURE FMLNE_RIM
       MODULE PROCEDURE FMLNE_RZM
       MODULE PROCEDURE FMLNE_DFM
       MODULE PROCEDURE FMLNE_DIM
       MODULE PROCEDURE FMLNE_DZM
       MODULE PROCEDURE FMLNE_ZFM
       MODULE PROCEDURE FMLNE_ZIM
       MODULE PROCEDURE FMLNE_ZZM
       MODULE PROCEDURE FMLNE_CFM
       MODULE PROCEDURE FMLNE_CIM
       MODULE PROCEDURE FMLNE_CZM
       MODULE PROCEDURE FMLNE_FMI
       MODULE PROCEDURE FMLNE_FMR
       MODULE PROCEDURE FMLNE_FMD
       MODULE PROCEDURE FMLNE_FMZ
       MODULE PROCEDURE FMLNE_FMC
       MODULE PROCEDURE FMLNE_FMFM
       MODULE PROCEDURE FMLNE_FMIM
       MODULE PROCEDURE FMLNE_FMZM
       MODULE PROCEDURE FMLNE_IMI
       MODULE PROCEDURE FMLNE_IMR
       MODULE PROCEDURE FMLNE_IMD
       MODULE PROCEDURE FMLNE_IMZ
       MODULE PROCEDURE FMLNE_IMC
       MODULE PROCEDURE FMLNE_IMFM
       MODULE PROCEDURE FMLNE_IMIM
       MODULE PROCEDURE FMLNE_IMZM
       MODULE PROCEDURE FMLNE_ZMI
       MODULE PROCEDURE FMLNE_ZMR
       MODULE PROCEDURE FMLNE_ZMD
       MODULE PROCEDURE FMLNE_ZMZ
       MODULE PROCEDURE FMLNE_ZMC
       MODULE PROCEDURE FMLNE_ZMFM
       MODULE PROCEDURE FMLNE_ZMIM
       MODULE PROCEDURE FMLNE_ZMZM
    END INTERFACE

    INTERFACE OPERATOR (>)
       MODULE PROCEDURE FMLGT_IFM
       MODULE PROCEDURE FMLGT_IIM
       MODULE PROCEDURE FMLGT_RFM
       MODULE PROCEDURE FMLGT_RIM
       MODULE PROCEDURE FMLGT_DFM
       MODULE PROCEDURE FMLGT_DIM
       MODULE PROCEDURE FMLGT_FMI
       MODULE PROCEDURE FMLGT_FMR
       MODULE PROCEDURE FMLGT_FMD
       MODULE PROCEDURE FMLGT_FMFM
       MODULE PROCEDURE FMLGT_FMIM
       MODULE PROCEDURE FMLGT_IMI
       MODULE PROCEDURE FMLGT_IMR
       MODULE PROCEDURE FMLGT_IMD
       MODULE PROCEDURE FMLGT_IMFM
       MODULE PROCEDURE FMLGT_IMIM
    END INTERFACE

    INTERFACE OPERATOR (>=)
       MODULE PROCEDURE FMLGE_IFM
       MODULE PROCEDURE FMLGE_IIM
       MODULE PROCEDURE FMLGE_RFM
       MODULE PROCEDURE FMLGE_RIM
       MODULE PROCEDURE FMLGE_DFM
       MODULE PROCEDURE FMLGE_DIM
       MODULE PROCEDURE FMLGE_FMI
       MODULE PROCEDURE FMLGE_FMR
       MODULE PROCEDURE FMLGE_FMD
       MODULE PROCEDURE FMLGE_FMFM
       MODULE PROCEDURE FMLGE_FMIM
       MODULE PROCEDURE FMLGE_IMI
       MODULE PROCEDURE FMLGE_IMR
       MODULE PROCEDURE FMLGE_IMD
       MODULE PROCEDURE FMLGE_IMFM
       MODULE PROCEDURE FMLGE_IMIM
    END INTERFACE

    INTERFACE OPERATOR (<)
       MODULE PROCEDURE FMLLT_IFM
       MODULE PROCEDURE FMLLT_IIM
       MODULE PROCEDURE FMLLT_RFM
       MODULE PROCEDURE FMLLT_RIM
       MODULE PROCEDURE FMLLT_DFM
       MODULE PROCEDURE FMLLT_DIM
       MODULE PROCEDURE FMLLT_FMI
       MODULE PROCEDURE FMLLT_FMR
       MODULE PROCEDURE FMLLT_FMD
       MODULE PROCEDURE FMLLT_FMFM
       MODULE PROCEDURE FMLLT_FMIM
       MODULE PROCEDURE FMLLT_IMI
       MODULE PROCEDURE FMLLT_IMR
       MODULE PROCEDURE FMLLT_IMD
       MODULE PROCEDURE FMLLT_IMFM
       MODULE PROCEDURE FMLLT_IMIM
    END INTERFACE

    INTERFACE OPERATOR (<=)
       MODULE PROCEDURE FMLLE_IFM
       MODULE PROCEDURE FMLLE_IIM
       MODULE PROCEDURE FMLLE_RFM
       MODULE PROCEDURE FMLLE_RIM
       MODULE PROCEDURE FMLLE_DFM
       MODULE PROCEDURE FMLLE_DIM
       MODULE PROCEDURE FMLLE_FMI
       MODULE PROCEDURE FMLLE_FMR
       MODULE PROCEDURE FMLLE_FMD
       MODULE PROCEDURE FMLLE_FMFM
       MODULE PROCEDURE FMLLE_FMIM
       MODULE PROCEDURE FMLLE_IMI
       MODULE PROCEDURE FMLLE_IMR
       MODULE PROCEDURE FMLLE_IMD
       MODULE PROCEDURE FMLLE_IMFM
       MODULE PROCEDURE FMLLE_IMIM
    END INTERFACE

 CONTAINS

!                                                                  /=

   FUNCTION FMLNE_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'NE',MA%MFM,QX)
   END FUNCTION FMLNE_IFM

   FUNCTION FMLNE_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MTLVIM,'NE',MA%MIM,QX)
   END FUNCTION FMLNE_IIM

   FUNCTION FMLNE_IZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_IZM

   FUNCTION FMLNE_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'NE',MA%MFM,QX)
   END FUNCTION FMLNE_RFM

   FUNCTION FMLNE_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      REAL :: R
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLNE_RIM

   FUNCTION FMLNE_RZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_RZM

   FUNCTION FMLNE_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'NE',MA%MFM,QX)
   END FUNCTION FMLNE_DFM

   FUNCTION FMLNE_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLNE_DIM

   FUNCTION FMLNE_DZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_DZM

   FUNCTION FMLNE_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MA%MFM,QX)
      L2 = .FALSE.
      IF (AIMAG(Z) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZFM

   FUNCTION FMLNE_ZIM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      QX%NDIG = NDSAVE
      L2 = .FALSE.
      IF (AIMAG(Z) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZIM

   FUNCTION FMLNE_ZZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMREAL(MTLVZM,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL ZMIMAG(MTLVZM,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZZM

   FUNCTION FMLNE_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MA%MFM,QX)
      L2 = .FALSE.
      IF (AIMAG(C) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_CFM

   FUNCTION FMLNE_CIM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      QX%NDIG = NDSAVE
      L2 = .FALSE.
      IF (AIMAG(C) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_CIM

   FUNCTION FMLNE_CZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL FMDP2M(AIMAG(C),MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_CZM

   FUNCTION FMLNE_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'NE',MTLVFM,QX)
   END FUNCTION FMLNE_FMI

   FUNCTION FMLNE_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'NE',MTLVFM,QX)
   END FUNCTION FMLNE_FMR

   FUNCTION FMLNE_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'NE',MTLVFM,QX)
   END FUNCTION FMLNE_FMD

   FUNCTION FMLNE_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      L1 = FMCOMP(MA%MFM,'NE',MTLVFM,QX)
      L2 = .FALSE.
      IF (AIMAG(Z) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_FMZ

   FUNCTION FMLNE_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      L1 = FMCOMP(MA%MFM,'NE',MTLVFM,QX)
      L2 = .FALSE.
      IF (AIMAG(C) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_FMC

   FUNCTION FMLNE_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = FMCOMP(MA%MFM,'NE',MB%MFM,QX)
   END FUNCTION FMLNE_FMFM

   FUNCTION FMLNE_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,MTLVFM,QX)
      IF (FMCOMP(MA%MFM,'EQ',MTLVFM,QX)) THEN
          CALL IMI2FM(MB%MIM,MTLVFM,QX)
          RETURN_VALUE = FMCOMP(MA%MFM,'NE',MTLVFM,QX)
      ELSE
          RETURN_VALUE = .TRUE.
      ENDIF
   END FUNCTION FMLNE_FMIM

   FUNCTION FMLNE_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      TYPE (ZM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      L1 = FMCOMP(MA%MFM,'NE',MTLVFM,QX)
      L2 = .FALSE.
      IF (MB%MZM(2)%MP(3) /= 0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_FMZM

   FUNCTION FMLNE_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MA%MIM,'NE',MTLVIM,QX)
   END FUNCTION FMLNE_IMI

   FUNCTION FMLNE_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'NE',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLNE_IMR

   FUNCTION FMLNE_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'NE',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLNE_IMD

   FUNCTION FMLNE_IMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(REAL(Z),MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      L1 = FMCOMP(MULVFM,'NE',MTLVFM,QX)
      QX%NDIG = NDSAVE
      L2 = .FALSE.
      IF (AIMAG(Z) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_IMZ

   FUNCTION FMLNE_IMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      L1 = FMCOMP(MULVFM,'NE',MTLVFM,QX)
      QX%NDIG = NDSAVE
      L2 = .FALSE.
      IF (AIMAG(C) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_IMC

   FUNCTION FMLNE_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MB%MFM,MTLVFM,QX)
      IF (FMCOMP(MB%MFM,'EQ',MTLVFM,QX)) THEN
          CALL IMI2FM(MA%MIM,MTLVFM,QX)
          RETURN_VALUE = FMCOMP(MB%MFM,'NE',MTLVFM,QX)
      ELSE
          RETURN_VALUE = .TRUE.
      ENDIF
   END FUNCTION FMLNE_IMFM

   FUNCTION FMLNE_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = IMCOMP(MA%MIM,'NE',MB%MIM,QX)
   END FUNCTION FMLNE_IMIM

   FUNCTION FMLNE_IMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      TYPE (ZM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MB%MZM,MTLVFM,QX)
      CALL FMINT(MTLVFM,MULVFM,QX)
      IF (FMCOMP(MULVFM,'EQ',MTLVFM,QX).AND.MB%MZM(2)%MP(3) == 0) THEN
          CALL IMI2FM(MA%MIM,MULVFM,QX)
          RETURN_VALUE = FMCOMP(MULVFM,'NE',MTLVFM,QX)
      ELSE
          RETURN_VALUE = .TRUE.
      ENDIF
   END FUNCTION FMLNE_IMZM

   FUNCTION FMLNE_ZMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMINT(MTLVFM,MULVFM,QX)
      IF (FMCOMP(MULVFM,'EQ',MTLVFM,QX).AND.MA%MZM(2)%MP(3) == 0) THEN
          CALL FMI2M(IVAL,MULVFM,QX)
          RETURN_VALUE = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      ELSE
          RETURN_VALUE = .TRUE.
      ENDIF
   END FUNCTION FMLNE_ZMI

   FUNCTION FMLNE_ZMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZMR

   FUNCTION FMLNE_ZMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZMD

   FUNCTION FMLNE_ZMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMREAL(MTLVZM,MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL ZMIMAG(MTLVZM,MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZMZ

   FUNCTION FMLNE_ZMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL ZMREAL(MA%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL FMDP2M(AIMAG(C),MTLVFM,QX)
      CALL ZMIMAG(MA%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZMC

   FUNCTION FMLNE_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MB
      TYPE (ZM) :: MA
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      L1 = FMCOMP(MB%MFM,'NE',MTLVFM,QX)
      L2 = .FALSE.
      IF (MA%MZM(2)%MP(3) /= 0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZMFM

   FUNCTION FMLNE_ZMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MB
      TYPE (ZM) :: MA
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMINT(MTLVFM,MULVFM,QX)
      IF (FMCOMP(MULVFM,'EQ',MTLVFM,QX).AND.MA%MZM(2)%MP(3) == 0) THEN
          CALL IMI2FM(MB%MIM,MULVFM,QX)
          RETURN_VALUE = FMCOMP(MULVFM,'NE',MTLVFM,QX)
      ELSE
          RETURN_VALUE = .TRUE.
      ENDIF
   END FUNCTION FMLNE_ZMIM

   FUNCTION FMLNE_ZMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL ZMREAL(MB%MZM,MULVFM,QX)
      L1 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      CALL ZMIMAG(MA%MZM,MTLVFM,QX)
      CALL ZMIMAG(MB%MZM,MULVFM,QX)
      L2 = FMCOMP(MTLVFM,'NE',MULVFM,QX)
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_ZMZM

!                                                                   >

   FUNCTION FMLGT_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GT',MA%MFM,QX)
   END FUNCTION FMLGT_IFM

   FUNCTION FMLGT_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MTLVIM,'GT',MA%MIM,QX)
   END FUNCTION FMLGT_IIM

   FUNCTION FMLGT_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GT',MA%MFM,QX)
   END FUNCTION FMLGT_RFM

   FUNCTION FMLGT_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GT',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGT_RIM

   FUNCTION FMLGT_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GT',MA%MFM,QX)
   END FUNCTION FMLGT_DFM

   FUNCTION FMLGT_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GT',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGT_DIM

   FUNCTION FMLGT_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'GT',MTLVFM,QX)
   END FUNCTION FMLGT_FMI

   FUNCTION FMLGT_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'GT',MTLVFM,QX)
   END FUNCTION FMLGT_FMR

   FUNCTION FMLGT_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'GT',MTLVFM,QX)
   END FUNCTION FMLGT_FMD

   FUNCTION FMLGT_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = FMCOMP(MA%MFM,'GT',MB%MFM,QX)
   END FUNCTION FMLGT_FMFM

   FUNCTION FMLGT_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      TYPE (IM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MB%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'GT',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGT_FMIM

   FUNCTION FMLGT_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MA%MIM,'GT',MTLVIM,QX)
   END FUNCTION FMLGT_IMI

   FUNCTION FMLGT_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'GT',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGT_IMR

   FUNCTION FMLGT_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'GT',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGT_IMD

   FUNCTION FMLGT_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      TYPE (FM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GT',MB%MFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGT_IMFM

   FUNCTION FMLGT_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = IMCOMP(MA%MIM,'GT',MB%MIM,QX)
   END FUNCTION FMLGT_IMIM

!                                                                  >=

   FUNCTION FMLGE_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GE',MA%MFM,QX)
   END FUNCTION FMLGE_IFM

   FUNCTION FMLGE_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MTLVIM,'GE',MA%MIM,QX)
   END FUNCTION FMLGE_IIM

   FUNCTION FMLGE_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GE',MA%MFM,QX)
   END FUNCTION FMLGE_RFM

   FUNCTION FMLGE_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GE',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGE_RIM

   FUNCTION FMLGE_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GE',MA%MFM,QX)
   END FUNCTION FMLGE_DFM

   FUNCTION FMLGE_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GE',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGE_DIM

   FUNCTION FMLGE_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'GE',MTLVFM,QX)
   END FUNCTION FMLGE_FMI

   FUNCTION FMLGE_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'GE',MTLVFM,QX)
   END FUNCTION FMLGE_FMR

   FUNCTION FMLGE_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'GE',MTLVFM,QX)
   END FUNCTION FMLGE_FMD

   FUNCTION FMLGE_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = FMCOMP(MA%MFM,'GE',MB%MFM,QX)
   END FUNCTION FMLGE_FMFM

   FUNCTION FMLGE_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      TYPE (IM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MB%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'GE',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGE_FMIM

   FUNCTION FMLGE_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MA%MIM,'GE',MTLVIM,QX)
   END FUNCTION FMLGE_IMI

   FUNCTION FMLGE_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'GE',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGE_IMR

   FUNCTION FMLGE_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'GE',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGE_IMD

   FUNCTION FMLGE_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      TYPE (FM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'GE',MB%MFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLGE_IMFM

   FUNCTION FMLGE_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = IMCOMP(MA%MIM,'GE',MB%MIM,QX)
   END FUNCTION FMLGE_IMIM

!                                                                   <

   FUNCTION FMLLT_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LT',MA%MFM,QX)
   END FUNCTION FMLLT_IFM

   FUNCTION FMLLT_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MTLVIM,'LT',MA%MIM,QX)
   END FUNCTION FMLLT_IIM

   FUNCTION FMLLT_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LT',MA%MFM,QX)
   END FUNCTION FMLLT_RFM

   FUNCTION FMLLT_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LT',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLT_RIM

   FUNCTION FMLLT_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LT',MA%MFM,QX)
   END FUNCTION FMLLT_DFM

   FUNCTION FMLLT_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LT',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLT_DIM

   FUNCTION FMLLT_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'LT',MTLVFM,QX)
   END FUNCTION FMLLT_FMI

   FUNCTION FMLLT_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'LT',MTLVFM,QX)
   END FUNCTION FMLLT_FMR

   FUNCTION FMLLT_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'LT',MTLVFM,QX)
   END FUNCTION FMLLT_FMD

   FUNCTION FMLLT_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = FMCOMP(MA%MFM,'LT',MB%MFM,QX)
   END FUNCTION FMLLT_FMFM

   FUNCTION FMLLT_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      TYPE (IM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MB%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'LT',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLT_FMIM

   FUNCTION FMLLT_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MA%MIM,'LT',MTLVIM,QX)
   END FUNCTION FMLLT_IMI

   FUNCTION FMLLT_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'LT',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLT_IMR

   FUNCTION FMLLT_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'LT',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLT_IMD

   FUNCTION FMLLT_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      TYPE (FM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LT',MB%MFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLT_IMFM

   FUNCTION FMLLT_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = IMCOMP(MA%MIM,'LT',MB%MIM,QX)
   END FUNCTION FMLLT_IMIM

!                                                                  <=

   FUNCTION FMLLE_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LE',MA%MFM,QX)
   END FUNCTION FMLLE_IFM

   FUNCTION FMLLE_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MTLVIM,'LE',MA%MIM,QX)
   END FUNCTION FMLLE_IIM

   FUNCTION FMLLE_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LE',MA%MFM,QX)
   END FUNCTION FMLLE_RFM

   FUNCTION FMLLE_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LE',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLE_RIM

   FUNCTION FMLLE_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LE',MA%MFM,QX)
   END FUNCTION FMLLE_DFM

   FUNCTION FMLLE_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LE',MULVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLE_DIM

   FUNCTION FMLLE_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'LE',MTLVFM,QX)
   END FUNCTION FMLLE_FMI

   FUNCTION FMLLE_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'LE',MTLVFM,QX)
   END FUNCTION FMLLE_FMR

   FUNCTION FMLLE_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'LE',MTLVFM,QX)
   END FUNCTION FMLLE_FMD

   FUNCTION FMLLE_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = FMCOMP(MA%MFM,'LE',MB%MFM,QX)
   END FUNCTION FMLLE_FMFM

   FUNCTION FMLLE_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA
      TYPE (IM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MB%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MA%MFM,'LE',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLE_FMIM

   FUNCTION FMLLE_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      RETURN_VALUE = IMCOMP(MA%MIM,'LE',MTLVIM,QX)
   END FUNCTION FMLLE_IMI

   FUNCTION FMLLE_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      INTEGER :: KA,NDSAVE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'LE',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLE_IMR

   FUNCTION FMLLE_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      RETURN_VALUE = FMCOMP(MULVFM,'LE',MTLVFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLE_IMD

   FUNCTION FMLLE_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (IM) :: MA
      TYPE (FM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      KA = MA%MIM%MP(2)
      QX%NDIG = MAX(KA+QX%NGRD52,QX%NDIG)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      RETURN_VALUE = FMCOMP(MTLVFM,'LE',MB%MFM,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMLLE_IMFM

   FUNCTION FMLLE_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = IMCOMP(MA%MIM,'LE',MB%MIM,QX)
   END FUNCTION FMLLE_IMIM

 END MODULE FMZM_3_PARALLEL

 MODULE FMZM_4_PARALLEL
    USE FMZM_1_PARALLEL

    INTERFACE OPERATOR (+)
       MODULE PROCEDURE FMADD_IFM
       MODULE PROCEDURE FMADD_IIM
       MODULE PROCEDURE FMADD_IZM
       MODULE PROCEDURE FMADD_RFM
       MODULE PROCEDURE FMADD_RIM
       MODULE PROCEDURE FMADD_RZM
       MODULE PROCEDURE FMADD_DFM
       MODULE PROCEDURE FMADD_DIM
       MODULE PROCEDURE FMADD_DZM
       MODULE PROCEDURE FMADD_ZFM
       MODULE PROCEDURE FMADD_ZIM
       MODULE PROCEDURE FMADD_ZZM
       MODULE PROCEDURE FMADD_CFM
       MODULE PROCEDURE FMADD_CIM
       MODULE PROCEDURE FMADD_CZM
       MODULE PROCEDURE FMADD_FMI
       MODULE PROCEDURE FMADD_FMR
       MODULE PROCEDURE FMADD_FMD
       MODULE PROCEDURE FMADD_FMZ
       MODULE PROCEDURE FMADD_FMC
       MODULE PROCEDURE FMADD_FMFM
       MODULE PROCEDURE FMADD_FMIM
       MODULE PROCEDURE FMADD_FMZM
       MODULE PROCEDURE FMADD_IMI
       MODULE PROCEDURE FMADD_IMR
       MODULE PROCEDURE FMADD_IMD
       MODULE PROCEDURE FMADD_IMZ
       MODULE PROCEDURE FMADD_IMC
       MODULE PROCEDURE FMADD_IMFM
       MODULE PROCEDURE FMADD_IMIM
       MODULE PROCEDURE FMADD_IMZM
       MODULE PROCEDURE FMADD_ZMI
       MODULE PROCEDURE FMADD_ZMR
       MODULE PROCEDURE FMADD_ZMD
       MODULE PROCEDURE FMADD_ZMZ
       MODULE PROCEDURE FMADD_ZMC
       MODULE PROCEDURE FMADD_ZMFM
       MODULE PROCEDURE FMADD_ZMIM
       MODULE PROCEDURE FMADD_ZMZM
       MODULE PROCEDURE FMADD_FM
       MODULE PROCEDURE FMADD_IM
       MODULE PROCEDURE FMADD_ZM
       MODULE PROCEDURE FMADD_IFM1
       MODULE PROCEDURE FMADD_RFM1
       MODULE PROCEDURE FMADD_DFM1
       MODULE PROCEDURE FMADD_ZFM1
       MODULE PROCEDURE FMADD_CFM1
       MODULE PROCEDURE FMADD_FMI1
       MODULE PROCEDURE FMADD_FMR1
       MODULE PROCEDURE FMADD_FMD1
       MODULE PROCEDURE FMADD_FMZ1
       MODULE PROCEDURE FMADD_FMC1
       MODULE PROCEDURE FMADD_FMFM1
       MODULE PROCEDURE FMADD_IMFM1
       MODULE PROCEDURE FMADD_ZMFM1
       MODULE PROCEDURE FMADD_FMIM1
       MODULE PROCEDURE FMADD_FMZM1
       MODULE PROCEDURE FMADD_FM1I
       MODULE PROCEDURE FMADD_FM1R
       MODULE PROCEDURE FMADD_FM1D
       MODULE PROCEDURE FMADD_FM1Z
       MODULE PROCEDURE FMADD_FM1C
       MODULE PROCEDURE FMADD_I1FM
       MODULE PROCEDURE FMADD_R1FM
       MODULE PROCEDURE FMADD_D1FM
       MODULE PROCEDURE FMADD_Z1FM
       MODULE PROCEDURE FMADD_C1FM
       MODULE PROCEDURE FMADD_FM1FM
       MODULE PROCEDURE FMADD_FM1IM
       MODULE PROCEDURE FMADD_FM1ZM
       MODULE PROCEDURE FMADD_IM1FM
       MODULE PROCEDURE FMADD_ZM1FM
       MODULE PROCEDURE FMADD_I1FM1
       MODULE PROCEDURE FMADD_R1FM1
       MODULE PROCEDURE FMADD_D1FM1
       MODULE PROCEDURE FMADD_Z1FM1
       MODULE PROCEDURE FMADD_C1FM1
       MODULE PROCEDURE FMADD_FM1I1
       MODULE PROCEDURE FMADD_FM1R1
       MODULE PROCEDURE FMADD_FM1D1
       MODULE PROCEDURE FMADD_FM1Z1
       MODULE PROCEDURE FMADD_FM1C1
       MODULE PROCEDURE FMADD_FM1FM1
       MODULE PROCEDURE FMADD_IM1FM1
       MODULE PROCEDURE FMADD_ZM1FM1
       MODULE PROCEDURE FMADD_FM1IM1
       MODULE PROCEDURE FMADD_FM1ZM1
       MODULE PROCEDURE FMADD_IIM1
       MODULE PROCEDURE FMADD_RIM1
       MODULE PROCEDURE FMADD_DIM1
       MODULE PROCEDURE FMADD_ZIM1
       MODULE PROCEDURE FMADD_CIM1
       MODULE PROCEDURE FMADD_IMI1
       MODULE PROCEDURE FMADD_IMR1
       MODULE PROCEDURE FMADD_IMD1
       MODULE PROCEDURE FMADD_IMZ1
       MODULE PROCEDURE FMADD_IMC1
       MODULE PROCEDURE FMADD_IMIM1
       MODULE PROCEDURE FMADD_ZMIM1
       MODULE PROCEDURE FMADD_IMZM1
       MODULE PROCEDURE FMADD_IM1I
       MODULE PROCEDURE FMADD_IM1R
       MODULE PROCEDURE FMADD_IM1D
       MODULE PROCEDURE FMADD_IM1Z
       MODULE PROCEDURE FMADD_IM1C
       MODULE PROCEDURE FMADD_I1IM
       MODULE PROCEDURE FMADD_R1IM
       MODULE PROCEDURE FMADD_D1IM
       MODULE PROCEDURE FMADD_Z1IM
       MODULE PROCEDURE FMADD_C1IM
       MODULE PROCEDURE FMADD_IM1IM
       MODULE PROCEDURE FMADD_IM1ZM
       MODULE PROCEDURE FMADD_ZM1IM
       MODULE PROCEDURE FMADD_I1IM1
       MODULE PROCEDURE FMADD_R1IM1
       MODULE PROCEDURE FMADD_D1IM1
       MODULE PROCEDURE FMADD_Z1IM1
       MODULE PROCEDURE FMADD_C1IM1
       MODULE PROCEDURE FMADD_IM1I1
       MODULE PROCEDURE FMADD_IM1R1
       MODULE PROCEDURE FMADD_IM1D1
       MODULE PROCEDURE FMADD_IM1Z1
       MODULE PROCEDURE FMADD_IM1C1
       MODULE PROCEDURE FMADD_IM1IM1
       MODULE PROCEDURE FMADD_ZM1IM1
       MODULE PROCEDURE FMADD_IM1ZM1
       MODULE PROCEDURE FMADD_IZM1
       MODULE PROCEDURE FMADD_RZM1
       MODULE PROCEDURE FMADD_DZM1
       MODULE PROCEDURE FMADD_ZZM1
       MODULE PROCEDURE FMADD_CZM1
       MODULE PROCEDURE FMADD_ZMI1
       MODULE PROCEDURE FMADD_ZMR1
       MODULE PROCEDURE FMADD_ZMD1
       MODULE PROCEDURE FMADD_ZMZ1
       MODULE PROCEDURE FMADD_ZMC1
       MODULE PROCEDURE FMADD_ZMZM1
       MODULE PROCEDURE FMADD_ZM1I
       MODULE PROCEDURE FMADD_ZM1R
       MODULE PROCEDURE FMADD_ZM1D
       MODULE PROCEDURE FMADD_ZM1Z
       MODULE PROCEDURE FMADD_ZM1C
       MODULE PROCEDURE FMADD_I1ZM
       MODULE PROCEDURE FMADD_R1ZM
       MODULE PROCEDURE FMADD_D1ZM
       MODULE PROCEDURE FMADD_Z1ZM
       MODULE PROCEDURE FMADD_C1ZM
       MODULE PROCEDURE FMADD_ZM1ZM
       MODULE PROCEDURE FMADD_I1ZM1
       MODULE PROCEDURE FMADD_R1ZM1
       MODULE PROCEDURE FMADD_D1ZM1
       MODULE PROCEDURE FMADD_Z1ZM1
       MODULE PROCEDURE FMADD_C1ZM1
       MODULE PROCEDURE FMADD_ZM1I1
       MODULE PROCEDURE FMADD_ZM1R1
       MODULE PROCEDURE FMADD_ZM1D1
       MODULE PROCEDURE FMADD_ZM1Z1
       MODULE PROCEDURE FMADD_ZM1C1
       MODULE PROCEDURE FMADD_ZM1ZM1
       MODULE PROCEDURE FMADD_IFM2
       MODULE PROCEDURE FMADD_RFM2
       MODULE PROCEDURE FMADD_DFM2
       MODULE PROCEDURE FMADD_ZFM2
       MODULE PROCEDURE FMADD_CFM2
       MODULE PROCEDURE FMADD_FMI2
       MODULE PROCEDURE FMADD_FMR2
       MODULE PROCEDURE FMADD_FMD2
       MODULE PROCEDURE FMADD_FMZ2
       MODULE PROCEDURE FMADD_FMC2
       MODULE PROCEDURE FMADD_FMFM2
       MODULE PROCEDURE FMADD_IMFM2
       MODULE PROCEDURE FMADD_ZMFM2
       MODULE PROCEDURE FMADD_FMIM2
       MODULE PROCEDURE FMADD_FMZM2
       MODULE PROCEDURE FMADD_FM2I
       MODULE PROCEDURE FMADD_FM2R
       MODULE PROCEDURE FMADD_FM2D
       MODULE PROCEDURE FMADD_FM2Z
       MODULE PROCEDURE FMADD_FM2C
       MODULE PROCEDURE FMADD_I2FM
       MODULE PROCEDURE FMADD_R2FM
       MODULE PROCEDURE FMADD_D2FM
       MODULE PROCEDURE FMADD_Z2FM
       MODULE PROCEDURE FMADD_C2FM
       MODULE PROCEDURE FMADD_FM2FM
       MODULE PROCEDURE FMADD_FM2IM
       MODULE PROCEDURE FMADD_FM2ZM
       MODULE PROCEDURE FMADD_IM2FM
       MODULE PROCEDURE FMADD_ZM2FM
       MODULE PROCEDURE FMADD_I2FM2
       MODULE PROCEDURE FMADD_R2FM2
       MODULE PROCEDURE FMADD_D2FM2
       MODULE PROCEDURE FMADD_Z2FM2
       MODULE PROCEDURE FMADD_C2FM2
       MODULE PROCEDURE FMADD_FM2I2
       MODULE PROCEDURE FMADD_FM2R2
       MODULE PROCEDURE FMADD_FM2D2
       MODULE PROCEDURE FMADD_FM2Z2
       MODULE PROCEDURE FMADD_FM2C2
       MODULE PROCEDURE FMADD_FM2FM2
       MODULE PROCEDURE FMADD_IM2FM2
       MODULE PROCEDURE FMADD_ZM2FM2
       MODULE PROCEDURE FMADD_FM2IM2
       MODULE PROCEDURE FMADD_FM2ZM2
       MODULE PROCEDURE FMADD_IIM2
       MODULE PROCEDURE FMADD_RIM2
       MODULE PROCEDURE FMADD_DIM2
       MODULE PROCEDURE FMADD_ZIM2
       MODULE PROCEDURE FMADD_CIM2
       MODULE PROCEDURE FMADD_IMI2
       MODULE PROCEDURE FMADD_IMR2
       MODULE PROCEDURE FMADD_IMD2
       MODULE PROCEDURE FMADD_IMZ2
       MODULE PROCEDURE FMADD_IMC2
       MODULE PROCEDURE FMADD_IMIM2
       MODULE PROCEDURE FMADD_ZMIM2
       MODULE PROCEDURE FMADD_IMZM2
       MODULE PROCEDURE FMADD_IM2I
       MODULE PROCEDURE FMADD_IM2R
       MODULE PROCEDURE FMADD_IM2D
       MODULE PROCEDURE FMADD_IM2Z
       MODULE PROCEDURE FMADD_IM2C
       MODULE PROCEDURE FMADD_I2IM
       MODULE PROCEDURE FMADD_R2IM
       MODULE PROCEDURE FMADD_D2IM
       MODULE PROCEDURE FMADD_Z2IM
       MODULE PROCEDURE FMADD_C2IM
       MODULE PROCEDURE FMADD_IM2IM
       MODULE PROCEDURE FMADD_IM2ZM
       MODULE PROCEDURE FMADD_ZM2IM
       MODULE PROCEDURE FMADD_I2IM2
       MODULE PROCEDURE FMADD_R2IM2
       MODULE PROCEDURE FMADD_D2IM2
       MODULE PROCEDURE FMADD_Z2IM2
       MODULE PROCEDURE FMADD_C2IM2
       MODULE PROCEDURE FMADD_IM2I2
       MODULE PROCEDURE FMADD_IM2R2
       MODULE PROCEDURE FMADD_IM2D2
       MODULE PROCEDURE FMADD_IM2Z2
       MODULE PROCEDURE FMADD_IM2C2
       MODULE PROCEDURE FMADD_IM2IM2
       MODULE PROCEDURE FMADD_ZM2IM2
       MODULE PROCEDURE FMADD_IM2ZM2
       MODULE PROCEDURE FMADD_IZM2
       MODULE PROCEDURE FMADD_RZM2
       MODULE PROCEDURE FMADD_DZM2
       MODULE PROCEDURE FMADD_ZZM2
       MODULE PROCEDURE FMADD_CZM2
       MODULE PROCEDURE FMADD_ZMI2
       MODULE PROCEDURE FMADD_ZMR2
       MODULE PROCEDURE FMADD_ZMD2
       MODULE PROCEDURE FMADD_ZMZ2
       MODULE PROCEDURE FMADD_ZMC2
       MODULE PROCEDURE FMADD_ZMZM2
       MODULE PROCEDURE FMADD_ZM2I
       MODULE PROCEDURE FMADD_ZM2R
       MODULE PROCEDURE FMADD_ZM2D
       MODULE PROCEDURE FMADD_ZM2Z
       MODULE PROCEDURE FMADD_ZM2C
       MODULE PROCEDURE FMADD_I2ZM
       MODULE PROCEDURE FMADD_R2ZM
       MODULE PROCEDURE FMADD_D2ZM
       MODULE PROCEDURE FMADD_Z2ZM
       MODULE PROCEDURE FMADD_C2ZM
       MODULE PROCEDURE FMADD_ZM2ZM
       MODULE PROCEDURE FMADD_I2ZM2
       MODULE PROCEDURE FMADD_R2ZM2
       MODULE PROCEDURE FMADD_D2ZM2
       MODULE PROCEDURE FMADD_Z2ZM2
       MODULE PROCEDURE FMADD_C2ZM2
       MODULE PROCEDURE FMADD_ZM2I2
       MODULE PROCEDURE FMADD_ZM2R2
       MODULE PROCEDURE FMADD_ZM2D2
       MODULE PROCEDURE FMADD_ZM2Z2
       MODULE PROCEDURE FMADD_ZM2C2
       MODULE PROCEDURE FMADD_ZM2ZM2
       MODULE PROCEDURE FMADD_FM1
       MODULE PROCEDURE FMADD_IM1
       MODULE PROCEDURE FMADD_ZM1
       MODULE PROCEDURE FMADD_FM2
       MODULE PROCEDURE FMADD_IM2
       MODULE PROCEDURE FMADD_ZM2
    END INTERFACE

 CONTAINS

!                                                                   +

   FUNCTION FMADD_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_IFM

   FUNCTION FMADD_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      CALL IMADD(MTLVIM,MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMADD_IIM

   FUNCTION FMADD_IZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_IZM

   FUNCTION FMADD_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_RFM

   FUNCTION FMADD_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMADD(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_RIM

   FUNCTION FMADD_RZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_RZM

   FUNCTION FMADD_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_DFM

   FUNCTION FMADD_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMADD(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_DIM

   FUNCTION FMADD_DZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_DZM

   FUNCTION FMADD_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZFM

   FUNCTION FMADD_ZIM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZIM

   FUNCTION FMADD_ZZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZZM

   FUNCTION FMADD_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_CFM

   FUNCTION FMADD_CIM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_CIM

   FUNCTION FMADD_CZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_CZM

   FUNCTION FMADD_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_FMI

   FUNCTION FMADD_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_FMR

   FUNCTION FMADD_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_FMD

   FUNCTION FMADD_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_FMZ

   FUNCTION FMADD_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_FMC

   FUNCTION FMADD_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMADD(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_FMFM

   FUNCTION FMADD_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_FMIM

   FUNCTION FMADD_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMADD(MTLVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_FMZM

   FUNCTION FMADD_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      CALL IMADD(MA%MIM,MTLVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMADD_IMI

   FUNCTION FMADD_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMADD(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_IMR

   FUNCTION FMADD_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMADD(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_IMD

   FUNCTION FMADD_IMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_IMZ

   FUNCTION FMADD_IMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_IMC

   FUNCTION FMADD_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMADD(MTLVFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_IMFM

   FUNCTION FMADD_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMADD(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMADD_IMIM

   FUNCTION FMADD_IMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MULVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_IMZM

   FUNCTION FMADD_ZMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZMI

   FUNCTION FMADD_ZMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZMR

   FUNCTION FMADD_ZMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZMD

   FUNCTION FMADD_ZMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZMZ

   FUNCTION FMADD_ZMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZMC

   FUNCTION FMADD_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZMFM

   FUNCTION FMADD_ZMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMADD(MA%MZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZMIM

   FUNCTION FMADD_ZMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMADD(MA%MZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZMZM

   FUNCTION FMADD_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMADD_FM

   FUNCTION FMADD_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMADD_IM

   FUNCTION FMADD_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQ(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMADD_ZM

!             Array addition operations for FM.

!             (1) rank 0  +  rank 1

   FUNCTION FMADD_IFM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMADD(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IFM1

   FUNCTION FMADD_RFM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMADD(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_RFM1

   FUNCTION FMADD_DFM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMADD(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_DFM1

   FUNCTION FMADD_ZFM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZFM1

   FUNCTION FMADD_CFM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_CFM1

   FUNCTION FMADD_FMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FMI1

   FUNCTION FMADD_FMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FMR1

   FUNCTION FMADD_FMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FMD1

   FUNCTION FMADD_FMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FMZ1

   FUNCTION FMADD_FMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FMC1

   FUNCTION FMADD_FMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL FMADD(MA%MFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FMFM1

   FUNCTION FMADD_IMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMADD(MTLVFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IMFM1

   FUNCTION FMADD_ZMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N	
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZMFM1

   FUNCTION FMADD_FMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MTLVFM,QX)
         CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FMIM1

   FUNCTION FMADD_FMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FMZM1

!             (2) rank 1  +  rank 0

   FUNCTION FMADD_FM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMADD(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1I

   FUNCTION FMADD_FM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMADD(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1R

   FUNCTION FMADD_FM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMADD(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1D

   FUNCTION FMADD_FM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FM1Z

   FUNCTION FMADD_FM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FM1C

   FUNCTION FMADD_I1FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_I1FM

   FUNCTION FMADD_R1FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_R1FM

   FUNCTION FMADD_D1FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_D1FM

   FUNCTION FMADD_Z1FM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_Z1FM

   FUNCTION FMADD_C1FM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_C1FM

   FUNCTION FMADD_FM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMADD(MA(J)%MFM,MB%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1FM

   FUNCTION FMADD_FM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMADD(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1IM

   FUNCTION FMADD_FM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FM1ZM

   FUNCTION FMADD_IM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMADD(MTLVFM,MB%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IM1FM

   FUNCTION FMADD_ZM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1FM

!             (3) rank 1  +  rank 1

   FUNCTION FMADD_FM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMADD(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1I1

   FUNCTION FMADD_FM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMADD(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1R1

   FUNCTION FMADD_FM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMADD(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1D1

   FUNCTION FMADD_FM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FM1Z1

   FUNCTION FMADD_FM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FM1C1

   FUNCTION FMADD_I1FM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_I1FM1

   FUNCTION FMADD_R1FM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_R1FM1

   FUNCTION FMADD_D1FM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_D1FM1

   FUNCTION FMADD_Z1FM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_Z1FM1

   FUNCTION FMADD_C1FM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_C1FM1

   FUNCTION FMADD_FM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMADD(MA(J)%MFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1FM1

   FUNCTION FMADD_FM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MTLVFM,QX)
         CALL FMADD(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1IM1

   FUNCTION FMADD_FM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_FM1ZM1

   FUNCTION FMADD_IM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMADD(MTLVFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IM1FM1

   FUNCTION FMADD_ZM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1FM1

!             (4) rank 0  +  rank 2

   FUNCTION FMADD_IFM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IFM2

   FUNCTION FMADD_RFM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_RFM2

   FUNCTION FMADD_DFM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_DFM2

   FUNCTION FMADD_ZFM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZFM2

   FUNCTION FMADD_CFM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_CFM2

   FUNCTION FMADD_FMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FMI2

   FUNCTION FMADD_FMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FMR2

   FUNCTION FMADD_FMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FMD2

   FUNCTION FMADD_FMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FMZ2

   FUNCTION FMADD_FMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FMC2

   FUNCTION FMADD_FMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMADD(MA%MFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FMFM2

   FUNCTION FMADD_IMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMADD(MTLVFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IMFM2

   FUNCTION FMADD_ZMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZMFM2

   FUNCTION FMADD_FMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MTLVFM,QX)
            CALL FMADD(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FMIM2

   FUNCTION FMADD_FMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMADD(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FMZM2

!             (5) rank 2  +  rank 0

   FUNCTION FMADD_FM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2I

   FUNCTION FMADD_FM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2R

   FUNCTION FMADD_FM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2D

   FUNCTION FMADD_FM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2Z

   FUNCTION FMADD_FM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2C

   FUNCTION FMADD_I2FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_I2FM

   FUNCTION FMADD_R2FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_R2FM

   FUNCTION FMADD_D2FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_D2FM

   FUNCTION FMADD_Z2FM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_Z2FM

   FUNCTION FMADD_C2FM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_C2FM

   FUNCTION FMADD_FM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MA(J,K)%MFM,MB%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2FM

   FUNCTION FMADD_FM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2IM

   FUNCTION FMADD_FM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2ZM

   FUNCTION FMADD_IM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMADD(MTLVFM,MB%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2FM

   FUNCTION FMADD_ZM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2FM

!             (6) rank 2  +  rank 2

   FUNCTION FMADD_FM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMADD(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2I2

   FUNCTION FMADD_FM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMADD(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2R2

   FUNCTION FMADD_FM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMADD(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2D2

   FUNCTION FMADD_FM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2Z2

   FUNCTION FMADD_FM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2C2

   FUNCTION FMADD_I2FM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_I2FM2

   FUNCTION FMADD_R2FM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_R2FM2

   FUNCTION FMADD_D2FM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_D2FM2

   FUNCTION FMADD_Z2FM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_Z2FM2

   FUNCTION FMADD_C2FM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_C2FM2

   FUNCTION FMADD_FM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD(MA(J,K)%MFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2FM2

   FUNCTION FMADD_FM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MTLVFM,QX)
            CALL FMADD(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2IM2

   FUNCTION FMADD_FM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2ZM2

   FUNCTION FMADD_IM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMADD(MTLVFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2FM2

   FUNCTION FMADD_ZM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2FM2

!             Array addition operations for IM.

!             (1) rank 0  +  rank 1

   FUNCTION FMADD_IIM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMADD(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_IIM1

   FUNCTION FMADD_RIM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MULVFM,QX)
         CALL FMADD(MTLVFM,MULVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_RIM1

   FUNCTION FMADD_DIM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MULVFM,QX)
         CALL FMADD(MTLVFM,MULVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_DIM1

   FUNCTION FMADD_ZIM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZIM1

   FUNCTION FMADD_CIM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_CIM1

   FUNCTION FMADD_IMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMADD(MA%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_IMI1

   FUNCTION FMADD_IMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMADD(MULVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IMR1

   FUNCTION FMADD_IMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMADD(MULVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IMD1

   FUNCTION FMADD_IMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IMZ1

   FUNCTION FMADD_IMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IMC1

   FUNCTION FMADD_IMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL IMADD(MA%MIM,MB(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_IMIM1

   FUNCTION FMADD_ZMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
         CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZMIM1

   FUNCTION FMADD_IMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IMZM1

!             (2) rank 1  +  rank 0

   FUNCTION FMADD_IM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMADD(MA(J)%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_IM1I

   FUNCTION FMADD_IM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL FMADD(MVLVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IM1R

   FUNCTION FMADD_IM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL FMADD(MVLVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IM1D

   FUNCTION FMADD_IM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IM1Z

   FUNCTION FMADD_IM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IM1C

   FUNCTION FMADD_I1IM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMADD(MTLVIM,MA%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_I1IM

   FUNCTION FMADD_R1IM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,MVLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_R1IM

   FUNCTION FMADD_D1IM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,MVLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_D1IM

   FUNCTION FMADD_Z1IM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_Z1IM

   FUNCTION FMADD_C1IM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,M1LVFM,QX)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_C1IM

   FUNCTION FMADD_IM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMADD(MA(J)%MIM,MB%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_IM1IM

   FUNCTION FMADD_IM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMADD(M1LVZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IM1ZM

   FUNCTION FMADD_ZM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,M1LVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,M1LVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1IM

!             (3) rank 1  +  rank 1

   FUNCTION FMADD_IM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMADD(MA(J)%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_IM1I1

   FUNCTION FMADD_IM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMADD(M1LVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IM1R1

   FUNCTION FMADD_IM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMADD(M1LVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_IM1D1

   FUNCTION FMADD_IM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IM1Z1

   FUNCTION FMADD_IM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IM1C1

   FUNCTION FMADD_I1IM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMADD(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_I1IM1

   FUNCTION FMADD_R1IM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,M1LVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_R1IM1

   FUNCTION FMADD_D1IM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMADD(MTLVFM,M1LVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_D1IM1

   FUNCTION FMADD_Z1IM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_Z1IM1

   FUNCTION FMADD_C1IM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_C1IM1

   FUNCTION FMADD_IM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMADD(MA(J)%MIM,MB(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_IM1IM1

   FUNCTION FMADD_IM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMADD(M1LVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IM1ZM1

   FUNCTION FMADD_ZM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMADD(MA(J)%MZM,M1LVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1IM1

!             (4) rank 0  +  rank 2

   FUNCTION FMADD_IIM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMADD(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IIM2

   FUNCTION FMADD_RIM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MULVFM,QX)
            CALL FMADD(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_RIM2

   FUNCTION FMADD_DIM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MULVFM,QX)
            CALL FMADD(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_DIM2

   FUNCTION FMADD_ZIM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZIM2

   FUNCTION FMADD_CIM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_CIM2

   FUNCTION FMADD_IMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMADD(MA%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IMI2

   FUNCTION FMADD_IMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMADD(MULVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IMR2

   FUNCTION FMADD_IMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMADD(MULVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IMD2

   FUNCTION FMADD_IMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IMZ2

   FUNCTION FMADD_IMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IMC2

   FUNCTION FMADD_IMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMADD(MA%MIM,MB(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IMIM2

   FUNCTION FMADD_ZMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
            CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZMIM2

   FUNCTION FMADD_IMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMADD(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IMZM2

!             (5) rank 2  +  rank 0

   FUNCTION FMADD_IM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMADD(MA(J,K)%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2I

   FUNCTION FMADD_IM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL FMADD(MVLVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2R

   FUNCTION FMADD_IM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL FMADD(MVLVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2D

   FUNCTION FMADD_IM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2Z

   FUNCTION FMADD_IM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2C

   FUNCTION FMADD_I2IM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMADD(MTLVIM,MA%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_I2IM

   FUNCTION FMADD_R2IM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,MVLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_R2IM

   FUNCTION FMADD_D2IM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,MVLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_D2IM

   FUNCTION FMADD_Z2IM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_Z2IM

   FUNCTION FMADD_C2IM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,M1LVFM,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_C2IM

   FUNCTION FMADD_IM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMADD(MA(J,K)%MIM,MB%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2IM

   FUNCTION FMADD_IM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMADD(M1LVZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2ZM

   FUNCTION FMADD_ZM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,M1LVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,M1LVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2IM

!             (6) rank 2  +  rank 2

   FUNCTION FMADD_IM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMADD(MA(J,K)%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2I2

   FUNCTION FMADD_IM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMADD(M1LVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2R2

   FUNCTION FMADD_IM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMADD(M1LVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2D2

   FUNCTION FMADD_IM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2Z2

   FUNCTION FMADD_IM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2C2

   FUNCTION FMADD_I2IM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMADD(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_I2IM2

   FUNCTION FMADD_R2IM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,M1LVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_R2IM2

   FUNCTION FMADD_D2IM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMADD(MTLVFM,M1LVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_D2IM2

   FUNCTION FMADD_Z2IM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_Z2IM2

   FUNCTION FMADD_C2IM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMADD(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_C2IM2

   FUNCTION FMADD_IM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMADD(MA(J,K)%MIM,MB(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2IM2

   FUNCTION FMADD_IM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMADD(M1LVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2ZM2

   FUNCTION FMADD_ZM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMADD(MA(J,K)%MZM,M1LVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2IM2

!             Array addition operations for ZM.

!             (1) rank 0  +  rank 1

   FUNCTION FMADD_IZM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_IZM1

   FUNCTION FMADD_RZM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_RZM1

   FUNCTION FMADD_DZM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_DZM1

   FUNCTION FMADD_ZZM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZZM1

   FUNCTION FMADD_CZM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_CZM1

   FUNCTION FMADD_ZMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZMI1

   FUNCTION FMADD_ZMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZMR1

   FUNCTION FMADD_ZMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZMD1

   FUNCTION FMADD_ZMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZMZ1

   FUNCTION FMADD_ZMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZMC1

   FUNCTION FMADD_ZMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL ZMADD(MA%MZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZMZM1

!             (2) rank 1  +  rank 0

   FUNCTION FMADD_ZM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1I

   FUNCTION FMADD_ZM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1R

   FUNCTION FMADD_ZM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1D

   FUNCTION FMADD_ZM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1Z

   FUNCTION FMADD_ZM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1C

   FUNCTION FMADD_I1ZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_I1ZM

   FUNCTION FMADD_R1ZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_R1ZM

   FUNCTION FMADD_D1ZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_D1ZM

   FUNCTION FMADD_Z1ZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_Z1ZM

   FUNCTION FMADD_C1ZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_C1ZM

   FUNCTION FMADD_ZM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1ZM

!             (3) rank 1  +  rank 1

   FUNCTION FMADD_ZM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1I1

   FUNCTION FMADD_ZM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1R1

   FUNCTION FMADD_ZM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1D1

   FUNCTION FMADD_ZM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1Z1

   FUNCTION FMADD_ZM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1C1

   FUNCTION FMADD_I1ZM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_I1ZM1

   FUNCTION FMADD_R1ZM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_R1ZM1

   FUNCTION FMADD_D1ZM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_D1ZM1

   FUNCTION FMADD_Z1ZM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_Z1ZM1

   FUNCTION FMADD_C1ZM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMADD(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_C1ZM1

   FUNCTION FMADD_ZM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMADD(MA(J)%MZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1ZM1

!             (4) rank 0  +  rank 2

   FUNCTION FMADD_IZM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IZM2

   FUNCTION FMADD_RZM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_RZM2

   FUNCTION FMADD_DZM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_DZM2

   FUNCTION FMADD_ZZM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZZM2

   FUNCTION FMADD_CZM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_CZM2

   FUNCTION FMADD_ZMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZMI2

   FUNCTION FMADD_ZMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZMR2

   FUNCTION FMADD_ZMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZMD2

   FUNCTION FMADD_ZMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZMZ2

   FUNCTION FMADD_ZMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZMC2

   FUNCTION FMADD_ZMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMADD(MA%MZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZMZM2

!             (5) rank 2  +  rank 0

   FUNCTION FMADD_ZM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2I

   FUNCTION FMADD_ZM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2R

   FUNCTION FMADD_ZM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2D

   FUNCTION FMADD_ZM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2Z

   FUNCTION FMADD_ZM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2C

   FUNCTION FMADD_I2ZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_I2ZM

   FUNCTION FMADD_R2ZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_R2ZM

   FUNCTION FMADD_D2ZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_D2ZM

   FUNCTION FMADD_Z2ZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_Z2ZM

   FUNCTION FMADD_C2ZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_C2ZM

   FUNCTION FMADD_ZM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2ZM

!             (6) rank 2  +  rank 2

   FUNCTION FMADD_ZM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2I2

   FUNCTION FMADD_ZM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2R2

   FUNCTION FMADD_ZM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2D2

   FUNCTION FMADD_ZM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2Z2

   FUNCTION FMADD_ZM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2C2

   FUNCTION FMADD_I2ZM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_I2ZM2

   FUNCTION FMADD_R2ZM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_R2ZM2

   FUNCTION FMADD_D2ZM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_D2ZM2

   FUNCTION FMADD_Z2ZM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_Z2ZM2

   FUNCTION FMADD_C2ZM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMADD(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_C2ZM2

   FUNCTION FMADD_ZM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMADD(MA(J,K)%MZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2ZM2

   FUNCTION FMADD_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEQ(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMADD_FM1

   FUNCTION FMADD_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMEQ(MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMADD_IM1

   FUNCTION FMADD_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMEQ(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMADD_ZM1

   FUNCTION FMADD_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_FM2

   FUNCTION FMADD_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_IM2

   FUNCTION FMADD_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMADD_ZM2

 END MODULE FMZM_4_PARALLEL

 MODULE FMZM_5_PARALLEL
    USE FMZM_1_PARALLEL

    INTERFACE OPERATOR (-)
       MODULE PROCEDURE FMSUB_IFM
       MODULE PROCEDURE FMSUB_IIM
       MODULE PROCEDURE FMSUB_IZM
       MODULE PROCEDURE FMSUB_RFM
       MODULE PROCEDURE FMSUB_RIM
       MODULE PROCEDURE FMSUB_RZM
       MODULE PROCEDURE FMSUB_DFM
       MODULE PROCEDURE FMSUB_DIM
       MODULE PROCEDURE FMSUB_DZM
       MODULE PROCEDURE FMSUB_ZFM
       MODULE PROCEDURE FMSUB_ZIM
       MODULE PROCEDURE FMSUB_ZZM
       MODULE PROCEDURE FMSUB_CFM
       MODULE PROCEDURE FMSUB_CIM
       MODULE PROCEDURE FMSUB_CZM
       MODULE PROCEDURE FMSUB_FMI
       MODULE PROCEDURE FMSUB_FMR
       MODULE PROCEDURE FMSUB_FMD
       MODULE PROCEDURE FMSUB_FMZ
       MODULE PROCEDURE FMSUB_FMC
       MODULE PROCEDURE FMSUB_FMFM
       MODULE PROCEDURE FMSUB_FMIM
       MODULE PROCEDURE FMSUB_FMZM
       MODULE PROCEDURE FMSUB_IMI
       MODULE PROCEDURE FMSUB_IMR
       MODULE PROCEDURE FMSUB_IMD
       MODULE PROCEDURE FMSUB_IMZ
       MODULE PROCEDURE FMSUB_IMC
       MODULE PROCEDURE FMSUB_IMFM
       MODULE PROCEDURE FMSUB_IMIM
       MODULE PROCEDURE FMSUB_IMZM
       MODULE PROCEDURE FMSUB_ZMI
       MODULE PROCEDURE FMSUB_ZMR
       MODULE PROCEDURE FMSUB_ZMD
       MODULE PROCEDURE FMSUB_ZMZ
       MODULE PROCEDURE FMSUB_ZMC
       MODULE PROCEDURE FMSUB_ZMFM
       MODULE PROCEDURE FMSUB_ZMIM
       MODULE PROCEDURE FMSUB_ZMZM
       MODULE PROCEDURE FMSUB_FM
       MODULE PROCEDURE FMSUB_IM
       MODULE PROCEDURE FMSUB_ZM
       MODULE PROCEDURE FMSUB_IFM1
       MODULE PROCEDURE FMSUB_RFM1
       MODULE PROCEDURE FMSUB_DFM1
       MODULE PROCEDURE FMSUB_ZFM1
       MODULE PROCEDURE FMSUB_CFM1
       MODULE PROCEDURE FMSUB_FMI1
       MODULE PROCEDURE FMSUB_FMR1
       MODULE PROCEDURE FMSUB_FMD1
       MODULE PROCEDURE FMSUB_FMZ1
       MODULE PROCEDURE FMSUB_FMC1
       MODULE PROCEDURE FMSUB_FMFM1
       MODULE PROCEDURE FMSUB_IMFM1
       MODULE PROCEDURE FMSUB_ZMFM1
       MODULE PROCEDURE FMSUB_FMIM1
       MODULE PROCEDURE FMSUB_FMZM1
       MODULE PROCEDURE FMSUB_FM1I
       MODULE PROCEDURE FMSUB_FM1R
       MODULE PROCEDURE FMSUB_FM1D
       MODULE PROCEDURE FMSUB_FM1Z
       MODULE PROCEDURE FMSUB_FM1C
       MODULE PROCEDURE FMSUB_I1FM
       MODULE PROCEDURE FMSUB_R1FM
       MODULE PROCEDURE FMSUB_D1FM
       MODULE PROCEDURE FMSUB_Z1FM
       MODULE PROCEDURE FMSUB_C1FM
       MODULE PROCEDURE FMSUB_FM1FM
       MODULE PROCEDURE FMSUB_FM1IM
       MODULE PROCEDURE FMSUB_FM1ZM
       MODULE PROCEDURE FMSUB_IM1FM
       MODULE PROCEDURE FMSUB_ZM1FM
       MODULE PROCEDURE FMSUB_I1FM1
       MODULE PROCEDURE FMSUB_R1FM1
       MODULE PROCEDURE FMSUB_D1FM1
       MODULE PROCEDURE FMSUB_Z1FM1
       MODULE PROCEDURE FMSUB_C1FM1
       MODULE PROCEDURE FMSUB_FM1I1
       MODULE PROCEDURE FMSUB_FM1R1
       MODULE PROCEDURE FMSUB_FM1D1
       MODULE PROCEDURE FMSUB_FM1Z1
       MODULE PROCEDURE FMSUB_FM1C1
       MODULE PROCEDURE FMSUB_FM1FM1
       MODULE PROCEDURE FMSUB_IM1FM1
       MODULE PROCEDURE FMSUB_ZM1FM1
       MODULE PROCEDURE FMSUB_FM1IM1
       MODULE PROCEDURE FMSUB_FM1ZM1
       MODULE PROCEDURE FMSUB_IIM1
       MODULE PROCEDURE FMSUB_RIM1
       MODULE PROCEDURE FMSUB_DIM1
       MODULE PROCEDURE FMSUB_ZIM1
       MODULE PROCEDURE FMSUB_CIM1
       MODULE PROCEDURE FMSUB_IMI1
       MODULE PROCEDURE FMSUB_IMR1
       MODULE PROCEDURE FMSUB_IMD1
       MODULE PROCEDURE FMSUB_IMZ1
       MODULE PROCEDURE FMSUB_IMC1
       MODULE PROCEDURE FMSUB_IMIM1
       MODULE PROCEDURE FMSUB_ZMIM1
       MODULE PROCEDURE FMSUB_IMZM1
       MODULE PROCEDURE FMSUB_IM1I
       MODULE PROCEDURE FMSUB_IM1R
       MODULE PROCEDURE FMSUB_IM1D
       MODULE PROCEDURE FMSUB_IM1Z
       MODULE PROCEDURE FMSUB_IM1C
       MODULE PROCEDURE FMSUB_I1IM
       MODULE PROCEDURE FMSUB_R1IM
       MODULE PROCEDURE FMSUB_D1IM
       MODULE PROCEDURE FMSUB_Z1IM
       MODULE PROCEDURE FMSUB_C1IM
       MODULE PROCEDURE FMSUB_IM1IM
       MODULE PROCEDURE FMSUB_IM1ZM
       MODULE PROCEDURE FMSUB_ZM1IM
       MODULE PROCEDURE FMSUB_I1IM1
       MODULE PROCEDURE FMSUB_R1IM1
       MODULE PROCEDURE FMSUB_D1IM1
       MODULE PROCEDURE FMSUB_Z1IM1
       MODULE PROCEDURE FMSUB_C1IM1
       MODULE PROCEDURE FMSUB_IM1I1
       MODULE PROCEDURE FMSUB_IM1R1
       MODULE PROCEDURE FMSUB_IM1D1
       MODULE PROCEDURE FMSUB_IM1Z1
       MODULE PROCEDURE FMSUB_IM1C1
       MODULE PROCEDURE FMSUB_IM1IM1
       MODULE PROCEDURE FMSUB_ZM1IM1
       MODULE PROCEDURE FMSUB_IM1ZM1
       MODULE PROCEDURE FMSUB_IZM1
       MODULE PROCEDURE FMSUB_RZM1
       MODULE PROCEDURE FMSUB_DZM1
       MODULE PROCEDURE FMSUB_ZZM1
       MODULE PROCEDURE FMSUB_CZM1
       MODULE PROCEDURE FMSUB_ZMI1
       MODULE PROCEDURE FMSUB_ZMR1
       MODULE PROCEDURE FMSUB_ZMD1
       MODULE PROCEDURE FMSUB_ZMZ1
       MODULE PROCEDURE FMSUB_ZMC1
       MODULE PROCEDURE FMSUB_ZMZM1
       MODULE PROCEDURE FMSUB_ZM1I
       MODULE PROCEDURE FMSUB_ZM1R
       MODULE PROCEDURE FMSUB_ZM1D
       MODULE PROCEDURE FMSUB_ZM1Z
       MODULE PROCEDURE FMSUB_ZM1C
       MODULE PROCEDURE FMSUB_I1ZM
       MODULE PROCEDURE FMSUB_R1ZM
       MODULE PROCEDURE FMSUB_D1ZM
       MODULE PROCEDURE FMSUB_Z1ZM
       MODULE PROCEDURE FMSUB_C1ZM
       MODULE PROCEDURE FMSUB_ZM1ZM
       MODULE PROCEDURE FMSUB_I1ZM1
       MODULE PROCEDURE FMSUB_R1ZM1
       MODULE PROCEDURE FMSUB_D1ZM1
       MODULE PROCEDURE FMSUB_Z1ZM1
       MODULE PROCEDURE FMSUB_C1ZM1
       MODULE PROCEDURE FMSUB_ZM1I1
       MODULE PROCEDURE FMSUB_ZM1R1
       MODULE PROCEDURE FMSUB_ZM1D1
       MODULE PROCEDURE FMSUB_ZM1Z1
       MODULE PROCEDURE FMSUB_ZM1C1
       MODULE PROCEDURE FMSUB_ZM1ZM1
       MODULE PROCEDURE FMSUB_IFM2
       MODULE PROCEDURE FMSUB_RFM2
       MODULE PROCEDURE FMSUB_DFM2
       MODULE PROCEDURE FMSUB_ZFM2
       MODULE PROCEDURE FMSUB_CFM2
       MODULE PROCEDURE FMSUB_FMI2
       MODULE PROCEDURE FMSUB_FMR2
       MODULE PROCEDURE FMSUB_FMD2
       MODULE PROCEDURE FMSUB_FMZ2
       MODULE PROCEDURE FMSUB_FMC2
       MODULE PROCEDURE FMSUB_FMFM2
       MODULE PROCEDURE FMSUB_IMFM2
       MODULE PROCEDURE FMSUB_ZMFM2
       MODULE PROCEDURE FMSUB_FMIM2
       MODULE PROCEDURE FMSUB_FMZM2
       MODULE PROCEDURE FMSUB_FM2I
       MODULE PROCEDURE FMSUB_FM2R
       MODULE PROCEDURE FMSUB_FM2D
       MODULE PROCEDURE FMSUB_FM2Z
       MODULE PROCEDURE FMSUB_FM2C
       MODULE PROCEDURE FMSUB_I2FM
       MODULE PROCEDURE FMSUB_R2FM
       MODULE PROCEDURE FMSUB_D2FM
       MODULE PROCEDURE FMSUB_Z2FM
       MODULE PROCEDURE FMSUB_C2FM
       MODULE PROCEDURE FMSUB_FM2FM
       MODULE PROCEDURE FMSUB_FM2IM
       MODULE PROCEDURE FMSUB_FM2ZM
       MODULE PROCEDURE FMSUB_IM2FM
       MODULE PROCEDURE FMSUB_ZM2FM
       MODULE PROCEDURE FMSUB_I2FM2
       MODULE PROCEDURE FMSUB_R2FM2
       MODULE PROCEDURE FMSUB_D2FM2
       MODULE PROCEDURE FMSUB_Z2FM2
       MODULE PROCEDURE FMSUB_C2FM2
       MODULE PROCEDURE FMSUB_FM2I2
       MODULE PROCEDURE FMSUB_FM2R2
       MODULE PROCEDURE FMSUB_FM2D2
       MODULE PROCEDURE FMSUB_FM2Z2
       MODULE PROCEDURE FMSUB_FM2C2
       MODULE PROCEDURE FMSUB_FM2FM2
       MODULE PROCEDURE FMSUB_IM2FM2
       MODULE PROCEDURE FMSUB_ZM2FM2
       MODULE PROCEDURE FMSUB_FM2IM2
       MODULE PROCEDURE FMSUB_FM2ZM2
       MODULE PROCEDURE FMSUB_IIM2
       MODULE PROCEDURE FMSUB_RIM2
       MODULE PROCEDURE FMSUB_DIM2
       MODULE PROCEDURE FMSUB_ZIM2
       MODULE PROCEDURE FMSUB_CIM2
       MODULE PROCEDURE FMSUB_IMI2
       MODULE PROCEDURE FMSUB_IMR2
       MODULE PROCEDURE FMSUB_IMD2
       MODULE PROCEDURE FMSUB_IMZ2
       MODULE PROCEDURE FMSUB_IMC2
       MODULE PROCEDURE FMSUB_IMIM2
       MODULE PROCEDURE FMSUB_ZMIM2
       MODULE PROCEDURE FMSUB_IMZM2
       MODULE PROCEDURE FMSUB_IM2I
       MODULE PROCEDURE FMSUB_IM2R
       MODULE PROCEDURE FMSUB_IM2D
       MODULE PROCEDURE FMSUB_IM2Z
       MODULE PROCEDURE FMSUB_IM2C
       MODULE PROCEDURE FMSUB_I2IM
       MODULE PROCEDURE FMSUB_R2IM
       MODULE PROCEDURE FMSUB_D2IM
       MODULE PROCEDURE FMSUB_Z2IM
       MODULE PROCEDURE FMSUB_C2IM
       MODULE PROCEDURE FMSUB_IM2IM
       MODULE PROCEDURE FMSUB_IM2ZM
       MODULE PROCEDURE FMSUB_ZM2IM
       MODULE PROCEDURE FMSUB_I2IM2
       MODULE PROCEDURE FMSUB_R2IM2
       MODULE PROCEDURE FMSUB_D2IM2
       MODULE PROCEDURE FMSUB_Z2IM2
       MODULE PROCEDURE FMSUB_C2IM2
       MODULE PROCEDURE FMSUB_IM2I2
       MODULE PROCEDURE FMSUB_IM2R2
       MODULE PROCEDURE FMSUB_IM2D2
       MODULE PROCEDURE FMSUB_IM2Z2
       MODULE PROCEDURE FMSUB_IM2C2
       MODULE PROCEDURE FMSUB_IM2IM2
       MODULE PROCEDURE FMSUB_ZM2IM2
       MODULE PROCEDURE FMSUB_IM2ZM2
       MODULE PROCEDURE FMSUB_IZM2
       MODULE PROCEDURE FMSUB_RZM2
       MODULE PROCEDURE FMSUB_DZM2
       MODULE PROCEDURE FMSUB_ZZM2
       MODULE PROCEDURE FMSUB_CZM2
       MODULE PROCEDURE FMSUB_ZMI2
       MODULE PROCEDURE FMSUB_ZMR2
       MODULE PROCEDURE FMSUB_ZMD2
       MODULE PROCEDURE FMSUB_ZMZ2
       MODULE PROCEDURE FMSUB_ZMC2
       MODULE PROCEDURE FMSUB_ZMZM2
       MODULE PROCEDURE FMSUB_ZM2I
       MODULE PROCEDURE FMSUB_ZM2R
       MODULE PROCEDURE FMSUB_ZM2D
       MODULE PROCEDURE FMSUB_ZM2Z
       MODULE PROCEDURE FMSUB_ZM2C
       MODULE PROCEDURE FMSUB_I2ZM
       MODULE PROCEDURE FMSUB_R2ZM
       MODULE PROCEDURE FMSUB_D2ZM
       MODULE PROCEDURE FMSUB_Z2ZM
       MODULE PROCEDURE FMSUB_C2ZM
       MODULE PROCEDURE FMSUB_ZM2ZM
       MODULE PROCEDURE FMSUB_I2ZM2
       MODULE PROCEDURE FMSUB_R2ZM2
       MODULE PROCEDURE FMSUB_D2ZM2
       MODULE PROCEDURE FMSUB_Z2ZM2
       MODULE PROCEDURE FMSUB_C2ZM2
       MODULE PROCEDURE FMSUB_ZM2I2
       MODULE PROCEDURE FMSUB_ZM2R2
       MODULE PROCEDURE FMSUB_ZM2D2
       MODULE PROCEDURE FMSUB_ZM2Z2
       MODULE PROCEDURE FMSUB_ZM2C2
       MODULE PROCEDURE FMSUB_ZM2ZM2
       MODULE PROCEDURE FMSUB_FM1
       MODULE PROCEDURE FMSUB_IM1
       MODULE PROCEDURE FMSUB_ZM1
       MODULE PROCEDURE FMSUB_FM2
       MODULE PROCEDURE FMSUB_IM2
       MODULE PROCEDURE FMSUB_ZM2
    END INTERFACE

 CONTAINS

!                                                                   -

   FUNCTION FMSUB_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_IFM

   FUNCTION FMSUB_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      CALL IMSUB(MTLVIM,MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMSUB_IIM

   FUNCTION FMSUB_IZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_IZM

   FUNCTION FMSUB_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_RFM

   FUNCTION FMSUB_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMSUB(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_RIM

   FUNCTION FMSUB_RZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_RZM

   FUNCTION FMSUB_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_DFM

   FUNCTION FMSUB_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMSUB(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_DIM

   FUNCTION FMSUB_DZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_DZM

   FUNCTION FMSUB_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZFM

   FUNCTION FMSUB_ZIM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZIM

   FUNCTION FMSUB_ZZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZZM

   FUNCTION FMSUB_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_CFM

   FUNCTION FMSUB_CIM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_CIM

   FUNCTION FMSUB_CZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_CZM

   FUNCTION FMSUB_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_FMI

   FUNCTION FMSUB_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_FMR

   FUNCTION FMSUB_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_FMD

   FUNCTION FMSUB_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_FMZ

   FUNCTION FMSUB_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_FMC

   FUNCTION FMSUB_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSUB(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_FMFM

   FUNCTION FMSUB_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_FMIM

   FUNCTION FMSUB_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMSUB(MTLVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_FMZM

   FUNCTION FMSUB_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      CALL IMSUB(MA%MIM,MTLVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMSUB_IMI

   FUNCTION FMSUB_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMSUB(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_IMR

   FUNCTION FMSUB_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMSUB(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_IMD

   FUNCTION FMSUB_IMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_IMZ

   FUNCTION FMSUB_IMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_IMC

   FUNCTION FMSUB_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMSUB(MTLVFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_IMFM

   FUNCTION FMSUB_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMSUB(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMSUB_IMIM

   FUNCTION FMSUB_IMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MULVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_IMZM

   FUNCTION FMSUB_ZMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZMI

   FUNCTION FMSUB_ZMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZMR

   FUNCTION FMSUB_ZMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZMD

   FUNCTION FMSUB_ZMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZMZ

   FUNCTION FMSUB_ZMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZMC

   FUNCTION FMSUB_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZMFM

   FUNCTION FMSUB_ZMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMSUB(MA%MZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZMIM

   FUNCTION FMSUB_ZMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSUB(MA%MZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZMZM

   FUNCTION FMSUB_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,MTLVFM,QX)
      IF (MTLVFM%MP(2) /= QX%MUNKNO .AND. MTLVFM%MP(3) /= 0)  &
          MTLVFM%MP(1) = -MTLVFM%MP(1)
      CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSUB_FM

   FUNCTION FMSUB_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MA%MIM,MTLVIM,QX)
      IF (MTLVIM%MP(2) /= QX%MUNKNO .AND. MTLVIM%MP(3) /= 0)  &
          MTLVIM%MP(1) = -MTLVIM%MP(1)
      CALL IMEQ(MTLVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMSUB_IM

   FUNCTION FMSUB_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQ(MA%MZM,MTLVZM,QX)
      IF (MTLVZM(1)%MP(2) /= QX%MUNKNO .AND. MTLVZM(1)%MP(3) /= 0)  &
          MTLVZM(1)%MP(1) = -MTLVZM(1)%MP(1)
      IF (MTLVZM(2)%MP(2) /= QX%MUNKNO .AND. MTLVZM(2)%MP(3) /= 0) THEN
          MTLVZM(2)%MP(1) = -MTLVZM(2)%MP(1)
      ENDIF
      CALL ZMEQ(MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSUB_ZM

!             Array subtraction operations for FM.

!             (1) rank 0  -  rank 1

   FUNCTION FMSUB_IFM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IFM1

   FUNCTION FMSUB_RFM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_RFM1

   FUNCTION FMSUB_DFM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_DFM1

   FUNCTION FMSUB_ZFM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZFM1

   FUNCTION FMSUB_CFM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_CFM1

   FUNCTION FMSUB_FMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FMI1

   FUNCTION FMSUB_FMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FMR1

   FUNCTION FMSUB_FMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FMD1

   FUNCTION FMSUB_FMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FMZ1

   FUNCTION FMSUB_FMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FMC1

   FUNCTION FMSUB_FMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL FMSUB(MA%MFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FMFM1

   FUNCTION FMSUB_IMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MTLVFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IMFM1

   FUNCTION FMSUB_ZMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N	
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZMFM1

   FUNCTION FMSUB_FMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MTLVFM,QX)
         CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FMIM1

   FUNCTION FMSUB_FMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FMZM1

!             (2) rank 1  -  rank 0

   FUNCTION FMSUB_FM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1I

   FUNCTION FMSUB_FM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1R

   FUNCTION FMSUB_FM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1D

   FUNCTION FMSUB_FM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1Z

   FUNCTION FMSUB_FM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1C

   FUNCTION FMSUB_I1FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_I1FM

   FUNCTION FMSUB_R1FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_R1FM

   FUNCTION FMSUB_D1FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_D1FM

   FUNCTION FMSUB_Z1FM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_Z1FM

   FUNCTION FMSUB_C1FM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_C1FM

   FUNCTION FMSUB_FM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB(MA(J)%MFM,MB%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1FM

   FUNCTION FMSUB_FM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1IM

   FUNCTION FMSUB_FM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1ZM

   FUNCTION FMSUB_IM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMSUB(MTLVFM,MB%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1FM

   FUNCTION FMSUB_ZM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1FM

!             (3) rank 1  -  rank 1

   FUNCTION FMSUB_FM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMSUB(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1I1

   FUNCTION FMSUB_FM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMSUB(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1R1

   FUNCTION FMSUB_FM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMSUB(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1D1

   FUNCTION FMSUB_FM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1Z1

   FUNCTION FMSUB_FM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1C1

   FUNCTION FMSUB_I1FM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_I1FM1

   FUNCTION FMSUB_R1FM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_R1FM1

   FUNCTION FMSUB_D1FM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_D1FM1

   FUNCTION FMSUB_Z1FM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_Z1FM1

   FUNCTION FMSUB_C1FM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_C1FM1

   FUNCTION FMSUB_FM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB(MA(J)%MFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1FM1

   FUNCTION FMSUB_FM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MTLVFM,QX)
         CALL FMSUB(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1IM1

   FUNCTION FMSUB_FM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1ZM1

   FUNCTION FMSUB_IM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMSUB(MTLVFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1FM1

   FUNCTION FMSUB_ZM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1FM1

!             (4) rank 0  -  rank 2

   FUNCTION FMSUB_IFM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IFM2

   FUNCTION FMSUB_RFM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_RFM2

   FUNCTION FMSUB_DFM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_DFM2

   FUNCTION FMSUB_ZFM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZFM2

   FUNCTION FMSUB_CFM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_CFM2

   FUNCTION FMSUB_FMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FMI2

   FUNCTION FMSUB_FMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FMR2

   FUNCTION FMSUB_FMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FMD2

   FUNCTION FMSUB_FMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FMZ2

   FUNCTION FMSUB_FMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FMC2

   FUNCTION FMSUB_FMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMSUB(MA%MFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FMFM2

   FUNCTION FMSUB_IMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMSUB(MTLVFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IMFM2

   FUNCTION FMSUB_ZMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZMFM2

   FUNCTION FMSUB_FMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MTLVFM,QX)
            CALL FMSUB(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FMIM2

   FUNCTION FMSUB_FMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMSUB(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FMZM2

!             (5) rank 2  -  rank 0

   FUNCTION FMSUB_FM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2I

   FUNCTION FMSUB_FM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2R

   FUNCTION FMSUB_FM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2D

   FUNCTION FMSUB_FM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2Z

   FUNCTION FMSUB_FM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2C

   FUNCTION FMSUB_I2FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_I2FM

   FUNCTION FMSUB_R2FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_R2FM

   FUNCTION FMSUB_D2FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_D2FM

   FUNCTION FMSUB_Z2FM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_Z2FM

   FUNCTION FMSUB_C2FM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_C2FM

   FUNCTION FMSUB_FM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MA(J,K)%MFM,MB%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2FM

   FUNCTION FMSUB_FM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2IM

   FUNCTION FMSUB_FM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2ZM

   FUNCTION FMSUB_IM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMSUB(MTLVFM,MB%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2FM

   FUNCTION FMSUB_ZM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2FM

!             (6) rank 2  -  rank 2

   FUNCTION FMSUB_FM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMSUB(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2I2

   FUNCTION FMSUB_FM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMSUB(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2R2

   FUNCTION FMSUB_FM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMSUB(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2D2

   FUNCTION FMSUB_FM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2Z2

   FUNCTION FMSUB_FM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2C2

   FUNCTION FMSUB_I2FM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_I2FM2

   FUNCTION FMSUB_R2FM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_R2FM2

   FUNCTION FMSUB_D2FM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_D2FM2

   FUNCTION FMSUB_Z2FM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_Z2FM2

   FUNCTION FMSUB_C2FM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_C2FM2

   FUNCTION FMSUB_FM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MA(J,K)%MFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2FM2

   FUNCTION FMSUB_FM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MTLVFM,QX)
            CALL FMSUB(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2IM2

   FUNCTION FMSUB_FM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2ZM2

   FUNCTION FMSUB_IM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMSUB(MTLVFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2FM2

   FUNCTION FMSUB_ZM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2FM2

!             Array subtraction operations for IM.

!             (1) rank 0  -  rank 1

   FUNCTION FMSUB_IIM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMSUB(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_IIM1

   FUNCTION FMSUB_RIM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MULVFM,QX)
         CALL FMSUB(MTLVFM,MULVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_RIM1

   FUNCTION FMSUB_DIM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MULVFM,QX)
         CALL FMSUB(MTLVFM,MULVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_DIM1

   FUNCTION FMSUB_ZIM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZIM1

   FUNCTION FMSUB_CIM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_CIM1

   FUNCTION FMSUB_IMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMSUB(MA%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_IMI1

   FUNCTION FMSUB_IMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMSUB(MULVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IMR1

   FUNCTION FMSUB_IMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMSUB(MULVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IMD1

   FUNCTION FMSUB_IMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IMZ1

   FUNCTION FMSUB_IMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IMC1

   FUNCTION FMSUB_IMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL IMSUB(MA%MIM,MB(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_IMIM1

   FUNCTION FMSUB_ZMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
         CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZMIM1

   FUNCTION FMSUB_IMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IMZM1

!             (2) rank 1  -  rank 0

   FUNCTION FMSUB_IM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMSUB(MA(J)%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1I

   FUNCTION FMSUB_IM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL FMSUB(MVLVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1R

   FUNCTION FMSUB_IM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL FMSUB(MVLVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1D

   FUNCTION FMSUB_IM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1Z

   FUNCTION FMSUB_IM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1C

   FUNCTION FMSUB_I1IM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMSUB(MTLVIM,MA%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_I1IM

   FUNCTION FMSUB_R1IM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,MVLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_R1IM

   FUNCTION FMSUB_D1IM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,MVLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_D1IM

   FUNCTION FMSUB_Z1IM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_Z1IM

   FUNCTION FMSUB_C1IM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,M1LVFM,QX)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_C1IM

   FUNCTION FMSUB_IM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMSUB(MA(J)%MIM,MB%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1IM

   FUNCTION FMSUB_IM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMSUB(M1LVZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1ZM

   FUNCTION FMSUB_ZM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,M1LVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,M1LVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1IM

!             (3) rank 1  -  rank 1

   FUNCTION FMSUB_IM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMSUB(MA(J)%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1I1

   FUNCTION FMSUB_IM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMSUB(M1LVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1R1

   FUNCTION FMSUB_IM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMSUB(M1LVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1D1

   FUNCTION FMSUB_IM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1Z1

   FUNCTION FMSUB_IM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1C1

   FUNCTION FMSUB_I1IM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMSUB(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_I1IM1

   FUNCTION FMSUB_R1IM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,M1LVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_R1IM1

   FUNCTION FMSUB_D1IM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMSUB(MTLVFM,M1LVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_D1IM1

   FUNCTION FMSUB_Z1IM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_Z1IM1

   FUNCTION FMSUB_C1IM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_C1IM1

   FUNCTION FMSUB_IM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMSUB(MA(J)%MIM,MB(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1IM1

   FUNCTION FMSUB_IM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMSUB(M1LVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1ZM1

   FUNCTION FMSUB_ZM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMSUB(MA(J)%MZM,M1LVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1IM1

!             (4) rank 0  -  rank 2

   FUNCTION FMSUB_IIM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMSUB(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IIM2

   FUNCTION FMSUB_RIM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MULVFM,QX)
            CALL FMSUB(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_RIM2

   FUNCTION FMSUB_DIM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MULVFM,QX)
            CALL FMSUB(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_DIM2

   FUNCTION FMSUB_ZIM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZIM2

   FUNCTION FMSUB_CIM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_CIM2

   FUNCTION FMSUB_IMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMSUB(MA%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IMI2

   FUNCTION FMSUB_IMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMSUB(MULVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IMR2

   FUNCTION FMSUB_IMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMSUB(MULVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IMD2

   FUNCTION FMSUB_IMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IMZ2

   FUNCTION FMSUB_IMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IMC2

   FUNCTION FMSUB_IMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMSUB(MA%MIM,MB(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IMIM2

   FUNCTION FMSUB_ZMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
            CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZMIM2

   FUNCTION FMSUB_IMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMSUB(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IMZM2

!             (5) rank 2  -  rank 0

   FUNCTION FMSUB_IM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMSUB(MA(J,K)%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2I

   FUNCTION FMSUB_IM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL FMSUB(MVLVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2R

   FUNCTION FMSUB_IM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL FMSUB(MVLVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2D

   FUNCTION FMSUB_IM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2Z

   FUNCTION FMSUB_IM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2C

   FUNCTION FMSUB_I2IM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMSUB(MTLVIM,MA%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_I2IM

   FUNCTION FMSUB_R2IM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,MVLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_R2IM

   FUNCTION FMSUB_D2IM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,MVLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_D2IM

   FUNCTION FMSUB_Z2IM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_Z2IM

   FUNCTION FMSUB_C2IM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,M1LVFM,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_C2IM

   FUNCTION FMSUB_IM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMSUB(MA(J,K)%MIM,MB%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2IM

   FUNCTION FMSUB_IM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMSUB(M1LVZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2ZM

   FUNCTION FMSUB_ZM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,M1LVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,M1LVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2IM

!             (6) rank 2  -  rank 2

   FUNCTION FMSUB_IM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMSUB(MA(J,K)%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2I2

   FUNCTION FMSUB_IM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMSUB(M1LVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2R2

   FUNCTION FMSUB_IM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMSUB(M1LVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2D2

   FUNCTION FMSUB_IM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2Z2

   FUNCTION FMSUB_IM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2C2

   FUNCTION FMSUB_I2IM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMSUB(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_I2IM2

   FUNCTION FMSUB_R2IM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,M1LVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_R2IM2

   FUNCTION FMSUB_D2IM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMSUB(MTLVFM,M1LVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_D2IM2

   FUNCTION FMSUB_Z2IM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_Z2IM2

   FUNCTION FMSUB_C2IM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMSUB(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_C2IM2

   FUNCTION FMSUB_IM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMSUB(MA(J,K)%MIM,MB(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2IM2

   FUNCTION FMSUB_IM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMSUB(M1LVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2ZM2

   FUNCTION FMSUB_ZM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMSUB(MA(J,K)%MZM,M1LVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2IM2

!             Array subtraction operations for ZM.

!             (1) rank 0  -  rank 1

   FUNCTION FMSUB_IZM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_IZM1

   FUNCTION FMSUB_RZM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_RZM1

   FUNCTION FMSUB_DZM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_DZM1

   FUNCTION FMSUB_ZZM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZZM1

   FUNCTION FMSUB_CZM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_CZM1

   FUNCTION FMSUB_ZMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZMI1

   FUNCTION FMSUB_ZMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZMR1

   FUNCTION FMSUB_ZMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZMD1

   FUNCTION FMSUB_ZMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZMZ1

   FUNCTION FMSUB_ZMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZMC1

   FUNCTION FMSUB_ZMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL ZMSUB(MA%MZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZMZM1

!             (2) rank 1  -  rank 0

   FUNCTION FMSUB_ZM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1I

   FUNCTION FMSUB_ZM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1R

   FUNCTION FMSUB_ZM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1D

   FUNCTION FMSUB_ZM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1Z

   FUNCTION FMSUB_ZM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1C

   FUNCTION FMSUB_I1ZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_I1ZM

   FUNCTION FMSUB_R1ZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_R1ZM

   FUNCTION FMSUB_D1ZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_D1ZM

   FUNCTION FMSUB_Z1ZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_Z1ZM

   FUNCTION FMSUB_C1ZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_C1ZM

   FUNCTION FMSUB_ZM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1ZM

!             (3) rank 1  -  rank 1

   FUNCTION FMSUB_ZM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1I1

   FUNCTION FMSUB_ZM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1R1

   FUNCTION FMSUB_ZM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1D1

   FUNCTION FMSUB_ZM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1Z1

   FUNCTION FMSUB_ZM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1C1

   FUNCTION FMSUB_I1ZM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_I1ZM1

   FUNCTION FMSUB_R1ZM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_R1ZM1

   FUNCTION FMSUB_D1ZM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_D1ZM1

   FUNCTION FMSUB_Z1ZM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_Z1ZM1

   FUNCTION FMSUB_C1ZM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_C1ZM1

   FUNCTION FMSUB_ZM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMSUB(MA(J)%MZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1ZM1

!             (4) rank 0  -  rank 2

   FUNCTION FMSUB_IZM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IZM2

   FUNCTION FMSUB_RZM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_RZM2

   FUNCTION FMSUB_DZM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_DZM2

   FUNCTION FMSUB_ZZM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZZM2

   FUNCTION FMSUB_CZM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_CZM2

   FUNCTION FMSUB_ZMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZMI2

   FUNCTION FMSUB_ZMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZMR2

   FUNCTION FMSUB_ZMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZMD2

   FUNCTION FMSUB_ZMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZMZ2

   FUNCTION FMSUB_ZMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZMC2

   FUNCTION FMSUB_ZMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMSUB(MA%MZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZMZM2

!             (5) rank 2  -  rank 0

   FUNCTION FMSUB_ZM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2I

   FUNCTION FMSUB_ZM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2R

   FUNCTION FMSUB_ZM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2D

   FUNCTION FMSUB_ZM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2Z

   FUNCTION FMSUB_ZM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2C

   FUNCTION FMSUB_I2ZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_I2ZM

   FUNCTION FMSUB_R2ZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_R2ZM

   FUNCTION FMSUB_D2ZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_D2ZM

   FUNCTION FMSUB_Z2ZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_Z2ZM

   FUNCTION FMSUB_C2ZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_C2ZM

   FUNCTION FMSUB_ZM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2ZM

!             (6) rank 2  -  rank 2

   FUNCTION FMSUB_ZM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2I2

   FUNCTION FMSUB_ZM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2R2

   FUNCTION FMSUB_ZM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2D2

   FUNCTION FMSUB_ZM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2Z2

   FUNCTION FMSUB_ZM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2C2

   FUNCTION FMSUB_I2ZM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_I2ZM2

   FUNCTION FMSUB_R2ZM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_R2ZM2

   FUNCTION FMSUB_D2ZM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_D2ZM2

   FUNCTION FMSUB_Z2ZM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_Z2ZM2

   FUNCTION FMSUB_C2ZM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_C2ZM2

   FUNCTION FMSUB_ZM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MA(J,K)%MZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2ZM2

   FUNCTION FMSUB_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL FMSUB(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSUB_FM1

   FUNCTION FMSUB_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(0,MTLVIM,QX)
      DO J = 1, N
         CALL IMSUB(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMSUB_IM1

   FUNCTION FMSUB_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMI2M(0,MTLVZM,QX)
      DO J = 1, N
         CALL ZMSUB(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSUB_ZM1

   FUNCTION FMSUB_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_FM2

   FUNCTION FMSUB_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(0,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMSUB(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_IM2

   FUNCTION FMSUB_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(0,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSUB(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSUB_ZM2

 END MODULE FMZM_5_PARALLEL

 MODULE FMZM_6_PARALLEL
    USE FMZM_1_PARALLEL

    INTERFACE OPERATOR (*)
       MODULE PROCEDURE FMMPY_IFM
       MODULE PROCEDURE FMMPY_IIM
       MODULE PROCEDURE FMMPY_IZM
       MODULE PROCEDURE FMMPY_RFM
       MODULE PROCEDURE FMMPY_RIM
       MODULE PROCEDURE FMMPY_RZM
       MODULE PROCEDURE FMMPY_DFM
       MODULE PROCEDURE FMMPY_DIM
       MODULE PROCEDURE FMMPY_DZM
       MODULE PROCEDURE FMMPY_ZFM
       MODULE PROCEDURE FMMPY_ZIM
       MODULE PROCEDURE FMMPY_ZZM
       MODULE PROCEDURE FMMPY_CFM
       MODULE PROCEDURE FMMPY_CIM
       MODULE PROCEDURE FMMPY_CZM
       MODULE PROCEDURE FMMPY_FMI
       MODULE PROCEDURE FMMPY_FMR
       MODULE PROCEDURE FMMPY_FMD
       MODULE PROCEDURE FMMPY_FMZ
       MODULE PROCEDURE FMMPY_FMC
       MODULE PROCEDURE FMMPY_FMFM
       MODULE PROCEDURE FMMPY_FMIM
       MODULE PROCEDURE FMMPY_FMZM
       MODULE PROCEDURE FMMPY_IMI
       MODULE PROCEDURE FMMPY_IMR
       MODULE PROCEDURE FMMPY_IMD
       MODULE PROCEDURE FMMPY_IMZ
       MODULE PROCEDURE FMMPY_IMC
       MODULE PROCEDURE FMMPY_IMFM
       MODULE PROCEDURE FMMPY_IMIM
       MODULE PROCEDURE FMMPY_IMZM
       MODULE PROCEDURE FMMPY_ZMI
       MODULE PROCEDURE FMMPY_ZMR
       MODULE PROCEDURE FMMPY_ZMD
       MODULE PROCEDURE FMMPY_ZMZ
       MODULE PROCEDURE FMMPY_ZMC
       MODULE PROCEDURE FMMPY_ZMFM
       MODULE PROCEDURE FMMPY_ZMIM
       MODULE PROCEDURE FMMPY_ZMZM
       MODULE PROCEDURE FMMPY_IFM1
       MODULE PROCEDURE FMMPY_RFM1
       MODULE PROCEDURE FMMPY_DFM1
       MODULE PROCEDURE FMMPY_ZFM1
       MODULE PROCEDURE FMMPY_CFM1
       MODULE PROCEDURE FMMPY_FMI1
       MODULE PROCEDURE FMMPY_FMR1
       MODULE PROCEDURE FMMPY_FMD1
       MODULE PROCEDURE FMMPY_FMZ1
       MODULE PROCEDURE FMMPY_FMC1
       MODULE PROCEDURE FMMPY_FMFM1
       MODULE PROCEDURE FMMPY_IMFM1
       MODULE PROCEDURE FMMPY_ZMFM1
       MODULE PROCEDURE FMMPY_FMIM1
       MODULE PROCEDURE FMMPY_FMZM1
       MODULE PROCEDURE FMMPY_FM1I
       MODULE PROCEDURE FMMPY_FM1R
       MODULE PROCEDURE FMMPY_FM1D
       MODULE PROCEDURE FMMPY_FM1Z
       MODULE PROCEDURE FMMPY_FM1C
       MODULE PROCEDURE FMMPY_I1FM
       MODULE PROCEDURE FMMPY_R1FM
       MODULE PROCEDURE FMMPY_D1FM
       MODULE PROCEDURE FMMPY_Z1FM
       MODULE PROCEDURE FMMPY_C1FM
       MODULE PROCEDURE FMMPY_FM1FM
       MODULE PROCEDURE FMMPY_FM1IM
       MODULE PROCEDURE FMMPY_FM1ZM
       MODULE PROCEDURE FMMPY_IM1FM
       MODULE PROCEDURE FMMPY_ZM1FM
       MODULE PROCEDURE FMMPY_I1FM1
       MODULE PROCEDURE FMMPY_R1FM1
       MODULE PROCEDURE FMMPY_D1FM1
       MODULE PROCEDURE FMMPY_Z1FM1
       MODULE PROCEDURE FMMPY_C1FM1
       MODULE PROCEDURE FMMPY_FM1I1
       MODULE PROCEDURE FMMPY_FM1R1
       MODULE PROCEDURE FMMPY_FM1D1
       MODULE PROCEDURE FMMPY_FM1Z1
       MODULE PROCEDURE FMMPY_FM1C1
       MODULE PROCEDURE FMMPY_FM1FM1
       MODULE PROCEDURE FMMPY_IM1FM1
       MODULE PROCEDURE FMMPY_ZM1FM1
       MODULE PROCEDURE FMMPY_FM1IM1
       MODULE PROCEDURE FMMPY_FM1ZM1
       MODULE PROCEDURE FMMPY_IIM1
       MODULE PROCEDURE FMMPY_RIM1
       MODULE PROCEDURE FMMPY_DIM1
       MODULE PROCEDURE FMMPY_ZIM1
       MODULE PROCEDURE FMMPY_CIM1
       MODULE PROCEDURE FMMPY_IMI1
       MODULE PROCEDURE FMMPY_IMR1
       MODULE PROCEDURE FMMPY_IMD1
       MODULE PROCEDURE FMMPY_IMZ1
       MODULE PROCEDURE FMMPY_IMC1
       MODULE PROCEDURE FMMPY_IMIM1
       MODULE PROCEDURE FMMPY_ZMIM1
       MODULE PROCEDURE FMMPY_IMZM1
       MODULE PROCEDURE FMMPY_IM1I
       MODULE PROCEDURE FMMPY_IM1R
       MODULE PROCEDURE FMMPY_IM1D
       MODULE PROCEDURE FMMPY_IM1Z
       MODULE PROCEDURE FMMPY_IM1C
       MODULE PROCEDURE FMMPY_I1IM
       MODULE PROCEDURE FMMPY_R1IM
       MODULE PROCEDURE FMMPY_D1IM
       MODULE PROCEDURE FMMPY_Z1IM
       MODULE PROCEDURE FMMPY_C1IM
       MODULE PROCEDURE FMMPY_IM1IM
       MODULE PROCEDURE FMMPY_IM1ZM
       MODULE PROCEDURE FMMPY_ZM1IM
       MODULE PROCEDURE FMMPY_I1IM1
       MODULE PROCEDURE FMMPY_R1IM1
       MODULE PROCEDURE FMMPY_D1IM1
       MODULE PROCEDURE FMMPY_Z1IM1
       MODULE PROCEDURE FMMPY_C1IM1
       MODULE PROCEDURE FMMPY_IM1I1
       MODULE PROCEDURE FMMPY_IM1R1
       MODULE PROCEDURE FMMPY_IM1D1
       MODULE PROCEDURE FMMPY_IM1Z1
       MODULE PROCEDURE FMMPY_IM1C1
       MODULE PROCEDURE FMMPY_IM1IM1
       MODULE PROCEDURE FMMPY_ZM1IM1
       MODULE PROCEDURE FMMPY_IM1ZM1
       MODULE PROCEDURE FMMPY_IZM1
       MODULE PROCEDURE FMMPY_RZM1
       MODULE PROCEDURE FMMPY_DZM1
       MODULE PROCEDURE FMMPY_ZZM1
       MODULE PROCEDURE FMMPY_CZM1
       MODULE PROCEDURE FMMPY_ZMI1
       MODULE PROCEDURE FMMPY_ZMR1
       MODULE PROCEDURE FMMPY_ZMD1
       MODULE PROCEDURE FMMPY_ZMZ1
       MODULE PROCEDURE FMMPY_ZMC1
       MODULE PROCEDURE FMMPY_ZMZM1
       MODULE PROCEDURE FMMPY_ZM1I
       MODULE PROCEDURE FMMPY_ZM1R
       MODULE PROCEDURE FMMPY_ZM1D
       MODULE PROCEDURE FMMPY_ZM1Z
       MODULE PROCEDURE FMMPY_ZM1C
       MODULE PROCEDURE FMMPY_I1ZM
       MODULE PROCEDURE FMMPY_R1ZM
       MODULE PROCEDURE FMMPY_D1ZM
       MODULE PROCEDURE FMMPY_Z1ZM
       MODULE PROCEDURE FMMPY_C1ZM
       MODULE PROCEDURE FMMPY_ZM1ZM
       MODULE PROCEDURE FMMPY_I1ZM1
       MODULE PROCEDURE FMMPY_R1ZM1
       MODULE PROCEDURE FMMPY_D1ZM1
       MODULE PROCEDURE FMMPY_Z1ZM1
       MODULE PROCEDURE FMMPY_C1ZM1
       MODULE PROCEDURE FMMPY_ZM1I1
       MODULE PROCEDURE FMMPY_ZM1R1
       MODULE PROCEDURE FMMPY_ZM1D1
       MODULE PROCEDURE FMMPY_ZM1Z1
       MODULE PROCEDURE FMMPY_ZM1C1
       MODULE PROCEDURE FMMPY_ZM1ZM1
       MODULE PROCEDURE FMMPY_IFM2
       MODULE PROCEDURE FMMPY_RFM2
       MODULE PROCEDURE FMMPY_DFM2
       MODULE PROCEDURE FMMPY_ZFM2
       MODULE PROCEDURE FMMPY_CFM2
       MODULE PROCEDURE FMMPY_FMI2
       MODULE PROCEDURE FMMPY_FMR2
       MODULE PROCEDURE FMMPY_FMD2
       MODULE PROCEDURE FMMPY_FMZ2
       MODULE PROCEDURE FMMPY_FMC2
       MODULE PROCEDURE FMMPY_FMFM2
       MODULE PROCEDURE FMMPY_IMFM2
       MODULE PROCEDURE FMMPY_ZMFM2
       MODULE PROCEDURE FMMPY_FMIM2
       MODULE PROCEDURE FMMPY_FMZM2
       MODULE PROCEDURE FMMPY_FM2I
       MODULE PROCEDURE FMMPY_FM2R
       MODULE PROCEDURE FMMPY_FM2D
       MODULE PROCEDURE FMMPY_FM2Z
       MODULE PROCEDURE FMMPY_FM2C
       MODULE PROCEDURE FMMPY_I2FM
       MODULE PROCEDURE FMMPY_R2FM
       MODULE PROCEDURE FMMPY_D2FM
       MODULE PROCEDURE FMMPY_Z2FM
       MODULE PROCEDURE FMMPY_C2FM
       MODULE PROCEDURE FMMPY_FM2FM
       MODULE PROCEDURE FMMPY_FM2IM
       MODULE PROCEDURE FMMPY_FM2ZM
       MODULE PROCEDURE FMMPY_IM2FM
       MODULE PROCEDURE FMMPY_ZM2FM
       MODULE PROCEDURE FMMPY_I2FM2
       MODULE PROCEDURE FMMPY_R2FM2
       MODULE PROCEDURE FMMPY_D2FM2
       MODULE PROCEDURE FMMPY_Z2FM2
       MODULE PROCEDURE FMMPY_C2FM2
       MODULE PROCEDURE FMMPY_FM2I2
       MODULE PROCEDURE FMMPY_FM2R2
       MODULE PROCEDURE FMMPY_FM2D2
       MODULE PROCEDURE FMMPY_FM2Z2
       MODULE PROCEDURE FMMPY_FM2C2
       MODULE PROCEDURE FMMPY_FM2FM2
       MODULE PROCEDURE FMMPY_IM2FM2
       MODULE PROCEDURE FMMPY_ZM2FM2
       MODULE PROCEDURE FMMPY_FM2IM2
       MODULE PROCEDURE FMMPY_FM2ZM2
       MODULE PROCEDURE FMMPY_IIM2
       MODULE PROCEDURE FMMPY_RIM2
       MODULE PROCEDURE FMMPY_DIM2
       MODULE PROCEDURE FMMPY_ZIM2
       MODULE PROCEDURE FMMPY_CIM2
       MODULE PROCEDURE FMMPY_IMI2
       MODULE PROCEDURE FMMPY_IMR2
       MODULE PROCEDURE FMMPY_IMD2
       MODULE PROCEDURE FMMPY_IMZ2
       MODULE PROCEDURE FMMPY_IMC2
       MODULE PROCEDURE FMMPY_IMIM2
       MODULE PROCEDURE FMMPY_ZMIM2
       MODULE PROCEDURE FMMPY_IMZM2
       MODULE PROCEDURE FMMPY_IM2I
       MODULE PROCEDURE FMMPY_IM2R
       MODULE PROCEDURE FMMPY_IM2D
       MODULE PROCEDURE FMMPY_IM2Z
       MODULE PROCEDURE FMMPY_IM2C
       MODULE PROCEDURE FMMPY_I2IM
       MODULE PROCEDURE FMMPY_R2IM
       MODULE PROCEDURE FMMPY_D2IM
       MODULE PROCEDURE FMMPY_Z2IM
       MODULE PROCEDURE FMMPY_C2IM
       MODULE PROCEDURE FMMPY_IM2IM
       MODULE PROCEDURE FMMPY_IM2ZM
       MODULE PROCEDURE FMMPY_ZM2IM
       MODULE PROCEDURE FMMPY_I2IM2
       MODULE PROCEDURE FMMPY_R2IM2
       MODULE PROCEDURE FMMPY_D2IM2
       MODULE PROCEDURE FMMPY_Z2IM2
       MODULE PROCEDURE FMMPY_C2IM2
       MODULE PROCEDURE FMMPY_IM2I2
       MODULE PROCEDURE FMMPY_IM2R2
       MODULE PROCEDURE FMMPY_IM2D2
       MODULE PROCEDURE FMMPY_IM2Z2
       MODULE PROCEDURE FMMPY_IM2C2
       MODULE PROCEDURE FMMPY_IM2IM2
       MODULE PROCEDURE FMMPY_ZM2IM2
       MODULE PROCEDURE FMMPY_IM2ZM2
       MODULE PROCEDURE FMMPY_IZM2
       MODULE PROCEDURE FMMPY_RZM2
       MODULE PROCEDURE FMMPY_DZM2
       MODULE PROCEDURE FMMPY_ZZM2
       MODULE PROCEDURE FMMPY_CZM2
       MODULE PROCEDURE FMMPY_ZMI2
       MODULE PROCEDURE FMMPY_ZMR2
       MODULE PROCEDURE FMMPY_ZMD2
       MODULE PROCEDURE FMMPY_ZMZ2
       MODULE PROCEDURE FMMPY_ZMC2
       MODULE PROCEDURE FMMPY_ZMZM2
       MODULE PROCEDURE FMMPY_ZM2I
       MODULE PROCEDURE FMMPY_ZM2R
       MODULE PROCEDURE FMMPY_ZM2D
       MODULE PROCEDURE FMMPY_ZM2Z
       MODULE PROCEDURE FMMPY_ZM2C
       MODULE PROCEDURE FMMPY_I2ZM
       MODULE PROCEDURE FMMPY_R2ZM
       MODULE PROCEDURE FMMPY_D2ZM
       MODULE PROCEDURE FMMPY_Z2ZM
       MODULE PROCEDURE FMMPY_C2ZM
       MODULE PROCEDURE FMMPY_ZM2ZM
       MODULE PROCEDURE FMMPY_I2ZM2
       MODULE PROCEDURE FMMPY_R2ZM2
       MODULE PROCEDURE FMMPY_D2ZM2
       MODULE PROCEDURE FMMPY_Z2ZM2
       MODULE PROCEDURE FMMPY_C2ZM2
       MODULE PROCEDURE FMMPY_ZM2I2
       MODULE PROCEDURE FMMPY_ZM2R2
       MODULE PROCEDURE FMMPY_ZM2D2
       MODULE PROCEDURE FMMPY_ZM2Z2
       MODULE PROCEDURE FMMPY_ZM2C2
       MODULE PROCEDURE FMMPY_ZM2ZM2
    END INTERFACE

 CONTAINS

!                                                                   *

   FUNCTION FMMPY_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMMPYI(MA%MFM,IVAL,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_IFM

   FUNCTION FMMPY_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPYI(MA%MIM,IVAL,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMPY_IIM

   FUNCTION FMMPY_IZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMMPYI(MA%MZM,IVAL,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_IZM

   FUNCTION FMMPY_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMMPY(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_RFM

   FUNCTION FMMPY_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMMPY(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_RIM

   FUNCTION FMMPY_RZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_RZM

   FUNCTION FMMPY_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMMPY(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_DFM

   FUNCTION FMMPY_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMMPY(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_DIM

   FUNCTION FMMPY_DZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_DZM

   FUNCTION FMMPY_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZFM

   FUNCTION FMMPY_ZIM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZIM

   FUNCTION FMMPY_ZZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZZM

   FUNCTION FMMPY_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_CFM

   FUNCTION FMMPY_CIM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_CIM

   FUNCTION FMMPY_CZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_CZM

   FUNCTION FMMPY_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMMPYI(MA%MFM,IVAL,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_FMI

   FUNCTION FMMPY_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_FMR

   FUNCTION FMMPY_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_FMD

   FUNCTION FMMPY_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_FMZ

   FUNCTION FMMPY_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_FMC

   FUNCTION FMMPY_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMMPY(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_FMFM

   FUNCTION FMMPY_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_FMIM

   FUNCTION FMMPY_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMMPY(MTLVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_FMZM

   FUNCTION FMMPY_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPYI(MA%MIM,IVAL,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMPY_IMI

   FUNCTION FMMPY_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMMPY(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_IMR

   FUNCTION FMMPY_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMMPY(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_IMD

   FUNCTION FMMPY_IMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_IMZ

   FUNCTION FMMPY_IMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_IMC

   FUNCTION FMMPY_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMMPY(MTLVFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMPY_IMFM

   FUNCTION FMMPY_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPY(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMPY_IMIM

   FUNCTION FMMPY_IMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MULVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_IMZM

   FUNCTION FMMPY_ZMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMMPYI(MA%MZM,IVAL,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZMI

   FUNCTION FMMPY_ZMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZMR

   FUNCTION FMMPY_ZMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZMD

   FUNCTION FMMPY_ZMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZMZ

   FUNCTION FMMPY_ZMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZMC

   FUNCTION FMMPY_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZMFM

   FUNCTION FMMPY_ZMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMMPY(MA%MZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZMIM

   FUNCTION FMMPY_ZMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMMPY(MA%MZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMMPY_ZMZM

!             Array multiplication operations for FM.

!             (1) rank 0  *  rank 1

   FUNCTION FMMPY_IFM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMMPY(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IFM1

   FUNCTION FMMPY_RFM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMMPY(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_RFM1

   FUNCTION FMMPY_DFM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMMPY(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_DFM1

   FUNCTION FMMPY_ZFM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZFM1

   FUNCTION FMMPY_CFM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_CFM1

   FUNCTION FMMPY_FMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FMI1

   FUNCTION FMMPY_FMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FMR1

   FUNCTION FMMPY_FMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FMD1

   FUNCTION FMMPY_FMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FMZ1

   FUNCTION FMMPY_FMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FMC1

   FUNCTION FMMPY_FMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL FMMPY(MA%MFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FMFM1

   FUNCTION FMMPY_IMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMMPY(MTLVFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IMFM1

   FUNCTION FMMPY_ZMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N	
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZMFM1

   FUNCTION FMMPY_FMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MTLVFM,QX)
         CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FMIM1

   FUNCTION FMMPY_FMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FMZM1

!             (2) rank 1  *  rank 0

   FUNCTION FMMPY_FM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMMPY(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1I

   FUNCTION FMMPY_FM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMMPY(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1R

   FUNCTION FMMPY_FM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMMPY(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1D

   FUNCTION FMMPY_FM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1Z

   FUNCTION FMMPY_FM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1C

   FUNCTION FMMPY_I1FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_I1FM

   FUNCTION FMMPY_R1FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_R1FM

   FUNCTION FMMPY_D1FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_D1FM

   FUNCTION FMMPY_Z1FM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_Z1FM

   FUNCTION FMMPY_C1FM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_C1FM

   FUNCTION FMMPY_FM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMMPY(MA(J)%MFM,MB%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1FM

   FUNCTION FMMPY_FM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMMPY(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1IM

   FUNCTION FMMPY_FM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1ZM

   FUNCTION FMMPY_IM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMMPY(MTLVFM,MB%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1FM

   FUNCTION FMMPY_ZM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1FM

!             (3) rank 1  *  rank 1

   FUNCTION FMMPY_FM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMMPY(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1I1

   FUNCTION FMMPY_FM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMMPY(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1R1

   FUNCTION FMMPY_FM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMMPY(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1D1

   FUNCTION FMMPY_FM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1Z1

   FUNCTION FMMPY_FM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1C1

   FUNCTION FMMPY_I1FM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_I1FM1

   FUNCTION FMMPY_R1FM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_R1FM1

   FUNCTION FMMPY_D1FM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_D1FM1

   FUNCTION FMMPY_Z1FM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_Z1FM1

   FUNCTION FMMPY_C1FM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_C1FM1

   FUNCTION FMMPY_FM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMMPY(MA(J)%MFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1FM1

   FUNCTION FMMPY_FM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MTLVFM,QX)
         CALL FMMPY(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1IM1

   FUNCTION FMMPY_FM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_FM1ZM1

   FUNCTION FMMPY_IM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMMPY(MTLVFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1FM1

   FUNCTION FMMPY_ZM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1FM1

!             (4) rank 0  *  rank 2

   FUNCTION FMMPY_IFM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IFM2

   FUNCTION FMMPY_RFM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_RFM2

   FUNCTION FMMPY_DFM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_DFM2

   FUNCTION FMMPY_ZFM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZFM2

   FUNCTION FMMPY_CFM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_CFM2

   FUNCTION FMMPY_FMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FMI2

   FUNCTION FMMPY_FMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FMR2

   FUNCTION FMMPY_FMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FMD2

   FUNCTION FMMPY_FMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FMZ2

   FUNCTION FMMPY_FMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FMC2

   FUNCTION FMMPY_FMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMMPY(MA%MFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FMFM2

   FUNCTION FMMPY_IMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMMPY(MTLVFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IMFM2

   FUNCTION FMMPY_ZMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZMFM2

   FUNCTION FMMPY_FMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MTLVFM,QX)
            CALL FMMPY(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FMIM2

   FUNCTION FMMPY_FMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMMPY(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FMZM2

!             (5) rank 2  *  rank 0

   FUNCTION FMMPY_FM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2I

   FUNCTION FMMPY_FM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2R

   FUNCTION FMMPY_FM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2D

   FUNCTION FMMPY_FM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2Z

   FUNCTION FMMPY_FM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2C

   FUNCTION FMMPY_I2FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_I2FM

   FUNCTION FMMPY_R2FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_R2FM

   FUNCTION FMMPY_D2FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_D2FM

   FUNCTION FMMPY_Z2FM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_Z2FM

   FUNCTION FMMPY_C2FM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_C2FM

   FUNCTION FMMPY_FM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MA(J,K)%MFM,MB%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2FM

   FUNCTION FMMPY_FM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2IM

   FUNCTION FMMPY_FM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2ZM

   FUNCTION FMMPY_IM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMMPY(MTLVFM,MB%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2FM

   FUNCTION FMMPY_ZM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2FM

!             (6) rank 2  *  rank 2

   FUNCTION FMMPY_FM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMMPY(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2I2

   FUNCTION FMMPY_FM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMMPY(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2R2

   FUNCTION FMMPY_FM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMMPY(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2D2

   FUNCTION FMMPY_FM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2Z2

   FUNCTION FMMPY_FM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2C2

   FUNCTION FMMPY_I2FM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_I2FM2

   FUNCTION FMMPY_R2FM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_R2FM2

   FUNCTION FMMPY_D2FM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_D2FM2

   FUNCTION FMMPY_Z2FM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_Z2FM2

   FUNCTION FMMPY_C2FM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_C2FM2

   FUNCTION FMMPY_FM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY(MA(J,K)%MFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2FM2

   FUNCTION FMMPY_FM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MTLVFM,QX)
            CALL FMMPY(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2IM2

   FUNCTION FMMPY_FM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_FM2ZM2

   FUNCTION FMMPY_IM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMMPY(MTLVFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2FM2

   FUNCTION FMMPY_ZM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2FM2

!             Array multiplication operations for IM.

!             (1) rank 0  *  rank 1

   FUNCTION FMMPY_IIM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMMPY(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_IIM1

   FUNCTION FMMPY_RIM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MULVFM,QX)
         CALL FMMPY(MTLVFM,MULVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_RIM1

   FUNCTION FMMPY_DIM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MULVFM,QX)
         CALL FMMPY(MTLVFM,MULVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_DIM1

   FUNCTION FMMPY_ZIM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZIM1

   FUNCTION FMMPY_CIM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_CIM1

   FUNCTION FMMPY_IMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMMPY(MA%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_IMI1

   FUNCTION FMMPY_IMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMMPY(MULVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IMR1

   FUNCTION FMMPY_IMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMMPY(MULVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IMD1

   FUNCTION FMMPY_IMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IMZ1

   FUNCTION FMMPY_IMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IMC1

   FUNCTION FMMPY_IMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL IMMPY(MA%MIM,MB(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_IMIM1

   FUNCTION FMMPY_ZMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
         CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZMIM1

   FUNCTION FMMPY_IMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IMZM1

!             (2) rank 1  *  rank 0

   FUNCTION FMMPY_IM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMMPY(MA(J)%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1I

   FUNCTION FMMPY_IM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL FMMPY(MVLVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1R

   FUNCTION FMMPY_IM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL FMMPY(MVLVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1D

   FUNCTION FMMPY_IM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1Z

   FUNCTION FMMPY_IM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1C

   FUNCTION FMMPY_I1IM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMMPY(MTLVIM,MA%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_I1IM

   FUNCTION FMMPY_R1IM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,MVLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_R1IM

   FUNCTION FMMPY_D1IM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,MVLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_D1IM

   FUNCTION FMMPY_Z1IM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_Z1IM

   FUNCTION FMMPY_C1IM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,M1LVFM,QX)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_C1IM

   FUNCTION FMMPY_IM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMMPY(MA(J)%MIM,MB%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1IM

   FUNCTION FMMPY_IM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMMPY(M1LVZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1ZM

   FUNCTION FMMPY_ZM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,M1LVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,M1LVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1IM

!             (3) rank 1  *  rank 1

   FUNCTION FMMPY_IM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMMPY(MA(J)%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1I1

   FUNCTION FMMPY_IM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMMPY(M1LVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1R1

   FUNCTION FMMPY_IM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMMPY(M1LVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1D1

   FUNCTION FMMPY_IM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1Z1

   FUNCTION FMMPY_IM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1C1

   FUNCTION FMMPY_I1IM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMMPY(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_I1IM1

   FUNCTION FMMPY_R1IM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,M1LVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_R1IM1

   FUNCTION FMMPY_D1IM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMMPY(MTLVFM,M1LVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMMPY_D1IM1

   FUNCTION FMMPY_Z1IM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_Z1IM1

   FUNCTION FMMPY_C1IM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_C1IM1

   FUNCTION FMMPY_IM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMMPY(MA(J)%MIM,MB(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1IM1

   FUNCTION FMMPY_IM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMMPY(M1LVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IM1ZM1

   FUNCTION FMMPY_ZM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMMPY(MA(J)%MZM,M1LVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1IM1

!             (4) rank 0  *  rank 2

   FUNCTION FMMPY_IIM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMMPY(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IIM2

   FUNCTION FMMPY_RIM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MULVFM,QX)
            CALL FMMPY(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_RIM2

   FUNCTION FMMPY_DIM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MULVFM,QX)
            CALL FMMPY(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_DIM2

   FUNCTION FMMPY_ZIM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZIM2

   FUNCTION FMMPY_CIM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_CIM2

   FUNCTION FMMPY_IMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMMPY(MA%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IMI2

   FUNCTION FMMPY_IMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMMPY(MULVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IMR2

   FUNCTION FMMPY_IMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMMPY(MULVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IMD2

   FUNCTION FMMPY_IMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IMZ2

   FUNCTION FMMPY_IMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IMC2

   FUNCTION FMMPY_IMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMMPY(MA%MIM,MB(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IMIM2

   FUNCTION FMMPY_ZMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
            CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZMIM2

   FUNCTION FMMPY_IMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMMPY(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IMZM2

!             (5) rank 2  *  rank 0

   FUNCTION FMMPY_IM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMMPY(MA(J,K)%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2I

   FUNCTION FMMPY_IM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL FMMPY(MVLVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2R

   FUNCTION FMMPY_IM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL FMMPY(MVLVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2D

   FUNCTION FMMPY_IM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2Z

   FUNCTION FMMPY_IM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2C

   FUNCTION FMMPY_I2IM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMMPY(MTLVIM,MA%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_I2IM

   FUNCTION FMMPY_R2IM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,MVLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_R2IM

   FUNCTION FMMPY_D2IM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,MVLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_D2IM

   FUNCTION FMMPY_Z2IM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_Z2IM

   FUNCTION FMMPY_C2IM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,M1LVFM,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_C2IM

   FUNCTION FMMPY_IM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMMPY(MA(J,K)%MIM,MB%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2IM

   FUNCTION FMMPY_IM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMMPY(M1LVZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2ZM

   FUNCTION FMMPY_ZM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,M1LVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,M1LVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2IM

!             (6) rank 2  *  rank 2

   FUNCTION FMMPY_IM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMMPY(MA(J,K)%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2I2

   FUNCTION FMMPY_IM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMMPY(M1LVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2R2

   FUNCTION FMMPY_IM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMMPY(M1LVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2D2

   FUNCTION FMMPY_IM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2Z2

   FUNCTION FMMPY_IM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2C2

   FUNCTION FMMPY_I2IM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMMPY(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_I2IM2

   FUNCTION FMMPY_R2IM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,M1LVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_R2IM2

   FUNCTION FMMPY_D2IM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMMPY(MTLVFM,M1LVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_D2IM2

   FUNCTION FMMPY_Z2IM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_Z2IM2

   FUNCTION FMMPY_C2IM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMMPY(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_C2IM2

   FUNCTION FMMPY_IM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMMPY(MA(J,K)%MIM,MB(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2IM2

   FUNCTION FMMPY_IM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMMPY(M1LVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IM2ZM2

   FUNCTION FMMPY_ZM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMMPY(MA(J,K)%MZM,M1LVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2IM2

!             Array multiplication operations for ZM.

!             (1) rank 0  *  rank 1

   FUNCTION FMMPY_IZM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_IZM1

   FUNCTION FMMPY_RZM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_RZM1

   FUNCTION FMMPY_DZM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_DZM1

   FUNCTION FMMPY_ZZM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZZM1

   FUNCTION FMMPY_CZM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_CZM1

   FUNCTION FMMPY_ZMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZMI1

   FUNCTION FMMPY_ZMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZMR1

   FUNCTION FMMPY_ZMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZMD1

   FUNCTION FMMPY_ZMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZMZ1

   FUNCTION FMMPY_ZMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZMC1

   FUNCTION FMMPY_ZMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL ZMMPY(MA%MZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZMZM1

!             (2) rank 1  *  rank 0

   FUNCTION FMMPY_ZM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1I

   FUNCTION FMMPY_ZM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1R

   FUNCTION FMMPY_ZM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1D

   FUNCTION FMMPY_ZM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1Z

   FUNCTION FMMPY_ZM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1C

   FUNCTION FMMPY_I1ZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_I1ZM

   FUNCTION FMMPY_R1ZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_R1ZM

   FUNCTION FMMPY_D1ZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_D1ZM

   FUNCTION FMMPY_Z1ZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_Z1ZM

   FUNCTION FMMPY_C1ZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_C1ZM

   FUNCTION FMMPY_ZM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1ZM

!             (3) rank 1  *  rank 1

   FUNCTION FMMPY_ZM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1I1

   FUNCTION FMMPY_ZM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1R1

   FUNCTION FMMPY_ZM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1D1

   FUNCTION FMMPY_ZM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1Z1

   FUNCTION FMMPY_ZM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1C1

   FUNCTION FMMPY_I1ZM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_I1ZM1

   FUNCTION FMMPY_R1ZM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_R1ZM1

   FUNCTION FMMPY_D1ZM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_D1ZM1

   FUNCTION FMMPY_Z1ZM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_Z1ZM1

   FUNCTION FMMPY_C1ZM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMMPY(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_C1ZM1

   FUNCTION FMMPY_ZM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMMPY(MA(J)%MZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMMPY_ZM1ZM1

!             (4) rank 0  *  rank 2

   FUNCTION FMMPY_IZM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_IZM2

   FUNCTION FMMPY_RZM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_RZM2

   FUNCTION FMMPY_DZM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_DZM2

   FUNCTION FMMPY_ZZM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZZM2

   FUNCTION FMMPY_CZM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_CZM2

   FUNCTION FMMPY_ZMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZMI2

   FUNCTION FMMPY_ZMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZMR2

   FUNCTION FMMPY_ZMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZMD2

   FUNCTION FMMPY_ZMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZMZ2

   FUNCTION FMMPY_ZMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZMC2

   FUNCTION FMMPY_ZMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMMPY(MA%MZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZMZM2

!             (5) rank 2  *  rank 0

   FUNCTION FMMPY_ZM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2I

   FUNCTION FMMPY_ZM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2R

   FUNCTION FMMPY_ZM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2D

   FUNCTION FMMPY_ZM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2Z

   FUNCTION FMMPY_ZM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2C

   FUNCTION FMMPY_I2ZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_I2ZM

   FUNCTION FMMPY_R2ZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_R2ZM

   FUNCTION FMMPY_D2ZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_D2ZM

   FUNCTION FMMPY_Z2ZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_Z2ZM

   FUNCTION FMMPY_C2ZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_C2ZM

   FUNCTION FMMPY_ZM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2ZM

!             (6) rank 2  *  rank 2

   FUNCTION FMMPY_ZM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2I2

   FUNCTION FMMPY_ZM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2R2

   FUNCTION FMMPY_ZM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2D2

   FUNCTION FMMPY_ZM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2Z2

   FUNCTION FMMPY_ZM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2C2

   FUNCTION FMMPY_I2ZM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_I2ZM2

   FUNCTION FMMPY_R2ZM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_R2ZM2

   FUNCTION FMMPY_D2ZM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_D2ZM2

   FUNCTION FMMPY_Z2ZM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_Z2ZM2

   FUNCTION FMMPY_C2ZM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMMPY(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_C2ZM2

   FUNCTION FMMPY_ZM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMMPY(MA(J,K)%MZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMMPY_ZM2ZM2

 END MODULE FMZM_6_PARALLEL

 MODULE FMZM_7_PARALLEL
    USE FMZM_1_PARALLEL

    INTERFACE OPERATOR (/)
       MODULE PROCEDURE FMDIV_IFM
       MODULE PROCEDURE FMDIV_IIM
       MODULE PROCEDURE FMDIV_IZM
       MODULE PROCEDURE FMDIV_RFM
       MODULE PROCEDURE FMDIV_RIM
       MODULE PROCEDURE FMDIV_RZM
       MODULE PROCEDURE FMDIV_DFM
       MODULE PROCEDURE FMDIV_DIM
       MODULE PROCEDURE FMDIV_DZM
       MODULE PROCEDURE FMDIV_ZFM
       MODULE PROCEDURE FMDIV_ZIM
       MODULE PROCEDURE FMDIV_ZZM
       MODULE PROCEDURE FMDIV_CFM
       MODULE PROCEDURE FMDIV_CIM
       MODULE PROCEDURE FMDIV_CZM
       MODULE PROCEDURE FMDIV_FMI
       MODULE PROCEDURE FMDIV_FMR
       MODULE PROCEDURE FMDIV_FMD
       MODULE PROCEDURE FMDIV_FMZ
       MODULE PROCEDURE FMDIV_FMC
       MODULE PROCEDURE FMDIV_FMFM
       MODULE PROCEDURE FMDIV_FMIM
       MODULE PROCEDURE FMDIV_FMZM
       MODULE PROCEDURE FMDIV_IMI
       MODULE PROCEDURE FMDIV_IMR
       MODULE PROCEDURE FMDIV_IMD
       MODULE PROCEDURE FMDIV_IMZ
       MODULE PROCEDURE FMDIV_IMC
       MODULE PROCEDURE FMDIV_IMFM
       MODULE PROCEDURE FMDIV_IMIM
       MODULE PROCEDURE FMDIV_IMZM
       MODULE PROCEDURE FMDIV_ZMI
       MODULE PROCEDURE FMDIV_ZMR
       MODULE PROCEDURE FMDIV_ZMD
       MODULE PROCEDURE FMDIV_ZMZ
       MODULE PROCEDURE FMDIV_ZMC
       MODULE PROCEDURE FMDIV_ZMFM
       MODULE PROCEDURE FMDIV_ZMIM
       MODULE PROCEDURE FMDIV_ZMZM
       MODULE PROCEDURE FMDIV_IFM1
       MODULE PROCEDURE FMDIV_RFM1
       MODULE PROCEDURE FMDIV_DFM1
       MODULE PROCEDURE FMDIV_ZFM1
       MODULE PROCEDURE FMDIV_CFM1
       MODULE PROCEDURE FMDIV_FMI1
       MODULE PROCEDURE FMDIV_FMR1
       MODULE PROCEDURE FMDIV_FMD1
       MODULE PROCEDURE FMDIV_FMZ1
       MODULE PROCEDURE FMDIV_FMC1
       MODULE PROCEDURE FMDIV_FMFM1
       MODULE PROCEDURE FMDIV_IMFM1
       MODULE PROCEDURE FMDIV_ZMFM1
       MODULE PROCEDURE FMDIV_FMIM1
       MODULE PROCEDURE FMDIV_FMZM1
       MODULE PROCEDURE FMDIV_FM1I
       MODULE PROCEDURE FMDIV_FM1R
       MODULE PROCEDURE FMDIV_FM1D
       MODULE PROCEDURE FMDIV_FM1Z
       MODULE PROCEDURE FMDIV_FM1C
       MODULE PROCEDURE FMDIV_I1FM
       MODULE PROCEDURE FMDIV_R1FM
       MODULE PROCEDURE FMDIV_D1FM
       MODULE PROCEDURE FMDIV_Z1FM
       MODULE PROCEDURE FMDIV_C1FM
       MODULE PROCEDURE FMDIV_FM1FM
       MODULE PROCEDURE FMDIV_FM1IM
       MODULE PROCEDURE FMDIV_FM1ZM
       MODULE PROCEDURE FMDIV_IM1FM
       MODULE PROCEDURE FMDIV_ZM1FM
       MODULE PROCEDURE FMDIV_I1FM1
       MODULE PROCEDURE FMDIV_R1FM1
       MODULE PROCEDURE FMDIV_D1FM1
       MODULE PROCEDURE FMDIV_Z1FM1
       MODULE PROCEDURE FMDIV_C1FM1
       MODULE PROCEDURE FMDIV_FM1I1
       MODULE PROCEDURE FMDIV_FM1R1
       MODULE PROCEDURE FMDIV_FM1D1
       MODULE PROCEDURE FMDIV_FM1Z1
       MODULE PROCEDURE FMDIV_FM1C1
       MODULE PROCEDURE FMDIV_FM1FM1
       MODULE PROCEDURE FMDIV_IM1FM1
       MODULE PROCEDURE FMDIV_ZM1FM1
       MODULE PROCEDURE FMDIV_FM1IM1
       MODULE PROCEDURE FMDIV_FM1ZM1
       MODULE PROCEDURE FMDIV_IIM1
       MODULE PROCEDURE FMDIV_RIM1
       MODULE PROCEDURE FMDIV_DIM1
       MODULE PROCEDURE FMDIV_ZIM1
       MODULE PROCEDURE FMDIV_CIM1
       MODULE PROCEDURE FMDIV_IMI1
       MODULE PROCEDURE FMDIV_IMR1
       MODULE PROCEDURE FMDIV_IMD1
       MODULE PROCEDURE FMDIV_IMZ1
       MODULE PROCEDURE FMDIV_IMC1
       MODULE PROCEDURE FMDIV_IMIM1
       MODULE PROCEDURE FMDIV_ZMIM1
       MODULE PROCEDURE FMDIV_IMZM1
       MODULE PROCEDURE FMDIV_IM1I
       MODULE PROCEDURE FMDIV_IM1R
       MODULE PROCEDURE FMDIV_IM1D
       MODULE PROCEDURE FMDIV_IM1Z
       MODULE PROCEDURE FMDIV_IM1C
       MODULE PROCEDURE FMDIV_I1IM
       MODULE PROCEDURE FMDIV_R1IM
       MODULE PROCEDURE FMDIV_D1IM
       MODULE PROCEDURE FMDIV_Z1IM
       MODULE PROCEDURE FMDIV_C1IM
       MODULE PROCEDURE FMDIV_IM1IM
       MODULE PROCEDURE FMDIV_IM1ZM
       MODULE PROCEDURE FMDIV_ZM1IM
       MODULE PROCEDURE FMDIV_I1IM1
       MODULE PROCEDURE FMDIV_R1IM1
       MODULE PROCEDURE FMDIV_D1IM1
       MODULE PROCEDURE FMDIV_Z1IM1
       MODULE PROCEDURE FMDIV_C1IM1
       MODULE PROCEDURE FMDIV_IM1I1
       MODULE PROCEDURE FMDIV_IM1R1
       MODULE PROCEDURE FMDIV_IM1D1
       MODULE PROCEDURE FMDIV_IM1Z1
       MODULE PROCEDURE FMDIV_IM1C1
       MODULE PROCEDURE FMDIV_IM1IM1
       MODULE PROCEDURE FMDIV_ZM1IM1
       MODULE PROCEDURE FMDIV_IM1ZM1
       MODULE PROCEDURE FMDIV_IZM1
       MODULE PROCEDURE FMDIV_RZM1
       MODULE PROCEDURE FMDIV_DZM1
       MODULE PROCEDURE FMDIV_ZZM1
       MODULE PROCEDURE FMDIV_CZM1
       MODULE PROCEDURE FMDIV_ZMI1
       MODULE PROCEDURE FMDIV_ZMR1
       MODULE PROCEDURE FMDIV_ZMD1
       MODULE PROCEDURE FMDIV_ZMZ1
       MODULE PROCEDURE FMDIV_ZMC1
       MODULE PROCEDURE FMDIV_ZMZM1
       MODULE PROCEDURE FMDIV_ZM1I
       MODULE PROCEDURE FMDIV_ZM1R
       MODULE PROCEDURE FMDIV_ZM1D
       MODULE PROCEDURE FMDIV_ZM1Z
       MODULE PROCEDURE FMDIV_ZM1C
       MODULE PROCEDURE FMDIV_I1ZM
       MODULE PROCEDURE FMDIV_R1ZM
       MODULE PROCEDURE FMDIV_D1ZM
       MODULE PROCEDURE FMDIV_Z1ZM
       MODULE PROCEDURE FMDIV_C1ZM
       MODULE PROCEDURE FMDIV_ZM1ZM
       MODULE PROCEDURE FMDIV_I1ZM1
       MODULE PROCEDURE FMDIV_R1ZM1
       MODULE PROCEDURE FMDIV_D1ZM1
       MODULE PROCEDURE FMDIV_Z1ZM1
       MODULE PROCEDURE FMDIV_C1ZM1
       MODULE PROCEDURE FMDIV_ZM1I1
       MODULE PROCEDURE FMDIV_ZM1R1
       MODULE PROCEDURE FMDIV_ZM1D1
       MODULE PROCEDURE FMDIV_ZM1Z1
       MODULE PROCEDURE FMDIV_ZM1C1
       MODULE PROCEDURE FMDIV_ZM1ZM1
       MODULE PROCEDURE FMDIV_IFM2
       MODULE PROCEDURE FMDIV_RFM2
       MODULE PROCEDURE FMDIV_DFM2
       MODULE PROCEDURE FMDIV_ZFM2
       MODULE PROCEDURE FMDIV_CFM2
       MODULE PROCEDURE FMDIV_FMI2
       MODULE PROCEDURE FMDIV_FMR2
       MODULE PROCEDURE FMDIV_FMD2
       MODULE PROCEDURE FMDIV_FMZ2
       MODULE PROCEDURE FMDIV_FMC2
       MODULE PROCEDURE FMDIV_FMFM2
       MODULE PROCEDURE FMDIV_IMFM2
       MODULE PROCEDURE FMDIV_ZMFM2
       MODULE PROCEDURE FMDIV_FMIM2
       MODULE PROCEDURE FMDIV_FMZM2
       MODULE PROCEDURE FMDIV_FM2I
       MODULE PROCEDURE FMDIV_FM2R
       MODULE PROCEDURE FMDIV_FM2D
       MODULE PROCEDURE FMDIV_FM2Z
       MODULE PROCEDURE FMDIV_FM2C
       MODULE PROCEDURE FMDIV_I2FM
       MODULE PROCEDURE FMDIV_R2FM
       MODULE PROCEDURE FMDIV_D2FM
       MODULE PROCEDURE FMDIV_Z2FM
       MODULE PROCEDURE FMDIV_C2FM
       MODULE PROCEDURE FMDIV_FM2FM
       MODULE PROCEDURE FMDIV_FM2IM
       MODULE PROCEDURE FMDIV_FM2ZM
       MODULE PROCEDURE FMDIV_IM2FM
       MODULE PROCEDURE FMDIV_ZM2FM
       MODULE PROCEDURE FMDIV_I2FM2
       MODULE PROCEDURE FMDIV_R2FM2
       MODULE PROCEDURE FMDIV_D2FM2
       MODULE PROCEDURE FMDIV_Z2FM2
       MODULE PROCEDURE FMDIV_C2FM2
       MODULE PROCEDURE FMDIV_FM2I2
       MODULE PROCEDURE FMDIV_FM2R2
       MODULE PROCEDURE FMDIV_FM2D2
       MODULE PROCEDURE FMDIV_FM2Z2
       MODULE PROCEDURE FMDIV_FM2C2
       MODULE PROCEDURE FMDIV_FM2FM2
       MODULE PROCEDURE FMDIV_IM2FM2
       MODULE PROCEDURE FMDIV_ZM2FM2
       MODULE PROCEDURE FMDIV_FM2IM2
       MODULE PROCEDURE FMDIV_FM2ZM2
       MODULE PROCEDURE FMDIV_IIM2
       MODULE PROCEDURE FMDIV_RIM2
       MODULE PROCEDURE FMDIV_DIM2
       MODULE PROCEDURE FMDIV_ZIM2
       MODULE PROCEDURE FMDIV_CIM2
       MODULE PROCEDURE FMDIV_IMI2
       MODULE PROCEDURE FMDIV_IMR2
       MODULE PROCEDURE FMDIV_IMD2
       MODULE PROCEDURE FMDIV_IMZ2
       MODULE PROCEDURE FMDIV_IMC2
       MODULE PROCEDURE FMDIV_IMIM2
       MODULE PROCEDURE FMDIV_ZMIM2
       MODULE PROCEDURE FMDIV_IMZM2
       MODULE PROCEDURE FMDIV_IM2I
       MODULE PROCEDURE FMDIV_IM2R
       MODULE PROCEDURE FMDIV_IM2D
       MODULE PROCEDURE FMDIV_IM2Z
       MODULE PROCEDURE FMDIV_IM2C
       MODULE PROCEDURE FMDIV_I2IM
       MODULE PROCEDURE FMDIV_R2IM
       MODULE PROCEDURE FMDIV_D2IM
       MODULE PROCEDURE FMDIV_Z2IM
       MODULE PROCEDURE FMDIV_C2IM
       MODULE PROCEDURE FMDIV_IM2IM
       MODULE PROCEDURE FMDIV_IM2ZM
       MODULE PROCEDURE FMDIV_ZM2IM
       MODULE PROCEDURE FMDIV_I2IM2
       MODULE PROCEDURE FMDIV_R2IM2
       MODULE PROCEDURE FMDIV_D2IM2
       MODULE PROCEDURE FMDIV_Z2IM2
       MODULE PROCEDURE FMDIV_C2IM2
       MODULE PROCEDURE FMDIV_IM2I2
       MODULE PROCEDURE FMDIV_IM2R2
       MODULE PROCEDURE FMDIV_IM2D2
       MODULE PROCEDURE FMDIV_IM2Z2
       MODULE PROCEDURE FMDIV_IM2C2
       MODULE PROCEDURE FMDIV_IM2IM2
       MODULE PROCEDURE FMDIV_ZM2IM2
       MODULE PROCEDURE FMDIV_IM2ZM2
       MODULE PROCEDURE FMDIV_IZM2
       MODULE PROCEDURE FMDIV_RZM2
       MODULE PROCEDURE FMDIV_DZM2
       MODULE PROCEDURE FMDIV_ZZM2
       MODULE PROCEDURE FMDIV_CZM2
       MODULE PROCEDURE FMDIV_ZMI2
       MODULE PROCEDURE FMDIV_ZMR2
       MODULE PROCEDURE FMDIV_ZMD2
       MODULE PROCEDURE FMDIV_ZMZ2
       MODULE PROCEDURE FMDIV_ZMC2
       MODULE PROCEDURE FMDIV_ZMZM2
       MODULE PROCEDURE FMDIV_ZM2I
       MODULE PROCEDURE FMDIV_ZM2R
       MODULE PROCEDURE FMDIV_ZM2D
       MODULE PROCEDURE FMDIV_ZM2Z
       MODULE PROCEDURE FMDIV_ZM2C
       MODULE PROCEDURE FMDIV_I2ZM
       MODULE PROCEDURE FMDIV_R2ZM
       MODULE PROCEDURE FMDIV_D2ZM
       MODULE PROCEDURE FMDIV_Z2ZM
       MODULE PROCEDURE FMDIV_C2ZM
       MODULE PROCEDURE FMDIV_ZM2ZM
       MODULE PROCEDURE FMDIV_I2ZM2
       MODULE PROCEDURE FMDIV_R2ZM2
       MODULE PROCEDURE FMDIV_D2ZM2
       MODULE PROCEDURE FMDIV_Z2ZM2
       MODULE PROCEDURE FMDIV_C2ZM2
       MODULE PROCEDURE FMDIV_ZM2I2
       MODULE PROCEDURE FMDIV_ZM2R2
       MODULE PROCEDURE FMDIV_ZM2D2
       MODULE PROCEDURE FMDIV_ZM2Z2
       MODULE PROCEDURE FMDIV_ZM2C2
       MODULE PROCEDURE FMDIV_ZM2ZM2
    END INTERFACE

 CONTAINS

!                                                                   /

   FUNCTION FMDIV_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_IFM

   FUNCTION FMDIV_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      CALL IMDIV(MTLVIM,MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMDIV_IIM

   FUNCTION FMDIV_IZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_IZM

   FUNCTION FMDIV_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_RFM

   FUNCTION FMDIV_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMDIV(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_RIM

   FUNCTION FMDIV_RZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_RZM

   FUNCTION FMDIV_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_DFM

   FUNCTION FMDIV_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMDIV(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_DIM

   FUNCTION FMDIV_DZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_DZM

   FUNCTION FMDIV_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZFM

   FUNCTION FMDIV_ZIM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZIM

   FUNCTION FMDIV_ZZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZZM

   FUNCTION FMDIV_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_CFM

   FUNCTION FMDIV_CIM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_CIM

   FUNCTION FMDIV_CZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_CZM

   FUNCTION FMDIV_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIVI(MA%MFM,IVAL,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_FMI

   FUNCTION FMDIV_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_FMR

   FUNCTION FMDIV_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_FMD

   FUNCTION FMDIV_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_FMZ

   FUNCTION FMDIV_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_FMC

   FUNCTION FMDIV_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIV(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_FMFM

   FUNCTION FMDIV_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_FMIM

   FUNCTION FMDIV_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMDIV(MTLVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_FMZM

   FUNCTION FMDIV_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMDIVI(MA%MIM,IVAL,RETURN_VALUE%MIM,QX)
   END FUNCTION FMDIV_IMI

   FUNCTION FMDIV_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMDIV(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_IMR

   FUNCTION FMDIV_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMDIV(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_IMD

   FUNCTION FMDIV_IMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_IMZ

   FUNCTION FMDIV_IMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_IMC

   FUNCTION FMDIV_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMDIV(MTLVFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIV_IMFM

   FUNCTION FMDIV_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMDIV(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMDIV_IMIM

   FUNCTION FMDIV_IMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MULVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_IMZM

   FUNCTION FMDIV_ZMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMDIVI(MA%MZM,IVAL,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZMI

   FUNCTION FMDIV_ZMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZMR

   FUNCTION FMDIV_ZMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZMD

   FUNCTION FMDIV_ZMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZMZ

   FUNCTION FMDIV_ZMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZMC

   FUNCTION FMDIV_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZMFM

   FUNCTION FMDIV_ZMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMDIV(MA%MZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZMIM

   FUNCTION FMDIV_ZMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMDIV(MA%MZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDIV_ZMZM

!             Array division operations for FM.

!             (1) rank 0  /  rank 1

   FUNCTION FMDIV_IFM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMDIV(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IFM1

   FUNCTION FMDIV_RFM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMDIV(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_RFM1

   FUNCTION FMDIV_DFM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMDIV(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_DFM1

   FUNCTION FMDIV_ZFM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZFM1

   FUNCTION FMDIV_CFM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_CFM1

   FUNCTION FMDIV_FMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FMI1

   FUNCTION FMDIV_FMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FMR1

   FUNCTION FMDIV_FMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FMD1

   FUNCTION FMDIV_FMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FMZ1

   FUNCTION FMDIV_FMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FMC1

   FUNCTION FMDIV_FMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL FMDIV(MA%MFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FMFM1

   FUNCTION FMDIV_IMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMDIV(MTLVFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IMFM1

   FUNCTION FMDIV_ZMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N	
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZMFM1

   FUNCTION FMDIV_FMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MTLVFM,QX)
         CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FMIM1

   FUNCTION FMDIV_FMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FMZM1

!             (2) rank 1  /  rank 0

   FUNCTION FMDIV_FM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, N
         CALL FMDIV(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1I

   FUNCTION FMDIV_FM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL FMDIV(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1R

   FUNCTION FMDIV_FM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL FMDIV(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1D

   FUNCTION FMDIV_FM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1Z

   FUNCTION FMDIV_FM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1C

   FUNCTION FMDIV_I1FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_I1FM

   FUNCTION FMDIV_R1FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_R1FM

   FUNCTION FMDIV_D1FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_D1FM

   FUNCTION FMDIV_Z1FM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_Z1FM

   FUNCTION FMDIV_C1FM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_C1FM

   FUNCTION FMDIV_FM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDIV(MA(J)%MFM,MB%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1FM

   FUNCTION FMDIV_FM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, N
         CALL FMDIV(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1IM

   FUNCTION FMDIV_FM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1ZM

   FUNCTION FMDIV_IM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMDIV(MTLVFM,MB%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1FM

   FUNCTION FMDIV_ZM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1FM

!             (3) rank 1  /  rank 1

   FUNCTION FMDIV_FM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMDIV(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1I1

   FUNCTION FMDIV_FM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMDIV(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1R1

   FUNCTION FMDIV_FM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMDIV(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1D1

   FUNCTION FMDIV_FM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1Z1

   FUNCTION FMDIV_FM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1C1

   FUNCTION FMDIV_I1FM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_I1FM1

   FUNCTION FMDIV_R1FM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_R1FM1

   FUNCTION FMDIV_D1FM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_D1FM1

   FUNCTION FMDIV_Z1FM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_Z1FM1

   FUNCTION FMDIV_C1FM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MA(J)%MFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_C1FM1

   FUNCTION FMDIV_FM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDIV(MA(J)%MFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1FM1

   FUNCTION FMDIV_FM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MTLVFM,QX)
         CALL FMDIV(MA(J)%MFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1IM1

   FUNCTION FMDIV_FM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MA(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_FM1ZM1

   FUNCTION FMDIV_IM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL FMDIV(MTLVFM,MB(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1FM1

   FUNCTION FMDIV_ZM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL ZMCMPX(MB(J)%MFM,MTLVFM,MTLVZM,QX)
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1FM1

!             (4) rank 0  /  rank 2

   FUNCTION FMDIV_IFM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IFM2

   FUNCTION FMDIV_RFM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_RFM2

   FUNCTION FMDIV_DFM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_DFM2

   FUNCTION FMDIV_ZFM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZFM2

   FUNCTION FMDIV_CFM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_CFM2

   FUNCTION FMDIV_FMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FMI2

   FUNCTION FMDIV_FMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FMR2

   FUNCTION FMDIV_FMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FMD2

   FUNCTION FMDIV_FMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FMZ2

   FUNCTION FMDIV_FMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FMC2

   FUNCTION FMDIV_FMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMDIV(MA%MFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FMFM2

   FUNCTION FMDIV_IMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMDIV(MTLVFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IMFM2

   FUNCTION FMDIV_ZMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZMFM2

   FUNCTION FMDIV_FMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MTLVFM,QX)
            CALL FMDIV(MA%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FMIM2

   FUNCTION FMDIV_FMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMDIV(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FMZM2

!             (5) rank 2  /  rank 0

   FUNCTION FMDIV_FM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2I

   FUNCTION FMDIV_FM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2R

   FUNCTION FMDIV_FM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2D

   FUNCTION FMDIV_FM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2Z

   FUNCTION FMDIV_FM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2C

   FUNCTION FMDIV_I2FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_I2FM

   FUNCTION FMDIV_R2FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_R2FM

   FUNCTION FMDIV_D2FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,MA%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_D2FM

   FUNCTION FMDIV_Z2FM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_Z2FM

   FUNCTION FMDIV_C2FM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_C2FM

   FUNCTION FMDIV_FM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MA(J,K)%MFM,MB%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2FM

   FUNCTION FMDIV_FM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2IM

   FUNCTION FMDIV_FM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2ZM

   FUNCTION FMDIV_IM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMDIV(MTLVFM,MB%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2FM

   FUNCTION FMDIV_ZM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2FM

!             (6) rank 2  /  rank 2

   FUNCTION FMDIV_FM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMDIV(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2I2

   FUNCTION FMDIV_FM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMDIV(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2R2

   FUNCTION FMDIV_FM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMDIV(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2D2

   FUNCTION FMDIV_FM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2Z2

   FUNCTION FMDIV_FM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2C2

   FUNCTION FMDIV_I2FM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_I2FM2

   FUNCTION FMDIV_R2FM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_R2FM2

   FUNCTION FMDIV_D2FM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_D2FM2

   FUNCTION FMDIV_Z2FM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_Z2FM2

   FUNCTION FMDIV_C2FM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MA(J,K)%MFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_C2FM2

   FUNCTION FMDIV_FM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV(MA(J,K)%MFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2FM2

   FUNCTION FMDIV_FM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MTLVFM,QX)
            CALL FMDIV(MA(J,K)%MFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2IM2

   FUNCTION FMDIV_FM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MA(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_FM2ZM2

   FUNCTION FMDIV_IM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL FMDIV(MTLVFM,MB(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2FM2

   FUNCTION FMDIV_ZM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX(MB(J,K)%MFM,MTLVFM,MTLVZM,QX)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2FM2

!             Array division operations for IM.

!             (1) rank 0  /  rank 1

   FUNCTION FMDIV_IIM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMDIV(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_IIM1

   FUNCTION FMDIV_RIM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MULVFM,QX)
         CALL FMDIV(MTLVFM,MULVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_RIM1

   FUNCTION FMDIV_DIM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MULVFM,QX)
         CALL FMDIV(MTLVFM,MULVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_DIM1

   FUNCTION FMDIV_ZIM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZIM1

   FUNCTION FMDIV_CIM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_CIM1

   FUNCTION FMDIV_IMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMDIV(MA%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_IMI1

   FUNCTION FMDIV_IMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMDIV(MULVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IMR1

   FUNCTION FMDIV_IMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMDIV(MULVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IMD1

   FUNCTION FMDIV_IMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IMZ1

   FUNCTION FMDIV_IMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IMC1

   FUNCTION FMDIV_IMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL IMDIV(MA%MIM,MB(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_IMIM1

   FUNCTION FMDIV_ZMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
         CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZMIM1

   FUNCTION FMDIV_IMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MTLVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IMZM1

!             (2) rank 1  /  rank 0

   FUNCTION FMDIV_IM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, N
         CALL IMDIV(MA(J)%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1I

   FUNCTION FMDIV_IM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL FMDIV(MVLVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1R

   FUNCTION FMDIV_IM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL FMDIV(MVLVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1D

   FUNCTION FMDIV_IM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1Z

   FUNCTION FMDIV_IM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,MVLVFM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1C

   FUNCTION FMDIV_I1IM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMDIV(MTLVIM,MA%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_I1IM

   FUNCTION FMDIV_R1IM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,MVLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_R1IM

   FUNCTION FMDIV_D1IM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,MVLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_D1IM

   FUNCTION FMDIV_Z1IM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_Z1IM

   FUNCTION FMDIV_C1IM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      CALL IMI2FM(MA%MIM,M1LVFM,QX)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_C1IM

   FUNCTION FMDIV_IM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMDIV(MA(J)%MIM,MB%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1IM

   FUNCTION FMDIV_IM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMDIV(M1LVZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1ZM

   FUNCTION FMDIV_ZM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL IMI2FM(MB%MIM,M1LVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,M1LVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1IM

!             (3) rank 1  /  rank 1

   FUNCTION FMDIV_IM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMDIV(MA(J)%MIM,MTLVIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1I1

   FUNCTION FMDIV_IM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDIV(M1LVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1R1

   FUNCTION FMDIV_IM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDIV(M1LVFM,MTLVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1D1

   FUNCTION FMDIV_IM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1Z1

   FUNCTION FMDIV_IM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1C1

   FUNCTION FMDIV_I1IM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMI2M(IVAL(J),MTLVIM,QX)
         CALL IMDIV(MTLVIM,MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_I1IM1

   FUNCTION FMDIV_R1IM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,M1LVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_R1IM1

   FUNCTION FMDIV_D1IM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J)%MFM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL FMDIV(MTLVFM,M1LVFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMDIV_D1IM1

   FUNCTION FMDIV_Z1IM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_Z1IM1

   FUNCTION FMDIV_C1IM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL FMI2M(0,MULVFM,QX)
         CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
         CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_C1IM1

   FUNCTION FMDIV_IM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMDIV(MA(J)%MIM,MB(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1IM1

   FUNCTION FMDIV_IM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MA(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMDIV(M1LVZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IM1ZM1

   FUNCTION FMDIV_ZM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, N
         CALL IMI2FM(MB(J)%MIM,M1LVFM,QX)
         CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
         CALL ZMDIV(MA(J)%MZM,M1LVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1IM1

!             (4) rank 0  /  rank 2

   FUNCTION FMDIV_IIM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMDIV(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IIM2

   FUNCTION FMDIV_RIM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MULVFM,QX)
            CALL FMDIV(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_RIM2

   FUNCTION FMDIV_DIM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MULVFM,QX)
            CALL FMDIV(MTLVFM,MULVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_DIM2

   FUNCTION FMDIV_ZIM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZIM2

   FUNCTION FMDIV_CIM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_CIM2

   FUNCTION FMDIV_IMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMDIV(MA%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IMI2

   FUNCTION FMDIV_IMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMDIV(MULVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IMR2

   FUNCTION FMDIV_IMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMDIV(MULVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IMD2

   FUNCTION FMDIV_IMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IMZ2

   FUNCTION FMDIV_IMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IMC2

   FUNCTION FMDIV_IMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMDIV(MA%MIM,MB(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IMIM2

   FUNCTION FMDIV_ZMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
            CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZMIM2

   FUNCTION FMDIV_IMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MVLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MVLVFM,MTLVFM,MTLVZM,QX)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMDIV(MTLVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IMZM2

!             (5) rank 2  /  rank 0

   FUNCTION FMDIV_IM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMDIV(MA(J,K)%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2I

   FUNCTION FMDIV_IM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL FMDIV(MVLVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2R

   FUNCTION FMDIV_IM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL FMDIV(MVLVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2D

   FUNCTION FMDIV_IM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2Z

   FUNCTION FMDIV_IM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,MVLVFM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2C

   FUNCTION FMDIV_I2IM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMDIV(MTLVIM,MA%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_I2IM

   FUNCTION FMDIV_R2IM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,MVLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_R2IM

   FUNCTION FMDIV_D2IM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,MVLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_D2IM

   FUNCTION FMDIV_Z2IM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MVLVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MVLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMCMPX(MVLVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_Z2IM

   FUNCTION FMDIV_C2IM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,M1LVFM,QX)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_C2IM

   FUNCTION FMDIV_IM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMDIV(MA(J,K)%MIM,MB%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2IM

   FUNCTION FMDIV_IM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMDIV(M1LVZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2ZM

   FUNCTION FMDIV_ZM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,M1LVFM,QX)
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,M1LVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2IM

!             (6) rank 2  /  rank 2

   FUNCTION FMDIV_IM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMDIV(MA(J,K)%MIM,MTLVIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2I2

   FUNCTION FMDIV_IM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDIV(M1LVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2R2

   FUNCTION FMDIV_IM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDIV(M1LVFM,MTLVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2D2

   FUNCTION FMDIV_IM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2Z2

   FUNCTION FMDIV_IM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MULVZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2C2

   FUNCTION FMDIV_I2IM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2M(IVAL(J,K),MTLVIM,QX)
            CALL IMDIV(MTLVIM,MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_I2IM2

   FUNCTION FMDIV_R2IM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,M1LVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_R2IM2

   FUNCTION FMDIV_D2IM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,M1LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MFM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL FMDIV(MTLVFM,M1LVFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_D2IM2

   FUNCTION FMDIV_Z2IM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_Z2IM2

   FUNCTION FMDIV_C2IM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,M1LVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL FMI2M(0,MULVFM,QX)
            CALL ZMCMPX(M1LVFM,MULVFM,MULVZM,QX)
            CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_C2IM2

   FUNCTION FMDIV_IM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMDIV(MA(J,K)%MIM,MB(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2IM2

   FUNCTION FMDIV_IM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MA(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMDIV(M1LVZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IM2ZM2

   FUNCTION FMDIV_ZM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,M1LVFM,M1LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MTLVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM(MB(J,K)%MIM,M1LVFM,QX)
            CALL ZMCMPX(M1LVFM,MTLVFM,M1LVZM,QX)
            CALL ZMDIV(MA(J,K)%MZM,M1LVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2IM2

!             Array division operations for ZM.

!             (1) rank 0  /  rank 1

   FUNCTION FMDIV_IZM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_IZM1

   FUNCTION FMDIV_RZM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_RZM1

   FUNCTION FMDIV_DZM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_DZM1

   FUNCTION FMDIV_ZZM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZZM1

   FUNCTION FMDIV_CZM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_CZM1

   FUNCTION FMDIV_ZMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZMI1

   FUNCTION FMDIV_ZMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZMR1

   FUNCTION FMDIV_ZMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZMD1

   FUNCTION FMDIV_ZMZ1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZMZ1

   FUNCTION FMDIV_ZMC1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZMC1

   FUNCTION FMDIV_ZMZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MB)
      DO J = 1, N
         CALL ZMDIV(MA%MZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZMZM1

!             (2) rank 1  /  rank 0

   FUNCTION FMDIV_ZM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1I

   FUNCTION FMDIV_ZM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1R

   FUNCTION FMDIV_ZM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1D

   FUNCTION FMDIV_ZM1Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1Z

   FUNCTION FMDIV_ZM1C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1C

   FUNCTION FMDIV_I1ZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_I1ZM

   FUNCTION FMDIV_R1ZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_R1ZM

   FUNCTION FMDIV_D1ZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_D1ZM

   FUNCTION FMDIV_Z1ZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_Z1ZM

   FUNCTION FMDIV_C1ZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_C1ZM

   FUNCTION FMDIV_ZM1ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,MB%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1ZM

!             (3) rank 1  /  rank 1

   FUNCTION FMDIV_ZM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMI2M(IVAL(J),MTLVZM,QX)
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1I1

   FUNCTION FMDIV_ZM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1R1

   FUNCTION FMDIV_ZM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1D1

   FUNCTION FMDIV_ZM1Z1(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1Z1

   FUNCTION FMDIV_ZM1C1(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MA(J)%MZM,MTLVZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1C1

   FUNCTION FMDIV_I1ZM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMI2M(IVAL(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_I1ZM1

   FUNCTION FMDIV_R1ZM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (ZM), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMSP2M(R(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_R1ZM1

   FUNCTION FMDIV_D1ZM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (ZM), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, N
         CALL FMDP2M(D(J),MTLVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_D1ZM1

   FUNCTION FMDIV_Z1ZM1(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(Z)
      DO J = 1, N
         CALL ZMZ2M(Z(J),MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_Z1ZM1

   FUNCTION FMDIV_C1ZM1(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (ZM), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M(REAL(C(J),KIND(0.0D0)),MTLVFM,QX)
         CALL FMDP2M(AIMAG(C(J)),MULVFM,QX)
         CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
         CALL ZMDIV(MTLVZM,MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_C1ZM1

   FUNCTION FMDIV_ZM1ZM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J)%MZM,QX)
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMDIV(MA(J)%MZM,MB(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMDIV_ZM1ZM1

!             (4) rank 0  /  rank 2

   FUNCTION FMDIV_IZM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(IVAL,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_IZM2

   FUNCTION FMDIV_RZM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_RZM2

   FUNCTION FMDIV_DZM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_DZM2

   FUNCTION FMDIV_ZZM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZZM2

   FUNCTION FMDIV_CZM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_CZM2

   FUNCTION FMDIV_ZMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZMI2

   FUNCTION FMDIV_ZMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZMR2

   FUNCTION FMDIV_ZMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZMD2

   FUNCTION FMDIV_ZMZ2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZMZ2

   FUNCTION FMDIV_ZMC2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MA%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZMC2

   FUNCTION FMDIV_ZMZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL ZMDIV(MA%MZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZMZM2

!             (5) rank 2  /  rank 0

   FUNCTION FMDIV_ZM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2I

   FUNCTION FMDIV_ZM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2R

   FUNCTION FMDIV_ZM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2D

   FUNCTION FMDIV_ZM2Z(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2Z

   FUNCTION FMDIV_ZM2C(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2C

   FUNCTION FMDIV_I2ZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_I2ZM

   FUNCTION FMDIV_R2ZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_R2ZM

   FUNCTION FMDIV_D2ZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_D2ZM

   FUNCTION FMDIV_Z2ZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_Z2ZM

   FUNCTION FMDIV_C2ZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_C2ZM

   FUNCTION FMDIV_ZM2ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,MB%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2ZM

!             (6) rank 2  /  rank 2

   FUNCTION FMDIV_ZM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMI2M(IVAL(J,K),MTLVZM,QX)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2I2

   FUNCTION FMDIV_ZM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2R2

   FUNCTION FMDIV_ZM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2D2

   FUNCTION FMDIV_ZM2Z2(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2Z2

   FUNCTION FMDIV_ZM2C2(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MA(J,K)%MZM,MTLVZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2C2

   FUNCTION FMDIV_I2ZM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (ZM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M(IVAL(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_I2ZM2

   FUNCTION FMDIV_R2ZM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (ZM), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M(R(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_R2ZM2

   FUNCTION FMDIV_D2ZM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (ZM), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      CALL FMI2M(0,MULVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(D(J,K),MTLVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_D2ZM2

   FUNCTION FMDIV_Z2ZM2(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (ZM), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMZ2M(Z(J,K),MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_Z2ZM2

   FUNCTION FMDIV_C2ZM2(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (ZM), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M(REAL(C(J,K),KIND(0.0D0)),MTLVFM,QX)
            CALL FMDP2M(AIMAG(C(J,K)),MULVFM,QX)
            CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
            CALL ZMDIV(MTLVZM,MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_C2ZM2

   FUNCTION FMDIV_ZM2ZM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMST2M(' UNKNOWN + UNKNOWN i ',RETURN_VALUE(J,K)%MZM,QX)
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMDIV(MA(J,K)%MZM,MB(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMDIV_ZM2ZM2

 END MODULE FMZM_7_PARALLEL

 MODULE FMZM_8_PARALLEL
    USE FMZM_1_PARALLEL

    INTERFACE OPERATOR (**)
       MODULE PROCEDURE FMPWR_IFM
       MODULE PROCEDURE FMPWR_IIM
       MODULE PROCEDURE FMPWR_IZM
       MODULE PROCEDURE FMPWR_RFM
       MODULE PROCEDURE FMPWR_RIM
       MODULE PROCEDURE FMPWR_RZM
       MODULE PROCEDURE FMPWR_DFM
       MODULE PROCEDURE FMPWR_DIM
       MODULE PROCEDURE FMPWR_DZM
       MODULE PROCEDURE FMPWR_ZFM
       MODULE PROCEDURE FMPWR_ZIM
       MODULE PROCEDURE FMPWR_ZZM
       MODULE PROCEDURE FMPWR_CFM
       MODULE PROCEDURE FMPWR_CIM
       MODULE PROCEDURE FMPWR_CZM
       MODULE PROCEDURE FMPWR_FMI
       MODULE PROCEDURE FMPWR_FMR
       MODULE PROCEDURE FMPWR_FMD
       MODULE PROCEDURE FMPWR_FMZ
       MODULE PROCEDURE FMPWR_FMC
       MODULE PROCEDURE FMPWR_FMFM
       MODULE PROCEDURE FMPWR_FMIM
       MODULE PROCEDURE FMPWR_FMZM
       MODULE PROCEDURE FMPWR_IMI
       MODULE PROCEDURE FMPWR_IMR
       MODULE PROCEDURE FMPWR_IMD
       MODULE PROCEDURE FMPWR_IMZ
       MODULE PROCEDURE FMPWR_IMC
       MODULE PROCEDURE FMPWR_IMFM
       MODULE PROCEDURE FMPWR_IMIM
       MODULE PROCEDURE FMPWR_IMZM
       MODULE PROCEDURE FMPWR_ZMI
       MODULE PROCEDURE FMPWR_ZMR
       MODULE PROCEDURE FMPWR_ZMD
       MODULE PROCEDURE FMPWR_ZMZ
       MODULE PROCEDURE FMPWR_ZMC
       MODULE PROCEDURE FMPWR_ZMFM
       MODULE PROCEDURE FMPWR_ZMIM
       MODULE PROCEDURE FMPWR_ZMZM
    END INTERFACE

   INTERFACE ABS
      MODULE PROCEDURE FMABS_FM
      MODULE PROCEDURE FMABS_IM
      MODULE PROCEDURE FMABS_ZM
      MODULE PROCEDURE FMABS_FM1
      MODULE PROCEDURE FMABS_IM1
      MODULE PROCEDURE FMABS_ZM1
      MODULE PROCEDURE FMABS_FM2
      MODULE PROCEDURE FMABS_IM2
      MODULE PROCEDURE FMABS_ZM2
   END INTERFACE

   INTERFACE ACOS
      MODULE PROCEDURE FMACOS_FM
      MODULE PROCEDURE FMACOS_ZM
      MODULE PROCEDURE FMACOS_FM1
      MODULE PROCEDURE FMACOS_ZM1
      MODULE PROCEDURE FMACOS_FM2
      MODULE PROCEDURE FMACOS_ZM2
   END INTERFACE

   INTERFACE ACOSH
      MODULE PROCEDURE FMACOSH_FM
      MODULE PROCEDURE FMACOSH_ZM
      MODULE PROCEDURE FMACOSH_FM1
      MODULE PROCEDURE FMACOSH_ZM1
      MODULE PROCEDURE FMACOSH_FM2
      MODULE PROCEDURE FMACOSH_ZM2
   END INTERFACE

   INTERFACE AIMAG
      MODULE PROCEDURE FMAIMAG_ZM
      MODULE PROCEDURE FMAIMAG_ZM1
      MODULE PROCEDURE FMAIMAG_ZM2
   END INTERFACE

   INTERFACE AINT
      MODULE PROCEDURE FMAINT_FM
      MODULE PROCEDURE FMAINT_ZM
      MODULE PROCEDURE FMAINT_FM1
      MODULE PROCEDURE FMAINT_ZM1
      MODULE PROCEDURE FMAINT_FM2
      MODULE PROCEDURE FMAINT_ZM2
   END INTERFACE

   INTERFACE ANINT
      MODULE PROCEDURE FMANINT_FM
      MODULE PROCEDURE FMANINT_ZM
      MODULE PROCEDURE FMANINT_FM1
      MODULE PROCEDURE FMANINT_ZM1
      MODULE PROCEDURE FMANINT_FM2
      MODULE PROCEDURE FMANINT_ZM2
   END INTERFACE

   INTERFACE ASIN
      MODULE PROCEDURE FMASIN_FM
      MODULE PROCEDURE FMASIN_ZM
      MODULE PROCEDURE FMASIN_FM1
      MODULE PROCEDURE FMASIN_ZM1
      MODULE PROCEDURE FMASIN_FM2
      MODULE PROCEDURE FMASIN_ZM2
   END INTERFACE

   INTERFACE ASINH
      MODULE PROCEDURE FMASINH_FM
      MODULE PROCEDURE FMASINH_ZM
      MODULE PROCEDURE FMASINH_FM1
      MODULE PROCEDURE FMASINH_ZM1
      MODULE PROCEDURE FMASINH_FM2
      MODULE PROCEDURE FMASINH_ZM2
   END INTERFACE

   INTERFACE ATAN
      MODULE PROCEDURE FMATAN_FM
      MODULE PROCEDURE FMATAN2_FM
      MODULE PROCEDURE FMATAN_ZM
      MODULE PROCEDURE FMATAN_FM1
      MODULE PROCEDURE FMATAN_ZM1
      MODULE PROCEDURE FMATAN_FM2
      MODULE PROCEDURE FMATAN_ZM2
   END INTERFACE

   INTERFACE ATANH
      MODULE PROCEDURE FMATANH_FM
      MODULE PROCEDURE FMATANH_ZM
      MODULE PROCEDURE FMATANH_FM1
      MODULE PROCEDURE FMATANH_ZM1
      MODULE PROCEDURE FMATANH_FM2
      MODULE PROCEDURE FMATANH_ZM2
   END INTERFACE

   INTERFACE ATAN2
      MODULE PROCEDURE FMATAN2_FM
   END INTERFACE

   INTERFACE BTEST
      MODULE PROCEDURE FMBTEST_IM
   END INTERFACE

   INTERFACE CEILING
      MODULE PROCEDURE FMCEILING_FM
      MODULE PROCEDURE FMCEILING_IM
      MODULE PROCEDURE FMCEILING_ZM
      MODULE PROCEDURE FMCEILING_FM1
      MODULE PROCEDURE FMCEILING_IM1
      MODULE PROCEDURE FMCEILING_ZM1
      MODULE PROCEDURE FMCEILING_FM2
      MODULE PROCEDURE FMCEILING_IM2
      MODULE PROCEDURE FMCEILING_ZM2
   END INTERFACE

   INTERFACE CMPLX
      MODULE PROCEDURE FMCMPLX_FM
      MODULE PROCEDURE FMCMPLX_IM
   END INTERFACE

   INTERFACE CONJG
      MODULE PROCEDURE FMCONJG_ZM
      MODULE PROCEDURE FMCONJG_ZM1
      MODULE PROCEDURE FMCONJG_ZM2
   END INTERFACE

   INTERFACE COS
      MODULE PROCEDURE FMCOS_FM
      MODULE PROCEDURE FMCOS_ZM
      MODULE PROCEDURE FMCOS_FM1
      MODULE PROCEDURE FMCOS_ZM1
      MODULE PROCEDURE FMCOS_FM2
      MODULE PROCEDURE FMCOS_ZM2
   END INTERFACE

   INTERFACE COSH
      MODULE PROCEDURE FMCOSH_FM
      MODULE PROCEDURE FMCOSH_ZM
      MODULE PROCEDURE FMCOSH_FM1
      MODULE PROCEDURE FMCOSH_ZM1
      MODULE PROCEDURE FMCOSH_FM2
      MODULE PROCEDURE FMCOSH_ZM2
   END INTERFACE

   INTERFACE DBLE
      MODULE PROCEDURE FMDBLE_FM
      MODULE PROCEDURE FMDBLE_IM
      MODULE PROCEDURE FMDBLE_ZM
   END INTERFACE

   INTERFACE DIGITS
      MODULE PROCEDURE FMDIGITS_FM
      MODULE PROCEDURE FMDIGITS_IM
      MODULE PROCEDURE FMDIGITS_ZM
   END INTERFACE

   INTERFACE DIM
      MODULE PROCEDURE FMDIM_FM
      MODULE PROCEDURE FMDIM_IM
   END INTERFACE

   INTERFACE DINT
      MODULE PROCEDURE FMDINT_FM
      MODULE PROCEDURE FMDINT_ZM
   END INTERFACE

   INTERFACE DOT_PRODUCT
      MODULE PROCEDURE FMDOTPRODUCT_FM
      MODULE PROCEDURE FMDOTPRODUCT_IM
      MODULE PROCEDURE FMDOTPRODUCT_ZM
   END INTERFACE

   INTERFACE EPSILON
      MODULE PROCEDURE FMEPSILON_FM
   END INTERFACE

   INTERFACE EXP
      MODULE PROCEDURE FMEXP_FM
      MODULE PROCEDURE FMEXP_ZM
      MODULE PROCEDURE FMEXP_FM1
      MODULE PROCEDURE FMEXP_ZM1
      MODULE PROCEDURE FMEXP_FM2
      MODULE PROCEDURE FMEXP_ZM2
   END INTERFACE

   INTERFACE EXPONENT
      MODULE PROCEDURE FMEXPONENT_FM
   END INTERFACE

   INTERFACE FLOOR
      MODULE PROCEDURE FMFLOOR_FM
      MODULE PROCEDURE FMFLOOR_IM
      MODULE PROCEDURE FMFLOOR_ZM
      MODULE PROCEDURE FMFLOOR_FM1
      MODULE PROCEDURE FMFLOOR_IM1
      MODULE PROCEDURE FMFLOOR_ZM1
      MODULE PROCEDURE FMFLOOR_FM2
      MODULE PROCEDURE FMFLOOR_IM2
      MODULE PROCEDURE FMFLOOR_ZM2
   END INTERFACE

   INTERFACE FRACTION
      MODULE PROCEDURE FMFRACTION_FM
      MODULE PROCEDURE FMFRACTION_ZM
      MODULE PROCEDURE FMFRACTION_FM1
      MODULE PROCEDURE FMFRACTION_ZM1
      MODULE PROCEDURE FMFRACTION_FM2
      MODULE PROCEDURE FMFRACTION_ZM2
   END INTERFACE

   INTERFACE HUGE
      MODULE PROCEDURE FMHUGE_FM
      MODULE PROCEDURE FMHUGE_IM
      MODULE PROCEDURE FMHUGE_ZM
   END INTERFACE

   INTERFACE HYPOT
      MODULE PROCEDURE FMHYPOT_FM
   END INTERFACE

   INTERFACE INT
      MODULE PROCEDURE FMINT_FM
      MODULE PROCEDURE FMINT_IM
      MODULE PROCEDURE FMINT_ZM
      MODULE PROCEDURE FMINT_FM1
      MODULE PROCEDURE FMINT_IM1
      MODULE PROCEDURE FMINT_ZM1
      MODULE PROCEDURE FMINT_FM2
      MODULE PROCEDURE FMINT_IM2
      MODULE PROCEDURE FMINT_ZM2
   END INTERFACE

   INTERFACE LOG
      MODULE PROCEDURE FMLOG_FM
      MODULE PROCEDURE FMLOG_ZM
      MODULE PROCEDURE FMLOG_FM1
      MODULE PROCEDURE FMLOG_ZM1
      MODULE PROCEDURE FMLOG_FM2
      MODULE PROCEDURE FMLOG_ZM2
   END INTERFACE

   INTERFACE LOG10
      MODULE PROCEDURE FMLOG10_FM
      MODULE PROCEDURE FMLOG10_ZM
      MODULE PROCEDURE FMLOG10_FM1
      MODULE PROCEDURE FMLOG10_ZM1
      MODULE PROCEDURE FMLOG10_FM2
      MODULE PROCEDURE FMLOG10_ZM2
   END INTERFACE

   INTERFACE MATMUL
      MODULE PROCEDURE FMMATMUL22_FM
      MODULE PROCEDURE FMMATMUL12_FM
      MODULE PROCEDURE FMMATMUL21_FM
      MODULE PROCEDURE FMMATMUL22_IM
      MODULE PROCEDURE FMMATMUL12_IM
      MODULE PROCEDURE FMMATMUL21_IM
      MODULE PROCEDURE FMMATMUL22_ZM
      MODULE PROCEDURE FMMATMUL12_ZM
      MODULE PROCEDURE FMMATMUL21_ZM
   END INTERFACE

   INTERFACE MAX
      MODULE PROCEDURE FMMAX_FM
      MODULE PROCEDURE FMMAX_IM
   END INTERFACE

   INTERFACE MAXEXPONENT
      MODULE PROCEDURE FMMAXEXPONENT_FM
   END INTERFACE

   INTERFACE MAXLOC
      MODULE PROCEDURE FMMAXLOC1_FM
      MODULE PROCEDURE FMMAXLOC2_FM
      MODULE PROCEDURE FMMAXLOC1_IM
      MODULE PROCEDURE FMMAXLOC2_IM
   END INTERFACE

   INTERFACE MAXVAL
      MODULE PROCEDURE FMMAXVAL1_FM
      MODULE PROCEDURE FMMAXVAL2_FM
      MODULE PROCEDURE FMMAXVAL1_IM
      MODULE PROCEDURE FMMAXVAL2_IM
   END INTERFACE

   INTERFACE MIN
      MODULE PROCEDURE FMMIN_FM
      MODULE PROCEDURE FMMIN_IM
   END INTERFACE

   INTERFACE MINEXPONENT
      MODULE PROCEDURE FMMINEXPONENT_FM
   END INTERFACE

   INTERFACE MINLOC
      MODULE PROCEDURE FMMINLOC1_FM
      MODULE PROCEDURE FMMINLOC2_FM
      MODULE PROCEDURE FMMINLOC1_IM
      MODULE PROCEDURE FMMINLOC2_IM
   END INTERFACE

   INTERFACE MINVAL
      MODULE PROCEDURE FMMINVAL1_FM
      MODULE PROCEDURE FMMINVAL2_FM
      MODULE PROCEDURE FMMINVAL1_IM
      MODULE PROCEDURE FMMINVAL2_IM
   END INTERFACE

   INTERFACE MOD
      MODULE PROCEDURE FMMOD_FM
      MODULE PROCEDURE FMMOD_IM
   END INTERFACE

   INTERFACE MODULO
      MODULE PROCEDURE FMMODULO_FM
      MODULE PROCEDURE FMMODULO_IM
   END INTERFACE

   INTERFACE NEAREST
      MODULE PROCEDURE FMNEAREST_FM
   END INTERFACE

   INTERFACE NINT
      MODULE PROCEDURE FMNINT_FM
      MODULE PROCEDURE FMNINT_IM
      MODULE PROCEDURE FMNINT_ZM
      MODULE PROCEDURE FMNINT_FM1
      MODULE PROCEDURE FMNINT_IM1
      MODULE PROCEDURE FMNINT_ZM1
      MODULE PROCEDURE FMNINT_FM2
      MODULE PROCEDURE FMNINT_IM2
      MODULE PROCEDURE FMNINT_ZM2
   END INTERFACE

   INTERFACE NORM2
      MODULE PROCEDURE FMNORM21_FM
   END INTERFACE

   INTERFACE PRECISION
      MODULE PROCEDURE FMPRECISION_FM
      MODULE PROCEDURE FMPRECISION_ZM
   END INTERFACE

   INTERFACE PRODUCT
      MODULE PROCEDURE FMPRODUCT1_FM
      MODULE PROCEDURE FMPRODUCT2_FM
      MODULE PROCEDURE FMPRODUCT1_IM
      MODULE PROCEDURE FMPRODUCT2_IM
      MODULE PROCEDURE FMPRODUCT1_ZM
      MODULE PROCEDURE FMPRODUCT2_ZM
   END INTERFACE

   INTERFACE RADIX
      MODULE PROCEDURE FMRADIX_FM
      MODULE PROCEDURE FMRADIX_IM
      MODULE PROCEDURE FMRADIX_ZM
   END INTERFACE

   INTERFACE RANGE
      MODULE PROCEDURE FMRANGE_FM
      MODULE PROCEDURE FMRANGE_IM
      MODULE PROCEDURE FMRANGE_ZM
   END INTERFACE

   INTERFACE REAL
      MODULE PROCEDURE FMREAL_FM
      MODULE PROCEDURE FMREAL_IM
      MODULE PROCEDURE FMREAL_ZM
   END INTERFACE

   INTERFACE RRSPACING
      MODULE PROCEDURE FMRRSPACING_FM
   END INTERFACE

   INTERFACE SCALE
      MODULE PROCEDURE FMSCALE_FM
      MODULE PROCEDURE FMSCALE_ZM
   END INTERFACE

   INTERFACE SETEXPONENT
      MODULE PROCEDURE FMSETEXPONENT_FM
   END INTERFACE

   INTERFACE SIGN
      MODULE PROCEDURE FMSIGN_FM
      MODULE PROCEDURE FMSIGN_IM
   END INTERFACE

 CONTAINS

!                                                                  **

   FUNCTION FMPWR_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMPWR(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_IFM

   FUNCTION FMPWR_IIM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      CALL IMPWR(MTLVIM,MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMPWR_IIM

   FUNCTION FMPWR_IZM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMPWR(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_IZM

   FUNCTION FMPWR_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMPWR(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_RFM

   FUNCTION FMPWR_RIM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMPWR(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_RIM

   FUNCTION FMPWR_RZM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMPWR(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_RZM

   FUNCTION FMPWR_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMPWR(MTLVFM,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_DFM

   FUNCTION FMPWR_DIM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMPWR(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_DIM

   FUNCTION FMPWR_DZM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMPWR(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_DZM

   FUNCTION FMPWR_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZFM

   FUNCTION FMPWR_ZIM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZIM

   FUNCTION FMPWR_ZZM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMPWR(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZZM

   FUNCTION FMPWR_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_CFM

   FUNCTION FMPWR_CIM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_CIM

   FUNCTION FMPWR_CZM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMPWR(MTLVZM,MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_CZM

   FUNCTION FMPWR_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMIPWR(MA%MFM,IVAL,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_FMI

   FUNCTION FMPWR_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMPWR(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_FMR

   FUNCTION FMPWR_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMPWR(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_FMD

   FUNCTION FMPWR_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_FMZ

   FUNCTION FMPWR_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MA%MFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_FMC

   FUNCTION FMPWR_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMPWR(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_FMFM

   FUNCTION FMPWR_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMPWR(MA%MFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_FMIM

   FUNCTION FMPWR_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MA%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMPWR(MTLVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_FMZM

   FUNCTION FMPWR_IMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MTLVIM,QX)
      CALL IMPWR(MA%MIM,MTLVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMPWR_IMI

   FUNCTION FMPWR_IMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMPWR(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_IMR

   FUNCTION FMPWR_IMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL IMI2FM(MA%MIM,MULVFM,QX)
      CALL FMPWR(MULVFM,MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_IMD

   FUNCTION FMPWR_IMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_IMZ

   FUNCTION FMPWR_IMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2),MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MULVZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_IMC

   FUNCTION FMPWR_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMPWR(MTLVFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPWR_IMFM

   FUNCTION FMPWR_IMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMPWR(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMPWR_IMIM

   FUNCTION FMPWR_IMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (ZM) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MULVZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_IMZM

   FUNCTION FMPWR_ZMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMIPWR(MA%MZM,IVAL,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZMI

   FUNCTION FMPWR_ZMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(R,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMPWR(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZMR

   FUNCTION FMPWR_ZMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(D,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMPWR(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZMD

   FUNCTION FMPWR_ZMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(Z,MTLVZM,QX)
      CALL ZMPWR(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZMZ

   FUNCTION FMPWR_ZMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      TYPE(MULTI) :: MTLVFM,MULVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(REAL(C,KIND(0.0D0)),MTLVFM,QX)
      CALL FMDP2M(AIMAG(C),MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MTLVZM,QX)
      CALL ZMPWR(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZMC

   FUNCTION FMPWR_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,MTLVFM,QX)
      CALL ZMCMPX(MB%MFM,MTLVFM,MTLVZM,QX)
      CALL ZMPWR(MA%MZM,MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZMFM

   FUNCTION FMPWR_ZMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MB
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MULVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MB%MIM,MTLVFM,QX)
      CALL FMI2M(0,MULVFM,QX)
      CALL ZMCMPX(MTLVFM,MULVFM,MULVZM,QX)
      CALL ZMPWR(MA%MZM,MULVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZMIM

   FUNCTION FMPWR_ZMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMPWR(MA%MZM,MB%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMPWR_ZMZM

!                                                                 ABS

   FUNCTION FMABS_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMABS(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMABS_FM

   FUNCTION FMABS_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMABS(MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMABS_IM

   FUNCTION FMABS_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMABS(MA%MZM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMABS_ZM

   FUNCTION FMABS_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMABS(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMABS_FM1

   FUNCTION FMABS_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMABS(MA(J)%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMABS_IM1

   FUNCTION FMABS_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMABS(MA(J)%MZM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMABS_ZM1

   FUNCTION FMABS_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMABS(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMABS_FM2

   FUNCTION FMABS_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMABS(MA(J,K)%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMABS_IM2

   FUNCTION FMABS_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMABS(MA(J,K)%MZM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMABS_ZM2

!                                                                ACOS

   FUNCTION FMACOS_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMACOS(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMACOS_FM

   FUNCTION FMACOS_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMACOS(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMACOS_ZM

   FUNCTION FMACOS_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMACOS(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMACOS_FM1

   FUNCTION FMACOS_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMACOS(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMACOS_ZM1

   FUNCTION FMACOS_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMACOS(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMACOS_FM2

   FUNCTION FMACOS_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMACOS(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMACOS_ZM2

!                                                                ACOSH

   FUNCTION FMACOSH_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMACOSH(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMACOSH_FM

   FUNCTION FMACOSH_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMACOSH(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMACOSH_ZM

   FUNCTION FMACOSH_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMACOSH(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMACOSH_FM1

   FUNCTION FMACOSH_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMACOSH(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMACOSH_ZM1

   FUNCTION FMACOSH_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMACOSH(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMACOSH_FM2

   FUNCTION FMACOSH_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMACOSH(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMACOSH_ZM2

!                                                               AIMAG

   FUNCTION FMAIMAG_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMIMAG(MA%MZM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMAIMAG_ZM

   FUNCTION FMAIMAG_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMIMAG(MA(J)%MZM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMAIMAG_ZM1

   FUNCTION FMAIMAG_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMIMAG(MA(J,K)%MZM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMAIMAG_ZM2

!                                                                AINT

   FUNCTION FMAINT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMAINT_FM

   FUNCTION FMAINT_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMINT(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMAINT_ZM

   FUNCTION FMAINT_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMINT(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMAINT_FM1

   FUNCTION FMAINT_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMINT(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMAINT_ZM1

   FUNCTION FMAINT_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMINT(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMAINT_FM2

   FUNCTION FMAINT_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMINT(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMAINT_ZM2

!                                                               ANINT

   FUNCTION FMANINT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMNINT(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMANINT_FM

   FUNCTION FMANINT_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMNINT(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMANINT_ZM

   FUNCTION FMANINT_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMNINT(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMANINT_FM1

   FUNCTION FMANINT_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMNINT(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMANINT_ZM1

   FUNCTION FMANINT_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMNINT(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMANINT_FM2

   FUNCTION FMANINT_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMNINT(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMANINT_ZM2

!                                                                ASIN

   FUNCTION FMASIN_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMASIN(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMASIN_FM

   FUNCTION FMASIN_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMASIN(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMASIN_ZM

   FUNCTION FMASIN_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMASIN(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMASIN_FM1

   FUNCTION FMASIN_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMASIN(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMASIN_ZM1

   FUNCTION FMASIN_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMASIN(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMASIN_FM2

   FUNCTION FMASIN_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMASIN(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMASIN_ZM2

!                                                                ASINH

   FUNCTION FMASINH_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMASINH(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMASINH_FM

   FUNCTION FMASINH_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMASINH(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMASINH_ZM

   FUNCTION FMASINH_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMASINH(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMASINH_FM1

   FUNCTION FMASINH_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMASINH(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMASINH_ZM1

   FUNCTION FMASINH_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMASINH(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMASINH_FM2

   FUNCTION FMASINH_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMASINH(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMASINH_ZM2

!                                                                ATAN

   FUNCTION FMATAN_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMATAN(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMATAN_FM

   FUNCTION FMATAN_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMATAN(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMATAN_ZM

   FUNCTION FMATAN_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMATAN(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMATAN_FM1

   FUNCTION FMATAN_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMATAN(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMATAN_ZM1

   FUNCTION FMATAN_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMATAN(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMATAN_FM2

   FUNCTION FMATAN_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMATAN(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMATAN_ZM2

!                                                                ATANH

   FUNCTION FMATANH_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMATANH(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMATANH_FM

   FUNCTION FMATANH_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMATANH(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMATANH_ZM

   FUNCTION FMATANH_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMATANH(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMATANH_FM1

   FUNCTION FMATANH_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMATANH(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMATANH_ZM1

   FUNCTION FMATANH_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMATANH(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMATANH_FM2

   FUNCTION FMATANH_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMATANH(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMATANH_ZM2

!                                                               ATAN2

   FUNCTION FMATAN2_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMATN2(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMATAN2_FM

!                                                               BTEST

   FUNCTION FMBTEST_IM(MA,POS)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: POS
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA,POS
      TYPE(MULTI) :: MTLVIM,MULVIM,MVLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(2,MTLVIM,QX)
      CALL IMI2M(POS,MULVIM,QX)
      CALL IMPWR(MTLVIM,MULVIM,MVLVIM,QX)
      CALL IMDIV(MA%MIM,MVLVIM,MULVIM,QX)
      MULVIM%MP(1) = 1
      CALL IMMOD(MULVIM,MTLVIM,MVLVIM,QX)
      IF (MVLVIM%MP(3) == 0) THEN
          RETURN_VALUE = .FALSE.
      ELSE
          RETURN_VALUE = .TRUE.
      ENDIF
   END FUNCTION FMBTEST_IM

!                                                             CEILING

   FUNCTION FMCEILING_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,MTLVFM,QX)
      CALL FMSUB(MA%MFM,MTLVFM,MULVFM,QX)
      IF (MULVFM%MP(3) == 0) THEN
          CALL FMEQ(MA%MFM,RETURN_VALUE%MFM,QX)
      ELSE IF (MA%MFM%MP(1) > 0) THEN
          CALL FMADDI(MTLVFM,1,QX)
          CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
      ELSE
          CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
      ENDIF
   END FUNCTION FMCEILING_FM

   FUNCTION FMCEILING_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMCEILING_IM

   FUNCTION FMCEILING_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MZM(1),MTLVFM,QX)
      CALL FMSUB(MA%MZM(1),MTLVFM,MULVFM,QX)
      IF (MULVFM%MP(3) == 0) THEN
          CALL FMEQ(MA%MZM(1),MVLVFM,QX)
      ELSE IF (MA%MZM(1)%MP(1) > 0) THEN
          CALL FMADDI(MTLVFM,1,QX)
          CALL FMEQ(MTLVFM,MVLVFM,QX)
      ELSE
          CALL FMEQ(MTLVFM,MVLVFM,QX)
      ENDIF
      CALL FMINT(MA%MZM(2),MTLVFM,QX)
      CALL FMSUB(MA%MZM(2),MTLVFM,MULVFM,QX)
      IF (MULVFM%MP(3) == 0) THEN
          CALL FMEQ(MA%MZM(2),MULVFM,QX)
      ELSE IF (MA%MZM(2)%MP(1) > 0) THEN
          CALL FMADDI(MTLVFM,1,QX)
          CALL FMEQ(MTLVFM,MULVFM,QX)
      ELSE
          CALL FMEQ(MTLVFM,MULVFM,QX)
      ENDIF
      CALL ZMCMPX(MVLVFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMCEILING_ZM

   FUNCTION FMCEILING_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM) :: MT_FM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_FM = FMCEILING_FM(MA(J))
         CALL FMEQ(MT_FM%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMCEILING_FM1

   FUNCTION FMCEILING_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_IM = FMCEILING_IM(MA(J))
         CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMCEILING_IM1

   FUNCTION FMCEILING_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(ZM) :: MT_ZM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_ZM = FMCEILING_ZM(MA(J))
         CALL ZMEQ(MT_ZM%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMCEILING_ZM1

   FUNCTION FMCEILING_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM) :: MT_FM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_FM = FMCEILING_FM(MA(J,K))
            CALL FMEQ(MT_FM%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCEILING_FM2

   FUNCTION FMCEILING_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_IM = FMCEILING_IM(MA(J,K))
            CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCEILING_IM2

   FUNCTION FMCEILING_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(ZM) :: MT_ZM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_ZM = FMCEILING_ZM(MA(J,K))
            CALL ZMEQ(MT_ZM%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCEILING_ZM2

!                                                               CMPLX

   FUNCTION FMCMPLX_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM) :: MA
      TYPE (FM), OPTIONAL :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      IF (PRESENT(MB)) THEN
          CALL ZMCMPX(MA%MFM,MB%MFM,RETURN_VALUE%MZM,QX)
      ELSE
          CALL FMI2M(0,MTLVFM,QX)
          CALL ZMCMPX(MA%MFM,MTLVFM,RETURN_VALUE%MZM,QX)
      ENDIF
   END FUNCTION FMCMPLX_FM

   FUNCTION FMCMPLX_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (IM) :: MA
      TYPE (IM), OPTIONAL :: MB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      IF (PRESENT(MB)) THEN
          CALL IMI2FM(MA%MIM,MTLVFM,QX)
          CALL IMI2FM(MB%MIM,MULVFM,QX)
          CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE%MZM,QX)
      ELSE
          CALL IMI2FM(MA%MIM,MTLVFM,QX)
          CALL FMI2M(0,MULVFM,QX)
          CALL ZMCMPX(MTLVFM,MULVFM,RETURN_VALUE%MZM,QX)
      ENDIF
   END FUNCTION FMCMPLX_IM

!                                                               CONJG

   FUNCTION FMCONJG_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE,MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCONJ(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMCONJG_ZM

   FUNCTION FMCONJG_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMCONJ(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMCONJG_ZM1

   FUNCTION FMCONJG_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCONJ(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCONJG_ZM2

!                                                                 COS

   FUNCTION FMCOS_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMCOS(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMCOS_FM

   FUNCTION FMCOS_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCOS(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMCOS_ZM

   FUNCTION FMCOS_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMCOS(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMCOS_FM1

   FUNCTION FMCOS_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMCOS(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMCOS_ZM1

   FUNCTION FMCOS_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMCOS(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCOS_FM2

   FUNCTION FMCOS_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCOS(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCOS_ZM2

!                                                                COSH

   FUNCTION FMCOSH_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMCOSH(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMCOSH_FM

   FUNCTION FMCOSH_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMCOSH(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMCOSH_FM1

   FUNCTION FMCOSH_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMCOSH(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMCOSH_ZM1

   FUNCTION FMCOSH_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMCOSH(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCOSH_FM2

   FUNCTION FMCOSH_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCOSH(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCOSH_ZM2

   FUNCTION FMCOSH_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCOSH(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMCOSH_ZM

!                                                                DBLE

   FUNCTION FMDBLE_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDBLE_FM

   FUNCTION FMDBLE_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDBLE_IM

   FUNCTION FMDBLE_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDBLE_ZM

!                                                              DIGITS

   FUNCTION FMDIGITS_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = QX%NDIG
      IF (SIZE(MA%MFM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMDIGITS_FM

   FUNCTION FMDIGITS_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA

!             The number of possible digits for type(im) integers is limited only by the amount
!             of memory that can be allocated.  Return 10**6 since there is no fixed limit.

      RETURN_VALUE = 10**6
      IF (SIZE(MA%MIM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMDIGITS_IM

   FUNCTION FMDIGITS_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = QX%NDIG
      IF (SIZE(MA%MZM(1)%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMDIGITS_ZM

!                                                                 DIM

   FUNCTION FMDIM_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIM(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDIM_FM

   FUNCTION FMDIM_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMDIM(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMDIM_IM

!                                                                DINT

   FUNCTION FMDINT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMDINT_FM

   FUNCTION FMDINT_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMINT(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMDINT_ZM

!                                                         DOT_PRODUCT

   FUNCTION FMDOTPRODUCT_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:),MB(:),RETURN_VALUE
      INTEGER :: J,JA,JB,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,M3LVFM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) == SIZE(MB)) THEN
          NDSAVE = QX%NDIG
          J = MAX(QX%NGRD52,2)
          ND2 = MAX(2*QX%NDIG+J,2)
          QX%NDIG = ND2
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
          CALL FMI2M(0,M3LVFM,QX)
          DO J = 1, SIZE(MA)
             JA = LBOUND(MA,DIM=1) + J - 1
             CALL FMEQU(MA(JA)%MFM,MULVFM,NDSAVE,QX%NDIG,QX)
             JB = LBOUND(MB,DIM=1) + J - 1
             CALL FMEQU(MB(JB)%MFM,MVLVFM,NDSAVE,QX%NDIG,QX)
             CALL FMMPY(MULVFM,MVLVFM,MTLVFM,QX)
             CALL FMADD_R1(M3LVFM,MTLVFM,QX)
          ENDDO
          QX%MXEXP = MXSAVE
          CALL FMEQU(M3LVFM,RETURN_VALUE%MFM,QX%NDIG,NDSAVE,QX)
          QX%NDIG = NDSAVE
      ELSE
          CALL FMI2M(1,MTLVFM,QX)
          CALL FMI2M(0,MULVFM,QX)
          CALL FMDIV(MTLVFM,MULVFM,RETURN_VALUE%MFM,QX)
      ENDIF
   END FUNCTION FMDOTPRODUCT_FM

   FUNCTION FMDOTPRODUCT_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:),MB(:),RETURN_VALUE
      INTEGER :: J,JA,JB
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVIM,MULVIM,M3LVIM
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) == SIZE(MB)) THEN
          CALL IMI2M(0,M3LVIM,QX)
          DO J = 1, SIZE(MA)
             JA = LBOUND(MA,DIM=1) + J - 1
             JB = LBOUND(MB,DIM=1) + J - 1
             CALL IMMPY(MA(JA)%MIM,MB(JB)%MIM,MTLVIM,QX)
             CALL IMADD(M3LVIM,MTLVIM,MULVIM,QX)
             CALL IMEQ(MULVIM,M3LVIM,QX)
          ENDDO
          CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
      ELSE
          CALL IMI2M(1,MTLVIM,QX)
          CALL IMI2M(0,MULVIM,QX)
          CALL IMDIV(MTLVIM,MULVIM,RETURN_VALUE%MIM,QX)
      ENDIF
   END FUNCTION FMDOTPRODUCT_IM

   FUNCTION FMDOTPRODUCT_ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:),MB(:),RETURN_VALUE
      INTEGER :: J,JA,JB,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),MVLVZM(2),M3LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) == SIZE(MB)) THEN
          NDSAVE = QX%NDIG
          J = MAX(QX%NGRD52,2)
          ND2 = MAX(2*QX%NDIG+J,2)
          QX%NDIG = ND2
          MXSAVE = QX%MXEXP
          QX%MXEXP = QX%MXEXP2
          CALL ZMI2M(0,M3LVZM,QX)
          DO J = 1, SIZE(MA)
             JA = LBOUND(MA,DIM=1) + J - 1
             CALL ZMEQU(MA(JA)%MZM,MULVZM,NDSAVE,QX%NDIG,QX)
             MULVZM(2)%MP(1) = -MULVZM(2)%MP(1)
             JB = LBOUND(MB,DIM=1) + J - 1
             CALL ZMEQU(MB(JB)%MZM,MVLVZM,NDSAVE,QX%NDIG,QX)
             CALL ZMMPY(MULVZM,MVLVZM,MTLVZM,QX)
             CALL ZMADD(M3LVZM,MTLVZM,MULVZM,QX)
             CALL ZMEQ(MULVZM,M3LVZM,QX)
          ENDDO
          QX%MXEXP = MXSAVE
          CALL ZMEQU(M3LVZM,RETURN_VALUE%MZM,QX%NDIG,NDSAVE,QX)
          QX%NDIG = NDSAVE
      ELSE
          CALL ZMI2M(1,MTLVZM,QX)
          CALL ZMI2M(0,MULVZM,QX)
          CALL ZMDIV(MTLVZM,MULVZM,RETURN_VALUE%MZM,QX)
      ENDIF
   END FUNCTION FMDOTPRODUCT_ZM

!                                                             EPSILON

   FUNCTION FMEPSILON_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(1,MTLVFM,QX)
      IF (SIZE(MA%MFM%MP) <= 2) CALL FMI2M(2,MTLVFM,QX)
      CALL FMULP(MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMEPSILON_FM

!                                                                 EXP

   FUNCTION FMEXP_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEXP(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMEXP_FM

   FUNCTION FMEXP_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEXP(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMEXP_ZM

   FUNCTION FMEXP_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEXP(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMEXP_FM1

   FUNCTION FMEXP_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMEXP(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMEXP_ZM1

   FUNCTION FMEXP_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEXP(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMEXP_FM2

   FUNCTION FMEXP_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEXP(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMEXP_ZM2

!                                                            EXPONENT

   FUNCTION FMEXPONENT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      RETURN_VALUE = INT(MA%MFM%MP(2))
   END FUNCTION FMEXPONENT_FM

!                                                               FLOOR

   FUNCTION FMFLOOR_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,MTLVFM,QX)
      CALL FMSUB(MA%MFM,MTLVFM,MULVFM,QX)
      IF (MULVFM%MP(3) == 0) THEN
          CALL FMEQ(MA%MFM,RETURN_VALUE%MFM,QX)
      ELSE IF (MA%MFM%MP(1) < 0) THEN
          CALL FMADDI(MTLVFM,-1,QX)
          CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
      ELSE
          CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
      ENDIF
   END FUNCTION FMFLOOR_FM

   FUNCTION FMFLOOR_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMFLOOR_IM

   FUNCTION FMFLOOR_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MZM(1),MTLVFM,QX)
      CALL FMSUB(MA%MZM(1),MTLVFM,MULVFM,QX)
      IF (MULVFM%MP(3) == 0) THEN
          CALL FMEQ(MA%MZM(1),MVLVFM,QX)
      ELSE IF (MA%MZM(1)%MP(1) < 0) THEN
          CALL FMADDI(MTLVFM,-1,QX)
          CALL FMEQ(MTLVFM,MVLVFM,QX)
      ELSE
          CALL FMEQ(MTLVFM,MVLVFM,QX)
      ENDIF
      CALL FMINT(MA%MZM(2),MTLVFM,QX)
      CALL FMSUB(MA%MZM(2),MTLVFM,MULVFM,QX)
      IF (MULVFM%MP(3) == 0) THEN
          CALL FMEQ(MA%MZM(2),MULVFM,QX)
      ELSE IF (MA%MZM(2)%MP(1) < 0) THEN
          CALL FMADDI(MTLVFM,-1,QX)
          CALL FMEQ(MTLVFM,MULVFM,QX)
      ELSE
          CALL FMEQ(MTLVFM,MULVFM,QX)
      ENDIF
      CALL ZMCMPX(MVLVFM,MULVFM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMFLOOR_ZM

   FUNCTION FMFLOOR_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM) :: MT_FM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_FM = FMFLOOR_FM(MA(J))
         CALL FMEQ(MT_FM%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMFLOOR_FM1

   FUNCTION FMFLOOR_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_IM = FMFLOOR_IM(MA(J))
         CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMFLOOR_IM1

   FUNCTION FMFLOOR_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(ZM) :: MT_ZM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_ZM = FMFLOOR_ZM(MA(J))
         CALL ZMEQ(MT_ZM%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMFLOOR_ZM1

   FUNCTION FMFLOOR_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM) :: MT_FM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_FM = FMFLOOR_FM(MA(J,K))
            CALL FMEQ(MT_FM%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFLOOR_FM2

   FUNCTION FMFLOOR_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_IM = FMFLOOR_IM(MA(J,K))
            CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFLOOR_IM2

   FUNCTION FMFLOOR_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(ZM) :: MT_ZM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_ZM = FMFLOOR_ZM(MA(J,K))
            CALL ZMEQ(MT_ZM%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFLOOR_ZM2

!                                                            FRACTION

   FUNCTION FMFRACTION_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,MTLVFM,QX)
      MTLVFM%MP(2) = 0
      CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMFRACTION_FM

   FUNCTION FMFRACTION_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQ(MA%MZM,MTLVZM,QX)
      MTLVZM(1)%MP(2) = 0
      MTLVZM(2)%MP(2) = 0
      CALL ZMEQ(MTLVZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMFRACTION_ZM

   FUNCTION FMFRACTION_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM) :: MT_FM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_FM = FMFRACTION_FM(MA(J))
         CALL FMEQ(MT_FM%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMFRACTION_FM1

   FUNCTION FMFRACTION_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(ZM) :: MT_ZM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_ZM = FMFRACTION_ZM(MA(J))
         CALL ZMEQ(MT_ZM%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMFRACTION_ZM1

   FUNCTION FMFRACTION_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM) :: MT_FM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_FM = FMFRACTION_FM(MA(J,K))
            CALL FMEQ(MT_FM%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFRACTION_FM2

   FUNCTION FMFRACTION_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(ZM) :: MT_ZM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_ZM = FMFRACTION_ZM(MA(J,K))
            CALL ZMEQ(MT_ZM%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFRACTION_ZM2

!                                                                HUGE

   FUNCTION FMHUGE_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMBIG(RETURN_VALUE%MFM,QX)
      IF (SIZE(MA%MFM%MP) <= 2) THEN
          CALL FMI2M(1,MTLVFM,QX)
          CALL FMSUB_R1(RETURN_VALUE%MFM,MTLVFM,QX)
      ENDIF
   END FUNCTION FMHUGE_FM

   FUNCTION FMHUGE_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM,MULVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMBIG(RETURN_VALUE%MIM,QX)
      IF (SIZE(MA%MIM%MP) <= 2) THEN
          CALL IMI2M(0,MTLVIM,QX)
          CALL IMSUB(RETURN_VALUE%MIM,MTLVIM,MULVIM,QX)
      ENDIF
   END FUNCTION FMHUGE_IM

   FUNCTION FMHUGE_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMBIG(MTLVFM,QX)
      CALL ZMCMPX(MTLVFM,MTLVFM,RETURN_VALUE%MZM,QX)
      IF (SIZE(MA%MZM(1)%MP) <= 2) THEN
          CALL ZMI2M(1,MTLVZM,QX)
          CALL ZMSUB_R1(RETURN_VALUE%MZM,MTLVZM,QX)
      ENDIF
   END FUNCTION FMHUGE_ZM
!                                                               HYPOT

   FUNCTION FMHYPOT_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMHYPOT(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMHYPOT_FM

!                                                                 INT

   FUNCTION FMINT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM) :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMINT_FM

   FUNCTION FMINT_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMINT_IM

   FUNCTION FMINT_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM) :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMINT(MTLVFM,MULVFM,QX)
      CALL IMFM2I(MULVFM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMINT_ZM

   FUNCTION FMINT_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_IM = FMINT_FM(MA(J))
         CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMINT_FM1

   FUNCTION FMINT_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_IM = FMINT_IM(MA(J))
         CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMINT_IM1

   FUNCTION FMINT_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_IM = FMINT_ZM(MA(J))
         CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMINT_ZM1

   FUNCTION FMINT_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_IM = FMINT_FM(MA(J,K))
            CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMINT_FM2

   FUNCTION FMINT_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_IM = FMINT_IM(MA(J,K))
            CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMINT_IM2

   FUNCTION FMINT_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_IM = FMINT_ZM(MA(J,K))
            CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMINT_ZM2

!                                                                 LOG

   FUNCTION FMLOG_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMLN(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMLOG_FM

   FUNCTION FMLOG_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMLN(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMLOG_FM1

   FUNCTION FMLOG_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMLN(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMLOG_ZM1

   FUNCTION FMLOG_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMLN(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMLOG_FM2

   FUNCTION FMLOG_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMLN(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMLOG_ZM2

   FUNCTION FMLOG_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMLN(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMLOG_ZM

!                                                               LOG10

   FUNCTION FMLOG10_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMLG10(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMLOG10_FM

   FUNCTION FMLOG10_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMLG10(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMLOG10_ZM

   FUNCTION FMLOG10_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMLG10(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMLOG10_FM1

   FUNCTION FMLOG10_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMLG10(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMLOG10_ZM1

   FUNCTION FMLOG10_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMLG10(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMLOG10_FM2

   FUNCTION FMLOG10_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMLG10(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMLOG10_ZM2

!                                                              MATMUL

   FUNCTION FMMATMUL22_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:),MB(:,:)
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: I,J,K,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLV01
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=2) == SIZE(MB,DIM=1)) THEN
          NDSAVE = QX%NDIG
          J = MAX(QX%NGRD52,2)
          ND2 = MAX(2*QX%NDIG+J,2)
          QX%NDIG = ND2
          MXSAVE = QX%MXEXP
          DO I = 1, SIZE(MA,DIM=1)
             DO J = 1, SIZE(MB,DIM=2)
                QX%MXEXP = QX%MXEXP2
                CALL FMI2M(0,MTLVFM,QX)
                DO K = 1, SIZE(MA,DIM=2)
                   CALL FMEQU(MA(I,K)%MFM,MULVFM,NDSAVE,QX%NDIG,QX)
                   CALL FMEQU(MB(K,J)%MFM,MVLVFM,NDSAVE,QX%NDIG,QX)
                   CALL FMMPY(MULVFM,MVLVFM,MTLV01,QX)
                   CALL FMADD_R1(MTLVFM,MTLV01,QX)
                ENDDO
                QX%MXEXP = MXSAVE
                CALL FMEQU(MTLVFM,RETURN_VALUE(I,J)%MFM,QX%NDIG,NDSAVE,QX)
             ENDDO
          ENDDO
          QX%NDIG = NDSAVE
      ELSE
          CALL FMI2M(1,MTLVFM,QX)
          CALL FMI2M(0,MULVFM,QX)
          CALL FMDIV(MTLVFM,MULVFM,MVLVFM,QX)
          DO I = 1, SIZE(MA,DIM=1)
             DO J = 1, SIZE(MB,DIM=2)
                CALL FMEQ(MVLVFM,RETURN_VALUE(I,J)%MFM,QX)
             ENDDO
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL22_FM

   FUNCTION FMMATMUL12_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:),MB(:,:)
      TYPE (FM), DIMENSION(SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLV01
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) == SIZE(MB,DIM=1)) THEN
          NDSAVE = QX%NDIG
          J = MAX(QX%NGRD52,2)
          ND2 = MAX(2*QX%NDIG+J,2)
          QX%NDIG = ND2
          MXSAVE = QX%MXEXP
          DO J = 1, SIZE(MB,DIM=2)
             QX%MXEXP = QX%MXEXP2
             CALL FMI2M(0,MTLVFM,QX)
             DO K = 1, SIZE(MA,DIM=1)
                CALL FMEQU(MA(K)%MFM,MULVFM,NDSAVE,QX%NDIG,QX)
                CALL FMEQU(MB(K,J)%MFM,MVLVFM,NDSAVE,QX%NDIG,QX)
                CALL FMMPY(MULVFM,MVLVFM,MTLV01,QX)
                CALL FMADD_R1(MTLVFM,MTLV01,QX)
             ENDDO
             QX%MXEXP = MXSAVE
             CALL FMEQU(MTLVFM,RETURN_VALUE(J)%MFM,QX%NDIG,NDSAVE,QX)
          ENDDO
          QX%NDIG = NDSAVE
      ELSE
          CALL FMST2M(' UNKNOWN ',MVLVFM,QX)
          DO J = 1, SIZE(MB,DIM=2)
             CALL FMEQ(MVLVFM,RETURN_VALUE(J)%MFM,QX)
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL12_FM

   FUNCTION FMMATMUL21_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:),MB(:)
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1)) :: RETURN_VALUE
      INTEGER :: J,K,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLV01
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MB) == SIZE(MA,DIM=2)) THEN
          NDSAVE = QX%NDIG
          J = MAX(QX%NGRD52,2)
          ND2 = MAX(2*QX%NDIG+J,2)
          QX%NDIG = ND2
          MXSAVE = QX%MXEXP
          DO J = 1, SIZE(MA,DIM=1)
             QX%MXEXP = QX%MXEXP2
             CALL FMI2M(0,MTLVFM,QX)
             DO K = 1, SIZE(MB,DIM=1)
                CALL FMEQU(MA(J,K)%MFM,MULVFM,NDSAVE,QX%NDIG,QX)
                CALL FMEQU(MB(K)%MFM,MVLVFM,NDSAVE,QX%NDIG,QX)
                CALL FMMPY(MULVFM,MVLVFM,MTLV01,QX)
                CALL FMADD_R1(MTLVFM,MTLV01,QX)
             ENDDO
             QX%MXEXP = MXSAVE
             CALL FMEQU(MTLVFM,RETURN_VALUE(J)%MFM,QX%NDIG,NDSAVE,QX)
          ENDDO
          QX%NDIG = NDSAVE
      ELSE
          CALL FMST2M(' UNKNOWN ',MVLVFM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             CALL FMEQ(MVLVFM,RETURN_VALUE(J)%MFM,QX)
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL21_FM

   FUNCTION FMMATMUL22_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:),MB(:,:)
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: I,J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVIM,MULVIM,M3LVIM,MTLV01
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=2) == SIZE(MB,DIM=1)) THEN
          DO I = 1, SIZE(MA,DIM=1)
             DO J = 1, SIZE(MB,DIM=2)
                CALL IMI2M(0,MTLVIM,QX)
                DO K = 1, SIZE(MA,DIM=2)
                   CALL IMMPY(MA(I,K)%MIM,MB(K,J)%MIM,MTLV01,QX)
                   CALL IMADD(MTLVIM,MTLV01,MULVIM,QX)
                   CALL IMEQ(MULVIM,MTLVIM,QX)
                ENDDO
                CALL IMEQ(MTLVIM,RETURN_VALUE(I,J)%MIM,QX)
             ENDDO
          ENDDO
      ELSE
          CALL IMI2M(1,MTLVIM,QX)
          CALL IMI2M(0,MULVIM,QX)
          CALL IMDIV(MTLVIM,MULVIM,M3LVIM,QX)
          DO I = 1, SIZE(MA,DIM=1)
             DO J = 1, SIZE(MB,DIM=2)
                CALL IMEQ(M3LVIM,RETURN_VALUE(I,J)%MIM,QX)
             ENDDO
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL22_IM

   FUNCTION FMMATMUL12_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:),MB(:,:)
      TYPE (IM), DIMENSION(SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVIM,MULVIM,MTLV01
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) == SIZE(MB,DIM=1)) THEN
          DO J = 1, SIZE(MB,DIM=2)
             CALL IMI2M(0,MTLVIM,QX)
             DO K = 1, SIZE(MA,DIM=1)
                CALL IMMPY(MA(K)%MIM,MB(K,J)%MIM,MTLV01,QX)
                CALL IMADD(MTLVIM,MTLV01,MULVIM,QX)
                CALL IMEQ(MULVIM,MTLVIM,QX)
             ENDDO
             CALL IMEQ(MTLVIM,RETURN_VALUE(J)%MIM,QX)
          ENDDO
      ELSE
          CALL IMST2M(' UNKNOWN ',MULVIM,QX)
          DO J = 1, SIZE(MB,DIM=2)
             CALL IMEQ(MULVIM,RETURN_VALUE(J)%MIM,QX)
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL12_IM

   FUNCTION FMMATMUL21_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:),MB(:)
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVIM,MULVIM,MTLV01
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MB) == SIZE(MA,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             CALL IMI2M(0,MTLVIM,QX)
             DO K = 1, SIZE(MB,DIM=1)
                CALL IMMPY(MA(J,K)%MIM,MB(K)%MIM,MTLV01,QX)
                CALL IMADD(MTLVIM,MTLV01,MULVIM,QX)
                CALL IMEQ(MULVIM,MTLVIM,QX)
             ENDDO
             CALL IMEQ(MTLVIM,RETURN_VALUE(J)%MIM,QX)
          ENDDO
      ELSE
          CALL IMST2M(' UNKNOWN ',MULVIM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             CALL IMEQ(MULVIM,RETURN_VALUE(J)%MIM,QX)
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL21_IM

   FUNCTION FMMATMUL22_ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:,:),MB(:,:)
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: I,J,K,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),MVLVZM(2),MZLV02(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA,DIM=2) == SIZE(MB,DIM=1)) THEN
          NDSAVE = QX%NDIG
          J = MAX(QX%NGRD52,2)
          ND2 = MAX(2*QX%NDIG+J,2)
          QX%NDIG = ND2
          MXSAVE = QX%MXEXP
          DO I = 1, SIZE(MA,DIM=1)
             DO J = 1, SIZE(MB,DIM=2)
                QX%MXEXP = QX%MXEXP2
                CALL ZMI2M(0,MTLVZM,QX)
                DO K = 1, SIZE(MA,DIM=2)
                   CALL ZMEQU(MA(I,K)%MZM,MULVZM,NDSAVE,QX%NDIG,QX)
                   CALL ZMEQU(MB(K,J)%MZM,MVLVZM,NDSAVE,QX%NDIG,QX)
                   CALL ZMMPY(MULVZM,MVLVZM,MZLV02,QX)
                   CALL ZMADD(MTLVZM,MZLV02,MULVZM,QX)
                   CALL ZMEQ(MULVZM,MTLVZM,QX)
                ENDDO
                QX%MXEXP = MXSAVE
                CALL ZMEQU(MTLVZM,RETURN_VALUE(I,J)%MZM,QX%NDIG,NDSAVE,QX)
             ENDDO
          ENDDO
          QX%NDIG = NDSAVE
      ELSE
          CALL ZMI2M(1,MTLVZM,QX)
          CALL ZMI2M(0,MULVZM,QX)
          CALL ZMDIV(MTLVZM,MULVZM,MVLVZM,QX)
          DO I = 1, SIZE(MA,DIM=1)
             DO J = 1, SIZE(MB,DIM=2)
                CALL ZMEQ(MVLVZM,RETURN_VALUE(I,J)%MZM,QX)
             ENDDO
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL22_ZM

   FUNCTION FMMATMUL12_ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:),MB(:,:)
      TYPE (ZM), DIMENSION(SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),MVLVZM(2),MZLV01(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MA) == SIZE(MB,DIM=1)) THEN
          NDSAVE = QX%NDIG
          J = MAX(QX%NGRD52,2)
          ND2 = MAX(2*QX%NDIG+J,2)
          QX%NDIG = ND2
          MXSAVE = QX%MXEXP
          DO J = 1, SIZE(MB,DIM=2)
             QX%MXEXP = QX%MXEXP2
             CALL ZMI2M(0,MTLVZM,QX)
             DO K = 1, SIZE(MA,DIM=1)
                CALL ZMEQU(MA(K)%MZM,MULVZM,NDSAVE,QX%NDIG,QX)
                CALL ZMEQU(MB(K,J)%MZM,MVLVZM,NDSAVE,QX%NDIG,QX)
                CALL ZMMPY(MULVZM,MVLVZM,MZLV01,QX)
                CALL ZMADD(MTLVZM,MZLV01,MULVZM,QX)
                CALL ZMEQ(MULVZM,MTLVZM,QX)
             ENDDO
             QX%MXEXP = MXSAVE
             CALL ZMEQU(MTLVZM,RETURN_VALUE(J)%MZM,QX%NDIG,NDSAVE,QX)
          ENDDO
          QX%NDIG = NDSAVE
      ELSE
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MVLVZM,QX)
          DO J = 1, SIZE(MB,DIM=2)
             CALL ZMEQ(MVLVZM,RETURN_VALUE(J)%MZM,QX)
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL12_ZM

   FUNCTION FMMATMUL21_ZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:,:),MB(:)
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1)) :: RETURN_VALUE
      INTEGER :: J,K,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),MVLVZM(2),MZLV01(2)
      TYPE(FM_SETTINGS) :: QX
      IF (SIZE(MB) == SIZE(MA,DIM=2)) THEN
          NDSAVE = QX%NDIG
          J = MAX(QX%NGRD52,2)
          ND2 = MAX(2*QX%NDIG+J,2)
          QX%NDIG = ND2
          MXSAVE = QX%MXEXP
          DO J = 1, SIZE(MA,DIM=1)
             QX%MXEXP = QX%MXEXP2
             CALL ZMI2M(0,MTLVZM,QX)
             DO K = 1, SIZE(MB,DIM=1)
                CALL ZMEQU(MA(J,K)%MZM,MULVZM,NDSAVE,QX%NDIG,QX)
                CALL ZMEQU(MB(K)%MZM,MVLVZM,NDSAVE,QX%NDIG,QX)
                CALL ZMMPY(MULVZM,MVLVZM,MZLV01,QX)
                CALL ZMADD(MTLVZM,MZLV01,MULVZM,QX)
                CALL ZMEQ(MULVZM,MTLVZM,QX)
             ENDDO
             QX%MXEXP = MXSAVE
             CALL ZMEQU(MTLVZM,RETURN_VALUE(J)%MZM,QX%NDIG,NDSAVE,QX)
          ENDDO
          QX%NDIG = NDSAVE
      ELSE
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MVLVZM,QX)
          DO J = 1, SIZE(MA,DIM=1)
             CALL ZMEQ(MVLVZM,RETURN_VALUE(J)%MZM,QX)
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL21_ZM

!                                                                 MAX

   FUNCTION FMMAX_FM(MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      TYPE (FM), OPTIONAL :: MC,MD,ME,MF,MG,MH,MI,MJ
      INTENT (IN) :: MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMMAX(MA%MFM,MB%MFM,MTLVFM,QX)
      IF (PRESENT(MC)) THEN
          CALL FMMAX(MTLVFM,MC%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MD)) THEN
          CALL FMMAX(MTLVFM,MD%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(ME)) THEN
          CALL FMMAX(MTLVFM,ME%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MF)) THEN
          CALL FMMAX(MTLVFM,MF%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MG)) THEN
          CALL FMMAX(MTLVFM,MG%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MH)) THEN
          CALL FMMAX(MTLVFM,MH%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MI)) THEN
          CALL FMMAX(MTLVFM,MI%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MJ)) THEN
          CALL FMMAX(MTLVFM,MJ%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMAX_FM

   FUNCTION FMMAX_IM(MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      TYPE (IM), OPTIONAL :: MC,MD,ME,MF,MG,MH,MI,MJ
      INTENT (IN) :: MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ
      TYPE(MULTI) :: MTLVIM,MULVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMMAX(MA%MIM,MB%MIM,MTLVIM,QX)
      IF (PRESENT(MC)) THEN
          CALL IMMAX(MTLVIM,MC%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MD)) THEN
          CALL IMMAX(MTLVIM,MD%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(ME)) THEN
          CALL IMMAX(MTLVIM,ME%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MF)) THEN
          CALL IMMAX(MTLVIM,MF%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MG)) THEN
          CALL IMMAX(MTLVIM,MG%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MH)) THEN
          CALL IMMAX(MTLVIM,MH%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MI)) THEN
          CALL IMMAX(MTLVIM,MI%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MJ)) THEN
          CALL IMMAX(MTLVIM,MJ%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      CALL IMEQ(MTLVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMAX_IM

!                                                         MAXEXPONENT

   FUNCTION FMMAXEXPONENT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = INT(QX%MXEXP) + 1
      IF (SIZE(MA%MFM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMMAXEXPONENT_FM

!                                                              MAXLOC

   FUNCTION FMMAXLOC1_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:)
      INTEGER :: RETURN_VALUE
      TYPE(FM_SETTINGS) :: QX
      INTEGER :: J,JA
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVFM
      CALL FMST2M(' -OVERFLOW ',M3LVFM,QX)
      RETURN_VALUE = LBOUND(MA,DIM=1)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         IF (FMCOMP(MA(JA)%MFM,'>',M3LVFM,QX)) THEN
             CALL FMEQ(MA(JA)%MFM,M3LVFM,QX)
             RETURN_VALUE = JA
         ENDIF
      ENDDO
   END FUNCTION FMMAXLOC1_FM

   FUNCTION FMMAXLOC2_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:)
      INTEGER :: RETURN_VALUE(2)
      INTEGER :: J,K,JA,JB
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(' -OVERFLOW ',M3LVFM,QX)
      RETURN_VALUE = (/ LBOUND(MA,DIM=1), LBOUND(MA,DIM=2) /)
      DO K = 1, SIZE(MA,DIM=2)
         DO J = 1, SIZE(MA,DIM=1)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            IF (FMCOMP(MA(JA,JB)%MFM,'>',M3LVFM,QX)) THEN
                CALL FMEQ(MA(JA,JB)%MFM,M3LVFM,QX)
                RETURN_VALUE = (/ JA, JB /)
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION FMMAXLOC2_FM

   FUNCTION FMMAXLOC1_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:)
      INTEGER :: RETURN_VALUE
      INTEGER :: J,JA
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(' -OVERFLOW ',M3LVIM,QX)
      RETURN_VALUE = LBOUND(MA,DIM=1)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         IF (IMCOMP(MA(JA)%MIM,'>',M3LVIM,QX)) THEN
             CALL IMEQ(MA(JA)%MIM,M3LVIM,QX)
             RETURN_VALUE = JA
         ENDIF
      ENDDO
   END FUNCTION FMMAXLOC1_IM

   FUNCTION FMMAXLOC2_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:)
      INTEGER :: RETURN_VALUE(2)
      INTEGER :: J,K,JA,JB
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(' -OVERFLOW ',M3LVIM,QX)
      RETURN_VALUE = (/ LBOUND(MA,DIM=1), LBOUND(MA,DIM=2) /)
      DO K = 1, SIZE(MA,DIM=2)
         DO J = 1, SIZE(MA,DIM=1)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            IF (IMCOMP(MA(JA,JB)%MIM,'>',M3LVIM,QX)) THEN
                CALL IMEQ(MA(JA,JB)%MIM,M3LVIM,QX)
                RETURN_VALUE = (/ JA, JB /)
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION FMMAXLOC2_IM

!                                                              MAXVAL

   FUNCTION FMMAXVAL1_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(' -OVERFLOW ',M3LVFM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         IF (FMCOMP(MA(JA)%MFM,'>',M3LVFM,QX)) CALL FMEQ(MA(JA)%MFM,M3LVFM,QX)
      ENDDO
      CALL FMEQ(M3LVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMAXVAL1_FM

   FUNCTION FMMAXVAL2_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(' -OVERFLOW ',M3LVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            IF (FMCOMP(MA(JA,JB)%MFM,'>',M3LVFM,QX)) CALL FMEQ(MA(JA,JB)%MFM,M3LVFM,QX)
         ENDDO
      ENDDO
      CALL FMEQ(M3LVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMAXVAL2_FM

   FUNCTION FMMAXVAL1_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(' -OVERFLOW ',M3LVIM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         IF (IMCOMP(MA(JA)%MIM,'>',M3LVIM,QX)) CALL IMEQ(MA(JA)%MIM,M3LVIM,QX)
      ENDDO
      CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMAXVAL1_IM

   FUNCTION FMMAXVAL2_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(' -OVERFLOW ',M3LVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            IF (IMCOMP(MA(JA,JB)%MIM,'>',M3LVIM,QX)) CALL IMEQ(MA(JA,JB)%MIM,M3LVIM,QX)
         ENDDO
      ENDDO
      CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMAXVAL2_IM

!                                                                 MIN

   FUNCTION FMMIN_FM(MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      TYPE (FM), OPTIONAL :: MC,MD,ME,MF,MG,MH,MI,MJ
      INTENT (IN) :: MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMMIN(MA%MFM,MB%MFM,MTLVFM,QX)
      IF (PRESENT(MC)) THEN
          CALL FMMIN(MTLVFM,MC%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MD)) THEN
          CALL FMMIN(MTLVFM,MD%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(ME)) THEN
          CALL FMMIN(MTLVFM,ME%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MF)) THEN
          CALL FMMIN(MTLVFM,MF%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MG)) THEN
          CALL FMMIN(MTLVFM,MG%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MH)) THEN
          CALL FMMIN(MTLVFM,MH%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MI)) THEN
          CALL FMMIN(MTLVFM,MI%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      IF (PRESENT(MJ)) THEN
          CALL FMMIN(MTLVFM,MJ%MFM,MULVFM,QX)
          CALL FMEQ(MULVFM,MTLVFM,QX)
      ENDIF
      CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMIN_FM

   FUNCTION FMMIN_IM(MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      TYPE (IM), OPTIONAL :: MC,MD,ME,MF,MG,MH,MI,MJ
      INTENT (IN) :: MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ
      TYPE(MULTI) :: MTLVIM,MULVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMMIN(MA%MIM,MB%MIM,MTLVIM,QX)
      IF (PRESENT(MC)) THEN
          CALL IMMIN(MTLVIM,MC%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MD)) THEN
          CALL IMMIN(MTLVIM,MD%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(ME)) THEN
          CALL IMMIN(MTLVIM,ME%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MF)) THEN
          CALL IMMIN(MTLVIM,MF%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MG)) THEN
          CALL IMMIN(MTLVIM,MG%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MH)) THEN
          CALL IMMIN(MTLVIM,MH%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MI)) THEN
          CALL IMMIN(MTLVIM,MI%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      IF (PRESENT(MJ)) THEN
          CALL IMMIN(MTLVIM,MJ%MIM,MULVIM,QX)
          CALL IMEQ(MULVIM,MTLVIM,QX)
      ENDIF
      CALL IMEQ(MTLVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMIN_IM

!                                                         MINEXPONENT

   FUNCTION FMMINEXPONENT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = -INT(QX%MXEXP)
      IF (SIZE(MA%MFM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMMINEXPONENT_FM

!                                                              MINVAL

   FUNCTION FMMINVAL1_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(' OVERFLOW ',M3LVFM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         IF (FMCOMP(MA(JA)%MFM,'<',M3LVFM,QX)) CALL FMEQ(MA(JA)%MFM,M3LVFM,QX)
      ENDDO
      CALL FMEQ(M3LVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMINVAL1_FM

   FUNCTION FMMINVAL2_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(' OVERFLOW ',M3LVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            IF (FMCOMP(MA(JA,JB)%MFM,'<',M3LVFM,QX)) CALL FMEQ(MA(JA,JB)%MFM,M3LVFM,QX)
         ENDDO
      ENDDO
      CALL FMEQ(M3LVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMINVAL2_FM

   FUNCTION FMMINVAL1_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(' OVERFLOW ',M3LVIM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         IF (IMCOMP(MA(JA)%MIM,'<',M3LVIM,QX)) CALL IMEQ(MA(JA)%MIM,M3LVIM,QX)
      ENDDO
      CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMINVAL1_IM

   FUNCTION FMMINVAL2_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(' OVERFLOW ',M3LVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            IF (IMCOMP(MA(JA,JB)%MIM,'<',M3LVIM,QX)) CALL IMEQ(MA(JA,JB)%MIM,M3LVIM,QX)
         ENDDO
      ENDDO
      CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMINVAL2_IM

!                                                              MINLOC

   FUNCTION FMMINLOC1_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:)
      INTEGER :: RETURN_VALUE
      INTEGER :: J,JA
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(' OVERFLOW ',M3LVFM,QX)
      RETURN_VALUE = LBOUND(MA,DIM=1)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         IF (FMCOMP(MA(JA)%MFM,'<',M3LVFM,QX)) THEN
             CALL FMEQ(MA(JA)%MFM,M3LVFM,QX)
             RETURN_VALUE = JA
         ENDIF
      ENDDO
   END FUNCTION FMMINLOC1_FM

   FUNCTION FMMINLOC2_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:)
      INTEGER :: RETURN_VALUE(2)
      INTEGER :: J,K,JA,JB
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(' OVERFLOW ',M3LVFM,QX)
      RETURN_VALUE = (/ LBOUND(MA,DIM=1), LBOUND(MA,DIM=2) /)
      DO K = 1, SIZE(MA,DIM=2)
         DO J = 1, SIZE(MA,DIM=1)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            IF (FMCOMP(MA(JA,JB)%MFM,'<',M3LVFM,QX)) THEN
                CALL FMEQ(MA(JA,JB)%MFM,M3LVFM,QX)
                RETURN_VALUE = (/ JA, JB /)
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION FMMINLOC2_FM

   FUNCTION FMMINLOC1_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:)
      INTEGER :: RETURN_VALUE
      INTEGER :: J,JA
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(' OVERFLOW ',M3LVIM,QX)
      RETURN_VALUE = LBOUND(MA,DIM=1)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         IF (IMCOMP(MA(JA)%MIM,'<',M3LVIM,QX)) THEN
             CALL IMEQ(MA(JA)%MIM,M3LVIM,QX)
             RETURN_VALUE = JA
         ENDIF
      ENDDO
   END FUNCTION FMMINLOC1_IM

   FUNCTION FMMINLOC2_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:)
      INTEGER :: RETURN_VALUE(2)
      INTEGER :: J,K,JA,JB
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA
      TYPE(MULTI) :: M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(' OVERFLOW ',M3LVIM,QX)
      RETURN_VALUE = (/ LBOUND(MA,DIM=1), LBOUND(MA,DIM=2) /)
      DO K = 1, SIZE(MA,DIM=2)
         DO J = 1, SIZE(MA,DIM=1)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            IF (IMCOMP(MA(JA,JB)%MIM,'<',M3LVIM,QX)) THEN
                CALL IMEQ(MA(JA,JB)%MIM,M3LVIM,QX)
                RETURN_VALUE = (/ JA, JB /)
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION FMMINLOC2_IM

!                                                                 MOD

   FUNCTION FMMOD_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMMOD(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMOD_FM

   FUNCTION FMMOD_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMMOD(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMOD_IM

!                                                              MODULO

   FUNCTION FMMODULO_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMMOD(MA%MFM,MB%MFM,MTLVFM,QX)
      IF (MTLVFM%MP(3) /= 0) THEN
          IF ((MA%MFM%MP(3) > 0 .AND. MA%MFM%MP(1) > 0 .AND.  &
               MB%MFM%MP(3) > 0 .AND. MB%MFM%MP(1) < 0) .OR.  &
              (MA%MFM%MP(3) > 0 .AND. MA%MFM%MP(1) < 0 .AND.  &
               MB%MFM%MP(3) > 0 .AND. MB%MFM%MP(1) > 0)) THEN
              CALL FMADD_R1(MTLVFM,MB%MFM,QX)
          ENDIF
      ENDIF
      CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMMODULO_FM

   FUNCTION FMMODULO_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVIM,MULVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMMOD(MA%MIM,MB%MIM,MTLVIM,QX)
      IF (MTLVIM%MP(3) /= 0) THEN
          IF ((MA%MIM%MP(3) > 0 .AND. MA%MIM%MP(1) > 0 .AND.  &
               MB%MIM%MP(3) > 0 .AND. MB%MIM%MP(1) < 0) .OR.  &
              (MA%MIM%MP(3) > 0 .AND. MA%MIM%MP(1) < 0 .AND.  &
               MB%MIM%MP(3) > 0 .AND. MB%MIM%MP(1) > 0)) THEN
              CALL IMADD(MTLVIM,MB%MIM,MULVIM,QX)
              CALL IMEQ(MULVIM,MTLVIM,QX)
          ENDIF
      ENDIF
      CALL IMEQ(MTLVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMMODULO_IM

!                                                             NEAREST

   FUNCTION FMNEAREST_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTEGER :: KRSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: M3LVFM
      TYPE(FM_SETTINGS) :: QX
      KRSAVE = QX%KROUND
      CALL FMTINY(M3LVFM,QX)
      IF (MA%MFM%MP(2) /= QX%MEXPUN) THEN
          IF (MB%MFM%MP(1) > 0) THEN
              QX%KROUND = 2
              CALL FMADD(MA%MFM,M3LVFM,RETURN_VALUE%MFM,QX)
          ELSE
              QX%KROUND = -1
              CALL FMSUB(MA%MFM,M3LVFM,RETURN_VALUE%MFM,QX)
          ENDIF
      ELSE
          IF (MA%MFM%MP(1) > 0 .AND. MB%MFM%MP(1) > 0) THEN
              CALL FMEQ(M3LVFM,RETURN_VALUE%MFM,QX)
          ELSE IF (MA%MFM%MP(1) > 0 .AND. MB%MFM%MP(1) < 0) THEN
              CALL FMI2M(0,RETURN_VALUE%MFM,QX)
          ELSE IF (MA%MFM%MP(1) < 0 .AND. MB%MFM%MP(1) > 0) THEN
              CALL FMI2M(0,RETURN_VALUE%MFM,QX)
          ELSE
              CALL FMMPYI_R1(M3LVFM,-1,QX)
              CALL FMEQ(M3LVFM,RETURN_VALUE%MFM,QX)
          ENDIF
      ENDIF
      QX%KROUND = KRSAVE
   END FUNCTION FMNEAREST_FM

!                                                                NINT

   FUNCTION FMNINT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (IM) :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMNINT(MA%MFM,MTLVFM,QX)
      CALL IMFM2I(MTLVFM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMNINT_FM

   FUNCTION FMNINT_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMEQ(MA%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMNINT_IM

   FUNCTION FMNINT_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      TYPE (IM) :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MTLVFM,QX)
      CALL FMNINT(MTLVFM,MULVFM,QX)
      CALL IMFM2I(MULVFM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMNINT_ZM

   FUNCTION FMNINT_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_IM = FMNINT_FM(MA(J))
         CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMNINT_FM1

   FUNCTION FMNINT_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_IM = FMNINT_IM(MA(J))
         CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMNINT_IM1

   FUNCTION FMNINT_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         MT_IM = FMNINT_ZM(MA(J))
         CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMNINT_ZM1

   FUNCTION FMNINT_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_IM = FMNINT_FM(MA(J,K))
            CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMNINT_FM2

   FUNCTION FMNINT_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_IM = FMNINT_IM(MA(J,K))
            CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMNINT_IM2

   FUNCTION FMNINT_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(IM) :: MT_IM
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            MT_IM = FMNINT_ZM(MA(J,K))
            CALL IMEQ(MT_IM%MIM,RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMNINT_ZM2

!                                                             NORM2

   FUNCTION FMNORM21_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:),RETURN_VALUE
      TYPE(MULTI), ALLOCATABLE :: A(:)
      INTEGER :: J,JA,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(0,RETURN_VALUE%MFM,QX)
      N = SIZE(MA)
      ALLOCATE(A(N))
      DO J = 1, N
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL FMEQ(MA(JA)%MFM,A(J),QX)
      ENDDO
      CALL FMNORM2(A,N,RETURN_VALUE%MFM,QX)
      DEALLOCATE(A)
   END FUNCTION FMNORM21_FM

!                                                           PRECISION

   FUNCTION FMPRECISION_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = INT(LOG10(REAL(QX%MBASE))*(QX%NDIG-1) + 1)
      IF (SIZE(MA%MFM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMPRECISION_FM

   FUNCTION FMPRECISION_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = INT(LOG10(REAL(QX%MBASE))*(QX%NDIG-1) + 1)
      IF (SIZE(MA%MZM(1)%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMPRECISION_ZM

!                                                             PRODUCT

   FUNCTION FMPRODUCT1_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MULVFM,M3LVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL FMI2M(1,M3LVFM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL FMEQU(MA(JA)%MFM,MULVFM,NDSAVE,QX%NDIG,QX)
         CALL FMMPY_R1(M3LVFM,MULVFM,QX)
      ENDDO
      QX%MXEXP = MXSAVE
      CALL FMEQU(M3LVFM,RETURN_VALUE%MFM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMPRODUCT1_FM

   FUNCTION FMPRODUCT2_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MULVFM,M3LVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL FMI2M(1,M3LVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL FMEQU(MA(JA,JB)%MFM,MULVFM,NDSAVE,QX%NDIG,QX)
            CALL FMMPY_R1(M3LVFM,MULVFM,QX)
         ENDDO
      ENDDO
      QX%MXEXP = MXSAVE
      CALL FMEQU(M3LVFM,RETURN_VALUE%MFM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMPRODUCT2_FM

   FUNCTION FMPRODUCT1_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM,M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(1,M3LVIM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL IMMPY(MA(JA)%MIM,M3LVIM,MTLVIM,QX)
         CALL IMEQ(MTLVIM,M3LVIM,QX)
      ENDDO
      CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMPRODUCT1_IM

   FUNCTION FMPRODUCT2_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM,M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(1,M3LVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL IMMPY(MA(JA,JB)%MIM,M3LVIM,MTLVIM,QX)
            CALL IMEQ(MTLVIM,M3LVIM,QX)
         ENDDO
      ENDDO
      CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMPRODUCT2_IM

   FUNCTION FMPRODUCT1_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),M3LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL ZMI2M(1,M3LVZM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL ZMEQU(MA(JA)%MZM,MULVZM,NDSAVE,QX%NDIG,QX)
         CALL ZMMPY(MULVZM,M3LVZM,MTLVZM,QX)
         CALL ZMEQ(MTLVZM,M3LVZM,QX)
      ENDDO
      QX%MXEXP = MXSAVE
      CALL ZMEQU(M3LVZM,RETURN_VALUE%MZM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMPRODUCT1_ZM

   FUNCTION FMPRODUCT2_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),M3LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL ZMI2M(1,M3LVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL ZMEQU(MA(JA,JB)%MZM,MULVZM,NDSAVE,QX%NDIG,QX)
            CALL ZMMPY(MULVZM,M3LVZM,MTLVZM,QX)
            CALL ZMEQ(MTLVZM,M3LVZM,QX)
         ENDDO
      ENDDO
      QX%MXEXP = MXSAVE
      CALL ZMEQU(M3LVZM,RETURN_VALUE%MZM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMPRODUCT2_ZM

!                                                               RADIX

   FUNCTION FMRADIX_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = INT(QX%MBASE)
      IF (SIZE(MA%MFM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMRADIX_FM

   FUNCTION FMRADIX_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = INT(QX%MBASE)
      IF (SIZE(MA%MIM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMRADIX_IM

   FUNCTION FMRADIX_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = INT(QX%MBASE)
      IF (SIZE(MA%MZM(1)%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMRADIX_ZM

!                                                               RANGE

   FUNCTION FMRANGE_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = NINT((QX%MXEXP+1)*LOG10(DBLE(QX%MBASE))) - 1
      IF (SIZE(MA%MFM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMRANGE_FM

   FUNCTION FMRANGE_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA

!             The number of possible digits for type(im) integers is limited only by the amount
!             of memory that can be allocated.  Return 10**6 since there is no fixed limit.

      RETURN_VALUE = 10**6
      IF (SIZE(MA%MIM%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMRANGE_IM

   FUNCTION FMRANGE_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      RETURN_VALUE = NINT((QX%MXEXP+1)*LOG10(DBLE(QX%MBASE))) - 1
      IF (SIZE(MA%MZM(1)%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
   END FUNCTION FMRANGE_ZM


!                                                                REAL

   FUNCTION FMREAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMREAL_FM

   FUNCTION FMREAL_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMREAL_IM

   FUNCTION FMREAL_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMREAL_ZM

!                                                           RRSPACING

   FUNCTION FMRRSPACING_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMABS(MA%MFM,MTLVFM,QX)
      MTLVFM%MP(2) = QX%NDIG
      CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMRRSPACING_FM

!                                                               SCALE

   FUNCTION FMSCALE_FM(MA,L)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: L
      INTENT (IN) :: MA,L
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,M3LVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,MTLVFM,QX)
      IF (ABS(MTLVFM%MP(2)+L) < QX%MXEXP) THEN
          MTLVFM%MP(2) = MTLVFM%MP(2) + L
          CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
      ELSE
          CALL FMI2M(INT(QX%MBASE),MULVFM,QX)
          CALL FMIPWR(MULVFM,L,MVLVFM,QX)
          CALL FMMPY(MA%MFM,MVLVFM,M3LVFM,QX)
          CALL FMEQ(M3LVFM,RETURN_VALUE%MFM,QX)
      ENDIF
   END FUNCTION FMSCALE_FM

   FUNCTION FMSCALE_ZM(MA,L)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: L
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA,L
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),MVLVZM(2),M3LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQ(MA%MZM,MTLVZM,QX)
      IF (ABS(MTLVZM(1)%MP(2)+L) < QX%MXEXP .AND. &
          ABS(MTLVZM(2)%MP(2)+L) < QX%MXEXP) THEN
          MTLVZM(1)%MP(2) = MTLVZM(1)%MP(2) + L
          MTLVZM(2)%MP(2) = MTLVZM(2)%MP(2) + L
          CALL ZMEQ(MTLVZM,RETURN_VALUE%MZM,QX)
      ELSE
          CALL ZMI2M(INT(QX%MBASE),MULVZM,QX)
          CALL ZMIPWR(MULVZM,L,MVLVZM,QX)
          CALL ZMMPY(MA%MZM,MVLVZM,M3LVZM,QX)
          CALL ZMEQ(M3LVZM,RETURN_VALUE%MZM,QX)
      ENDIF
   END FUNCTION FMSCALE_ZM

!                                                         SETEXPONENT

   FUNCTION FMSETEXPONENT_FM(MA,L)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: L
      INTENT (IN) :: MA,L
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,MTLVFM,QX)
      MTLVFM%MP(2) = L
      CALL FMEQ(MTLVFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSETEXPONENT_FM

!                                                                SIGN

   FUNCTION FMSIGN_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSIGN(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSIGN_FM

   FUNCTION FMSIGN_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMSIGN(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMSIGN_IM

 END MODULE FMZM_8_PARALLEL

 MODULE FMZM_9_PARALLEL
    USE FMZM_1_PARALLEL

   INTERFACE SIN
      MODULE PROCEDURE FMSIN_FM
      MODULE PROCEDURE FMSIN_ZM
      MODULE PROCEDURE FMSIN_FM1
      MODULE PROCEDURE FMSIN_ZM1
      MODULE PROCEDURE FMSIN_FM2
      MODULE PROCEDURE FMSIN_ZM2
   END INTERFACE

   INTERFACE SINH
      MODULE PROCEDURE FMSINH_FM
      MODULE PROCEDURE FMSINH_ZM
      MODULE PROCEDURE FMSINH_FM1
      MODULE PROCEDURE FMSINH_ZM1
      MODULE PROCEDURE FMSINH_FM2
      MODULE PROCEDURE FMSINH_ZM2
   END INTERFACE

   INTERFACE SPACING
      MODULE PROCEDURE FMSPACING_FM
   END INTERFACE

   INTERFACE SQRT
      MODULE PROCEDURE FMSQRT_FM
      MODULE PROCEDURE FMSQRT_ZM
      MODULE PROCEDURE FMSQRT_FM1
      MODULE PROCEDURE FMSQRT_ZM1
      MODULE PROCEDURE FMSQRT_FM2
      MODULE PROCEDURE FMSQRT_ZM2
   END INTERFACE

   INTERFACE SUM
      MODULE PROCEDURE FMSUM1_FM
      MODULE PROCEDURE FMSUM2_FM
      MODULE PROCEDURE FMSUM1_IM
      MODULE PROCEDURE FMSUM2_IM
      MODULE PROCEDURE FMSUM1_ZM
      MODULE PROCEDURE FMSUM2_ZM
   END INTERFACE

   INTERFACE TAN
      MODULE PROCEDURE FMTAN_FM
      MODULE PROCEDURE FMTAN_ZM
      MODULE PROCEDURE FMTAN_FM1
      MODULE PROCEDURE FMTAN_ZM1
      MODULE PROCEDURE FMTAN_FM2
      MODULE PROCEDURE FMTAN_ZM2
   END INTERFACE

   INTERFACE TANH
      MODULE PROCEDURE FMTANH_FM
      MODULE PROCEDURE FMTANH_ZM
      MODULE PROCEDURE FMTANH_FM1
      MODULE PROCEDURE FMTANH_ZM1
      MODULE PROCEDURE FMTANH_FM2
      MODULE PROCEDURE FMTANH_ZM2
   END INTERFACE

   INTERFACE TINY
      MODULE PROCEDURE FMTINY_FM
      MODULE PROCEDURE FMTINY_IM
      MODULE PROCEDURE FMTINY_ZM
   END INTERFACE

   INTERFACE TRANSPOSE
      MODULE PROCEDURE FMTRANSPOSE_FM
      MODULE PROCEDURE FMTRANSPOSE_IM
      MODULE PROCEDURE FMTRANSPOSE_ZM
   END INTERFACE

   INTERFACE FM_FORMAT
      MODULE PROCEDURE FMFORMAT_FM
   END INTERFACE

   INTERFACE IM_FORMAT
      MODULE PROCEDURE IMFORMAT_IM
   END INTERFACE

   INTERFACE ZM_FORMAT
      MODULE PROCEDURE ZMFORMAT_ZM
   END INTERFACE

   INTERFACE GCD
      MODULE PROCEDURE GCD_IM
   END INTERFACE

   INTERFACE MULTIPLY_MOD
      MODULE PROCEDURE MULTIPLYMOD_IM
   END INTERFACE

   INTERFACE POWER_MOD
      MODULE PROCEDURE POWERMOD_IM
   END INTERFACE

   INTERFACE BERNOULLI
      MODULE PROCEDURE FMBERNOULLI_FM
   END INTERFACE

   INTERFACE BETA
      MODULE PROCEDURE FMBETA_FM
   END INTERFACE

   INTERFACE BINOMIAL
      MODULE PROCEDURE FMBINOMIAL_FM
      MODULE PROCEDURE FMBINOMIAL_IM
      MODULE PROCEDURE FMBINOMIAL_I
   END INTERFACE

   INTERFACE FACTORIAL
      MODULE PROCEDURE FMFACTORIAL_FM
      MODULE PROCEDURE FMFACTORIAL_FM1
      MODULE PROCEDURE FMFACTORIAL_FM2
      MODULE PROCEDURE FMFACTORIAL_IM
      MODULE PROCEDURE FMFACTORIAL_IM1
      MODULE PROCEDURE FMFACTORIAL_IM2
      MODULE PROCEDURE FMFACTORIAL_ZM
      MODULE PROCEDURE FMFACTORIAL_ZM1
      MODULE PROCEDURE FMFACTORIAL_ZM2
      MODULE PROCEDURE FMFACTORIAL_I
      MODULE PROCEDURE FMFACTORIAL_I1
      MODULE PROCEDURE FMFACTORIAL_I2
   END INTERFACE

   INTERFACE GAMMA
      MODULE PROCEDURE FMGAMMA_FM
      MODULE PROCEDURE FMGAMMA_FM1
      MODULE PROCEDURE FMGAMMA_FM2
      MODULE PROCEDURE FMGAMMA_ZM
      MODULE PROCEDURE FMGAMMA_ZM1
      MODULE PROCEDURE FMGAMMA_ZM2
   END INTERFACE

   INTERFACE INCOMPLETE_BETA
      MODULE PROCEDURE FMINCOMPLETE_BETA_FM
   END INTERFACE

   INTERFACE INCOMPLETE_GAMMA1
      MODULE PROCEDURE FMINCOMPLETE_GAMMA1_FM
   END INTERFACE

   INTERFACE INCOMPLETE_GAMMA2
      MODULE PROCEDURE FMINCOMPLETE_GAMMA2_FM
   END INTERFACE

   INTERFACE LOG_GAMMA
      MODULE PROCEDURE FMLOG_GAMMA_FM
      MODULE PROCEDURE FMLOG_GAMMA_FM1
      MODULE PROCEDURE FMLOG_GAMMA_FM2
      MODULE PROCEDURE FMLOG_GAMMA_ZM
      MODULE PROCEDURE FMLOG_GAMMA_ZM1
      MODULE PROCEDURE FMLOG_GAMMA_ZM2
   END INTERFACE

   INTERFACE POLYGAMMA
      MODULE PROCEDURE FMPOLYGAMMA_FM
   END INTERFACE

   INTERFACE POCHHAMMER
      MODULE PROCEDURE FMPOCHHAMMER_FM
   END INTERFACE

   INTERFACE PSI
      MODULE PROCEDURE FMPSI_FM
      MODULE PROCEDURE FMPSI_FM1
      MODULE PROCEDURE FMPSI_FM2
   END INTERFACE

   INTERFACE BESSEL_J
      MODULE PROCEDURE FMBESSEL_J_FM
   END INTERFACE

   INTERFACE BESSEL_J0
      MODULE PROCEDURE FMBESSEL_J0_FM
   END INTERFACE

   INTERFACE BESSEL_J1
      MODULE PROCEDURE FMBESSEL_J1_FM
   END INTERFACE

   INTERFACE BESSEL_JN
      MODULE PROCEDURE FMBESSEL_JN_FM
      MODULE PROCEDURE FMBESSEL_JN2_FM
   END INTERFACE

   INTERFACE BESSEL_Y
      MODULE PROCEDURE FMBESSEL_Y_FM
   END INTERFACE

   INTERFACE BESSEL_Y0
      MODULE PROCEDURE FMBESSEL_Y0_FM
   END INTERFACE

   INTERFACE BESSEL_Y1
      MODULE PROCEDURE FMBESSEL_Y1_FM
   END INTERFACE

   INTERFACE BESSEL_YN
      MODULE PROCEDURE FMBESSEL_YN_FM
      MODULE PROCEDURE FMBESSEL_YN2_FM
   END INTERFACE

   INTERFACE COS_INTEGRAL
      MODULE PROCEDURE FMCOS_INTEGRAL_FM
      MODULE PROCEDURE FMCOS_INTEGRAL_FM1
      MODULE PROCEDURE FMCOS_INTEGRAL_FM2
   END INTERFACE

   INTERFACE COSH_INTEGRAL
      MODULE PROCEDURE FMCOSH_INTEGRAL_FM
      MODULE PROCEDURE FMCOSH_INTEGRAL_FM1
      MODULE PROCEDURE FMCOSH_INTEGRAL_FM2
   END INTERFACE

   INTERFACE EXP_INTEGRAL_EI
      MODULE PROCEDURE FMEXP_INTEGRAL_EI_FM
      MODULE PROCEDURE FMEXP_INTEGRAL_EI_FM1
      MODULE PROCEDURE FMEXP_INTEGRAL_EI_FM2
   END INTERFACE

   INTERFACE EXP_INTEGRAL_EN
      MODULE PROCEDURE FMEXP_INTEGRAL_EN_FM
   END INTERFACE

   INTERFACE FRESNEL_C
      MODULE PROCEDURE FMFRESNEL_C_FM
      MODULE PROCEDURE FMFRESNEL_C_FM1
      MODULE PROCEDURE FMFRESNEL_C_FM2
   END INTERFACE

   INTERFACE FRESNEL_S
      MODULE PROCEDURE FMFRESNEL_S_FM
      MODULE PROCEDURE FMFRESNEL_S_FM1
      MODULE PROCEDURE FMFRESNEL_S_FM2
   END INTERFACE

   INTERFACE ERF
      MODULE PROCEDURE FMERF_FM
      MODULE PROCEDURE FMERF_FM1
      MODULE PROCEDURE FMERF_FM2
      MODULE PROCEDURE FMERF_ZM
      MODULE PROCEDURE FMERF_ZM1
      MODULE PROCEDURE FMERF_ZM2
   END INTERFACE

   INTERFACE ERFC
      MODULE PROCEDURE FMERFC_FM
      MODULE PROCEDURE FMERFC_FM1
      MODULE PROCEDURE FMERFC_FM2
      MODULE PROCEDURE FMERFC_ZM
      MODULE PROCEDURE FMERFC_ZM1
      MODULE PROCEDURE FMERFC_ZM2
   END INTERFACE

   INTERFACE ERFC_SCALED
      MODULE PROCEDURE FMERFC_SCALED_FM
      MODULE PROCEDURE FMERFC_SCALED_FM1
      MODULE PROCEDURE FMERFC_SCALED_FM2
      MODULE PROCEDURE FMERFC_SCALED_ZM
      MODULE PROCEDURE FMERFC_SCALED_ZM1
      MODULE PROCEDURE FMERFC_SCALED_ZM2
   END INTERFACE

   INTERFACE LOG_ERFC
      MODULE PROCEDURE FMLOG_ERFC_FM
      MODULE PROCEDURE FMLOG_ERFC_FM1
      MODULE PROCEDURE FMLOG_ERFC_FM2
   END INTERFACE

   INTERFACE LOG_INTEGRAL
      MODULE PROCEDURE FMLOG_INTEGRAL_FM
      MODULE PROCEDURE FMLOG_INTEGRAL_FM1
      MODULE PROCEDURE FMLOG_INTEGRAL_FM2
   END INTERFACE

   INTERFACE SIN_INTEGRAL
      MODULE PROCEDURE FMSIN_INTEGRAL_FM
      MODULE PROCEDURE FMSIN_INTEGRAL_FM1
      MODULE PROCEDURE FMSIN_INTEGRAL_FM2
   END INTERFACE

   INTERFACE SINH_INTEGRAL
      MODULE PROCEDURE FMSINH_INTEGRAL_FM
      MODULE PROCEDURE FMSINH_INTEGRAL_FM1
      MODULE PROCEDURE FMSINH_INTEGRAL_FM2
   END INTERFACE

 CONTAINS

!                                                                 SIN

   FUNCTION FMSIN_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMSIN(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSIN_FM

   FUNCTION FMSIN_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSIN(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSIN_ZM

   FUNCTION FMSIN_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSIN(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSIN_FM1

   FUNCTION FMSIN_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMSIN(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSIN_ZM1

   FUNCTION FMSIN_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSIN(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSIN_FM2

   FUNCTION FMSIN_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSIN(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSIN_ZM2

!                                                                SINH

   FUNCTION FMSINH_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMSINH(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSINH_FM

   FUNCTION FMSINH_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSINH(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSINH_ZM

   FUNCTION FMSINH_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSINH(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSINH_FM1

   FUNCTION FMSINH_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMSINH(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSINH_ZM1

   FUNCTION FMSINH_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSINH(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSINH_FM2

   FUNCTION FMSINH_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSINH(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSINH_ZM2

!                                                             SPACING

   FUNCTION FMSPACING_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KWRNSV
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMABS(MA%MFM,MTLVFM,QX)
      IF (MTLVFM%MP(3) /= 0) THEN
          KWRNSV = QX%KWARN
          QX%KWARN = 0
          CALL FMULP(MTLVFM,RETURN_VALUE%MFM,QX)
          QX%KWARN = KWRNSV
          IF (MTLVFM%MP(2) <= -QX%MXEXP) THEN
              CALL FMTINY(RETURN_VALUE%MFM,QX)
          ENDIF
      ELSE
          CALL FMTINY(RETURN_VALUE%MFM,QX)
      ENDIF
   END FUNCTION FMSPACING_FM

!                                                                SQRT

   FUNCTION FMSQRT_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMSQRT(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSQRT_FM

   FUNCTION FMSQRT_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSQRT(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMSQRT_ZM

   FUNCTION FMSQRT_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSQRT(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSQRT_FM1

   FUNCTION FMSQRT_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMSQRT(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMSQRT_ZM1

   FUNCTION FMSQRT_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSQRT(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSQRT_FM2

   FUNCTION FMSQRT_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMSQRT(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSQRT_ZM2

!                                                                 SUM

   FUNCTION FMSUM1_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MULVFM,M3LVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL FMI2M(0,M3LVFM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL FMEQU(MA(JA)%MFM,MULVFM,NDSAVE,QX%NDIG,QX)
         CALL FMADD_R1(M3LVFM,MULVFM,QX)
      ENDDO
      QX%MXEXP = MXSAVE
      CALL FMEQU(M3LVFM,RETURN_VALUE%MFM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMSUM1_FM

   FUNCTION FMSUM2_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MULVFM,M3LVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL FMI2M(0,M3LVFM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL FMEQU(MA(JA,JB)%MFM,MULVFM,NDSAVE,QX%NDIG,QX)
            CALL FMADD_R1(M3LVFM,MULVFM,QX)
         ENDDO
      ENDDO
      QX%MXEXP = MXSAVE
      CALL FMEQU(M3LVFM,RETURN_VALUE%MFM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMSUM2_FM

   FUNCTION FMSUM1_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM,M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(0,M3LVIM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL IMADD(MA(JA)%MIM,M3LVIM,MTLVIM,QX)
         CALL IMEQ(MTLVIM,M3LVIM,QX)
      ENDDO
      CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMSUM1_IM

   FUNCTION FMSUM2_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM,M3LVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(0,M3LVIM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL IMADD(MA(JA,JB)%MIM,M3LVIM,MTLVIM,QX)
            CALL IMEQ(MTLVIM,M3LVIM,QX)
         ENDDO
      ENDDO
      CALL IMEQ(M3LVIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMSUM2_IM

   FUNCTION FMSUM1_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),M3LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL ZMI2M(0,M3LVZM,QX)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL ZMEQU(MA(JA)%MZM,MULVZM,NDSAVE,QX%NDIG,QX)
         CALL ZMADD(MULVZM,M3LVZM,MTLVZM,QX)
         CALL ZMEQ(MTLVZM,M3LVZM,QX)
      ENDDO
      QX%MXEXP = MXSAVE
      CALL ZMEQU(M3LVZM,RETURN_VALUE%MZM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMSUM1_ZM

   FUNCTION FMSUM2_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVZM(2),MULVZM(2),M3LVZM(2)
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL ZMI2M(0,M3LVZM,QX)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL ZMEQU(MA(JA,JB)%MZM,MULVZM,NDSAVE,QX%NDIG,QX)
            CALL ZMADD(MULVZM,M3LVZM,MTLVZM,QX)
            CALL ZMEQ(MTLVZM,M3LVZM,QX)
         ENDDO
      ENDDO
      QX%MXEXP = MXSAVE
      CALL ZMEQU(M3LVZM,RETURN_VALUE%MZM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
   END FUNCTION FMSUM2_ZM

!                                                                 TAN

   FUNCTION FMTAN_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMTAN(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMTAN_FM

   FUNCTION FMTAN_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMTAN(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMTAN_ZM

   FUNCTION FMTAN_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMTAN(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMTAN_FM1

   FUNCTION FMTAN_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMTAN(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMTAN_ZM1

   FUNCTION FMTAN_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMTAN(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMTAN_FM2

   FUNCTION FMTAN_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMTAN(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMTAN_ZM2

!                                                                TANH

   FUNCTION FMTANH_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMTANH(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMTANH_FM

   FUNCTION FMTANH_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMTANH(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMTANH_ZM

   FUNCTION FMTANH_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMTANH(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMTANH_FM1

   FUNCTION FMTANH_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMTANH(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMTANH_ZM1

   FUNCTION FMTANH_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMTANH(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMTANH_FM2

   FUNCTION FMTANH_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMTANH(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMTANH_ZM2

!                                                                TINY

   FUNCTION FMTINY_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMTINY(RETURN_VALUE%MFM,QX)
      IF (SIZE(MA%MFM%MP) <= 2) CALL FMMPYI_R1(RETURN_VALUE%MFM,1,QX)
   END FUNCTION FMTINY_FM

   FUNCTION FMTINY_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVIM
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(1,RETURN_VALUE%MIM,QX)
      IF (SIZE(MA%MIM%MP) <= 2) CALL IMMPYI(RETURN_VALUE%MIM,1,MTLVIM,QX)
   END FUNCTION FMTINY_IM

   FUNCTION FMTINY_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI) :: MTLVFM,MTLVZM(2)
      TYPE(FM_SETTINGS) :: QX
      CALL FMTINY(MTLVFM,QX)
      CALL ZMCMPX(MTLVFM,MTLVFM,RETURN_VALUE%MZM,QX)
      IF (SIZE(MA%MZM(1)%MP) <= 2) CALL ZMMPYI(RETURN_VALUE%MZM,1,MTLVZM,QX)
   END FUNCTION FMTINY_ZM

!                                                           TRANSPOSE

   FUNCTION FMTRANSPOSE_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA(:,:)
      TYPE (FM), DIMENSION(SIZE(MA,DIM=2),SIZE(MA,DIM=1)) :: RETURN_VALUE
      INTEGER :: I,J
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO I = 1, SIZE(MA,DIM=1)
         DO J = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MA(I,J)%MFM,RETURN_VALUE(J,I)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMTRANSPOSE_FM

   FUNCTION FMTRANSPOSE_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA(:,:)
      TYPE (IM), DIMENSION(SIZE(MA,DIM=2),SIZE(MA,DIM=1)) :: RETURN_VALUE
      INTEGER :: I,J
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO I = 1, SIZE(MA,DIM=1)
         DO J = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MA(I,J)%MIM,RETURN_VALUE(J,I)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMTRANSPOSE_IM

   FUNCTION FMTRANSPOSE_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA(:,:)
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=2),SIZE(MA,DIM=1)) :: RETURN_VALUE
      INTEGER :: I,J
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO I = 1, SIZE(MA,DIM=1)
         DO J = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MA(I,J)%MZM,RETURN_VALUE(J,I)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMTRANSPOSE_ZM

!                                                           FM_FORMAT

   FUNCTION FMFORMAT_FM(FMT,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FMT
      TYPE (FM) :: MA
      CHARACTER(200) :: RETURN_VALUE
      INTENT (IN) :: FMT,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMFORM(FMT,MA%MFM,RETURN_VALUE,QX)
   END FUNCTION FMFORMAT_FM

!                                                           IM_FORMAT

   FUNCTION IMFORMAT_IM(FMT,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FMT
      CHARACTER(200) :: RETURN_VALUE
      TYPE (IM) :: MA
      INTENT (IN) :: FMT,MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMFORM(FMT,MA%MIM,RETURN_VALUE,QX)
   END FUNCTION IMFORMAT_IM

!                                                           ZM_FORMAT

   FUNCTION ZMFORMAT_ZM(FMTR,FMTI,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FMTR,FMTI
      CHARACTER(200) :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: FMTR,FMTI,MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMFORM(FMTR,FMTI,MA%MZM,RETURN_VALUE,QX)
   END FUNCTION ZMFORMAT_ZM

!                                                                 GCD

   FUNCTION GCD_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMGCD(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION GCD_IM

!                                                        MULTIPLY_MOD

   FUNCTION MULTIPLYMOD_IM(MA,MB,MC)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC,RETURN_VALUE
      INTENT (IN) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPYM(MA%MIM,MB%MIM,MC%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION MULTIPLYMOD_IM

!                                                           POWER_MOD

   FUNCTION POWERMOD_IM(MA,MB,MC)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC,RETURN_VALUE
      INTENT (IN) :: MA,MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMPMOD(MA%MIM,MB%MIM,MC%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION POWERMOD_IM

!                                                           BERNOULLI

   FUNCTION FMBERNOULLI_FM(N)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N
      TYPE(FM_SETTINGS) :: QX
      CALL FMBERNOULLI(N,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBERNOULLI_FM

!                                                                BETA

   FUNCTION FMBETA_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMBETA(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBETA_FM

!                                                            BINOMIAL

   FUNCTION FMBINOMIAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMCOMB(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBINOMIAL_FM

   FUNCTION FMBINOMIAL_IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMCOMB(MA%MIM,MB%MIM,RETURN_VALUE%MIM,QX)
   END FUNCTION FMBINOMIAL_IM

   FUNCTION FMBINOMIAL_I(N,K)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N,K
      TYPE (IM) :: RETURN_VALUE
      INTENT (IN) :: N,K
      TYPE(FM_SETTINGS) :: QX
      CALL IMCOMBI(N,K,RETURN_VALUE%MIM,QX)
   END FUNCTION FMBINOMIAL_I

!                                                           FACTORIAL

   FUNCTION FMFACTORIAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMFACT(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMFACTORIAL_FM

   FUNCTION FMFACTORIAL_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMFACT(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMFACTORIAL_ZM

   FUNCTION FMFACTORIAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMFACT(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMFACTORIAL_FM1

   FUNCTION FMFACTORIAL_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMFACT(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMFACTORIAL_ZM1

   FUNCTION FMFACTORIAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMFACT(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFACTORIAL_FM2

   FUNCTION FMFACTORIAL_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMFACT(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFACTORIAL_ZM2

   FUNCTION FMFACTORIAL_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2I(MA%MIM,IVAL,QX)
      IF (QX%KFLAG == 0) THEN
          CALL IMFACT(IVAL,RETURN_VALUE%MIM,QX)
      ELSE
          CALL IMST2M(' UNKNOWN ',RETURN_VALUE%MIM,QX)
          QX%KFLAG = 0
      ENDIF
   END FUNCTION FMFACTORIAL_IM

   FUNCTION FMFACTORIAL_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL IMM2I(MA(J)%MIM,IVAL,QX)
         IF (QX%KFLAG == 0) THEN
             CALL IMFACT(IVAL,RETURN_VALUE(J)%MIM,QX)
         ELSE
             CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J)%MIM,QX)
             QX%KFLAG = 0
         ENDIF
      ENDDO
   END FUNCTION FMFACTORIAL_IM1

   FUNCTION FMFACTORIAL_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMM2I(MA(J,K)%MIM,IVAL,QX)
            IF (QX%KFLAG == 0) THEN
                CALL IMFACT(IVAL,RETURN_VALUE(J,K)%MIM,QX)
            ELSE
                CALL IMST2M(' UNKNOWN ',RETURN_VALUE(J,K)%MIM,QX)
                QX%KFLAG = 0
            ENDIF
         ENDDO
      ENDDO
   END FUNCTION FMFACTORIAL_IM2

   FUNCTION FMFACTORIAL_I(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMFACT(IVAL,RETURN_VALUE%MIM,QX)
   END FUNCTION FMFACTORIAL_I

   FUNCTION FMFACTORIAL_I1(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(IVAL)
      DO J = 1, N
         CALL IMFACT(IVAL(J),RETURN_VALUE(J)%MIM,QX)
      ENDDO
   END FUNCTION FMFACTORIAL_I1

   FUNCTION FMFACTORIAL_I2(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (IM), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL IMFACT(IVAL(J,K),RETURN_VALUE(J,K)%MIM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFACTORIAL_I2

!                                                               GAMMA

   FUNCTION FMGAMMA_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMGAM(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMGAMMA_FM

   FUNCTION FMGAMMA_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMGAM(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMGAMMA_ZM

   FUNCTION FMGAMMA_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMGAM(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMGAMMA_FM1

   FUNCTION FMGAMMA_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMGAM(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMGAMMA_ZM1

   FUNCTION FMGAMMA_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMGAM(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMGAMMA_FM2

   FUNCTION FMGAMMA_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMGAM(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMGAMMA_ZM2

!                                                     INCOMPLETE_BETA

   FUNCTION FMINCOMPLETE_BETA_FM(MX,MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MX,MA,MB,RETURN_VALUE
      INTENT (IN) :: MX,MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMIBTA(MX%MFM,MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMINCOMPLETE_BETA_FM

!                                                   INCOMPLETE_GAMMA1

   FUNCTION FMINCOMPLETE_GAMMA1_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMIGM1(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMINCOMPLETE_GAMMA1_FM

!                                                   INCOMPLETE_GAMMA2

   FUNCTION FMINCOMPLETE_GAMMA2_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMIGM2(MA%MFM,MB%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMINCOMPLETE_GAMMA2_FM

!                                                           LOG_GAMMA

   FUNCTION FMLOG_GAMMA_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMLNGM(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMLOG_GAMMA_FM

   FUNCTION FMLOG_GAMMA_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMLNGM(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMLOG_GAMMA_ZM

   FUNCTION FMLOG_GAMMA_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMLNGM(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMLOG_GAMMA_FM1

   FUNCTION FMLOG_GAMMA_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMLNGM(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMLOG_GAMMA_ZM1

   FUNCTION FMLOG_GAMMA_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMLNGM(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMLOG_GAMMA_FM2

   FUNCTION FMLOG_GAMMA_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMLNGM(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMLOG_GAMMA_ZM2

!                                                           POLYGAMMA

   FUNCTION FMPOLYGAMMA_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMPGAM(N,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPOLYGAMMA_FM

!                                                          POCHHAMMER

   FUNCTION FMPOCHHAMMER_FM(MA,N)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMPOCH(MA%MFM,N,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPOCHHAMMER_FM

!                                                                 PSI

   FUNCTION FMPSI_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMPSI(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMPSI_FM

   FUNCTION FMPSI_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMPSI(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMPSI_FM1

   FUNCTION FMPSI_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMPSI(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMPSI_FM2

!                                                            BESSEL_J

   FUNCTION FMBESSEL_J_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESJ(N,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBESSEL_J_FM

!                                                            BESSEL_J0

   FUNCTION FMBESSEL_J0_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESJ(0,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBESSEL_J0_FM

!                                                            BESSEL_J1

   FUNCTION FMBESSEL_J1_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESJ(1,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBESSEL_J1_FM

!                                                            BESSEL_JN

   FUNCTION FMBESSEL_JN_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESJ(N,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBESSEL_JN_FM

!                                                            BESSEL_JN2

   FUNCTION FMBESSEL_JN2_FM(N1,N2,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N1,N2,J
      TYPE (FM) :: MA,RETURN_VALUE(ABS(N2-N1)+1)
      TYPE(MULTI), ALLOCATABLE :: A(:)
      INTENT (IN) :: N1,N2,MA
      TYPE(FM_SETTINGS) :: QX
      ALLOCATE(A(ABS(N2-N1)+1))
      CALL FMBESJ2(N1,N2,MA%MFM,A,QX)
      DO J = 1, ABS(N2-N1)+1
         CALL FMEQ(A(J),RETURN_VALUE(J)%MFM,QX)
      ENDDO
      DEALLOCATE(A)
   END FUNCTION FMBESSEL_JN2_FM

!                                                            BESSEL_Y

   FUNCTION FMBESSEL_Y_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESY(N,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBESSEL_Y_FM

!                                                            BESSEL_Y0

   FUNCTION FMBESSEL_Y0_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESY(0,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBESSEL_Y0_FM

!                                                            BESSEL_Y1

   FUNCTION FMBESSEL_Y1_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESY(1,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBESSEL_Y1_FM

!                                                            BESSEL_YN

   FUNCTION FMBESSEL_YN_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESY(N,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMBESSEL_YN_FM

!                                                            BESSEL_YN2

   FUNCTION FMBESSEL_YN2_FM(N1,N2,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N1,N2,J
      TYPE (FM) :: MA,RETURN_VALUE(ABS(N2-N1)+1)
      TYPE(MULTI), ALLOCATABLE :: A(:)
      INTENT (IN) :: N1,N2,MA
      TYPE(FM_SETTINGS) :: QX
      ALLOCATE(A(ABS(N2-N1)+1))
      CALL FMBESY2(N1,N2,MA%MFM,A,QX)
      DO J = 1, ABS(N2-N1)+1
         CALL FMEQ(A(J),RETURN_VALUE(J)%MFM,QX)
      ENDDO
      DEALLOCATE(A)
   END FUNCTION FMBESSEL_YN2_FM

!                                                        COS_INTEGRAL

   FUNCTION FMCOS_INTEGRAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMCI(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMCOS_INTEGRAL_FM

   FUNCTION FMCOS_INTEGRAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMCI(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMCOS_INTEGRAL_FM1

   FUNCTION FMCOS_INTEGRAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMCI(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCOS_INTEGRAL_FM2

!                                                       COSH_INTEGRAL

   FUNCTION FMCOSH_INTEGRAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMCHI(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMCOSH_INTEGRAL_FM

   FUNCTION FMCOSH_INTEGRAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMCHI(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMCOSH_INTEGRAL_FM1

   FUNCTION FMCOSH_INTEGRAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMCHI(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMCOSH_INTEGRAL_FM2

!                                                     EXP_INTEGRAL_EI

   FUNCTION FMEXP_INTEGRAL_EI_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEI(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMEXP_INTEGRAL_EI_FM

   FUNCTION FMEXP_INTEGRAL_EI_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEI(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMEXP_INTEGRAL_EI_FM1

   FUNCTION FMEXP_INTEGRAL_EI_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEI(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMEXP_INTEGRAL_EI_FM2

!                                                     EXP_INTEGRAL_EN

   FUNCTION FMEXP_INTEGRAL_EN_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEN(N,MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMEXP_INTEGRAL_EN_FM

!                                                           FRESNEL_C

   FUNCTION FMFRESNEL_C_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMC(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMFRESNEL_C_FM

   FUNCTION FMFRESNEL_C_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMC(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMFRESNEL_C_FM1

   FUNCTION FMFRESNEL_C_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMC(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFRESNEL_C_FM2

!                                                           FRESNEL_S

   FUNCTION FMFRESNEL_S_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMS(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMFRESNEL_S_FM

   FUNCTION FMFRESNEL_S_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMS(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMFRESNEL_S_FM1

   FUNCTION FMFRESNEL_S_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMS(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMFRESNEL_S_FM2

!                                                                 ERF

   FUNCTION FMERF_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMERF(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMERF_FM

   FUNCTION FMERF_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMERF(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMERF_ZM

   FUNCTION FMERF_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMERF(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMERF_FM1

   FUNCTION FMERF_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMERF(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMERF_ZM1

   FUNCTION FMERF_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMERF(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMERF_FM2

   FUNCTION FMERF_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMERF(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMERF_ZM2

!                                                                ERFC

   FUNCTION FMERFC_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMERFC(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMERFC_FM

   FUNCTION FMERFC_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMERFC(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMERFC_ZM

   FUNCTION FMERFC_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMERFC(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMERFC_FM1

   FUNCTION FMERFC_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMERFC(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMERFC_ZM1

   FUNCTION FMERFC_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMERFC(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMERFC_FM2

   FUNCTION FMERFC_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMERFC(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMERFC_ZM2

!                                                                ERFC_SCALED

   FUNCTION FMERFC_SCALED_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMERFCS(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMERFC_SCALED_FM

   FUNCTION FMERFC_SCALED_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMERFC_SC(MA%MZM,RETURN_VALUE%MZM,QX)
   END FUNCTION FMERFC_SCALED_ZM

   FUNCTION FMERFC_SCALED_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMERFCS(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMERFC_SCALED_FM1

   FUNCTION FMERFC_SCALED_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMERFC_SC(MA(J)%MZM,RETURN_VALUE(J)%MZM,QX)
      ENDDO
   END FUNCTION FMERFC_SCALED_ZM1

   FUNCTION FMERFC_SCALED_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMERFCS(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMERFC_SCALED_FM2

   FUNCTION FMERFC_SCALED_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMERFC_SC(MA(J,K)%MZM,RETURN_VALUE(J,K)%MZM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMERFC_SCALED_ZM2

!                                                            LOG_ERFC

   FUNCTION FMLOG_ERFC_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMLERC(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMLOG_ERFC_FM

   FUNCTION FMLOG_ERFC_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMLERC(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMLOG_ERFC_FM1

   FUNCTION FMLOG_ERFC_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMLERC(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMLOG_ERFC_FM2

!                                                        LOG_INTEGRAL

   FUNCTION FMLOG_INTEGRAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMLI(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMLOG_INTEGRAL_FM

   FUNCTION FMLOG_INTEGRAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMLI(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMLOG_INTEGRAL_FM1

   FUNCTION FMLOG_INTEGRAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMLI(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMLOG_INTEGRAL_FM2

!                                                        SIN_INTEGRAL

   FUNCTION FMSIN_INTEGRAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMSI(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSIN_INTEGRAL_FM

   FUNCTION FMSIN_INTEGRAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSI(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSIN_INTEGRAL_FM1

   FUNCTION FMSIN_INTEGRAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSI(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSIN_INTEGRAL_FM2

!                                                       SINH_INTEGRAL

   FUNCTION FMSINH_INTEGRAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMSHI(MA%MFM,RETURN_VALUE%MFM,QX)
   END FUNCTION FMSINH_INTEGRAL_FM

   FUNCTION FMSINH_INTEGRAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSHI(MA(J)%MFM,RETURN_VALUE(J)%MFM,QX)
      ENDDO
   END FUNCTION FMSINH_INTEGRAL_FM1

   FUNCTION FMSINH_INTEGRAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSHI(MA(J,K)%MFM,RETURN_VALUE(J,K)%MFM,QX)
         ENDDO
      ENDDO
   END FUNCTION FMSINH_INTEGRAL_FM2

 END MODULE FMZM_9_PARALLEL

 MODULE FMZM_10_PARALLEL
   USE FMZM_1_PARALLEL

   CONTAINS

! Interface routines for calling with the FM, IM, and ZM derived types.

   SUBROUTINE FM_ABS(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMABS(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ABS

   SUBROUTINE FM_ACOS(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMACOS(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ACOS

   SUBROUTINE FM_ACOSH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMACOSH(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ACOSH

   SUBROUTINE FM_ADD(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMADD(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_ADD

   SUBROUTINE FM_ADD_R1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMADD_R1(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ADD_R1

   SUBROUTINE FM_ADD_R2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMADD_R2(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ADD_R2

   SUBROUTINE FM_ADDI(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMADDI(MA%MFM,IVAL,QX)
   END SUBROUTINE FM_ADDI

   SUBROUTINE FM_ASIN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMASIN(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ASIN

   SUBROUTINE FM_ASINH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMASINH(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ASINH

   SUBROUTINE FM_ATAN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMATAN(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ATAN

   SUBROUTINE FM_ATANH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMATANH(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ATANH

   SUBROUTINE FM_ATN2(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMATN2(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_ATN2

   SUBROUTINE FM_BIG(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMBIG(MA%MFM,QX)
   END SUBROUTINE FM_BIG

   SUBROUTINE FM_CEILING(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,MTLVFM,QX)
      CALL FMSUB(MA%MFM,MTLVFM,MULVFM,QX)
      IF (MULVFM%MP(3) == 0) THEN
          CALL FMEQ(MA%MFM,MB%MFM,QX)
      ELSE IF (MA%MFM%MP(1) > 0) THEN
          CALL FMADDI(MTLVFM,1,QX)
          CALL FMEQ(MTLVFM,MB%MFM,QX)
      ELSE
          CALL FMEQ(MTLVFM,MB%MFM,QX)
      ENDIF
   END SUBROUTINE FM_CEILING

   SUBROUTINE FM_CHANGEBASE(MA,MB,NEW_MBASE,NEW_NDIG)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTEGER :: NEW_MBASE,NEW_NDIG
      INTENT (IN) :: MA,NEW_MBASE,NEW_NDIG
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMCHANGEBASE(MA%MFM,MB%MFM,NEW_MBASE,NEW_NDIG,QX)
   END SUBROUTINE FM_CHANGEBASE

   SUBROUTINE FM_CHSH(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMCHSH(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_CHSH

   FUNCTION FM_COMP(MA,LREL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: FM_COMP
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,MB
      CHARACTER(*) :: LREL
      INTENT (IN) :: LREL
      TYPE(FM_SETTINGS) :: QX
      FM_COMP = FMCOMP(MA%MFM,LREL,MB%MFM,QX)
   END FUNCTION FM_COMP

   SUBROUTINE FM_COS(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMCOS(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_COS

   SUBROUTINE FM_COSH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMCOSH(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_COSH

   SUBROUTINE FM_CSSN(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMCSSN(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_CSSN

   SUBROUTINE FM_DIM(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIM(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_DIM

   SUBROUTINE FM_DIV(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIV(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_DIV

   SUBROUTINE FM_DIV_R1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIV_R1(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_DIV_R1

   SUBROUTINE FM_DIV_R2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIV_R2(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_DIV_R2

   SUBROUTINE FM_DIVI(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIVI(MA%MFM,IVAL,MB%MFM,QX)
   END SUBROUTINE FM_DIVI

   SUBROUTINE FM_DIVI_R1(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMDIVI_R1(MA%MFM,IVAL,QX)
   END SUBROUTINE FM_DIVI_R1

   SUBROUTINE FM_DP2M(X,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      DOUBLE PRECISION :: X
      INTENT (IN) :: X
      TYPE(FM_SETTINGS) :: QX
      CALL FMDP2M(X,MA%MFM,QX)
   END SUBROUTINE FM_DP2M

   SUBROUTINE FM_DPM(X,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      DOUBLE PRECISION :: X
      INTENT (IN) :: X
      TYPE(FM_SETTINGS) :: QX
      CALL FMDPM(X,MA%MFM,QX)
   END SUBROUTINE FM_DPM

   SUBROUTINE FM_EPSILON(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(1,MTLVFM,QX)
      CALL FMULP(MTLVFM,MB%MFM,QX)
      IF (SIZE(MA%MFM%MP) <= 2) CALL FMMPYI(MB%MFM,1,MTLVFM,QX)
   END SUBROUTINE FM_EPSILON

   SUBROUTINE FM_EQU(MA,MB,NA,NB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KA,KB,NA,NB,NDSAVE
      INTENT (IN) :: NA,NB
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      KA = NA
      KB = NB
      NDSAVE = QX%NDIG
      QX%NDIG = KA
      CALL FMEQU(MA%MFM,MB%MFM,KA,KB,QX)
      QX%NDIG = NDSAVE
   END SUBROUTINE FM_EQU

   SUBROUTINE FM_EQU_R1(MA,NA,NB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KA,KB,NA,NB,NDSAVE
      INTENT (IN) :: NA,NB
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      KA = NA
      KB = NB
      NDSAVE = QX%NDIG
      QX%NDIG = KA
      CALL FMEQU_R1(MA%MFM,KA,KB,QX)
      QX%NDIG = NDSAVE
   END SUBROUTINE FM_EQU_R1

   SUBROUTINE FM_EXP(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMEXP(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_EXP

   SUBROUTINE FM_FLAG(K)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: K
      INTENT (INOUT) :: K
      TYPE(FM_SETTINGS) :: QX
      CALL FMFLAG(K,QX)
   END SUBROUTINE FM_FLAG

   SUBROUTINE FM_FORM(FORM,MA,STRING)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM,STRING
      INTENT (IN) :: FORM
      INTENT (INOUT) :: STRING
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMFORM(FORM,MA%MFM,STRING,QX)
   END SUBROUTINE FM_FORM

   SUBROUTINE FM_FLOOR(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MTLVFM,MULVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,MTLVFM,QX)
      CALL FMSUB(MA%MFM,MTLVFM,MULVFM,QX)
      IF (MULVFM%MP(3) == 0) THEN
          CALL FMEQ(MA%MFM,MB%MFM,QX)
      ELSE IF (MA%MFM%MP(1) < 0) THEN
          CALL FMADDI(MTLVFM,-1,QX)
          CALL FMEQ(MTLVFM,MB%MFM,QX)
      ELSE
          CALL FMEQ(MTLVFM,MB%MFM,QX)
      ENDIF
   END SUBROUTINE FM_FLOOR

   SUBROUTINE FM_FPRT(FORM,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTENT (IN) :: FORM
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMFPRT(FORM,MA%MFM,QX)
   END SUBROUTINE FM_FPRT

   SUBROUTINE FM_FRACTION(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMEQ(MA%MFM,MTLVFM,QX)
      MTLVFM%MP(2) = 0
      CALL FMEQ(MTLVFM,MB%MFM,QX)
   END SUBROUTINE FM_FRACTION

   SUBROUTINE FM_HYPOT(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMHYPOT(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_HYPOT

   SUBROUTINE FM_I2M(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMI2M(IVAL,MA%MFM,QX)
   END SUBROUTINE FM_I2M

   SUBROUTINE FM_INP(LINE,MA,LA,LB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: LA,LB
      INTENT (IN) :: LA,LB
      CHARACTER :: LINE(LB)
      INTENT (IN) :: LINE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMINP(LINE,MA%MFM,LA,LB,QX)
   END SUBROUTINE FM_INP

   SUBROUTINE FM_INT(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMINT(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_INT

   SUBROUTINE FM_IPWR(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMIPWR(MA%MFM,IVAL,MB%MFM,QX)
   END SUBROUTINE FM_IPWR

   SUBROUTINE FM_LG10(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMLG10(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_LG10

   SUBROUTINE FM_LN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMLN(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_LN

   SUBROUTINE FM_LNI(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (MULTI) :: MLN2,MLN3,MLN5,MLN7
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMLNI(IVAL,MA%MFM,MLN2,MLN3,MLN5,MLN7,QX)
   END SUBROUTINE FM_LNI

   SUBROUTINE FM_M2DP(MA,X)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      DOUBLE PRECISION :: X
      INTENT (INOUT) :: X
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2DP(MA%MFM,X,QX)
   END SUBROUTINE FM_M2DP

   SUBROUTINE FM_M2I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2I(MA%MFM,IVAL,QX)
   END SUBROUTINE FM_M2I

   SUBROUTINE FM_M2SP(MA,X)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      REAL :: X
      INTENT (INOUT) :: X
      TYPE(FM_SETTINGS) :: QX
      CALL FMM2SP(MA%MFM,X,QX)
   END SUBROUTINE FM_M2SP

   SUBROUTINE FM_MAX(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMMAX(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_MAX

   SUBROUTINE FM_MIN(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMMIN(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_MIN

   SUBROUTINE FM_MOD(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMMOD(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_MOD

   SUBROUTINE FM_MODULO(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMMOD(MA%MFM,MB%MFM,MTLVFM,QX)
      IF (MTLVFM%MP(3) /= 0) THEN
          IF ((MA%MFM%MP(3) > 0 .AND. MA%MFM%MP(1) > 0 .AND.  &
               MB%MFM%MP(3) > 0 .AND. MB%MFM%MP(1) < 0) .OR.  &
              (MA%MFM%MP(3) > 0 .AND. MA%MFM%MP(1) < 0 .AND.  &
               MB%MFM%MP(3) > 0 .AND. MB%MFM%MP(1) > 0)) THEN
              CALL FMADD_R1(MTLVFM,MB%MFM,QX)
          ENDIF
      ENDIF
      CALL FMEQ(MTLVFM,MC%MFM,QX)
   END SUBROUTINE FM_MODULO

   SUBROUTINE FM_MPY(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMMPY(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_MPY

   SUBROUTINE FM_MPY_R1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMMPY_R1(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_MPY_R1

   SUBROUTINE FM_MPY_R2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMMPY_R2(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_MPY_R2

   SUBROUTINE FM_MPYI(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMMPYI(MA%MFM,IVAL,MB%MFM,QX)
   END SUBROUTINE FM_MPYI

   SUBROUTINE FM_MPYI_R1(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMMPYI_R1(MA%MFM,IVAL,QX)
   END SUBROUTINE FM_MPYI_R1

   SUBROUTINE FM_NEAREST(MA,MB,MC)
      USE FMVALS_PARALLEL
      USE FMZM_8_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM) :: MT_FM
      TYPE(FM_SETTINGS) :: QX
      MC = FMNEAREST_FM(MA,MB)
      CALL FMEQ(MT_FM%MFM,MC%MFM,QX)
   END SUBROUTINE FM_NEAREST

   SUBROUTINE FM_NINT(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMNINT(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_NINT

   SUBROUTINE FM_OUT(MA,LINE,LB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: LB
      INTENT (IN) :: LB
      CHARACTER :: LINE(LB)
      INTENT (INOUT) :: LINE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMOUT(MA%MFM,LINE,LB,QX)
   END SUBROUTINE FM_OUT

   SUBROUTINE FM_PI(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMPI(MA%MFM,QX)
   END SUBROUTINE FM_PI

   SUBROUTINE FM_PRNT(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMPRNT(MA%MFM,QX)
   END SUBROUTINE FM_PRNT

   SUBROUTINE FM_PWR(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMPWR(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_PWR

   SUBROUTINE FM_READ(KREAD,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KREAD
      TYPE (FM) :: MA
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMREAD(KREAD,MA%MFM,QX)
   END SUBROUTINE FM_READ

   SUBROUTINE FM_RPWR(MA,IVAL,JVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: IVAL,JVAL
      TYPE(FM_SETTINGS) :: QX
      CALL FMRPWR(MA%MFM,IVAL,JVAL,MB%MFM,QX)
   END SUBROUTINE FM_RPWR

   SUBROUTINE FM_RRSPACING(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMABS(MA%MFM,MTLVFM,QX)
      MTLVFM%MP(2) = QX%NDIG
      CALL FMEQ(MTLVFM,MB%MFM,QX)
   END SUBROUTINE FM_RRSPACING

   SUBROUTINE FM_SET(NPREC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: NPREC
      INTENT (IN) :: NPREC
      TYPE(FM_SETTINGS) :: QX
      CALL FMSET(NPREC,QX)
   END SUBROUTINE FM_SET

   SUBROUTINE FM_SETVAR(STRING)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      TYPE(FM_SETTINGS) :: QX
      CALL FMSETVAR(STRING,QX)
   END SUBROUTINE FM_SETVAR

   SUBROUTINE FM_SIGN(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMSIGN(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_SIGN

   SUBROUTINE FM_SIN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSIN(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_SIN

   SUBROUTINE FM_SINH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSINH(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_SINH

   SUBROUTINE FM_SP2M(X,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      REAL :: X
      INTENT (IN) :: X
      TYPE(FM_SETTINGS) :: QX
      CALL FMSP2M(X,MA%MFM,QX)
   END SUBROUTINE FM_SP2M

   SUBROUTINE FM_SPACING(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(MULTI) :: MTLVFM
      TYPE(FM_SETTINGS) :: QX
      CALL FMABS(MA%MFM,MTLVFM,QX)
      CALL FMULP(MTLVFM,MB%MFM,QX)
   END SUBROUTINE FM_SPACING

   SUBROUTINE FM_SQR(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSQR(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_SQR

   SUBROUTINE FM_SQR_R1(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMSQR_R1(MA%MFM,QX)
   END SUBROUTINE FM_SQR_R1

   SUBROUTINE FM_SQRT(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSQRT(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_SQRT

   SUBROUTINE FM_SQRT_R1(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMSQRT_R1(MA%MFM,QX)
   END SUBROUTINE FM_SQRT_R1

   SUBROUTINE FM_ST2M(STRING,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      TYPE(FM_SETTINGS) :: QX
      CALL FMST2M(STRING,MA%MFM,QX)
   END SUBROUTINE FM_ST2M

   SUBROUTINE FM_SUB(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMSUB(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_SUB

   SUBROUTINE FM_SUB_R1(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMSUB_R1(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_SUB_R1

   SUBROUTINE FM_SUB_R2(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSUB_R2(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_SUB_R2

   SUBROUTINE FM_TAN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMTAN(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_TAN

   SUBROUTINE FM_TANH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMTANH(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_TANH

   SUBROUTINE FM_TINY(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMTINY(MA%MFM,QX)
   END SUBROUTINE FM_TINY

   SUBROUTINE FM_ULP(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMULP(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ULP

   SUBROUTINE FM_VARS(QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE(FM_SETTINGS) :: QX
      CALL FMVARS(QX)
   END SUBROUTINE FM_VARS

   SUBROUTINE FM_WRIT(KWRITE,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTENT (IN) :: KWRITE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMWRIT(KWRITE,MA%MFM,QX)
   END SUBROUTINE FM_WRIT

   SUBROUTINE IM_ABS(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMABS(MA%MIM,MB%MIM,QX)
   END SUBROUTINE IM_ABS

   SUBROUTINE IM_ADD(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMADD(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_ADD

   SUBROUTINE IM_BIG(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMBIG(MA%MIM,QX)
   END SUBROUTINE IM_BIG

   SUBROUTINE IM_COMB(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMCOMB(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_COMB

   FUNCTION IM_COMP(MA,LREL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: IM_COMP
      LOGICAL, EXTERNAL :: IMCOMP
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA,MB
      CHARACTER(*) :: LREL
      INTENT (IN) :: LREL
      TYPE(FM_SETTINGS) :: QX
      IM_COMP = IMCOMP(MA%MIM,LREL,MB%MIM,QX)
   END FUNCTION IM_COMP

   SUBROUTINE IM_DIM(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMDIM(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_DIM

   SUBROUTINE IM_DIV(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMDIV(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_DIV

   SUBROUTINE IM_DIVI(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMDIVI(MA%MIM,IVAL,MB%MIM,QX)
   END SUBROUTINE IM_DIVI

   SUBROUTINE IM_DIVR(MA,MB,MC,MD)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC,MD
      TYPE(FM_SETTINGS) :: QX
      CALL IMDIVR(MA%MIM,MB%MIM,MC%MIM,MD%MIM,QX)
   END SUBROUTINE IM_DIVR

   SUBROUTINE IM_DVIR(MA,IVAL,MB,IREM)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL,IREM
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: IREM
      TYPE(FM_SETTINGS) :: QX
      CALL IMDVIR(MA%MIM,IVAL,MB%MIM,IREM,QX)
   END SUBROUTINE IM_DVIR

   SUBROUTINE IM_FACT(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMFACT(IVAL,MA%MIM,QX)
   END SUBROUTINE IM_FACT

   SUBROUTINE IM_FM2I(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE (IM) :: MB
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMFM2I(MA%MFM,MB%MIM,QX)
   END SUBROUTINE IM_FM2I

   SUBROUTINE IM_FORM(FORM,MA,STRING)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM,STRING
      INTENT (IN) :: FORM,MA
      TYPE (IM) :: MA
      INTENT (INOUT) :: STRING
      TYPE(FM_SETTINGS) :: QX
      CALL IMFORM(FORM,MA%MIM,STRING,QX)
   END SUBROUTINE IM_FORM

   SUBROUTINE IM_FPRT(FORM,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTENT (IN) :: FORM
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMFPRT(FORM,MA%MIM,QX)
   END SUBROUTINE IM_FPRT

   SUBROUTINE IM_GCD(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMGCD(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_GCD

   SUBROUTINE IM_I2FM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE (FM) :: MB
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2FM(MA%MIM,MB%MFM,QX)
   END SUBROUTINE IM_I2FM

   SUBROUTINE IM_I2M(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMI2M(IVAL,MA%MIM,QX)
   END SUBROUTINE IM_I2M

   SUBROUTINE IM_INP(LINE,MA,LA,LB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: LA,LB
      INTENT (IN) :: LA,LB
      CHARACTER :: LINE(LB)
      INTENT (IN) :: LINE
      TYPE (IM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMINP(LINE,MA%MIM,LA,LB,QX)
   END SUBROUTINE IM_INP

   SUBROUTINE IM_M2DP(MA,X)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      DOUBLE PRECISION :: X
      INTENT (INOUT) :: X
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2DP(MA%MIM,X,QX)
   END SUBROUTINE IM_M2DP

   SUBROUTINE IM_M2I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMM2I(MA%MIM,IVAL,QX)
   END SUBROUTINE IM_M2I

   SUBROUTINE IM_MAX(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMMAX(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_MAX

   SUBROUTINE IM_MIN(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMMIN(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_MIN

   SUBROUTINE IM_MOD(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMMOD(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_MOD

   SUBROUTINE IM_MPY(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPY(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_MPY

   SUBROUTINE IM_MPYI(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPYI(MA%MIM,IVAL,MB%MIM,QX)
   END SUBROUTINE IM_MPYI

   SUBROUTINE IM_MPYM(MA,MB,MC,MD)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPYM(MA%MIM,MB%MIM,MC%MIM,MD%MIM,QX)
   END SUBROUTINE IM_MPYM

   SUBROUTINE IM_OUT(MA,LINE,LB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: LB
      INTENT (IN) :: LB
      CHARACTER :: LINE(LB)
      INTENT (INOUT) :: LINE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMOUT(MA%MIM,LINE,LB,QX)
   END SUBROUTINE IM_OUT

   SUBROUTINE IM_PMOD(MA,MB,MC,MD)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TYPE(FM_SETTINGS) :: QX
      CALL IMPMOD(MA%MIM,MB%MIM,MC%MIM,MD%MIM,QX)
   END SUBROUTINE IM_PMOD

   SUBROUTINE IM_PRNT(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMPRNT(MA%MIM,QX)
   END SUBROUTINE IM_PRNT

   SUBROUTINE IM_PWR(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMPWR(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_PWR

   SUBROUTINE IM_READ(KREAD,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KREAD
      INTENT (IN) :: KREAD
      TYPE (IM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMREAD(KREAD,MA%MIM,QX)
   END SUBROUTINE IM_READ

   SUBROUTINE IM_SIGN(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMSIGN(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_SIGN

   SUBROUTINE IM_SQR(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL IMSQR(MA%MIM,MB%MIM,QX)
   END SUBROUTINE IM_SQR

   SUBROUTINE IM_ST2M(STRING,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (INOUT) :: MA
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      TYPE(FM_SETTINGS) :: QX
      CALL IMST2M(STRING,MA%MIM,QX)
   END SUBROUTINE IM_ST2M

   SUBROUTINE IM_SUB(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMSUB(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_SUB

   SUBROUTINE IM_WRIT(KWRITE,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTENT (IN) :: KWRITE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMWRIT(KWRITE,MA%MIM,QX)
   END SUBROUTINE IM_WRIT

   SUBROUTINE ZM_ABS(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE (FM) :: MB
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMABS(MA%MZM,MB%MFM,QX)
   END SUBROUTINE ZM_ABS

   SUBROUTINE ZM_ACOS(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMACOS(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ACOS

   SUBROUTINE ZM_ACOSH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMACOSH(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ACOSH

   SUBROUTINE ZM_ADD(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMADD(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_ADD

   SUBROUTINE ZM_ADDI(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMADDI(MA%MZM,IVAL,QX)
   END SUBROUTINE ZM_ADDI

   SUBROUTINE ZM_ARG(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE (FM) :: MB
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMARG(MA%MZM,MB%MFM,QX)
   END SUBROUTINE ZM_ARG

   SUBROUTINE ZM_ASIN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMASIN(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ASIN

   SUBROUTINE ZM_ASINH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMASINH(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ASINH

   SUBROUTINE ZM_ATAN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMATAN(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ATAN

   SUBROUTINE ZM_ATANH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMATANH(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ATANH

   SUBROUTINE ZM_CHSH(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCHSH(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_CHSH

   SUBROUTINE ZM_CMPX(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE (ZM) :: MC
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCMPX(MA%MFM,MB%MFM,MC%MZM,QX)
   END SUBROUTINE ZM_CMPX

   SUBROUTINE ZM_CONJ(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCONJ(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_CONJ

   SUBROUTINE ZM_COS(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCOS(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_COS

   SUBROUTINE ZM_COSH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCOSH(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_COSH

   SUBROUTINE ZM_CSSN(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCSSN(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_CSSN

   SUBROUTINE ZM_DIV(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMDIV(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_DIV

   SUBROUTINE ZM_DIVI(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMDIVI(MA%MZM,IVAL,MB%MZM,QX)
   END SUBROUTINE ZM_DIVI

   SUBROUTINE ZM_EQU(MA,MB,NA,NB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: NA,NB
      INTENT (IN) :: NA,NB
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEQU(MA%MZM,MB%MZM,NA,NB,QX)
   END SUBROUTINE ZM_EQU

   SUBROUTINE ZM_EXP(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMEXP(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_EXP

   SUBROUTINE ZM_FORM(FORM1,FORM2,MA,STRING)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM1,FORM2,STRING
      INTENT (IN) :: FORM1,FORM2
      INTENT (INOUT) :: STRING
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMFORM(FORM1,FORM2,MA%MZM,STRING,QX)
   END SUBROUTINE ZM_FORM

   SUBROUTINE ZM_FPRT(FORM1,FORM2,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM1,FORM2
      INTENT (IN) :: FORM1,FORM2
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMFPRT(FORM1,FORM2,MA%MZM,QX)
   END SUBROUTINE ZM_FPRT

   SUBROUTINE ZM_I2M(IVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMI2M(IVAL,MA%MZM,QX)
   END SUBROUTINE ZM_I2M

   SUBROUTINE ZM_2I2M(IVAL1,IVAL2,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL1,IVAL2
      INTENT (IN) :: IVAL1,IVAL2
      TYPE(FM_SETTINGS) :: QX
      CALL ZM2I2M(IVAL1,IVAL2,MA%MZM,QX)
   END SUBROUTINE ZM_2I2M

   SUBROUTINE ZM_IMAG(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE (FM) :: MB
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMIMAG(MA%MZM,MB%MFM,QX)
   END SUBROUTINE ZM_IMAG

   SUBROUTINE ZM_INP(LINE,MA,LA,LB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: LA,LB
      INTENT (IN) :: LA,LB
      CHARACTER :: LINE(LB)
      INTENT (IN) :: LINE
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMINP(LINE,MA%MZM,LA,LB,QX)
   END SUBROUTINE ZM_INP

   SUBROUTINE ZM_INT(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMINT(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_INT

   SUBROUTINE ZM_IPWR(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMIPWR(MA%MZM,IVAL,MB%MZM,QX)
   END SUBROUTINE ZM_IPWR

   SUBROUTINE ZM_LG10(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMLG10(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_LG10

   SUBROUTINE ZM_LN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMLN(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_LN

   SUBROUTINE ZM_M2I(MA,IVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMM2I(MA%MZM,IVAL,QX)
   END SUBROUTINE ZM_M2I

   SUBROUTINE ZM_M2Z(MA,ZVAL)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      COMPLEX :: ZVAL
      INTENT (INOUT) :: ZVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMM2Z(MA%MZM,ZVAL,QX)
   END SUBROUTINE ZM_M2Z

   SUBROUTINE ZM_MPY(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMMPY(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_MPY

   SUBROUTINE ZM_MPYI(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMMPYI(MA%MZM,IVAL,MB%MZM,QX)
   END SUBROUTINE ZM_MPYI

   SUBROUTINE ZM_NINT(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMNINT(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_NINT

   SUBROUTINE ZM_OUT(MA,LINE,LB,LAST1,LAST2)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: LB,LAST1,LAST2
      INTENT (IN) :: LB
      CHARACTER :: LINE(LB)
      INTENT (INOUT) :: LINE,LAST1,LAST2
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMOUT(MA%MZM,LINE,LB,LAST1,LAST2,QX)
   END SUBROUTINE ZM_OUT

   SUBROUTINE ZM_PRNT(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMPRNT(MA%MZM,QX)
   END SUBROUTINE ZM_PRNT

   SUBROUTINE ZM_PWR(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMPWR(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_PWR

   SUBROUTINE ZM_READ(KREAD,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KREAD
      INTENT (IN) :: KREAD
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAD(KREAD,MA%MZM,QX)
   END SUBROUTINE ZM_READ

   SUBROUTINE ZM_REAL(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE (FM) :: MB
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMREAL(MA%MZM,MB%MFM,QX)
   END SUBROUTINE ZM_REAL

   SUBROUTINE ZM_RPWR(MA,IVAL,JVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: IVAL,JVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMRPWR(MA%MZM,IVAL,JVAL,MB%MZM,QX)
   END SUBROUTINE ZM_RPWR

   SUBROUTINE ZM_SET(NPREC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: NPREC
      INTENT (IN) :: NPREC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSET(NPREC,QX)
   END SUBROUTINE ZM_SET

   SUBROUTINE ZM_SIN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSIN(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_SIN

   SUBROUTINE ZM_SINH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSINH(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_SINH

   SUBROUTINE ZM_SQR(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSQR(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_SQR

   SUBROUTINE ZM_SQRT(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSQRT(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_SQRT

   SUBROUTINE ZM_ST2M(STRING,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      TYPE(FM_SETTINGS) :: QX
      CALL ZMST2M(STRING,MA%MZM,QX)
   END SUBROUTINE ZM_ST2M

   SUBROUTINE ZM_SUB(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMSUB(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_SUB

   SUBROUTINE ZM_TAN(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMTAN(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_TAN

   SUBROUTINE ZM_TANH(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMTANH(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_TANH

   SUBROUTINE ZM_WRIT(KWRITE,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTENT (IN) :: KWRITE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMWRIT(KWRITE,MA%MZM,QX)
   END SUBROUTINE ZM_WRIT

   SUBROUTINE ZM_Z2M(ZVAL,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      COMPLEX :: ZVAL
      INTENT (IN) :: ZVAL
      TYPE(FM_SETTINGS) :: QX
      CALL ZMZ2M(ZVAL,MA%MZM,QX)
   END SUBROUTINE ZM_Z2M

   SUBROUTINE ZM_ERF(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMERF(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ERF

   SUBROUTINE ZM_ERFC(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMERFC(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ERFC

   SUBROUTINE ZM_ERFC_SC(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMERFC_SC(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_ERFC_SC

   SUBROUTINE ZM_LNGM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMLNGM(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_LNGM

   SUBROUTINE ZM_GAM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMGAM(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_GAM

   SUBROUTINE ZM_FACT(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMFACT(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_FACT

   SUBROUTINE FM_ATAN2(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMATN2(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_ATAN2

   SUBROUTINE FM_COSH_SINH(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMCHSH(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_COSH_SINH

   FUNCTION FM_COMPARE(MA,LREL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: FM_COMPARE
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(*) :: LREL
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA,LREL,MB
      TYPE(FM_SETTINGS) :: QX
      FM_COMPARE = FMCOMP(MA%MFM,LREL,MB%MFM,QX)
   END FUNCTION FM_COMPARE

   SUBROUTINE FM_COS_SIN(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMCSSN(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_COS_SIN

   SUBROUTINE FM_EULER(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEULR(MA%MFM,QX)
   END SUBROUTINE FM_EULER

   SUBROUTINE FM_FPRINT(FORM,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      TYPE (FM) :: MA
      INTENT (IN) :: FORM,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMFPRT(FORM,MA%MFM,QX)
   END SUBROUTINE FM_FPRINT

   SUBROUTINE FM_IPOWER(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMIPWR(MA%MFM,IVAL,MB%MFM,QX)
   END SUBROUTINE FM_IPOWER

   SUBROUTINE FM_LOG10(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMLG10(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_LOG10

   SUBROUTINE FM_PRINT(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMPRNT(MA%MFM,QX)
   END SUBROUTINE FM_PRINT

   SUBROUTINE FM_POWER(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMPWR(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_POWER

   SUBROUTINE FM_RATIONAL_POWER(MA,IVAL,JVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMRPWR(MA%MFM,IVAL,JVAL,MB%MFM,QX)
   END SUBROUTINE FM_RATIONAL_POWER

   SUBROUTINE FM_WRITE(KWRITE,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      TYPE (FM) :: MA
      INTENT (IN) :: KWRITE,MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMWRIT(KWRITE,MA%MFM,QX)
   END SUBROUTINE FM_WRITE

   FUNCTION IM_COMPARE(MA,LREL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      LOGICAL :: IM_COMPARE
      LOGICAL, EXTERNAL :: IMCOMP
      CHARACTER(*) :: LREL
      TYPE (IM) :: MA,MB
      INTENT (IN) :: MA,LREL,MB
      TYPE(FM_SETTINGS) :: QX
      IM_COMPARE = IMCOMP(MA%MIM,LREL,MB%MIM,QX)
   END FUNCTION IM_COMPARE

   SUBROUTINE IM_FPRINT(FORM,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      TYPE (IM) :: MA
      INTENT (IN) :: FORM,MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMFPRT(FORM,MA%MIM,QX)
   END SUBROUTINE IM_FPRINT

   SUBROUTINE IM_MPY_MOD(MA,MB,MC,MD)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TYPE(FM_SETTINGS) :: QX
      CALL IMMPYM(MA%MIM,MB%MIM,MC%MIM,MD%MIM,QX)
   END SUBROUTINE IM_MPY_MOD

   SUBROUTINE IM_POWER_MOD(MA,MB,MC,MD)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TYPE(FM_SETTINGS) :: QX
      CALL IMPMOD(MA%MIM,MB%MIM,MC%MIM,MD%MIM,QX)
   END SUBROUTINE IM_POWER_MOD

   SUBROUTINE IM_PRINT(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMPRNT(MA%MIM,QX)
   END SUBROUTINE IM_PRINT

   SUBROUTINE IM_POWER(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (IM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL IMPWR(MA%MIM,MB%MIM,MC%MIM,QX)
   END SUBROUTINE IM_POWER

   SUBROUTINE IM_WRITE(KWRITE,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTENT (IN) :: KWRITE
      TYPE (IM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL IMWRITE(KWRITE,MA%MIM,QX)
   END SUBROUTINE IM_WRITE

   SUBROUTINE ZM_COSH_SINH(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCHSH(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_COSH_SINH

   SUBROUTINE ZM_COMPLEX(MAFM,MBFM,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MAFM,MBFM
      TYPE (ZM) :: MC
      INTENT (IN) :: MAFM,MBFM
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCMPX(MAFM%MFM,MBFM%MFM,MC%MZM,QX)
   END SUBROUTINE ZM_COMPLEX

   SUBROUTINE ZM_CONJUGATE(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCONJ(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_CONJUGATE

   SUBROUTINE ZM_COS_SIN(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMCSSN(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_COS_SIN

   SUBROUTINE ZM_FPRINT(FORM1,FORM2,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      CHARACTER(*) :: FORM1,FORM2
      TYPE (ZM) :: MA
      INTENT (IN) :: FORM1,FORM2,MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMFPRT(FORM1,FORM2,MA%MZM,QX)
   END SUBROUTINE ZM_FPRINT

   SUBROUTINE ZM_IPOWER(MA,IVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMIPWR(MA%MZM,IVAL,MB%MZM,QX)
   END SUBROUTINE ZM_IPOWER

   SUBROUTINE ZM_LOG10(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMLG10(MA%MZM,MB%MZM,QX)
   END SUBROUTINE ZM_LOG10

   SUBROUTINE ZM_PRINT(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMPRNT(MA%MZM,QX)
   END SUBROUTINE ZM_PRINT

   SUBROUTINE ZM_POWER(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL ZMPWR(MA%MZM,MB%MZM,MC%MZM,QX)
   END SUBROUTINE ZM_POWER

   SUBROUTINE ZM_RATIONAL_POWER(MA,IVAL,JVAL,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (ZM) :: MA,MB
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL ZMRPWR(MA%MZM,IVAL,JVAL,MB%MZM,QX)
   END SUBROUTINE ZM_RATIONAL_POWER

   SUBROUTINE ZM_WRITE(KWRITE,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: KWRITE
      TYPE (ZM) :: MA
      INTENT (IN) :: KWRITE,MA
      TYPE(FM_SETTINGS) :: QX
      CALL ZMWRIT(KWRITE,MA%MZM,QX)
   END SUBROUTINE ZM_WRITE

   SUBROUTINE FM_BERNOULLI(N,MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: N
      INTENT (IN) :: N
      TYPE(FM_SETTINGS) :: QX
      CALL FMBERNOULLI(N,MA%MFM,QX)
   END SUBROUTINE FM_BERNOULLI

   SUBROUTINE FM_BERN(N,MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: N
      INTENT (IN) :: N
      REAL (KIND(1.0D0)) :: MBSBRN
      INTEGER :: NUMBRN
      TYPE(MULTI) :: MBERN(LMBERN)
      INTEGER :: NDBERN(LMBERN)
      TYPE(FM_SETTINGS) :: QX
      MBSBRN = 0
      NUMBRN = 0
      NDBERN = 0
      CALL FMBERN(N,MA%MFM,MB%MFM,MBSBRN,NUMBRN,MBERN,NDBERN,QX)
   END SUBROUTINE FM_BERN

   SUBROUTINE FM_BETA(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMBETA(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_BETA

   SUBROUTINE FM_COMB(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMCOMB(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_COMB

   SUBROUTINE FM_EULR(MA)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      TYPE(FM_SETTINGS) :: QX
      CALL FMEULR(MA%MFM,QX)
   END SUBROUTINE FM_EULR

   SUBROUTINE FM_FACT(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMFACT(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_FACT

   SUBROUTINE FM_GAM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMGAM(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_GAM

   SUBROUTINE FM_IBTA(MA,MB,MC,MD)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TYPE(FM_SETTINGS) :: QX
      CALL FMIBTA(MA%MFM,MB%MFM,MC%MFM,MD%MFM,QX)
   END SUBROUTINE FM_IBTA

   SUBROUTINE FM_IGM1(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMIGM1(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_IGM1

   SUBROUTINE FM_IGM2(MA,MB,MC)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TYPE(FM_SETTINGS) :: QX
      CALL FMIGM2(MA%MFM,MB%MFM,MC%MFM,QX)
   END SUBROUTINE FM_IGM2

   SUBROUTINE FM_LNGM(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMLNGM(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_LNGM

   SUBROUTINE FM_PGAM(N,MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: N
      INTENT (IN) :: N
      TYPE(FM_SETTINGS) :: QX
      CALL FMPGAM(N,MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_PGAM

   SUBROUTINE FM_POCH(MA,N,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: N
      INTENT (IN) :: N
      TYPE(FM_SETTINGS) :: QX
      CALL FMPOCH(MA%MFM,N,MB%MFM,QX)
   END SUBROUTINE FM_POCH

   SUBROUTINE FM_PSI(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMPSI(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_PSI

   SUBROUTINE FM_BESJ(N,MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: N
      INTENT (IN) :: N
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESJ(N,MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_BESJ

   SUBROUTINE FM_BESY(N,MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: N
      INTENT (IN) :: N
      TYPE(FM_SETTINGS) :: QX
      CALL FMBESY(N,MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_BESY

   SUBROUTINE FM_CHI(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMCHI(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_CHI

   SUBROUTINE FM_CI(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMCI(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_CI

   SUBROUTINE FM_EI(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMEI(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_EI

   SUBROUTINE FM_EN(N,MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: N
      INTENT (IN) :: N
      TYPE(FM_SETTINGS) :: QX
      CALL FMEN(N,MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_EN

   SUBROUTINE FM_C(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMC(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_C

   SUBROUTINE FM_S(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMS(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_S

   SUBROUTINE FM_ERF(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMERF(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ERF

   SUBROUTINE FM_ERFC(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMERFC(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ERFC

   SUBROUTINE FM_ERFC_SCALED(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMERFCS(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_ERFC_SCALED

   SUBROUTINE FM_LERC(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMLERC(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_LERC

   SUBROUTINE FM_LI(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMLI(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_LI

   SUBROUTINE FM_SHI(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSHI(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_SHI

   SUBROUTINE FM_SI(MA,MB)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (FM) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TYPE(FM_SETTINGS) :: QX
      CALL FMSI(MA%MFM,MB%MFM,QX)
   END SUBROUTINE FM_SI

 END MODULE FMZM_10_PARALLEL

 MODULE FMZM_PARALLEL

   USE FMZM_1_PARALLEL
   USE FMZM_2_PARALLEL
   USE FMZM_3_PARALLEL
   USE FMZM_4_PARALLEL
   USE FMZM_5_PARALLEL
   USE FMZM_6_PARALLEL
   USE FMZM_7_PARALLEL
   USE FMZM_8_PARALLEL
   USE FMZM_9_PARALLEL
   USE FMZM_10_PARALLEL

 END MODULE FMZM_PARALLEL


!  Include all the various FM routines from the "More sample programs" page on the
!  FM web site.  See that page for the programs that call these routines and illustrate their
!  use.  Here is a list of the user-callable routines in this file (see the documentation at
!  the top of each routine for explanation of each of the arguments to the routines).

!  1.  Find a minimum or maximum function value of a real function of one variable.

!                   SUBROUTINE FM_FIND_MIN(MIN_OR_MAX,AX,BX,TOL,XVAL,FVAL,F,NF,KPRT,KW)

!  2.  Nth derivative of a real function of one variable.

!                   FUNCTION FM_FPRIME(N,A,F,NF)

!  3.  Nth derivative of a complex function of one variable.

!                   FUNCTION ZM_FPRIME(N,A,F,NF)

!  4.  Definite integral for a real function of one variable.

!                   SUBROUTINE FM_INTEGRATE(F,N,A,B,TOL,RESULT,KPRT,NW)

!  5.  Inverse matrix for a real NxN matrix.

!                   SUBROUTINE FM_INVERSE(A,N,B,DET)

!  6.  Inverse matrix for a complex NxN matrix.

!                   SUBROUTINE ZM_INVERSE(A,N,B,DET)

!  7.  Generate the real linear system of normal equations for a least square fit.

!                   SUBROUTINE FM_GENEQ(F,A,B,K,X,Y,N)

!  8.  Solve a real NxN linear system of equations.

!                   SUBROUTINE FM_LIN_SOLVE(A,X,B,N,DET)

!  9.  Solve a complex NxN linear system of equations.

!                   SUBROUTINE ZM_LIN_SOLVE(A,X,B,N,DET)

! 10.  Solve a real differential equation (initial value problem).

!                   SUBROUTINE FM_RK14(A,B,N_ORDER,F,N_FUNCTION,S,TOL,S1)

! 11.  Find a root of a real function of one variable.

!                   SUBROUTINE FM_SECANT(AX,BX,F,NF,ROOT,KPRT,KU)

! 12.  Find a root of a complex function of one variable.

!                   SUBROUTINE ZM_SECANT(AX,BX,F,NF,ROOT,KPRT,KU)

! 13.  Find NR roots of a complex function of one variable.

!                   SUBROUTINE ZM_ROOTS(NR,F,NF,N_FOUND,LIST_OF_ROOTS,KPRT,KU)



      SUBROUTINE FM_FIND_MIN(MIN_OR_MAX,AX,BX,TOL,XVAL,FVAL,F,NF,KPRT,KP)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL

!  MIN_OR_MAX having value 1 means minimize the function, otherwise maximize.
!  AX, BX     define the endpoints of an interval in which the search takes place.
!  TOL        is the tolerance for the minimum.  Usually TOL should be no less than
!             sqrt(epsilon(ax)), meaning the x-coordinate XVAL of the extreme point will
!             be accurate to only about half the digits carried.  The y-coordinate FVAL
!             should be accurate to nearly full precision.
!             This happens because the typical graph is nearly parabolic near the minimum,
!             and within sqrt(epsilon(ax)) of the minimum all the function values are
!             essentially identical at the current precision.
!  XVAL       is returned as the value of X that minimizes (or maximizes) function F(X,NF).
!             It is a relative extreme point, and may not be the global extreme point if the
!             function has more than one extremum on the interval.
!  FVAL       is returned as the function value at XVAL.
!  F(X,NF)    is the function to be minimized.  X is the argument and NF is the function
!             number, in case several functions are defined within F.
!  KPRT       controls printing within the routine:
!             KPRT = 0 for no output
!             KPRT = 1 for the approximation to the root and the function
!                      value to be printed once at the end of the routine.
!             KPRT = 2 for the approximation to the root and the function
!                      value to be printed each iteration.
!  KP         is the unit number for output.

!  The method used is a combination of golden section search and successive parabolic interpolation.
!  Convergence is never much slower than that for a fibonacci search.  If f has a continuous second
!  derivative which is positive at the minimum (which is not at ax or bx), then convergence is
!  superlinear, and usually of the order of about 1.324....

!  The function f is never evaluated at two points closer together than eps*abs(FVAL)+(tol/3),
!  where eps is approximately the square root of the relative machine precision.  If f is a
!  unimodal function and the computed values of f are always unimodal when separated by at least
!  eps*abs(x)+(tol/3), then FVAL approximates the abscissa of the global minimum of f on the
!  interval ax,bx with an error less than 3*eps*abs(FVAL)+tol.  If f is not unimodal, then FVAL
!  may approximate a local, but perhaps non-global, minimum to the same accuracy.

!  This routine is a slightly modified translation of function FVAL from netlib, which was adapted
!  from the algol 60 procedure localmin given by Richard Brent in Algorithms For Minimization
!  Without Derivatives, Prentice-Hall (1973).

      IMPLICIT NONE
      CHARACTER(80)  :: ST1,ST2
      INTEGER :: J,MINV,MIN_OR_MAX,NF,KPRT,KP
      TYPE (FM)           :: AX,BX,TOL,XVAL,FVAL
      TYPE (MULTI), EXTERNAL :: F
      TYPE(FM_SETTINGS) :: QX

      TYPE (FM) :: A, B, C, D, E, EPS, XM, P, Q, R, T2, U, V, W, FU, FV, FW, FX, X, TOL1, TOL3

      MINV = 1
      IF (MIN_OR_MAX /= 1) MINV = -1

!             C is the squared inverse of the golden ratio.

      C = (3-SQRT(TO_FM('5.0D0')))/2

!             EPS is approximately the square root of the relative machine precision.

      EPS = EPSILON(AX)
      TOL1 = EPS + 1
      EPS = SQRT(EPS)

      A = MIN(AX,BX)
      B = MAX(AX,BX)
      V = A + C*(B-A)
      W = V
      X = V
      E = 0
      FX%MFM = F(X%MFM,NF,QX)
      FX = FX*MINV
      FV = FX
      FW = FX
      TOL3 = TOL/3
      J = 1

      IF (KPRT == 2) THEN
          WRITE (KP,*) ' '
          IF (MIN_OR_MAX == 1) THEN
              WRITE (KP,*) ' FM_FIND_MIN.  Begin trace of all iterations.'
              WRITE (KP,*) '               Search for a relative minimum on the interval'
              WRITE (KP,"(13X,ES20.10,'    to ',ES20.10/)") TO_DP(AX),TO_DP(BX)
          ELSE
              WRITE (KP,*) ' FM_FIND_MIN.  Begin trace of all iterations.'
              WRITE (KP,*) '               Search for a relative maximum on the interval'
              WRITE (KP,"(13X,ES20.10,'    to ',ES20.10/)") TO_DP(AX),TO_DP(BX)
          ENDIF
          ST1 = FM_FORMAT('ES35.25',X)
          ST2 = FM_FORMAT('ES35.25',FX*MINV)
          WRITE (KP,"('      J =',I3,4X,'  x  = ',A)") J,TRIM(ST1)
          WRITE (KP,"('         ',3X,4X,'f(x) = ',A/)") TRIM(ST2)
      ENDIF

!             The main loop starts here.

  110 XM = (A+B)/2
      TOL1 = EPS*ABS(X) + TOL3
      T2 = 2*TOL1

!             Check the stopping criterion.

      IF (ABS(X-XM) <= (T2-(B-A)/2)) GO TO 160
      P = 0
      Q = 0
      R = 0
      IF (ABS(E) > TOL1) THEN
          R = (X-W)*(FX-FV)    !     Fit a parabola.
          Q = (X-V)*(FX-FW)
          P = (X-V)*Q-(X-W)*R
          Q = 2*(Q-R)
          IF (Q > 0) THEN
              P = -P
          ELSE
              Q = -Q
          ENDIF
          R = E
          E = D
      ENDIF

      IF ((ABS(P) >= ABS(Q*R/2)) .OR. (P <= Q*(A-X)) .OR. (P >= Q*(B-X))) GO TO 120

!             Make a parabolic-interpolation step.

      D = P/Q
      U = X + D

!             f must not be evaluated too close to ax or bx.

      IF (((U-A) >= T2) .AND. ((B-U) >= T2)) GO TO 130
      D = TOL1
      IF (X >= XM) D = -D
      GO TO 130

!             Make a golden-section step.

  120 IF (X < XM) THEN
          E = B - X
      ELSE
          E = A - X
      ENDIF
      D = C*E

!             f must not be evaluated too close to x.

  130 IF (ABS(D) >= TOL1) THEN
          U = X + D
      ELSE
          IF (D > 0) THEN
              U = X + TOL1
          ELSE
              U = X - TOL1
          ENDIF
      ENDIF
      FU%MFM = F(U%MFM,NF,QX)
      FU = FU*MINV

      J = J + 1
      IF (KPRT == 2) THEN
          ST1 = FM_FORMAT('ES35.25',U)
          ST2 = FM_FORMAT('ES35.25',FU*MINV)
          WRITE (KP,"('      J =',I3,4X,'  x  = ',A)") J,TRIM(ST1)
          WRITE (KP,"('         ',3X,4X,'f(x) = ',A/)") TRIM(ST2)
      ENDIF

!             update  a, b, v, w, and x.

      IF (FX <= FU) THEN
          IF (U < X) THEN
              A = U
          ELSE
              B = U
          ENDIF
      ENDIF
      IF (FU > FX) GO TO 140
      IF (U < X) THEN
          B = X
      ELSE
          A = X
      ENDIF
      V = W
      FV = FW
      W = X
      FW = FX
      X = U
      FX = FU
      GO TO 110

  140 IF ((FU > FW) .AND. (W /= X)) GO TO 150
      V = W
      FV = FW
      W = U
      FW = FU
      GO TO 110

  150 IF ((FU > FV) .AND. (V /= X) .AND. (V /= W)) GO TO 110
      V = U
      FV = FU
      GO TO 110

!  end of main loop

  160 XVAL = X
      FVAL = FX*MINV

      IF (KPRT >= 1) THEN
          IF (KPRT == 1) WRITE (KP,*) ' '
          IF (MIN_OR_MAX == 1) THEN
              WRITE (KP,"('  FM_FIND_MIN.   Function ',I3,I6,' iterations.  A relative minimum"// &
                        " on interval'/13X,ES20.10,'    to ',ES20.10,'  is')")                    &
                     NF,J,TO_DP(AX),TO_DP(BX)
              ST1 = FM_FORMAT('ES35.25',XVAL)
              ST2 = FM_FORMAT('ES35.25',FVAL)
              WRITE (KP,"(15X,'   x  = ',A)") TRIM(ST1)
              WRITE (KP,"(15X,' f(x) = ',A)") TRIM(ST2)
          ELSE
              WRITE (KP,"('  FM_FIND_MIN.   Function ',I3,I6,' iterations.  A relative maximum"// &
                        " on interval'/13X,ES20.10,'    to ',ES20.10,'  is')")                    &
                     NF,J,TO_DP(AX),TO_DP(BX)
              ST1 = FM_FORMAT('ES35.25',XVAL)
              ST2 = FM_FORMAT('ES35.25',FVAL)
              WRITE (KP,"(15X,'   x  = ',A)") TRIM(ST1)
              WRITE (KP,"(15X,' f(x) = ',A)") TRIM(ST2)
          ENDIF
          WRITE (KP,*) ' '
      ENDIF

      END SUBROUTINE FM_FIND_MIN

      FUNCTION FM_FPRIME(N,A,F,NF)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  This routine finds the Nth derivative of F(X,NF), evaluated at A.
!  NF is passed on to function F to indicate which function to use in cases where several
!  different functions may be defined there.

!  F must be defined in an interval containing A, so that F can be sampled on both sides of A.

!  N may be zero, so that in cases where F suffers cancellation error at A, an accurate
!  function value is returned.

!  FM_FPRIME tries to return full accuracy for the derivative, by raising precision above
!  the user's level and using difference formulas.

      TYPE (FM)           :: RETURN_VALUE, A
      TYPE (MULTI), EXTERNAL :: F
      INTEGER :: J, K, KWARN_SAVE, NDSAVE, N, NF
      TYPE (MULTI) :: D1, D2, F1, F2, H, TOL, TOL2, X1, MXY(4)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

!             Raise precision slightly.

      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL FMEQU(A%MFM,X1,NDSAVE,QX%NDIG,QX)
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

      CALL FMI2M(0,D2,QX)
      F1 = F(X1,NF,QX)
      IF (FMCOMP(F1,'/=',D2,QX)) THEN
          CALL FMULP(F1,TOL,QX)
      ELSE
          CALL FMI2M(1,MXY(1),QX)
          CALL FMULP(MXY(1),TOL,QX)
      ENDIF
      CALL FMABS(TOL,MXY(2),QX)
      CALL FMEQ(MXY(2),TOL,QX)

!             Check for a legal function value.

      IF (F1%MP(2) == QX%MUNKNO .OR. F1%MP(2) == QX%MEXPOV .OR.  &
          F1%MP(2) == QX%MEXPUN .OR. N < 0) THEN
          CALL FMST2M(' UNKNOWN ',D2,QX)
          GO TO 110
      ENDIF
      F2 = F1

!             Loop at increasing precision until the difference formula is accurate.

      DO J = 1, 100

         IF (3*QX%NDIG <= NDIG_MAX) THEN
             QX%NDIG = 2*QX%NDIG
         ELSE
             CALL FMST2M(' UNKNOWN ',D2,QX)
             GO TO 110
         ENDIF


!             Define the variables used below at the new higher precision.

         CALL FMEQU(D2,D1,QX%NDIG/2,QX%NDIG,QX)
         CALL FMEQU(F2,F1,QX%NDIG/2,QX%NDIG,QX)
         CALL FMEQU(TOL,TOL2,NDSAVE,QX%NDIG,QX)
         CALL FMEQU(A%MFM,X1,NDSAVE,QX%NDIG,QX)

!             Special case for N = 0.

         IF (N == 0) THEN
             F2 = F(X1,NF,QX)
             D2 = F2
             CALL FMSUB(F2,F1,MXY(1),QX)
             CALL FMABS(MXY(1),MXY(2),QX)
             IF (FMCOMP(MXY(2),'<',TOL2,QX)) GO TO 110
             CYCLE
         ENDIF
         F2 = F1

!             Special case for N = 1.

         IF (N == 1) THEN
             IF (X1%MP(3) /= 0) THEN
                 CALL FMULP(X1,H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             H%MP(1) = 1
             CALL FMSQRT_R1(H,QX)
             CALL FMADD(X1,H,MXY(1),QX)
             MXY(2) = F(MXY(1),NF,QX)
             CALL FMSUB(X1,H,MXY(1),QX)
             MXY(3) = F(MXY(1),NF,QX)
             CALL FMSUB(MXY(2),MXY(3),D2,QX)
             CALL FMDIVI_R1(D2,2,QX)
             CALL FMDIV_R1(D2,H,QX)
             CALL FMSUB(D2,D1,MXY(1),QX)
             MXY(1)%MP(1) = 1
             IF (FMCOMP(MXY(1),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

!             General case for even N > 1.

         IF (MOD(N,2) == 0) THEN
             IF (X1%MP(3) /= 0) THEN
                 CALL FMULP(X1,H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMI2M(1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),N+2,QX)
             CALL FMABS(H,MXY(2),QX)
             CALL FMPWR(MXY(2),MXY(1),H,QX)
             MXY(4) = F(X1,NF,QX)
             CALL FMI2M(N,MXY(1),QX)
             CALL FMI2M(N/2,MXY(2),QX)
             CALL FMCOMB(MXY(1),MXY(2),MXY(3),QX)
             CALL FMMPY(MXY(3),MXY(4),D2,QX)
             CALL FMMPYI_R1(D2,(-1)**(N/2),QX)
             DO K = 0, N/2-1
                CALL FMMPYI(H,N/2-K,MXY(1),QX)
                CALL FMADD(X1,MXY(1),MXY(2),QX)
                MXY(3) = F(MXY(2),NF,QX)
                CALL FMSUB(X1,MXY(1),MXY(2),QX)
                MXY(4) = F(MXY(2),NF,QX)
                CALL FMADD_R2(MXY(3),MXY(4),QX)
                CALL FMI2M(N,MXY(1),QX)
                CALL FMI2M(K,MXY(2),QX)
                CALL FMCOMB(MXY(1),MXY(2),MXY(3),QX)
                CALL FMMPY_R2(MXY(3),MXY(4),QX)
                CALL FMMPYI_R1(MXY(4),(-1)**K,QX)
                CALL FMADD_R1(D2,MXY(4),QX)
             ENDDO
             CALL FMIPWR(H,N,MXY(1),QX)
             CALL FMDIV_R1(D2,MXY(1),QX)
             CALL FMSUB(D2,D1,MXY(1),QX)
             CALL FMABS(MXY(1),MXY(2),QX)
             IF (FMCOMP(MXY(2),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

!             General case for odd N > 1.

         IF (MOD(N,2) == 1) THEN
             IF (X1%MP(3) /= 0) THEN
                 CALL FMULP(X1,H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMI2M(1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),N+2,QX)
             CALL FMABS(H,MXY(2),QX)
             CALL FMPWR(MXY(2),MXY(1),H,QX)
             CALL FMI2M(0,D2,QX)
             DO K = 0, N/2
                CALL FMMPYI(H,N/2-K+1,MXY(1),QX)
                CALL FMADD(X1,MXY(1),MXY(2),QX)
                MXY(3) = F(MXY(2),NF,QX)
                CALL FMSUB(X1,MXY(1),MXY(2),QX)
                MXY(4) = F(MXY(2),NF,QX)
                CALL FMSUB_R2(MXY(3),MXY(4),QX)
                CALL FMI2M(N-1,MXY(1),QX)
                CALL FMI2M(K,MXY(2),QX)
                CALL FMCOMB(MXY(1),MXY(2),MXY(3),QX)
                CALL FMMPY_R2(MXY(3),MXY(4),QX)
                CALL FMMPYI_R1(MXY(4),(-1)**K,QX)
                CALL FMMPYI_R1(MXY(4),N*(N+1-2*K),QX)
                CALL FMDIVI_R1(MXY(4),(N-K)*(N+1-K),QX)
                CALL FMADD_R1(D2,MXY(4),QX)
             ENDDO
             CALL FMIPWR(H,N,MXY(1),QX)
             CALL FMMPYI_R1(MXY(1),2,QX)
             CALL FMDIV_R1(D2,MXY(1),QX)
             CALL FMSUB(D2,D1,MXY(1),QX)
             CALL FMABS(MXY(1),MXY(2),QX)
             IF (FMCOMP(MXY(2),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

      ENDDO

!             Round and return.

  110 CALL FMEQU(D2,RETURN_VALUE%MFM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%KWARN = KWARN_SAVE
      END FUNCTION FM_FPRIME

      SUBROUTINE FM_GENEQ(F,A,B,K,X,Y,N)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Generate the KxK matrix A and Kx1 vector B of normal equations for the least square
!  fit of the K-parameter model

!     Y = C(1)*F(1,X) + ... + C(K)*F(K,X)

!  to the data points (X(J),Y(J)), J = 1, 2, ..., N.

!  A and B are returned, and then the coefficients C can be found by solving the
!  linear system  A * C = B.

!  Function L in the model evaluated at X is referenced by F(L,X) in this routine,
!  and F should be supplied as an external function subprogram by the user.

      INTEGER :: K, N
      TYPE (MULTI), EXTERNAL :: F
      TYPE (FM) :: A(K,K), B(K), X(N), Y(N)
      INTEGER :: I, J, L, NDSAVE
      TYPE (MULTI), ALLOCATABLE :: FXI(:)
      TYPE (MULTI) :: XI, YI, FXIL, MXY(2)
      TYPE(FM_SETTINGS) :: QX

      IF (N <= 0 .OR. K <= 0) THEN
          WRITE (*,"(/' Error in FM_GENEQ.  K,N=',2I8/)") K,N
          STOP
      ENDIF

      ALLOCATE(FXI(K),STAT=J)
      IF (J /= 0) THEN
          WRITE (*,"(/' Error in FM_GENEQ.  Unable to allocate FXI with size ',I8/)") K
          STOP
      ENDIF

      NDSAVE = QX%NDIG
      IF (2*QX%NDIG <= 4*NDIG_MAX/5) THEN
          QX%NDIG = 2*QX%NDIG
      ENDIF

!             Initialize the upper triangle of A.

      DO I = 1, K
         DO J = I, K
            CALL FMI2M(0,A(I,J)%MFM,QX)
         ENDDO
         CALL FMI2M(0,B(I)%MFM,QX)
      ENDDO

!             Loop over the data points.

      DO I = 1, N
         CALL FMEQU(X(I)%MFM,XI,NDSAVE,QX%NDIG,QX)
         CALL FMEQU(Y(I)%MFM,YI,NDSAVE,QX%NDIG,QX)

!             Compute the K function values at X(I).

         DO J = 1, K
            FXI(J) = F(J,XI,QX)
         ENDDO

!             Multiply the function values and add the products to the matrix.

         DO L = 1, K
            CALL FMEQ(FXI(L),FXIL,QX)
            DO J = L, K
               CALL FMMPY(FXIL,FXI(J),MXY(1),QX)
               CALL FMADD_R1(A(L,J)%MFM,MXY(1),QX)
            ENDDO

!             Sum the right-hand-side term.

            CALL FMMPY(FXIL,YI,MXY(1),QX)
            CALL FMADD_R1(B(L)%MFM,MXY(1),QX)
         ENDDO
      ENDDO

!             Fill the lower triangle of the A matrix using symmetry.

      IF (K >= 2) THEN
          DO L = 2, K
             DO J = 1, L-1
                CALL FMEQU(A(J,L)%MFM,A(L,J)%MFM,QX%NDIG,NDSAVE,QX)
                CALL FMEQU_R1(A(J,L)%MFM,QX%NDIG,NDSAVE,QX)
             ENDDO
          ENDDO
      ENDIF

      QX%NDIG = NDSAVE
      DEALLOCATE(FXI)
      END SUBROUTINE FM_GENEQ


      SUBROUTINE FM_INTEGRATE(F,N,A,B,TOL,RESULT,KPRT,NW)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  High-precision numerical integration.

!  Integrate F(X,N) from A to B.  N is passed on to function F to indicate which function to use in
!  cases where several different functions may be defined there.


!  WARNING:  If the function F being integrated or one of its derivatives does not exist at one or
!            both of the endpoints (A,B), the endpoints should be exactly representable in FM's
!            number system.  For non-exact numbers like 1/3, sqrt(2), or pi/2, when FM_INTEGRATE
!            raises precision to evaluate the integration formula the endpoints are not accurate
!            enough at the higher precision.

!  Example:  Integrate  sqrt( tan( x ) )  from  0  to  pi/2.
!            First, pi/2 is not exact as an FM number.  At some precisions it may have rounded up,
!            making tan(x) negative and causing an error in sqrt.  Using sqrt( abs( tan( x ) ) )
!            is safer.
!            Second, b = pi/2 has been computed at the user's precision, so when FM_INTEGRATE
!            raises precision, the value of b is just zero-padded on the end, which does not give
!            enough information about how f(x) behaves near the singularity at pi/2.
!
!            Make the endpoints exact by changing variables.  Change the interval to [ 0 , 1 ]:
!
!                                        u = ( 2/pi ) * x   =>   du = ( 2/pi ) * dx
!            so
!                                        x = ( pi/2 ) * u   =>   dx = ( pi/2 ) * du
!            new limits
!                                        x = 0  =>  u = 0  and  x = pi/2  =>  u = 1
!
!            New integral:   Integrate  (pi/2) * sqrt( abs( tan( pi*u/2 ) ) )  from  0  to  1.
!
!            Now the function F should declare a local variable PI, and then use CALL FM_PI(PI)
!            each time F is called to make sure the value of PI is correct at the higher precision
!            being used by FM_INTEGRATE when F is called.

      TYPE (FM) :: A,B,RESULT,TOL
      TYPE (MULTI), EXTERNAL :: F
      INTEGER :: N,KPRT,NW
      INTENT (IN) :: N,A,B,TOL,KPRT,NW
      INTENT (INOUT) :: RESULT
      TYPE(FM_SETTINGS) :: QX

!  A,B,TOL, and RESULT are all type (FM) variables, and function F returns a type (FM) result.

!  RESULT is returned as the value of the integral, with ABS((RESULT-true)/true) less than TOL
!         (i.e., TOL is a relative error tolerance).
!         For example, to get 30 significant digits correct for the integral, set TOL = 1.0E-30.

!  FM precision must be set high enough using FM_SIGNIFICANT_DIGITS so that 1+TOL > 1
!  at that precision.  Using TOL = EPSILON(TO_FM(1)) will usually get a full precision result,
!  but for some functions this might fail.  A better strategy is to set precision higher than
!  the accuracy required for the integral.  For example, to get the integral to 40 significant
!  digits, set FM_SIGNIFICANT_DIGITS = 50 and then set TOL = TO_FM(' 1.0E-40 ') before the call
!  to FM_INTEGRATE.

!  KPRT can be used to show intermediate results on unit NW.
!  KPRT = 0 for no output
!       = 1 prints a summary for each call to FM_INTEGRATE
!       = 2 prints a trace of all iterations.

!  NW is the unit number used for KPRT output and any error or warning messages.

!  No method for numerical integration is foolproof.  Since it samples only a finite number of
!  function values, any numerical integration algorithm can be made to fail by choosing a
!  sufficiently badly-behaved function.  Such functions often vary by many orders of magnitude
!  over relatively small fractions of the interval (A,B).

!  F should be well-behaved in the interior of the interval (A,B).
!  The routine tries to handle any singularities of F or F' at A and/or B, so cases with interior
!  singularities should be done as separate calls having the singularities as endpoints.
!  The routine will try to handle cases where F or F' has singularities inside (A,B), but then
!  the time will be much slower and the routine might fail.

!  For a function with a removable singularity in the interior of the interval, such as
!  f(x) = 1/ln(x) - 1/(x-1), define F(X,N) to check for X = 1 and return the correct limiting
!  value, 0.5 in this case, when X is 1.

!  Among functions with no singularities, examples of badly behaved functions are those with one
!  or more extremely narrow tall spikes in their graphs. If possible, identify the peaks of any
!  such spikes first, then make separate calls with the peaks as endpoints of the intervals of
!  integration.

!  If the value of the integral is zero or very close to zero, relative error may be undefined, so
!  this routine may fail to converge and then return unknown.  For these cases, try breaking the
!  integral into two pieces and calling twice to get two non-zero results.  These two results can
!  then be added, often giving the original integral with sufficiently small absolute error even
!  though small relative error could not be attained.

!  If the function values are too extreme, it can cause problems.  For example, if an exponential
!  in F underflows and then is multiplied by something bigger than one, then F will return unknown.
!  If the result of the integral is much larger than the underflow threshold (TINY(TO_FM(1))), then
!  it is safe to set the underflowed results in F to zero to avoid getting unknown.

!  If the function is nearly divergent FM_INTEGRATE may fail.  1/x from 0 to b is divergent.
!  1/x**0.99 converges, but so slowly that FM_INTEGRATE may run a long time and then might fail.
!  1/x**0.9999 converges even more slowly and FM_INTEGRATE may fail by declaring that the integral
!  seems divergent.

!  When the integrand is highly (or infinitely) oscillatory, FM_INTEGRATE may fail.
!  If F has more than about 100 oscillations on the interval (A,B), it may be necessary to break
!  the interval into smaller intervals and call FM_INTEGRATE several times.
!  For infinitely many oscillations, like sin(1/x) from 0 to 1, first turn the integral into an
!  infinite series by calling FM_INTEGRATE to integrate each separate loop between roots of
!  sin(1/x).  The function is well-behaved for each call, so FM_INTEGRATE can get high precision
!  quickly for each.  Next form a sequence of k partial sums for this series.  The series converges
!  slowly, with 50 or 100 terms giving only 3 or 4 significant digits of the sum, so an
!  extrapolation method can be used to get a more accurate value of the sum of this series from
!  its first k terms. For an alternating series like this, the extrapolation method of Cohen,
!  Villegas, and Zagier often works very well.
!  Repeated Aitken extrapolation could be used instead -- it is a more widely known method.
!  Sample program Oscillate.f95 computes this integral.


      CALL FMINTEGRATE2(F,N,A%MFM,B%MFM,TOL%MFM,RESULT%MFM,KPRT,NW,QX)

      END SUBROUTINE FM_INTEGRATE


      RECURSIVE SUBROUTINE FMINTEGRATE2(F,N,A,B,TOL,RESULT,KPRT,NW,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

      TYPE (MULTI) :: A,B,RESULT,TOL
      TYPE (MULTI), EXTERNAL :: F
      INTEGER :: N,KPRT,NW
      INTENT (IN) :: N,A,B,TOL,KPRT,NW
      INTENT (INOUT) :: RESULT
      TYPE(FM_SETTINGS) :: QX


!             M  is the maximum level for the integration algorithm.  The number of function
!                evaluations roughly doubles for each successive level until the tolerance is met.
!                Using M = 12 allows up to about 5,000 digits for most integrals, but the upper
!                limit for a given M depends on the function.
!                Raising M further will approximately double the maximum precision for each
!                extra level, but will also double the memory usage for each extra level.

      INTEGER, PARAMETER :: M = 12
      INTEGER, PARAMETER :: NT = 20*2**M
      INTEGER :: ABSIGN,I,ISTEP,K,NDS,NDSAVE,NRETRY
      INTEGER :: R_LEVEL, NUM_F
      LOGICAL, EXTERNAL :: FMCOMP

      TYPE (MULTI) :: A1,AB2,B1,C1,C2,CI,CT,D,EPS,ERR1,ERR2,FMAX,FMAX2,H,HF,LAST_H,PI,PRIOR_HS,  &
                      S,S1,S2,SI,ST,T,TOL1,TOL2,X,XF,XMAX,V,W,MXY(3)

      CHARACTER(80) :: ST1,ST2
      LOGICAL :: SPIKE_FOUND,ST_IS_SAVED

!             Iterative tanh-sinh integration is used, increasing the order until convergence
!             is obtained, or M levels have been done.

      CALL FMI2M(0,RESULT,QX)
      R_LEVEL = 0
      NUM_F = 0

      QX%NCALL = QX%NCALL + 1
      QX%NAMEST(QX%NCALL) = 'INTEGRATE'
      R_LEVEL = R_LEVEL + 1
      NRETRY = 0
      IF (KPRT >= 2) THEN
          WRITE (NW,"(A)") ' '
          WRITE (NW,"(A,I9,A)") ' Input to FM_INTEGRATE.    Function N = ',N,'.    A, B ='
          CALL FMPRINT(A,QX)
          CALL FMPRINT(B,QX)
          CALL FMFORM('ES20.8',TOL,ST1,QX)
          WRITE (NW,"(A,A)") ' TOL =',TRIM(ST1)
      ENDIF

!             Check for special cases.

      IF (FMCOMP(A,'==',B,QX)) THEN
          A1 = F(A,N,QX)
          IF (R_LEVEL <= 1) THEN
              NUM_F = 1
          ELSE
              NUM_F = NUM_F + 1
          ENDIF
          IF (A1%MP(2) == QX%MUNKNO) THEN
              CALL FMF_FAIL(A,N,NW,QX)
              PRIOR_HS = A1
              GO TO 120
          ELSE
              CALL FMI2M(0,PRIOR_HS,QX)
              GO TO 120
          ENDIF
      ENDIF

!             Check to make sure the user has set precision high enough for the value of TOL chosen.

      CALL FMEQ(TOL,TOL1,QX)
      CALL FMI2M(1,MXY(1),QX)
      CALL FMULP(MXY(1),MXY(2),QX)
      IF (FMCOMP(TOL,'<',MXY(2),QX)) THEN
          WRITE (NW,"(A)") ' '
          WRITE (NW,"(A)") ' Error in FM_INTEGRATE.  TOL is '
          CALL FMPRINT(TOL,QX)
          WRITE (NW,"(A)") ' This is too small for the current precision level.  Current epsilon ='
          CALL FMEQ(MXY(2),TOL1,QX)
          CALL FMPRINT(TOL1,QX)
          WRITE (NW,"(A)") ' This larger value will be used.  TOL ='
          CALL FMPRINT(TOL1,QX)
          WRITE (NW,"(A)") ' Set FM_SIGNIFICANT_DIGITS to a higher precision' //  &
                           ' if the smaller TOL is needed.'
      ENDIF

!             Raise the precision.
!             Check for an integrable singularity at either endpoint, and increase precision
!             if it seems that a retry would be needed at the first precision.

      NDSAVE = QX%NDIG
      CALL FMSUB(B,A,MXY(1),QX)
      CALL FMST2M(' 1.0E-10 ',MXY(2),QX)
      CALL FMMPY_R2(MXY(1),MXY(2),QX)
      CALL FMADD_R2(A,MXY(2),QX)
      MXY(3) = F(MXY(2),N,QX)
      CALL FMST2M(' 1.0E-20 ',MXY(2),QX)
      CALL FMMPY_R2(MXY(1),MXY(2),QX)
      CALL FMADD_R2(A,MXY(2),QX)
      MXY(1) = F(MXY(2),N,QX)
      CALL FMDIV_R1(MXY(3),MXY(1),QX)
      CALL FMLG10(MXY(3),MXY(1),QX)
      CALL FMDIVI(MXY(1),10,A1,QX)
      CALL FMSUB(B,A,MXY(1),QX)
      CALL FMST2M(' 1.0E-10 ',MXY(2),QX)
      CALL FMMPY_R2(MXY(1),MXY(2),QX)
      CALL FMSUB_R2(B,MXY(2),QX)
      MXY(3) = F(MXY(2),N,QX)
      CALL FMST2M(' 1.0E-20 ',MXY(2),QX)
      CALL FMMPY_R2(MXY(1),MXY(2),QX)
      CALL FMSUB_R2(B,MXY(2),QX)
      MXY(1) = F(MXY(2),N,QX)
      CALL FMDIV_R1(MXY(3),MXY(1),QX)
      CALL FMLG10(MXY(3),MXY(1),QX)
      CALL FMDIVI(MXY(1),10,B1,QX)
      IF (R_LEVEL <= 1) THEN
          NUM_F = 4
      ELSE
          NUM_F = NUM_F + 4
      ENDIF
      CALL FMST2M('-0.999',MXY(1),QX)
      IF (FMCOMP(A1,'<',MXY(1),QX) .OR. FMCOMP(B1,'<',MXY(1),QX)) THEN
          CALL FMST2M(' UNKNOWN ',PRIOR_HS,QX)
          WRITE (NW,"(A)") ' '
          WRITE (NW,"(A,I9,A)") ' FM_INTEGRATE failed -- F(X,N) for N = ',N,  &
                                ' seems to have a non-integrable singularity'
          WRITE (NW,"(A)")      '                        at an endpoint.  A,B ='
          CALL FMPRINT(A,QX)
          CALL FMPRINT(B,QX)
          WRITE (NW,"(A)") ' Check the limits of integration, function number (N), and' // &
                           ' function definition.'
          WRITE (NW,"(A)") ' '
          GO TO 120
      ENDIF
      IF (QX%NDIG+INT(30/QX%ALOGMT) > 4*NDIG_MAX/5) THEN
          CALL FMST2M(' UNKNOWN ',PRIOR_HS,QX)
          GO TO 120
      ENDIF
      QX%NDIG = QX%NDIG+INT(30/QX%ALOGMT)
      CALL FMEQU_R1(A1,NDSAVE,QX%NDIG,QX)
      CALL FMEQU_R1(B1,NDSAVE,QX%NDIG,QX)
      CALL FMST2M('-0.2',MXY(1),QX)
      IF (FMCOMP(A1,'<',MXY(1),QX) .OR. FMCOMP(B1,'<',MXY(1),QX)) THEN
         IF (2*QX%NDIG <= 4*NDIG_MAX/5) THEN
             QX%NDIG = 2*QX%NDIG
         ELSE
             CALL FMST2M(' UNKNOWN ',PRIOR_HS,QX)
             GO TO 120
         ENDIF
      ENDIF

!             Start here when doing a retry.

  110 NRETRY = NRETRY + 1
      CALL FMEQU(A,A1,NDSAVE,QX%NDIG,QX)
      CALL FMEQU(B,B1,NDSAVE,QX%NDIG,QX)
      ABSIGN = 1
      IF (FMCOMP(A1,'>',B1,QX)) THEN
          CALL FMEQU(B,A1,NDSAVE,QX%NDIG,QX)
          CALL FMEQU(A,B1,NDSAVE,QX%NDIG,QX)
          ABSIGN = -1
      ELSE IF (FMCOMP(A1,'==',B1,QX)) THEN
          CALL FMI2M(0,PRIOR_HS,QX)
          GO TO 120
      ENDIF
      CALL FMEQU(TOL1,TOL2,NDSAVE,QX%NDIG,QX)

      IF (KPRT >= 2) THEN
          WRITE (NW,"(A)") ' '
          WRITE (NW,"(A,I9,A,I5)") ' Begin FM_INTEGRATE.  NDIG = ',QX%NDIG,'   Recursion level = ',  &
                                   R_LEVEL
      ENDIF

      CALL FMI2M(0,S,QX)
      CALL FMI2M(0,PRIOR_HS,QX)
      CALL FMI2M(1,ERR2,QX)
      CALL FMULP(ERR2,EPS,QX)
      CALL FMSUB(B1,A1,MXY(1),QX)
      CALL FMDIVI(MXY(1),100,D,QX)
      D%MP(1) = 1
      CALL FMI2M(0,FMAX,QX)
      CALL FMI2M(0,FMAX2,QX)
      CALL FMEQ(A1,XMAX,QX)
      CALL FMI2M(1,H,QX)
      CALL FMDIVI(H,2**M,LAST_H,QX)
      CALL FMPI(PI,QX)

      CALL FMSUB(B1,A1,MXY(1),QX)
      CALL FMDIVI(MXY(1),2,HF,QX)
      CALL FMADD(A1,HF,AB2,QX)
      DO K = 1, M
         CALL FMDIVI_R1(H,2,QX)
         ISTEP = 2**(M-K)
         IF (K > 1) THEN
             CALL FMMPYI(LAST_H,ISTEP,T,QX)
             CALL FMCHSH(T,C1,S1,QX)
             CALL FMMPY(S1,C1,MXY(1),QX)
             CALL FMMPYI(MXY(1),2,T,QX)
             CALL FMSQR(C1,MXY(1),QX)
             CALL FMSQR(S1,MXY(2),QX)
             CALL FMADD(MXY(1),MXY(2),C2,QX)
             CALL FMEQ(T,S2,QX)
         ENDIF
         DO I = 0, NT, ISTEP
            IF (MOD(I,2*ISTEP) /= 0 .OR. K == 1) THEN

!                The + or -X values are the abscissas for interval (-1,1).
!                XF translates these to the interval (A,B).

                IF (I == 0) THEN
                    CALL FMI2M(0,X,QX)
                    CALL FMDIVI(PI,2,W,QX)
                    CALL FMMPY(HF,X,MXY(1),QX)
                    CALL FMADD(MXY(1),AB2,XF,QX)
                    T = F(XF,N,QX)
                    NUM_F = NUM_F + 1
                    IF (T%MP(2) == QX%MUNKNO) THEN
                        CALL FMF_FAIL(XF,N,NW,QX)
                        CALL FMEQ(T,PRIOR_HS,QX)
                        GO TO 120
                    ENDIF
                    CALL FMABS(T,MXY(1),QX)
                    CALL FMMAX(FMAX2,MXY(1),FMAX2,QX)
                    CALL FMADD(A1,D,MXY(2),QX)
                    CALL FMSUB(B1,D,MXY(3),QX)
                    IF (FMCOMP(MXY(1),'>',FMAX,QX) .AND. FMCOMP(XF,'>',MXY(2),QX) .AND.  &
                        FMCOMP(XF,'<',MXY(3),QX)) THEN
                        CALL FMEQ(MXY(1),FMAX,QX)
                        CALL FMEQ(XF,XMAX,QX)
                    ENDIF
                    CALL FMMPY(W,HF,MXY(1),QX)
                    CALL FMMPY(MXY(1),T,MXY(2),QX)
                    CALL FMADD_R1(S,MXY(2),QX)
                ELSE
                    IF (K == 1) THEN
                        CALL FMMPYI(LAST_H,I,T,QX)
                        CALL FMCHSH(T,CI,SI,QX)
                    ELSE

!                       Use the hyperbolic addition formulas to get the next cosh and sinh
!                       quickly when evaluated at I*LAST_H.

                        IF (I == ISTEP) THEN
                            CI = C1
                            SI = S1
                        ELSE
                            CALL FMMPY(SI,C2,MXY(1),QX)
                            CALL FMMPY(CI,S2,MXY(2),QX)
                            CALL FMADD(MXY(1),MXY(2),T,QX)
                            CALL FMMPY(CI,C2,MXY(1),QX)
                            CALL FMMPY(SI,S2,MXY(2),QX)
                            CALL FMADD(MXY(1),MXY(2),CI,QX)
                            SI = T
                            C1 = CI
                            S1 = SI
                        ENDIF
                    ENDIF
                    ST_IS_SAVED = .FALSE.
                    IF (ST_IS_SAVED) THEN
                        CALL FMSQR(ST,MXY(1),QX)
                        CALL FMADDI(MXY(1),1,QX)
                        CALL FMSQRT(MXY(1),CT,QX)
                    ELSE
                        CALL FMMPY(PI,SI,MXY(1),QX)
                        CALL FMDIVI(MXY(1),2,T,QX)
                        CALL FMCHSH(T,CT,ST,QX)
                    ENDIF
                    CALL FMDIVI(PI,2,MXY(1),QX)
                    CALL FMMPY_R1(MXY(1),CI,QX)
                    CALL FMSQR(CT,MXY(2),QX)
                    CALL FMDIV(MXY(1),MXY(2),W,QX)
                    IF (FMCOMP(W,'<',EPS,QX)) EXIT
                    CALL FMDIV(ST,CT,X,QX)
                    CALL FMMPY(HF,X,MXY(1),QX)
                    CALL FMSUB(AB2,MXY(1),XF,QX)
                    IF (FMCOMP(XF,'>',A1,QX)) THEN
                        T = F(XF,N,QX)
                        NUM_F = NUM_F + 1
                        IF (T%MP(2) == QX%MUNKNO) THEN
                            CALL FMF_FAIL(XF,N,NW,QX)
                            PRIOR_HS = T
                            GO TO 120
                        ENDIF
                        CALL FMABS(T,MXY(1),QX)
                        CALL FMMAX(FMAX2,MXY(1),MXY(2),QX)
                        CALL FMEQ(MXY(2),FMAX2,QX)
                        CALL FMADD(A1,D,MXY(2),QX)
                        CALL FMSUB(B1,D,MXY(3),QX)
                        IF (FMCOMP(MXY(1),'>',FMAX,QX) .AND. FMCOMP(XF,'>',MXY(2),QX) .AND.  &
                            FMCOMP(XF,'<',MXY(3),QX)) THEN

                            CALL FMABS(T,FMAX,QX)
                            XMAX = XF
                        ENDIF
                        CALL FMMPY(W,HF,MXY(1),QX)
                        CALL FMMPY(MXY(1),T,MXY(2),QX)
                        CALL FMADD_R1(S,MXY(2),QX)
                    ENDIF
                    CALL FMMPY(HF,X,MXY(1),QX)
                    CALL FMADD(AB2,MXY(1),XF,QX)
                    IF (FMCOMP(XF,'<',B1,QX)) THEN
                        T = F(XF,N,QX)
                        NUM_F = NUM_F + 1
                        IF (T%MP(2) == QX%MUNKNO) THEN
                            CALL FMF_FAIL(XF,N,NW,QX)
                            PRIOR_HS = T
                            GO TO 120
                        ENDIF
                        CALL FMABS(T,MXY(1),QX)
                        CALL FMMAX(FMAX2,MXY(1),MXY(2),QX)
                        CALL FMEQ(MXY(2),FMAX,QX)
                        CALL FMADD(A1,D,MXY(2),QX)
                        CALL FMSUB(B1,D,MXY(3),QX)
                        IF (FMCOMP(MXY(1),'>',FMAX,QX) .AND. FMCOMP(XF,'>',MXY(2),QX) .AND.  &
                            FMCOMP(XF,'<',MXY(3),QX)) THEN
                            CALL FMABS(T,FMAX,QX)
                            XMAX = XF
                        ENDIF
                        CALL FMMPY(W,HF,MXY(1),QX)
                        CALL FMMPY(MXY(1),T,MXY(2),QX)
                        CALL FMADD_R1(S,MXY(2),QX)
                    ENDIF
                ENDIF
            ENDIF
         ENDDO
         IF (KPRT >= 2) THEN
             WRITE (NW,"(A)") ' '
             WRITE (NW,"(A,I9,A,I9,A)") ' K = ',K,'   ',NUM_F,  &
                                        ' function calls so far.   Integral approximation ='
             CALL FMMPY(H,S,V,QX)
             CALL FMPRINT(V,QX)
         ENDIF
         IF (K > 1) THEN
             ERR1 = ERR2
             IF (S%MP(3) /= 0) THEN
                 CALL FMMPY(H,S,MXY(1),QX)
                 CALL FMSUB(PRIOR_HS,MXY(1),MXY(2),QX)
                 CALL FMDIV(MXY(2),MXY(1),MXY(3),QX)
                 CALL FMABS(MXY(3),ERR2,QX)
             ELSE
                 CALL FMMPY(H,S,MXY(1),QX)
                 CALL FMSUB(PRIOR_HS,MXY(1),MXY(2),QX)
                 CALL FMABS(MXY(3),ERR2,QX)
             ENDIF
             IF (KPRT >= 2) THEN
                 CALL FMFORM('ES15.3',ERR2,ST1,QX)
                 WRITE (NW,"(A,A)") '      relative error of the last two approximations = ',  &
                                    TRIM(ST1)
             ENDIF

!             Check for convergence.

             CALL FMDIVI(TOL2,10,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             IF (K > 3 .AND. FMCOMP(ERR2,'>',MXY(2),QX) .AND. FMCOMP(ERR2,'<',MXY(1),QX)) EXIT

!             If the errors do not decrease fast enough, raise precision and try again.

             IF (K > 3*NRETRY .AND. FMCOMP(ERR1,'>',MXY(2),QX) .AND. FMCOMP(ERR2,'>',MXY(2),QX)) THEN
                 CALL FMLN(ERR1,MXY(1),QX)
                 CALL FMLN(ERR2,MXY(2),QX)
                 CALL FMDIV(MXY(2),MXY(1),MXY(3),QX)
                 CALL FMST2M('1.2',MXY(1),QX)
                 CALL FMST2M('1.0E-6',MXY(2),QX)
                 IF (FMCOMP(MXY(3),'<',MXY(1),QX) .AND. FMCOMP(ERR1,'<',MXY(2),QX)) THEN
                     QX%NDIG = 2*QX%NDIG
                     IF (QX%NDIG > 4*NDIG_MAX/5) THEN
                         NRETRY = 5
                     ENDIF
                     IF (KPRT >= 2) THEN
                         WRITE (NW,"(A,I9,A,I9)") ' FM_INTEGRATE Retry.  So far, NUM_F = ',NUM_F,  &
                                                  '   New NDIG = ',QX%NDIG
                     ENDIF
                     IF (NRETRY <= 3) GO TO 110
                     QX%NDIG = QX%NDIG/2
                 ENDIF
             ENDIF
         ENDIF
         CALL FMMPY(H,S,PRIOR_HS,QX)

!             No convergence in M iterations.
!             Before giving up, look for an interior singularity or tall spike.  If one is found,
!             split (A,B) into two intervals with the interior singularity as an endpoint, and try
!             again as two integrals.

         CALL FMST2M('1.0E-7',MXY(1),QX)
         CALL FMABS(TOL2,MXY(2),QX)
         CALL FMST2M('1.0E-16',MXY(3),QX)
         IF (K == M .OR.  &
                        (K >= 9 .AND. FMCOMP(ERR2,'>',MXY(1),QX) .AND. FMCOMP(MXY(2),'<',MXY(3),QX))) THEN
             IF (KPRT >= 2) THEN
                 WRITE (NW,"(A)") ' '
                 WRITE (NW,"(A,I6,A)") ' No convergence in ',M,  &
                              ' iterations.  Look for an interior singularity.'
                 CALL FMFORM('ES25.6',XMAX,ST1,QX)
                 CALL FMFORM('ES25.6',FMAX,ST2,QX)
                 WRITE (NW,"(I9,A,A,A)") NUM_F,' function calls so far.   XMAX, FMAX =',  &
                                         TRIM(ST1),TRIM(ST2)
             ENDIF
             CALL FMSPIKE(F,N,A1,B1,XMAX,FMAX,NUM_F,SPIKE_FOUND,KPRT,NW,QX)
             CALL FMEQU_R1(A1,QX%NDIG,NDSAVE,QX)
             CALL FMEQU_R1(B1,QX%NDIG,NDSAVE,QX)
             CALL FMEQU_R1(XMAX,QX%NDIG,NDSAVE,QX)
             NDS = QX%NDIG
             QX%NDIG = NDSAVE
             IF (SPIKE_FOUND) THEN
                 CALL FMSUB(A,XMAX,MXY(1),QX)
                 MXY(1)%MP(1) = 1
                 CALL FMSUB(B,XMAX,MXY(2),QX)
                 MXY(2)%MP(1) = 1
                 CALL FMMIN(MXY(1),MXY(2),MXY(3),QX)
                 CALL FMMPYI(D,101,MXY(1),QX)
                 CALL FMDIVI(MXY(1),100,MXY(2),QX)
                 IF (FMCOMP(MXY(3),'<',MXY(2),QX)) THEN
                     QX%NDIG = 2*NDS
                     IF (NRETRY <= 5 .AND. QX%NDIG <= 4*NDIG_MAX/5) GO TO 110
                     QX%NDIG = NDSAVE
                 ENDIF
                 IF (KPRT >= 2) THEN
                     WRITE (NW,"(A)") ' '
                     WRITE (NW,"(A)") ' Split the integral.  First half:  A,B = '
                     CALL FMPRINT(A1,QX)
                     CALL FMPRINT(XMAX,QX)
                 ENDIF
                 CALL FMINTEGRATE2(F,N,A1,XMAX,TOL,C1,KPRT,NW,QX)
                 IF (C1%MP(2) == QX%MUNKNO) THEN
                     PRIOR_HS = C1
                     GO TO 120
                 ENDIF
                 IF (KPRT >= 2) THEN
                     WRITE (NW,"(A)") ' '
                     WRITE (NW,"(A)") ' Split the integral.  Second half:  A,B = '
                     CALL FMPRINT(XMAX,QX)
                     CALL FMPRINT(B1,QX)
                 ENDIF
                 CALL FMINTEGRATE2(F,N,XMAX,B1,TOL,C2,KPRT,NW,QX)
                 CALL FMADD(C1,C2,PRIOR_HS,QX)
                 GO TO 120
             ENDIF
             CALL FMINT_FAIL(N,A,B,TOL,M,ERR2,PRIOR_HS,NW,QX)
             CALL FMST2M(' UNKNOWN ',PRIOR_HS,QX)
             GO TO 120
         ENDIF
      ENDDO

      CALL FMMPY(H,S,MXY(1),QX)
      CALL FMMPYI(MXY(1),ABSIGN,PRIOR_HS,QX)

!             Round the result and return.

  120 CALL FMEQU(PRIOR_HS,RESULT,QX%NDIG,NDSAVE,QX)

      QX%NDIG = NDSAVE
      QX%NCALL = QX%NCALL - 1

      IF (KPRT >= 2 .OR. ( R_LEVEL <= 1 .AND. KPRT == 1 ) ) THEN
          WRITE (NW,"(A)") ' '
          WRITE (NW,"(A,I9,A)") ' Return from FM_INTEGRATE.    Function N = ',N,'.    A, B ='
          CALL FMPRINT(A,QX)
          CALL FMPRINT(B,QX)
          CALL FMFORM('ES20.8',TOL,ST1,QX)
          WRITE (NW,"(A,A)") ' TOL =',TRIM(ST1)
          WRITE (NW,"(A)") ' RESULT ='
          CALL FMPRINT(RESULT,QX)
      ENDIF
      R_LEVEL = R_LEVEL - 1

      END SUBROUTINE FMINTEGRATE2

      SUBROUTINE FMINT_FAIL(N,A,B,TOL,M,ERR,VAL,NW,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE
      INTEGER :: N,M,NW
      TYPE (MULTI) :: A,B,TOL,ERR,VAL
      TYPE(FM_SETTINGS) :: QX

      WRITE (NW,*) ' '
      WRITE (NW,*) ' FM_INTEGRATE failed -- no convergence in ',M,' iterations.'
      WRITE (NW,*) ' UNKNOWN has been returned in RESULT.'
      WRITE (NW,*) ' Possible causes:  (1) highly oscillatory integrand'
      WRITE (NW,*) '                   (2) non-convergent integral'
      WRITE (NW,*) '                   (3) integrable singularity in the interior of interval (A,B)'
      WRITE (NW,*) '                   (4) narrow spike in the interior of interval (A,B)'
      WRITE (NW,*) '                   (5) integral too close to zero'
      WRITE (NW,*) ' A possible remedy for the last 3 is to split the integral into two pieces,'
      WRITE (NW,*) ' making two calls to FM_INTEGRATE and then adding the two results.'
      WRITE (NW,*) ' Put singularities or spikes at the endpoints of the intervals of integration.'
      WRITE (NW,*) ' '
      WRITE (NW,*) ' Function N = ',N,'.    A, B ='
      CALL FMPRINT(A,QX)
      CALL FMPRINT(B,QX)
      WRITE (NW,*) ' TOL ='
      CALL FMPRINT(TOL,QX)
      WRITE (NW,*) ' The last integral approximation ='
      CALL FMPRINT(VAL,QX)
      WRITE (NW,*) ' The estimated relative error in the last integral approximation ='
      CALL FMPRINT(ERR,QX)
      WRITE (NW,*) ' '

      END SUBROUTINE FMINT_FAIL

      SUBROUTINE FMF_FAIL(X,N,NW,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE
      INTEGER :: N,NW
      TYPE (MULTI) :: X
      TYPE(FM_SETTINGS) :: QX

      WRITE (NW,*) ' '
      WRITE (NW,*) ' FM_INTEGRATE failed -- F(X,N) gave UNKNOWN for N = ',N,'   and X ='
      CALL FMPRINT(X,QX)
      WRITE (NW,*) ' Check the limits of integration, function number (N), and' // &
                   ' function definition.'
      WRITE (NW,*) ' Be careful of rounding at an irrational endpoint producing an' // &
                   ' illegal function argument.'
      WRITE (NW,*) ' Example:  Integrate  log( cos( t ) ) from 0 to pi/2'
      WRITE (NW,*) ' At some precisions the computed value of pi/2 rounds up, giving' // &
                   ' a small negative cos(t),'
      WRITE (NW,*) ' which then causes the log function to return UNKNOWN.'
      WRITE (NW,*) ' Possible fixes:'
      WRITE (NW,*) '     Change variables to get an integral from 0 to 1'
      WRITE (NW,*) '     Change the function to log( abs( cos( t ) ) )'
      WRITE (NW,*) '     Compute pi/2 with rounding toward -infinity'
      WRITE (NW,*) ' '

      END SUBROUTINE FMF_FAIL

      SUBROUTINE FMSPIKE(F,N,A,B,XMAX,FMAX,NUM_F,SPIKE_FOUND,KPRT,NW,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  look for an interior singularity or tall spike in F(X,N).
!  After getting no convergence in M iterations in FM_INTEGRATE, FMAX = ABS(F(XMAX,N)) was
!  the largest magnitude found for F on the interval (A+D,B-D), where D = ABS(B-A)/100.

      TYPE (MULTI) :: A,B,XMAX,FMAX
      TYPE (MULTI), EXTERNAL :: F
      INTEGER :: N,NUM_F,KPRT,NW
      LOGICAL :: SPIKE_FOUND
      TYPE (MULTI) :: AB,AVERAGE,D,DX,FPMAX,EPS,F1,F2,H,T,X1,XPMAX,MXY(3)
      INTEGER :: J
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      SPIKE_FOUND = .FALSE.
      IF (KPRT >= 2) THEN
          WRITE (NW,"(A)") ' Enter FMSPIKE'
      ENDIF

      CALL FMSUB(B,A,MXY(1),QX)
      MXY(1)%MP(1) = 1
      CALL FMDIVI(MXY(1),100,DX,QX)
      CALL FMSUB(XMAX,A,MXY(1),QX)
      CALL FMSUB(B,XMAX,MXY(2),QX)
      CALL FMMIN(MXY(1),MXY(2),MXY(3),QX)
      CALL FMDIVI(MXY(3),2,H,QX)

      CALL FMI2M(0,AVERAGE,QX)
      DO J = 1, 99
         CALL FMSUB(B,A,MXY(1),QX)
         CALL FMMPYI_R1(MXY(1),J,QX)
         CALL FMDIVI_R1(MXY(1),100,QX)
         CALL FMADD(A,MXY(1),X1,QX)
         F1 = F(X1,N,QX)
         NUM_F = NUM_F + 1
         IF (F1%MP(2) == QX%MUNKNO) THEN
             XMAX = X1
             FMAX = F1
             FMAX%MP(1) = 1
             SPIKE_FOUND = .TRUE.
             RETURN
         ELSE
             CALL FMABS(F1,MXY(1),QX)
             CALL FMADD_R1(AVERAGE,MXY(1),QX)
         ENDIF
      ENDDO
      CALL FMDIVI_R1(AVERAGE,99,QX)

!             Search for a singularity in F.

      DO
         CALL FMADD(XMAX,H,X1,QX)
         CALL FMADD(A,DX,MXY(1),QX)
         CALL FMSUB(B,DX,MXY(2),QX)
         IF (FMCOMP(X1,'>',MXY(1),QX) .AND. FMCOMP(X1,'<',MXY(2),QX)) THEN
             F1 = F(X1,N,QX)
             NUM_F = NUM_F + 1
             IF (F1%MP(2) == QX%MUNKNO) THEN
                 XMAX = X1
                 CALL FMABS(F1,FMAX,QX)
                 SPIKE_FOUND = .TRUE.
                 RETURN
             ENDIF
             CALL FMABS(F1,MXY(1),QX)
             IF (FMCOMP(MXY(1),'>',FMAX,QX)) THEN
                 XMAX = X1
                 CALL FMABS(F1,FMAX,QX)
                 CALL FMMPYI(H,-14,MXY(1),QX)
                 CALL FMDIVI(MXY(1),10,H,QX)
             ENDIF
         ENDIF
         CALL FMMPYI(H,-10,MXY(1),QX)
         CALL FMDIVI(MXY(1),14,H,QX)
         CALL FMABS(A,MXY(1),QX)
         CALL FMABS(B,MXY(2),QX)
         CALL FMMAX(MXY(1),MXY(2),AB,QX)
         CALL FMULP(AB,EPS,QX)
         CALL FMABS(H,MXY(1),QX)
         CALL FMABS(EPS,MXY(2),QX)
         IF (FMCOMP(MXY(1),'<',MXY(2),QX)) THEN
             CALL FMMPYI(AVERAGE,50,MXY(1),QX)
             IF (FMCOMP(FMAX,'>',MXY(1),QX)) THEN
                 SPIKE_FOUND = .TRUE.
                 RETURN
             ELSE
                 EXIT
             ENDIF
         ENDIF
      ENDDO

!             Search for a singularity in F'.

      CALL FMI2M(-1,FPMAX,QX)
      CALL FMI2M(0,AVERAGE,QX)
      CALL FMABS(A,MXY(1),QX)
      CALL FMABS(B,MXY(2),QX)
      CALL FMMAX(MXY(1),MXY(2),AB,QX)
      CALL FMULP(AB,EPS,QX)
      CALL FMSQRT_R1(EPS,QX)
      DO J = 1, 99
         CALL FMSUB(B,A,MXY(1),QX)
         CALL FMMPYI_R1(MXY(1),J,QX)
         CALL FMDIVI_R1(MXY(1),100,QX)
         CALL FMADD(A,MXY(1),X1,QX)
         CALL FMSUB(X1,EPS,MXY(1),QX)
         IF (FMCOMP(MXY(1),'<=',A,QX)) CYCLE
         F1 = F(MXY(1),N,QX)
         CALL FMADD(X1,EPS,MXY(2),QX)
         IF (FMCOMP(MXY(2),'>=',B,QX)) CYCLE
         F2 = F(MXY(2),N,QX)
         NUM_F = NUM_F + 2
         IF (F1%MP(2) == QX%MUNKNO .OR. F2%MP(2) == QX%MUNKNO) THEN
             IF (F1%MP(2) == QX%MUNKNO) THEN
                 CALL FMSUB(X1,EPS,XMAX,QX)
                 CALL FMABS(F1,FMAX,QX)
             ELSE
                 CALL FMADD(X1,EPS,XMAX,QX)
                 CALL FMABS(F2,FMAX,QX)
             ENDIF
             SPIKE_FOUND = .TRUE.
             RETURN
         ELSE
             CALL FMSUB(F2,F1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),2,QX)
             CALL FMDIV_R1(MXY(1),EPS,QX)
             CALL FMABS(MXY(1),D,QX)
             CALL FMADD_R1(AVERAGE,D,QX)
             IF (FMCOMP(D,'>',FPMAX,QX)) THEN
                 XPMAX = X1
                 FPMAX = D
             ENDIF
         ENDIF
      ENDDO
      CALL FMDIVI_R1(AVERAGE,99,QX)

      CALL FMSUB(XPMAX,A,MXY(1),QX)
      CALL FMSUB(B,XPMAX,MXY(2),QX)
      CALL FMMIN(MXY(1),MXY(2),MXY(3),QX)
      CALL FMDIVI(MXY(3),2,H,QX)
      DO
         CALL FMADD(XPMAX,H,X1,QX)
         CALL FMADD(A,DX,MXY(1),QX)
         CALL FMSUB(B,DX,MXY(2),QX)
         IF (FMCOMP(X1,'>',MXY(1),QX) .AND. FMCOMP(X1,'<',MXY(2),QX)) THEN
             CALL FMSUB(X1,EPS,MXY(1),QX)
             F1 = F(MXY(1),N,QX)
             NUM_F = NUM_F + 1
             IF (F1%MP(2) == QX%MUNKNO) THEN
                 XPMAX = X1
                 CALL FMABS(F1,FPMAX,QX)
                 SPIKE_FOUND = .TRUE.
                 RETURN
             ENDIF
             CALL FMADD(X1,EPS,MXY(1),QX)
             F2 = F(MXY(1),N,QX)
             NUM_F = NUM_F + 1
             IF (F2%MP(2) == QX%MUNKNO) THEN
                 CALL FMADD(X1,EPS,XPMAX,QX)
                 CALL FMABS(F2,FPMAX,QX)
                 SPIKE_FOUND = .TRUE.
                 RETURN
             ENDIF
             CALL FMSUB(F2,F1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),2,QX)
             CALL FMDIV_R1(MXY(1),EPS,QX)
             CALL FMABS(MXY(1),D,QX)
             IF (FMCOMP(D,'>',FPMAX,QX)) THEN
                 XPMAX = X1
                 FPMAX = D
                 CALL FMMPYI(H,-14,MXY(1),QX)
                 CALL FMDIVI(MXY(1),10,H,QX)
             ENDIF
         ENDIF
         CALL FMMPYI(H,-10,MXY(1),QX)
         CALL FMDIVI(MXY(1),14,H,QX)
         CALL FMABS(A,MXY(1),QX)
         CALL FMABS(B,MXY(2),QX)
         CALL FMMAX(MXY(1),MXY(2),AB,QX)
         CALL FMULP(AB,T,QX)
         CALL FMABS(H,MXY(1),QX)
         CALL FMABS(T,MXY(2),QX)
         IF (FMCOMP(MXY(1),'<',MXY(2),QX)) THEN
             CALL FMMPYI(AVERAGE,50,MXY(1),QX)
             IF (FMCOMP(FPMAX,'>',MXY(1),QX)) THEN
                 SPIKE_FOUND = .TRUE.
                 XMAX = XPMAX
                 FMAX = FPMAX
                 RETURN
             ELSE
                 EXIT
             ENDIF
         ENDIF
      ENDDO

      END SUBROUTINE FMSPIKE

      SUBROUTINE FM_INVERSE(A,N,B,DET)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Return B as the inverse of the N x N matrix A, and DET as the determinant of A.

!  A and B are type (fm) (real) multiprecision arrays.

      INTEGER :: N
      TYPE (FM) :: A(N,N), B(N,N), DET
      TYPE (MULTI) :: D1, TOL, MXY(3)
      TYPE (MULTI), ALLOCATABLE :: A1(:,:), A2(:,:), B1(:), R1(:), X1(:)
      INTEGER, ALLOCATABLE :: KSWAP(:)
      INTEGER :: I, J, K, KWARN_SAVE, NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      CALL FMI2M(1,MXY(1),QX)
      CALL FMULP(MXY(1),MXY(2),QX)
      MXY(2)%MP(2) = MXY(2)%MP(2) - 1
      CALL FMST2M('1.0E+10',MXY(3),QX)
      CALL FMDIV(MXY(2),MXY(3),TOL,QX)

      ALLOCATE(A1(N,N),A2(N,N),B1(N),R1(N),X1(N),KSWAP(N),STAT=J)
      IF (J /= 0) THEN
          WRITE (*,"(/' Error in FM_INVERSE.  Unable to allocate arrays with N = ',I8/)") N
          STOP
      ENDIF

!             Raise precision.

      NDSAVE = QX%NDIG
      QX%NDIG = 2*QX%NDIG
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

!             Copy A to A1 with higher precision.

  110 CALL FMEQU_R1(TOL,NDSAVE,QX%NDIG,QX)
      DO I = 1, N
         DO J = 1, N
            CALL FMEQU(A(I,J)%MFM,A1(I,J),NDSAVE,QX%NDIG,QX)
            CALL FMEQ(A1(I,J),A2(I,J),QX)
         ENDDO
      ENDDO

!             Factor A into L*U form.

      CALL FMFACTOR_LU(A1,N,D1,KSWAP,QX)
      IF (D1%MP(3) == 0 .OR. D1%MP(2) == QX%MUNKNO) THEN
          IF (QX%KWARN > 0) THEN
              WRITE (KW,"(/' Error in FM_INVERSE.  The matrix is singular.'/)")
          ENDIF
          IF (QX%KWARN >= 2) STOP
          DO I = 1, N
             DO J = 1, N
                CALL FMST2M('UNKNOWN',B(I,J)%MFM,QX)
             ENDDO
          ENDDO
          GO TO 120
      ENDIF

!             Solve for the inverse matrix one column at a time.

      DO K = 1, N
         DO J = 1, N
            CALL FMI2M(0,B1(J),QX)
         ENDDO
         CALL FMI2M(1,B1(K),QX)
         CALL FMSOLVE_LU(A1,N,B1,X1,KSWAP,QX)

!             Do an iterative refinement.

         CALL FMMATMUL21(N,A2,X1,R1,QX)
         DO I = 1, N
            CALL FMSUB_R1(R1(I),B1(I),QX)
         ENDDO

         CALL FMSOLVE_LU(A1,N,R1,B1,KSWAP,QX)
         DO I = 1, N
            CALL FMSUB_R1(X1(I),B1(I),QX)
         ENDDO

!             Check for accuracy at the user's precision.

         CALL FMNORM2(B1,N,MXY(1),QX)
         IF (FMCOMP(MXY(1),'>',TOL,QX)) THEN
             IF (2*QX%NDIG <= NDIG_MAX) THEN
                 QX%NDIG = 2*QX%NDIG
                 GO TO 110
             ENDIF
         ENDIF

!             Round the results and store column K in the B matrix.

         DO I = 1, N
            CALL FMEQU(X1(I),B(I,K)%MFM,QX%NDIG,NDSAVE,QX)
         ENDDO
      ENDDO
  120 CALL FMEQU(D1,DET%MFM,QX%NDIG,NDSAVE,QX)
      DEALLOCATE(A1,A2,B1,R1,X1,KSWAP)

      QX%NDIG = NDSAVE
      QX%KWARN = KWARN_SAVE
      END SUBROUTINE FM_INVERSE

      SUBROUTINE FM_LIN_SOLVE(A,X,B,N,DET)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Gauss elimination to solve the linear system  A X = B, where:

!  A   is the matrix of the system, containing the  N x N coefficient matrix.

!  B   is the  N x 1  right-hand-side vector.

!  X   is the returned  N x 1  solution vector.

!  DET is returned as the determinant of A.
!      Nonzero DET means a solution was found.
!      DET = 0 is returned if the system is singular.

!  A,X,B,DET are all type (fm) multiprecision variables.


      INTEGER :: N
      TYPE (FM) :: A(N,N), B(N), X(N), DET
      TYPE (MULTI) :: D1, TOL, MXY(3)
      TYPE (MULTI), ALLOCATABLE :: A1(:,:), A2(:,:), B1(:), R1(:), X1(:)
      INTEGER, ALLOCATABLE :: KSWAP(:)
      INTEGER :: I, J, NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      ALLOCATE(A1(N,N),A2(N,N),B1(N),R1(N),X1(N),KSWAP(N),STAT=J)
      IF (J /= 0) THEN
          WRITE (*,"(/' Error in FM_LIN_SOLVE.  Unable to allocate arrays with N = ',I8/)") N
          STOP
      ENDIF

      CALL FMI2M(1,MXY(1),QX)
      CALL FMULP(MXY(1),MXY(2),QX)
      MXY(2)%MP(2) = MXY(2)%MP(2) - 1
      CALL FMST2M('1.0E+10',MXY(3),QX)
      CALL FMDIV(MXY(2),MXY(3),TOL,QX)

      NDSAVE = QX%NDIG
      QX%NDIG = 2*QX%NDIG

!             Copy A and B to A1 and B1 with higher precision.

  110 CALL FMEQU_R1(TOL,NDSAVE,QX%NDIG,QX)
      DO I = 1, N
         DO J = 1, N
            CALL FMEQU(A(I,J)%MFM,A1(I,J),NDSAVE,QX%NDIG,QX)
            CALL FMEQ(A1(I,J),A2(I,J),QX)
         ENDDO
         CALL FMEQU(B(I)%MFM,B1(I),NDSAVE,QX%NDIG,QX)
      ENDDO

!             Solve the system.

      CALL FMFACTOR_LU(A1,N,D1,KSWAP,QX)
      IF (D1%MP(3) == 0 .OR. D1%MP(2) == QX%MUNKNO) THEN
          IF (QX%KWARN > 0) THEN
              WRITE (KW,"(/' Error in FM_LIN_SOLVE.  The matrix is singular.'/)")
          ENDIF
          IF (QX%KWARN >= 2) STOP
          DO J = 1, N
             CALL FMST2M('UNKNOWN',X1(J),QX)
          ENDDO
          GO TO 120
      ENDIF
      CALL FMSOLVE_LU(A1,N,B1,X1,KSWAP,QX)

!             Do an iterative refinement.

      CALL FMMATMUL21(N,A2,X1,R1,QX)
      DO I = 1, N
         CALL FMSUB_R1(R1(I),B1(I),QX)
      ENDDO

      CALL FMSOLVE_LU(A1,N,R1,B1,KSWAP,QX)
      DO I = 1, N
         CALL FMSUB_R1(X1(I),B1(I),QX)
      ENDDO

!             Check for accuracy at the user's precision.

      CALL FMNORM2(B1,N,MXY(1),QX)
      IF (FMCOMP(MXY(1),'>',TOL,QX)) THEN
          IF (2*QX%NDIG <= NDIG_MAX) THEN
              QX%NDIG = 2*QX%NDIG
              GO TO 110
          ENDIF
      ENDIF

!             Round and return X and DET.

  120 DO I = 1, N
         CALL FMEQU(X1(I),X(I)%MFM,QX%NDIG,NDSAVE,QX)
      ENDDO
      CALL FMEQU(D1,DET%MFM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      DEALLOCATE(A1,A2,B1,R1,X1,KSWAP)
      END SUBROUTINE FM_LIN_SOLVE


      SUBROUTINE FMMATMUL21(N,MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N
      TYPE (MULTI) :: MA(N,N),MB(N),MC(N)
      INTEGER :: J,K,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(MULTI) :: MTLVFM,MULVFM,MVLVFM,MTLV01
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      DO J = 1, N
         QX%MXEXP = QX%MXEXP2
         CALL FMI2M(0,MTLVFM,QX)
         DO K = 1, N
            CALL FMEQU(MA(J,K),MULVFM,NDSAVE,QX%NDIG,QX)
            CALL FMEQU(MB(K),MVLVFM,NDSAVE,QX%NDIG,QX)
            CALL FMMPY(MULVFM,MVLVFM,MTLV01,QX)
            CALL FMADD_R1(MTLVFM,MTLV01,QX)
         ENDDO
         QX%MXEXP = MXSAVE
         CALL FMEQU(MTLVFM,MC(J),QX%NDIG,NDSAVE,QX)
      ENDDO
      QX%NDIG = NDSAVE
      END SUBROUTINE FMMATMUL21


      SUBROUTINE FMFACTOR_LU(A,N,DET,KSWAP,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Gauss elimination to factor the NxN matrix A (LU decomposition).

!  The time is proportional to  N**3.

!  Once this factorization has been done, a linear system  A x = b
!  with the same coefficient matrix A and Nx1 vector b can be solved
!  for x using routine FMSOLVE_LU in time proportional to  N**2.

!  DET is returned as the determinant of A.
!      Nonzero DET means there is a unique solution.
!      DET = 0 is returned if the system is singular.

!  KSWAP is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase.

!  After returning, the values in matrix A have been replaced by the multipliers
!  used during elimination.  This is equivalent to factoring the A matrix into
!  a lower triangular matrix L times an upper triangular matrix U.


      INTEGER :: N
      INTEGER :: JCOL, JDIAG, JMAX, JROW, KSWAP(N)
      TYPE (MULTI) :: A(N,N), DET
      TYPE (MULTI) :: AMAX, AMULT, TEMP
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      CALL FMI2M(1,DET,QX)
      KSWAP(1:N) = 1
      IF (N <= 0) THEN
          CALL FMI2M(0,DET,QX)
          RETURN
      ENDIF
      IF (N == 1) THEN
          KSWAP(1) = 1
          CALL FMEQ(A(1,1),DET,QX)
          RETURN
      ENDIF

!             Do the elimination phase.
!             JDIAG is the current diagonal element below which the elimination proceeds.

      DO JDIAG = 1, N-1

!             Pivot to put the element with the largest absolute value on the diagonal.

         CALL FMABS(A(JDIAG,JDIAG),AMAX,QX)
         JMAX = JDIAG
         DO JROW = JDIAG+1, N
            CALL FMABS(A(JROW,JDIAG),TEMP,QX)
            IF (FMCOMP(TEMP,'>',AMAX,QX)) THEN
                CALL FMEQ(TEMP,AMAX,QX)
                JMAX = JROW
            ENDIF
         ENDDO

!             If AMAX is zero here then the system is singular.

         IF (AMAX%MP(3) == 0) THEN
             CALL FMI2M(0,DET,QX)
             RETURN
         ENDIF

!             Swap rows JDIAG and JMAX unless they are the same row.

         KSWAP(JDIAG) = JMAX
         IF (JMAX /= JDIAG) THEN
             CALL FMMPYI_R1(DET,-1,QX)
             DO JCOL = JDIAG, N
                CALL FMEQ(A(JDIAG,JCOL),TEMP,QX)
                CALL FMEQ(A(JMAX,JCOL),A(JDIAG,JCOL),QX)
                CALL FMEQ(TEMP,A(JMAX,JCOL),QX)
             ENDDO
         ENDIF
         CALL FMMPY_R1(DET,A(JDIAG,JDIAG),QX)

!             For JROW = JDIAG+1, ..., N, eliminate A(JROW,JDIAG) by replacing row JROW by
!                 row JROW - A(JROW,JDIAG) * row JDIAG / A(JDIAG,JDIAG)

         DO JROW = JDIAG+1, N
            IF (A(JROW,JDIAG)%MP(3) == 0) CYCLE
            CALL FMDIV(A(JROW,JDIAG),A(JDIAG,JDIAG),AMULT,QX)

!             Save the multiplier for use later by FMSOLVE_LU.

            CALL FMEQ(AMULT,A(JROW,JDIAG),QX)
            DO JCOL = JDIAG+1, N
               CALL FMMPY_SUB(A(JROW,JCOL),AMULT,A(JDIAG,JCOL),QX)
            ENDDO
         ENDDO
      ENDDO
      CALL FMMPY_R1(DET,A(N,N),QX)

      END SUBROUTINE FMFACTOR_LU

      SUBROUTINE FMSOLVE_LU(A,N,B,X,KSWAP,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Solve a linear system  A x = b.
!  A is the NxN coefficient matrix, after having been factored by FMFACTOR_LU.
!  B is the Nx1 right-hand-side vector.
!  X is returned with the solution of the linear system.
!  KSWAP is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase in FMFACTOR_LU.
!  Time for this call is proportional to  N**2.

      INTEGER :: N, KSWAP(N)
      TYPE (MULTI) :: A(N,N), B(N), X(N)
      INTEGER :: J, JDIAG, JMAX
      TYPE (MULTI) :: TEMP
      TYPE(FM_SETTINGS) :: QX

      IF (N <= 0) THEN
          RETURN
      ENDIF
      IF (N == 1) THEN
          CALL FMDIV(B(1),A(1,1),X(1),QX)
          RETURN
      ENDIF
      DO J = 1, N
         CALL FMEQ(B(J),X(J),QX)
      ENDDO

!             Do the elimination phase operations only on X.
!             JDIAG is the current diagonal element below which the elimination proceeds.

      DO JDIAG = 1, N-1

!             Pivot to put the element with the largest absolute value on the diagonal.

         JMAX = KSWAP(JDIAG)

!             Swap rows JDIAG and JMAX unless they are the same row.

         IF (JMAX /= JDIAG) THEN
             CALL FMEQ(X(JDIAG),TEMP,QX)
             CALL FMEQ(X(JMAX),X(JDIAG),QX)
             CALL FMEQ(TEMP,X(JMAX),QX)
         ENDIF

!             For JROW = JDIAG+1, ..., N, eliminate A(JROW,JDIAG) by replacing row JROW by
!                 row JROW - A(JROW,JDIAG) * row JDIAG / A(JDIAG,JDIAG)
!             After factoring, A(JROW,JDIAG) is the original A(JROW,JDIAG) / A(JDIAG,JDIAG).

         DO J = JDIAG+1, N
            CALL FMMPY_SUB(X(J),A(J,JDIAG),X(JDIAG),QX)
         ENDDO
      ENDDO

!             Do the back substitution.

      DO JDIAG = N, 1, -1

!             Divide row JDIAG by the diagonal element.

         CALL FMDIV_R1(X(JDIAG),A(JDIAG,JDIAG),QX)

!             Zero above the diagonal in column JDIAG by replacing row JROW by
!                 row JROW - A(JROW,JDIAG) * row JDIAG
!             For JROW = 1, ..., JDIAG-1.

         IF (JDIAG == 1) EXIT
         DO J = 1, JDIAG-1
            CALL FMMPY_SUB(X(J),A(J,JDIAG),X(JDIAG),QX)
         ENDDO
      ENDDO

      END SUBROUTINE FMSOLVE_LU

      SUBROUTINE FMMPY_SUB(MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE

!  Fused multiply-subtract operation.  Return  MA = MA - MB*MC
!  This is an internal FM routine used by FMFACTOR_LU.  It doesn't always return correctly
!  rounded results, since precision will have already been raised by FM_LIN_SOLVE before
!  calling FMFACTOR_LU.

      TYPE(MULTI) :: MA,MB,MC
      TYPE(MULTI) :: MXY
      INTEGER :: J,K,K1,KPTA,KPTC,MA_VS_MBMC
      DOUBLE PRECISION :: A1,A2,B,B1,B2,C1,C2,DPA,DPBC
      REAL (KIND(1.0D0)) :: MBJ, MGD
      TYPE(FM_SETTINGS) :: QX

!             Special cases.

      IF (MB%MP(3) == 0 .OR. MC%MP(3) == 0 .OR.  &
          MA%MP(2) - 1 > MB%MP(2) + MC%MP(2) + QX%NDIG) THEN
          RETURN
      ENDIF
      IF (MA%MP(3) == 0 .OR.  &
          MB%MP(2) + MC%MP(2) - 1 > MA%MP(2) + QX%NDIG) THEN
          CALL FMMPY(MB,MC,MA,QX)
          IF (MA%MP(2) /= QX%MUNKNO) MA%MP(1) = -MA%MP(1)
          RETURN
      ENDIF

      IF (ABS(MA%MP(2)) > QX%MEXPAB .OR. ABS(MB%MP(2)) > QX%MEXPAB .OR.                  &
          ABS(MC%MP(2)) > QX%MEXPAB .OR. QX%MBASE < 1000 .OR. QX%MBASE**2 > MAXINT .OR.  &
          QX%NDIG > 900 .OR. QX%NDIG > MAXINT/QX%MBASE**2) THEN
          GO TO 110
      ENDIF

!             Determine which of abs(MA) and abs(MB*MC) is larger.

      MA_VS_MBMC = 0
      B = QX%MBASE
      IF (MA%MP(2) <= MB%MP(2) + MC%MP(2) - 2) THEN
          MA_VS_MBMC = -1
          GO TO 120
      ENDIF
      IF (MA%MP(2) >= MB%MP(2) + MC%MP(2) + 1) THEN
          MA_VS_MBMC = 1
          GO TO 120
      ENDIF
      A1 = MA%MP(3)
      A2 = MA%MP(4)
      B1 = MB%MP(3)
      B2 = MB%MP(4)
      C1 = MC%MP(3)
      C2 = MC%MP(4)
      IF (MA%MP(2) == MB%MP(2) + MC%MP(2) - 1) THEN
          DPA = A1 * B + A2 + 1
          DPBC = B1 * C1 * B  +  B1 * C2  +  B2 * C1  +  C2 * B2 / B
          IF (DPA < DPBC) THEN
              MA_VS_MBMC = -1
              GO TO 120
          ENDIF

          DPA = A1 * B + A2
          DPBC = B1 * C1 * B  +  B1 * (C2+1)  +  (B2+1) * C1  +  (C2+1) * (B2+1) / B
          IF (DPA > DPBC) THEN
              MA_VS_MBMC = 1
              GO TO 120
          ENDIF
      ELSE IF (MA%MP(2) == MB%MP(2) + MC%MP(2)) THEN
          DPA = A1 * B + A2 + 1
          DPBC = B1 * C1  +  ( B1 * C2 + B2 * C1 ) / B  +  C2 * B2 / B**2
          IF (DPA < DPBC) THEN
              MA_VS_MBMC = -1
              GO TO 120
          ENDIF

          DPA = A1 * B + A2
          DPBC = B1 * C1  +  ( B1 * (C2+1) + (B2+1) * C1 ) / B  +  (C2+1) * (B2+1) / B**2
          IF (DPA > DPBC) THEN
              MA_VS_MBMC = 1
              GO TO 120
          ENDIF
      ENDIF

!             If it is not easy to determine which term is larger, make separate calls to
!             multiply and subtract.

  110 CALL FMMPY(MB,MC,MXY,QX)
      CALL FMSUB_R1(MA,MXY,QX)
      RETURN

!             Handle the operation using 4 cases, depending on which term is larger and whether
!             MA and MB*MC have opposite signs or not.

  120 IF (MA%MP(1) * MB%MP(1) * MC%MP(1) < 0) THEN
          IF (MA_VS_MBMC == 1) THEN
              MGD = 0
              K1 = 2 + MA%MP(2) - MB%MP(2) - MC%MP(2)
              DO J = K1, QX%NDIG
                 MBJ = MB%MP(3+J-K1)
                 KPTA = 2+J
                 KPTC = 3
                 DO K = J, QX%NDIG
                    MA%MP(KPTA) = MA%MP(KPTA) + MBJ * MC%MP(KPTC)
                    KPTA = KPTA + 1
                    KPTC = KPTC + 1
                 ENDDO
                 IF (KPTC <= 2+QX%NDIG) MGD = MGD + MBJ * MC%MP(KPTC)
              ENDDO
              K1 = MA%MP(2)
              MA%MP(2) = 0
              KPTA = 3+QX%NDIG
              MA%MP(KPTA-1) = MA%MP(KPTA-1) + NINT( MGD / QX%MBASE )
              DO J = QX%NDIG, 1, -1
                 KPTA = KPTA - 1
                 IF (MA%MP(KPTA) >= QX%MBASE) THEN
                     K = MA%MP(KPTA) / QX%MBASE
                     MA%MP(KPTA) = MA%MP(KPTA) - K * QX%MBASE
                     MA%MP(KPTA-1) = MA%MP(KPTA-1) + K
                 ENDIF
              ENDDO
              IF (MA%MP(2) > 0) THEN
                  DO J = QX%NDIG, 1, -1
                     MA%MP(2+J) = MA%MP(2+J-1)
                  ENDDO
                  K1 = K1 + 1
              ENDIF
              MA%MP(2) = K1
              IF (MA%MP(3) >= QX%MBASE) THEN
                  DO J = QX%NDIG, 3, -1
                     MA%MP(2+J) = MA%MP(2+J-1)
                  ENDDO
                  K = MA%MP(3) / QX%MBASE
                  MA%MP(4) = MA%MP(3) - K * QX%MBASE
                  MA%MP(3) = K
                  MA%MP(2) = MA%MP(2) + 1
              ENDIF
          ENDIF

          IF (MA_VS_MBMC == -1) THEN
              MGD = 0
              K1 = MB%MP(2) + MC%MP(2) - 1
              K = MB%MP(2) + MC%MP(2) - MA%MP(2) - 1
              MA%MP(2) = 0
              IF (K > 0) THEN
                  IF (K <= QX%NDIG) MGD = MA%MP(2+QX%NDIG+1-K)
                  DO J = QX%NDIG, K+1, -1
                     MA%MP(2+J) = MA%MP(2+J-K)
                  ENDDO
                  DO J = 1, MIN(K,QX%NDIG)
                     MA%MP(2+J) = 0
                  ENDDO
              ELSE IF (K == -1) THEN
                  DO J = 1, QX%NDIG
                     MA%MP(1+J) = MA%MP(1+J+1)
                  ENDDO
                  MA%MP(2+QX%NDIG) = 0
              ENDIF

              DO J = 1, QX%NDIG
                 MBJ = MB%MP(2+J)
                 KPTA = 2+J
                 KPTC = 3
                 DO K = J, QX%NDIG
                    MA%MP(KPTA) = MA%MP(KPTA) + MBJ * MC%MP(KPTC)
                    KPTA = KPTA + 1
                    KPTC = KPTC + 1
                 ENDDO
                 IF (KPTC <= 2+QX%NDIG) MGD = MGD + MBJ * MC%MP(KPTC)
              ENDDO
              KPTA = 3+QX%NDIG
              MA%MP(KPTA-1) = MA%MP(KPTA-1) + NINT( MGD / QX%MBASE )
              DO J = QX%NDIG, 1, -1
                 KPTA = KPTA - 1
                 IF (MA%MP(KPTA) >= QX%MBASE) THEN
                     K = MA%MP(KPTA) / QX%MBASE
                     MA%MP(KPTA) = MA%MP(KPTA) - K * QX%MBASE
                     MA%MP(KPTA-1) = MA%MP(KPTA-1) + K
                 ENDIF
              ENDDO
              IF (MA%MP(2) > 0) THEN
                  DO J = QX%NDIG, 1, -1
                     MA%MP(2+J) = MA%MP(2+J-1)
                  ENDDO
                  K1 = K1 + 1
              ENDIF
              MA%MP(2) = K1
              IF (MA%MP(3) >= QX%MBASE) THEN
                  DO J = QX%NDIG, 3, -1
                     MA%MP(2+J) = MA%MP(2+J-1)
                  ENDDO
                  K = MA%MP(3) / QX%MBASE
                  MA%MP(4) = MA%MP(3) - K * QX%MBASE
                  MA%MP(3) = K
                  MA%MP(2) = MA%MP(2) + 1
              ENDIF
          ENDIF

      ELSE
          CALL FMEQ(MA,MXY,QX)

          IF (MA_VS_MBMC == 1) THEN
              MGD = 0
              K1 = 2 + MA%MP(2) - MB%MP(2) - MC%MP(2)
              DO J = K1, QX%NDIG
                 MBJ = MB%MP(3+J-K1)
                 KPTA = 2+J
                 KPTC = 3
                 DO K = J, QX%NDIG
                    MA%MP(KPTA) = MA%MP(KPTA) - MBJ * MC%MP(KPTC)
                    KPTA = KPTA + 1
                    KPTC = KPTC + 1
                 ENDDO
                 IF (KPTC <= 2+QX%NDIG) MGD = MGD - MBJ * MC%MP(KPTC)
              ENDDO
              K1 = MA%MP(2)
              MA%MP(2) = 0
              KPTA = 3+QX%NDIG
              MA%MP(KPTA-1) = MA%MP(KPTA-1) + NINT( MGD / QX%MBASE )
              DO J = QX%NDIG, 1, -1
                 KPTA = KPTA - 1
                 IF (MA%MP(KPTA) < 0) THEN
                     K = (-MA%MP(KPTA)-1) / QX%MBASE + 1
                     MA%MP(KPTA) = MA%MP(KPTA) + K * QX%MBASE
                     MA%MP(KPTA-1) = MA%MP(KPTA-1) - K
                 ELSE IF (MA%MP(KPTA) >= QX%MBASE) THEN
                     K = MA%MP(KPTA) / QX%MBASE
                     MA%MP(KPTA) = MA%MP(KPTA) - K * QX%MBASE
                     MA%MP(KPTA-1) = MA%MP(KPTA-1) + K
                 ENDIF
              ENDDO
              IF (MA%MP(2) > 0) THEN
                  DO J = QX%NDIG, 1, -1
                     MA%MP(2+J) = MA%MP(2+J-1)
                  ENDDO
                  K1 = K1 + 1
              ENDIF
              MA%MP(2) = K1
              IF (MA%MP(3) == 0) THEN
                  CALL FMMPY(MB,MC,MA,QX)
                  CALL FMSUB_R2(MXY,MA,QX)
                  RETURN
              ENDIF
          ENDIF

          IF (MA_VS_MBMC == -1) THEN
              MGD = 0
              K1 = MB%MP(2) + MC%MP(2) - 1
              K = MB%MP(2) + MC%MP(2) - MA%MP(2) - 1
              MA%MP(2) = 0
              IF (K > 0) THEN
                  IF (K <= QX%NDIG) MGD = -MA%MP(2+QX%NDIG+1-K)
                  DO J = QX%NDIG, K+1, -1
                     MA%MP(2+J) = -MA%MP(2+J-K)
                  ENDDO
                  DO J = 1, MIN(K,QX%NDIG)
                     MA%MP(2+J) = 0
                  ENDDO
              ELSE IF (K == -1) THEN
                  DO J = 1, QX%NDIG
                     MA%MP(1+J) = -MA%MP(1+J+1)
                  ENDDO
                  MA%MP(2+QX%NDIG) = 0
              ELSE IF (K == 0) THEN
                  DO J = 1, QX%NDIG
                     MA%MP(2+J) = -MA%MP(2+J)
                  ENDDO
              ENDIF

              DO J = 1, QX%NDIG
                 MBJ = MB%MP(2+J)
                 KPTA = 2+J
                 KPTC = 3
                 DO K = J, QX%NDIG
                    MA%MP(KPTA) = MA%MP(KPTA) + MBJ * MC%MP(KPTC)
                    KPTA = KPTA + 1
                    KPTC = KPTC + 1
                 ENDDO
                 IF (KPTC <= 2+QX%NDIG) MGD = MGD + MBJ * MC%MP(KPTC)
              ENDDO
              KPTA = 3+QX%NDIG
              MA%MP(KPTA-1) = MA%MP(KPTA-1) + NINT( MGD / QX%MBASE )
              DO J = QX%NDIG, 1, -1
                 KPTA = KPTA - 1
                 IF (MA%MP(KPTA) >= QX%MBASE) THEN
                     K = MA%MP(KPTA) / QX%MBASE
                     MA%MP(KPTA) = MA%MP(KPTA) - K * QX%MBASE
                     MA%MP(KPTA-1) = MA%MP(KPTA-1) + K
                 ELSE IF (MA%MP(KPTA) < 0) THEN
                     K = (-MA%MP(KPTA)-1) / QX%MBASE + 1
                     MA%MP(KPTA) = MA%MP(KPTA) + K * QX%MBASE
                     MA%MP(KPTA-1) = MA%MP(KPTA-1) - K
                 ENDIF
              ENDDO
              IF (MA%MP(2) > 0) THEN
                  DO J = QX%NDIG, 1, -1
                     MA%MP(2+J) = MA%MP(2+J-1)
                  ENDDO
                  K1 = K1 + 1
              ENDIF
              MA%MP(2) = K1
              MA%MP(1) = -MA%MP(1)
              IF (MA%MP(3) == 0) THEN
                  CALL FMMPY(MB,MC,MA,QX)
                  CALL FMSUB_R2(MXY,MA,QX)
                  RETURN
              ENDIF
          ENDIF

          RETURN
      ENDIF
      END SUBROUTINE FMMPY_SUB

      SUBROUTINE FM_RK14( AX, BX, N_ORDER, F, N_FUNCTION, S, TOL, S1 )

!  Solve the vector first-order differential equation s' = f(x,s).

!  This routine uses 14th order Runge-Kutta with adjustable step size, starting at x = AX
!  with state vector S (initial conditions), and returns state vector S1 as the solution
!  at x = BX.

!  N_ORDER is the order of the differential equation (length of vectors S and S1).

!  N_FUNCTION is the function number (used in F) identifying which function f(x,s)
!             defines the right-hand-side of the differential equation to be solved.

!  TOL is the absolute error tolerance.  Because the coefficients are defined with no more than
!      about 85-digit precision, TOL should not be less than 1.0e-75.

!  The FM precision level should be set to at least 10 digits more than TOL.
!  For example, set precision with CALL FM_SET(30) if FM_RK14 will be called with TOL = 1.0e-20.

!  The error estimate that is used to control step size will fail if f(x,s) is a function of
!  x only, not depending on s.  In this case, the differential equation is really just an
!  integration problem and should be done as a numerical integration.

      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

      INTEGER, PARAMETER :: MAXIMUM_ORDER = 3
      INTEGER :: J, N_ORDER, N_FUNCTION
      TYPE (FM) :: AX, BX, TOL, S(MAXIMUM_ORDER), S1(MAXIMUM_ORDER)
      TYPE (MULTI) :: ERROR_EST, H, TOL2, X, MXY(3), SL(MAXIMUM_ORDER), S1L(MAXIMUM_ORDER)
      TYPE (MULTI) :: A(0:34), B(0:34,0:34), C(0:34)
      EXTERNAL :: F
      LOGICAL :: LAST_STEP
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX


      CALL FMST2M('1.0E-75',MXY(1),QX)
      IF (FMCOMP(TOL%MFM,'<',MXY(1),QX)) THEN
          WRITE (*,*) ' '
          WRITE (*,*) ' Error in input to FM_RK14.  TOL should not be less than 1.0e-75.  It was'
          CALL FMPRINT(TOL%MFM,QX)
          WRITE (*,*) ' '
          STOP
      ENDIF

      DO J = 1, N_ORDER
         CALL FMEQ(S(J)%MFM,SL(J),QX)
         CALL FMEQ(S1(J)%MFM,S1L(J),QX)
      ENDDO
      CALL FMRK14_COEFFS(A, B, C,QX)

!             Pick an initial step size.

      CALL FMABS(TOL%MFM,TOL2,QX)
      CALL FMDIVI_R1(TOL2,1000,QX)
      CALL FMI2M(1,MXY(1),QX)
      CALL FMDIVI(MXY(1),14,MXY(2),QX)
      CALL FMPWR(TOL2,MXY(2),H,QX)

      CALL FMEQ(AX%MFM,X,QX)
      LAST_STEP = .FALSE.

      DO J = 1, 10**7
         CALL FMADD(X,H,MXY(1),QX)
         IF (FMCOMP(MXY(1),'>=',BX%MFM,QX)) THEN
             CALL FMSUB(BX%MFM,X,H,QX)
             LAST_STEP = .TRUE.
         ENDIF
         CALL FMRK14_STEP( N_ORDER, F, N_FUNCTION, A, B, C, X, SL, H, ERROR_EST, S1L ,QX)

!             If the error is too big, try again with halved step size.

         IF (FMCOMP(ERROR_EST,'>',TOL2,QX)) THEN
             CALL FMDIVI_R1(H,2,QX)
             CYCLE
         ENDIF

!             Make the step.

         IF (LAST_STEP) THEN
             EXIT
         ENDIF
         SL(1:N_ORDER) = S1L(1:N_ORDER)
         CALL FMADD_R1(X,H,QX)

!             If the error is much smaller than TOL2, try doubling the step size.
!             Otherwise, if the error is less than TOL2/10, try to fine-tune the
!             step size by increasing H slightly.

         CALL FMDIVI(TOL2,100000,MXY(1),QX)
         CALL FMDIVI(TOL2,10,MXY(2),QX)
         IF (FMCOMP(ERROR_EST,'<',MXY(1),QX)) THEN
             CALL FMMPYI_R1(H,2,QX)
         ELSE IF (FMCOMP(ERROR_EST,'<',MXY(2),QX)) THEN
             CALL FMMPYI(H,105,MXY(3),QX)
             CALL FMDIVI(MXY(3),100,H,QX)
         ENDIF
      ENDDO

      DO J = 1, N_ORDER
         CALL FMEQ(S1L(J),S1(J)%MFM,QX)
      ENDDO

      END SUBROUTINE FM_RK14

      SUBROUTINE FMRK14_STEP( N_ORDER, F, N_FUNCTION, A, B, C, X, S, H, ERROR_EST, S1 ,QX)

!  Do one step of 14th order Runge-Kutta, starting with state vector S(X) and returning
!  state vector S1(X+H) after a step of H.
!  N_ORDER is the order of the differential equation (length of vector S).
!  N_FUNCTION is the function number (used in F) identifying which function is to be solved.

      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

      INTEGER, PARAMETER :: MAXIMUM_ORDER = 3
      INTEGER :: J, K, L, N_STAGES, N_ORDER, N_FUNCTION
      TYPE (MULTI) :: H, ERROR_EST, S(MAXIMUM_ORDER), S1(MAXIMUM_ORDER), X,  &
                      A(0:34), B(0:34,0:34), C(0:34)
      TYPE (MULTI) :: FI_J(MAXIMUM_ORDER,0:34), FI(MAXIMUM_ORDER), YK(0:34,MAXIMUM_ORDER),  &
                      Y(MAXIMUM_ORDER), MXY(3)
      LOGICAL, EXTERNAL :: FMCOMP
      EXTERNAL :: F
      TYPE(FM_SETTINGS) :: QX

      N_STAGES = 35


!             Do the step.

      YK(0,1:N_ORDER) = S(1:N_ORDER)
      DO K = 1, N_STAGES - 1
         DO L = 1, N_ORDER
            CALL FMI2M(0,YK(K,L),QX)
         ENDDO
         DO J = 0, K-1
            IF (J == K-1) THEN
                Y(1:N_ORDER) = YK(J,1:N_ORDER)
                CALL FMMPY(A(J),H,MXY(1),QX)
                CALL FMADD(X,MXY(1),MXY(2),QX)
                CALL F(N_ORDER, N_FUNCTION, MXY(2), Y, FI,QX)
                FI_J(1:N_ORDER,J) = FI(1:N_ORDER)
            ENDIF
            CALL FMI2M(0,MXY(1),QX)
            IF (FMCOMP(B(K,J),'/=',MXY(1),QX)) THEN
                DO L = 1, N_ORDER
                   CALL FMMPY(B(K,J),FI_J(L,J),MXY(1),QX)
                   CALL FMADD_R1(YK(K,L),MXY(1),QX)
                ENDDO
            ENDIF
         ENDDO
         DO L = 1, N_ORDER
            CALL FMMPY(H,YK(K,L),MXY(1),QX)
            CALL FMADD(YK(0,L),MXY(1),YK(K,L),QX)
         ENDDO
      ENDDO

      DO L = 1, N_ORDER
         CALL FMI2M(0,S1(L),QX)
      ENDDO
      DO K = 0, N_STAGES - 1
         IF (K == N_STAGES-1) THEN
             Y(1:N_ORDER) = YK(K,1:N_ORDER)
             CALL FMMPY(A(K),H,MXY(1),QX)
             CALL FMADD(X,MXY(1),MXY(2),QX)
             CALL F(N_ORDER, N_FUNCTION, MXY(2), Y, FI,QX)
             DO L = 1, N_ORDER
                CALL FMMPY(C(K),FI(L),MXY(1),QX)
                CALL FMADD_R1(S1(L),MXY(1),QX)
             ENDDO
         ELSE
             DO L = 1, N_ORDER
                CALL FMMPY(C(K),FI_J(L,K),MXY(1),QX)
                CALL FMADD_R1(S1(L),MXY(1),QX)
             ENDDO
         ENDIF
      ENDDO

      DO L = 1, N_ORDER
         CALL FMMPY(H,S1(L),MXY(1),QX)
         CALL FMADD(S(L),MXY(1),S1(L),QX)
      ENDDO

      CALL FMI2M(0,MXY(1),QX)
      DO L = 1, N_ORDER
         CALL FMSUB(FI_J(L,33),FI_J(L,1),MXY(2),QX)
         CALL FMSQR(MXY(2),MXY(3),QX)
         CALL FMADD_R1(MXY(1),MXY(3),QX)
      ENDDO
      CALL FMSQRT(MXY(1),MXY(2),QX)
      CALL FMMPY(H,MXY(2),MXY(3),QX)
      CALL FMDIVI(MXY(3),1000,ERROR_EST,QX)

      END SUBROUTINE FMRK14_STEP

      SUBROUTINE FMRK14_COEFFS(A, B, C,QX)

!  Define the coefficients used in the RK14 formula (85 digits).

!  These came from:
!  http://www.peterstone.name/Maplepgs/Maple/nmthds/RKcoeff/Runge_Kutta_schemes/RK14/RKcoeff14a_1.pdf

      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

      TYPE (MULTI) :: A(0:34), B(0:34,0:34), C(0:34)
      INTEGER :: J, K
      TYPE(FM_SETTINGS) :: QX

!             Many of the coefficients are zero.  Initialize A, B, and C here, then
!             skip those definitions below.

      DO J = 0, 34
         DO K = 0, 34
            CALL FMI2M(0,B(J,K),QX)
         ENDDO
         CALL FMI2M(0,A(J),QX)
         CALL FMI2M(0,C(J),QX)
      ENDDO

      CALL FMST2M('1',A(1),QX)
      CALL FMDIVI_R1(A(1),9,QX)
      CALL FMST2M('5',A(2),QX)
      CALL FMDIVI_R1(A(2),9,QX)
      CALL FMST2M('5',A(3),QX)
      CALL FMDIVI_R1(A(3),6,QX)
      CALL FMST2M('1',A(4),QX)
      CALL FMDIVI_R1(A(4),3,QX)
      CALL FMST2M('1',A(5),QX)
      CALL FMST2M('.6699869792727729217646837855059985139388452296384603532851421391683474428303956826239',A(6),QX)
      CALL FMST2M('.2970683842138183573895847168082194132233320946989156873791682903324708698499266217383',A(7),QX)
      CALL FMST2M('8',A(8),QX)
      CALL FMDIVI_R1(A(8),11,QX)
      CALL FMST2M('.1401527990421887652761874879669467176298064630825329362873230163439023340348096838456',A(9),QX)
      CALL FMST2M('.7007010397701507371510998548307493379414070492655464089692218490447945746638665522966',A(10),QX)
      CALL FMST2M('4',A(11),QX)
      CALL FMDIVI_R1(A(11),11,QX)
      CALL FMST2M('5',A(12),QX)
      CALL FMDIVI_R1(A(12),19,QX)
      CALL FMST2M('.392172246650270859125196642501208648863714315266128052078483e-1',A(13),QX)
      CALL FMST2M('.8129175029283767629833931592780365061896123726172385507744269795906758195776958783707',A(14),QX)
      CALL FMST2M('1',A(15),QX)
      CALL FMDIVI_R1(A(15),6,QX)
      CALL FMST2M('9',A(16),QX)
      CALL FMDIVI_R1(A(16),10,QX)
      CALL FMST2M('.6412992574519669233127711938966828094810966516150832254029235721305050295351572963693e-1',A(17),QX)
      CALL FMST2M('.2041499092834288489277446343010234050271495052413337516288702042649259099754335560687',A(18),QX)
      CALL FMST2M('.3953503910487605656156713698273243723522272974566594505545766538389345381768585023057',A(19),QX)
      CALL FMST2M('.6046496089512394343843286301726756276477727025433405494454233461610654618231414976943',A(20),QX)
      CALL FMST2M('.7958500907165711510722553656989765949728504947586662483711297957350740900245664439313',A(21),QX)
      CALL FMST2M('.9358700742548033076687228806103317190518903348384916774597076427869494970464842703631',A(22),QX)
      CALL FMST2M('1',A(23),QX)
      CALL FMDIVI_R1(A(23),6,QX)
      CALL FMST2M('.8129175029283767629833931592780365061896123726172385507744269795906758195776958783707',A(24),QX)
      CALL FMST2M('.392172246650270859125196642501208648863714315266128052078483e-1',A(25),QX)
      CALL FMST2M('4',A(26),QX)
      CALL FMDIVI_R1(A(26),11,QX)
      CALL FMST2M('.7007010397701507371510998548307493379414070492655464089692218490447945746638665522966',A(27),QX)
      CALL FMST2M('.1401527990421887652761874879669467176298064630825329362873230163439023340348096838456',A(28),QX)
      CALL FMST2M('.2970683842138183573895847168082194132233320946989156873791682903324708698499266217383',A(29),QX)
      CALL FMST2M('.6699869792727729217646837855059985139388452296384603532851421391683474428303956826239',A(30),QX)
      CALL FMST2M('1',A(31),QX)
      CALL FMDIVI_R1(A(31),3,QX)
      CALL FMST2M('5',A(32),QX)
      CALL FMDIVI_R1(A(32),9,QX)
      CALL FMST2M('1',A(33),QX)
      CALL FMDIVI_R1(A(33),9,QX)
      CALL FMST2M('1',A(34),QX)

      CALL FMST2M('1',C(0),QX)
      CALL FMDIVI_R1(C(0),56,QX)
      CALL FMST2M('3',C(1),QX)
      CALL FMDIVI_R1(C(1),512,QX)
      CALL FMST2M('3',C(2),QX)
      CALL FMDIVI_R1(C(2),256,QX)
      CALL FMST2M('9',C(4),QX)
      CALL FMDIVI_R1(C(4),512,QX)
      CALL FMST2M('3',C(6),QX)
      CALL FMDIVI_R1(C(6),128,QX)
      CALL FMST2M('15',C(7),QX)
      CALL FMDIVI_R1(C(7),512,QX)
      CALL FMST2M('9',C(9),QX)
      CALL FMDIVI_R1(C(9),256,QX)
      CALL FMST2M('21',C(10),QX)
      CALL FMDIVI_R1(C(10),512,QX)
      CALL FMST2M('3',C(11),QX)
      CALL FMDIVI_R1(C(11),64,QX)
      CALL FMST2M('27',C(13),QX)
      CALL FMDIVI_R1(C(13),512,QX)
      CALL FMST2M('15',C(14),QX)
      CALL FMDIVI_R1(C(14),256,QX)
      CALL FMST2M('33',C(15),QX)
      CALL FMDIVI_R1(C(15),512,QX)
      CALL FMST2M('.1053521135717530196914960328878781622276730830805238840416702908213176249782427570033',C(17),QX)
      CALL FMST2M('.1705613462417521823821203385538740858875554878027908047375010369442754416180982144816',C(18),QX)
      CALL FMST2M('.2062293973293519407835264857011048947419142862595424540779715293772640762608018856579',C(19),QX)
      CALL FMST2M('.2062293973293519407835264857011048947419142862595424540779715293772640762608018856579',C(20),QX)
      CALL FMST2M('.1705613462417521823821203385538740858875554878027908047375010369442754416180982144816',C(21),QX)
      CALL FMST2M('.1053521135717530196914960328878781622276730830805238840416702908213176249782427570033',C(22),QX)
      CALL FMST2M('-33',C(23),QX)
      CALL FMDIVI_R1(C(23),512,QX)
      CALL FMST2M('-15',C(24),QX)
      CALL FMDIVI_R1(C(24),256,QX)
      CALL FMST2M('-27',C(25),QX)
      CALL FMDIVI_R1(C(25),512,QX)
      CALL FMST2M('-3',C(26),QX)
      CALL FMDIVI_R1(C(26),64,QX)
      CALL FMST2M('-21',C(27),QX)
      CALL FMDIVI_R1(C(27),512,QX)
      CALL FMST2M('-9',C(28),QX)
      CALL FMDIVI_R1(C(28),256,QX)
      CALL FMST2M('-15',C(29),QX)
      CALL FMDIVI_R1(C(29),512,QX)
      CALL FMST2M('-3',C(30),QX)
      CALL FMDIVI_R1(C(30),128,QX)
      CALL FMST2M('-9',C(31),QX)
      CALL FMDIVI_R1(C(31),512,QX)
      CALL FMST2M('-3',C(32),QX)
      CALL FMDIVI_R1(C(32),256,QX)
      CALL FMST2M('-3',C(33),QX)
      CALL FMDIVI_R1(C(33),512,QX)
      CALL FMST2M('1',C(34),QX)
      CALL FMDIVI_R1(C(34),56,QX)

      CALL FMST2M('1',B(1,0),QX)
      CALL FMDIVI_R1(B(1,0),9,QX)
      CALL FMST2M('-5',B(2,0),QX)
      CALL FMDIVI_R1(B(2,0),6,QX)
      CALL FMST2M('25',B(2,1),QX)
      CALL FMDIVI_R1(B(2,1),18,QX)
      CALL FMST2M('5',B(3,0),QX)
      CALL FMDIVI_R1(B(3,0),24,QX)
      CALL FMST2M('5',B(3,2),QX)
      CALL FMDIVI_R1(B(3,2),8,QX)
      CALL FMST2M('29',B(4,0),QX)
      CALL FMDIVI_R1(B(4,0),150,QX)
      CALL FMST2M('11',B(4,2),QX)
      CALL FMDIVI_R1(B(4,2),50,QX)
      CALL FMST2M('-2',B(4,3),QX)
      CALL FMDIVI_R1(B(4,3),25,QX)
      CALL FMST2M('1',B(5,0),QX)
      CALL FMDIVI_R1(B(5,0),10,QX)
      CALL FMST2M('2',B(5,3),QX)
      CALL FMDIVI_R1(B(5,3),5,QX)
      CALL FMST2M('1',B(5,4),QX)
      CALL FMDIVI_R1(B(5,4),2,QX)
      CALL FMST2M('.1034845616366797766729935465119103444997447982019713166066629728281981965079290745983',B(6,0),QX)
      CALL FMST2M('.1220688873064072225896440828689620771395927148341621347412746563709055937325311521675',B(6,3),QX)
      CALL FMST2M('.4825744903312466224751347801256881128659190238501680496794015023696413273862321544150',B(6,4),QX)
      CALL FMST2M('-.3814096000156069997308862400056202056641130724784114774219699240039767479629669855696e-1',B(6,5),QX)
      CALL FMST2M('.1243805266540944128815164208687993162684914663596714231632892354628068537117612942798',B(7,0),QX)
      CALL FMST2M('.2261202821975843014222386629792029011967523207426331439651447460281196206643404356021',B(7,4),QX)
      CALL FMST2M('.1378858876180808806076958370164778145309694174914933853635428709475288586061552782365e-1',B(7,5),QX)
      CALL FMST2M('-.6722101339966844497493995074143058569500863415253821828561997825320849038679063596730e-1',B(7,6),QX)
      CALL FMST2M('.9369190656596738155308854560830059338663496952177500856556033862893464429241815101000e-1',B(8,0),QX)
      CALL FMST2M('-.6134068434505109872294989956416647356209145071288588710070986068372475355320835997035e-2',B(8,5),QX)
      CALL FMST2M('.2160198256255030637088600976598665734909794332781173201886676706066128640340557614360',B(8,6),QX)
      CALL FMST2M('.4236950635157619373376190739609767532058674695441235326831157041055522397561196508237',B(8,7),QX)
      CALL FMST2M('.8384798124090526646169687913728140859805331392249111310693346670107922625197375034871e-1',B(9,0),QX)
      CALL FMST2M('-.1179493671009738143197550560312957753679619605907361507776128268875265788248790903515e-1',B(9,5),QX)
      CALL FMST2M('-.2472990205688126523394738387431945983259928403533401326974984247503501083158412965835',B(9,6),QX)
      CALL FMST2M('.9780808583677290122593130140812916655037406554767339407565991037499621093437371932341e-1',B(9,7),QX)
      CALL FMST2M('.2175906892434206313600086517678603183441681200247821768799893467069296630467914197921',B(9,8),QX)
      CALL FMST2M('.6152553597694282279545623896143147143334239690648211074539397569215087099333654844097e-1',B(10,0),QX)
      CALL FMST2M('.5922327803245033080429900057980465247383895604442571368349896773084347972825775455007e-2',B(10,5),QX)
      CALL FMST2M('.4703261599638411122172243032058941134553625307461088250108483236601604516650193568134',B(10,6),QX)
      CALL FMST2M('.2996888638486790008539818370961923991368311216717812791841936858888827504094204242461',B(10,7),QX)
      CALL FMST2M('-.2476568775939949146899922763298108258539580692639470955481886317480090967647905771626',B(10,8),QX)
      CALL FMST2M('.1108950297714376828939998518390617145224451736006787182086245987785252503880550245038',B(10,9),QX)
      CALL FMST2M('.4197000733627825798617928647872777872134836565431046112459945389674655429048057710370e-1',B(11,0),QX)
      CALL FMST2M('-.317987696266205093901912847692712407988609169703103952205634e-2',B(11,5),QX)
      CALL FMST2M('.8063977149061920772608217115203795063935431115674197501197468839656405367779525213500',B(11,6),QX)
      CALL FMST2M('.9759831264123889790935228506842888513146720480030545503571875185550549213299958241991e-1',B(11,7),QX)
      CALL FMST2M('.7785755781583989090275124464529272389997634605941819649588520345133050850477185489203',B(11,8),QX)
      CALL FMST2M('.2048904238315994281894992020981056033120292350814206535748293420400885242747823516625',B(11,9),QX)
      CALL FMST2M('-1.562615796274681883070709439505278252114628922364243608928053762634922556160297217820',B(11,10),QX)
      CALL FMST2M('.4377267822337301635744652424953398116882149670716141232569729223172939742940416733395e-1',B(12,0),QX)
      CALL FMST2M('.6243650275201952087943586285809336252816312169030959172012504609444028241438248581173e-2',B(12,8),QX)
      CALL FMST2M('.2000430971095773149944351654696478568290662322182649696087680691197048872391143823078',B(12,9),QX)
      CALL FMST2M('-.8053283678049830368238571620489029119233928873370293148442058928084075077460302544840e-2',B(12,10),QX)
      CALL FMST2M('.2115175280673965219157119035233996013168778251575505730512208770404786743066139905871e-1',B(12,11),QX)
      CALL FMST2M('.2834992503635145630950235919207173122471376548964770977684956012393009143065795513785e-1',B(13,0),QX)
      CALL FMST2M('.2491632048558174075389491488059951494598846535854176800982219995075912885766744587193e-2',B(13,8),QX)
      CALL FMST2M('.2301387878545931496383998463737427687720871226381422342236583655735620108657836993957e-1',B(13,9),QX)
      CALL FMST2M('-.3221559566929770987244760924671208781894636047606204610433085107190031098987004938258e-2',B(13,10),QX)
      CALL FMST2M('.9884425494476646689463354144878852560408199827860146481292993078049373245839618405001e-2',B(13,11),QX)
      CALL FMST2M('-.2130107713288873513843076428759273848866345654295724666320922464722154754985568313136e-1',B(13,12),QX)
      CALL FMST2M('.3435118942902430010494322347351479430833531749807014262686507474123120416010457867571',B(14,0),QX)
      CALL FMST2M('.2104519120236273856090970119990106557888074052256267000419050051487632641518018732685',B(14,8),QX)
      CALL FMST2M('1.034274520572304119364829268288257099386679996983247401666929134177931632176349026735',B(14,9),QX)
      CALL FMST2M('.6003036458644224870512404482066405749390780924061569454673075686417142117164254262878e-2',B(14,10),QX)
      CALL FMST2M('.8559381250996195375780121060024077289150626526164160058172684354881277648341960563008',B(14,11),QX)
      CALL FMST2M('-.9772350050367668108722648523725256330131076568928396776974412446349105799705851506077',B(14,12),QX)
      CALL FMST2M('-.6600269804792946946162250138563276937205739812199748747775581736879654453322759683463',B(14,13),QX)
      CALL FMST2M('-.1435740016721680695382063999350763666577559543783998809757153672896315044426183882232e-1',B(15,0),QX)
      CALL FMST2M('-.3662532700490399702936857968489747917331190817335522078657913621382824038988807796287e-1',B(15,8),QX)
      CALL FMST2M('.3502549756362136819768494069798465243467890824711035742020654749717518291597210559354e-1',B(15,9),QX)
      CALL FMST2M('.3609460163621135089317866587583352398236899298642376718895880083960486970547825683491e-1',B(15,10),QX)
      CALL FMST2M('-.2652199675536811063515959468346019236496270124574642848667252606942739787160130682669e-1',B(15,11),QX)
      CALL FMST2M('.4456990113056981196389115375088399081043363230822267716707629092315111479614958673268e-1',B(15,12),QX)
      CALL FMST2M('.1243430933313582432862255957417864480389734088951067419167759990001419776217292554191',B(15,13),QX)
      CALL FMST2M('.4138296932394806944035124962043359604261929086744760344472227418812310333088685698274e-2',B(15,14),QX)
      CALL FMST2M('.3560324044251202909756091163980891762641062223797488026536968101501275805051289760823',B(16,0),QX)
      CALL FMST2M('-.450192758947562595966821779075956175110645100214763601190349',B(16,8),QX)
      CALL FMST2M('.430527907083710898626656292808782917793030154094709462877146',B(16,9),QX)
      CALL FMST2M('.5119730290110222376685569603940716920771257870306513863906805244405042813755411512463',B(16,10),QX)
      CALL FMST2M('.9083036388864042603901591246381102139974962148199046305445452541870528153933236088278',B(16,11),QX)
      CALL FMST2M('-1.239210933719339317573724691515340288544138892486057261860887966510000755220957594942',B(16,12),QX)
      CALL FMST2M('-.6490486616717614651416723488790625539054028319671910976544025456235491510559878435372',B(16,13),QX)
      CALL FMST2M('.2517089045868192922104805299489705414048878529314474912189256354259853776829630937658',B(16,14),QX)
      CALL FMST2M('.7799064703455863988107567952823344760235405934115501870206452879298798513199886085571',B(16,15),QX)
      CALL FMST2M('.1309356874065130664068812064188349801274704382131924878449566575565302965696195341197e-1',B(17,0),QX)
      CALL FMST2M('-.9320530679851139459084619627671082378586315096846671421247697017556505173897578610165e-4',B(17,12),QX)
      CALL FMST2M('.5053743342622993596400904431385907267709423447161223817027456630856526555478831396014e-1',B(17,13),QX)
      CALL FMST2M('.8044703419444879791095791096101977976413118689308653610493721999399129417586629251430e-6',B(17,14),QX)
      CALL FMST2M('.5917260294941711905287557427777172598443409719243215281782302034071342229921661278343e-3',B(17,15),QX)
      CALL FMST2M('-.4016147221545573370646916849063755877322642479500938046774565993013424294867398455789e-6',B(17,16),QX)
      CALL FMST2M('.2079264844660530125419445440007656521672552061443734079797586969853055549175505457737e-1',B(18,0),QX)
      CALL FMST2M('.5826959188000859151019026978372841089514061030298715701031065480360641416298102920851e-3',B(18,12),QX)
      CALL FMST2M('-.8017007323588159390833421865258527466405584659196335246554992680506588169863285718822e-2',B(18,13),QX)
      CALL FMST2M('.4038476438471369403751708217435605704841172903308955066191655368223862388605213690921e-5',B(18,14),QX)
      CALL FMST2M('.8546099980555061442250561145675356025101146220336224918025961310211940592009621595606e-1',B(18,15),QX)
      CALL FMST2M('-.2044864809358042427067075696910043079044428375526774562331430989116458814609927891477e-5',B(18,16),QX)
      CALL FMST2M('.1053285788244318933997994029790939973542409042351728431465827473723673651882417656762',B(18,17),QX)
      CALL FMST2M('1.401534497957360214154462473557713067184864529175977331289881318884096354294079099114',B(19,0),QX)
      CALL FMST2M('-.2302520009842212616162724103674156212611302982744556219175010157057031125814669239016',B(19,12),QX)
      CALL FMST2M('-7.211068404669129056595822371068742471658564935099615697324849532576890894506619405031',B(19,13),QX)
      CALL FMST2M('.3729015606948363352369953278521323402177595666786623882373057096229137360164435411243e-2',B(19,14),QX)
      CALL FMST2M('-4.714154957271250206787781793922247570113233732218200980194845522013711035054762664884',B(19,15),QX)
      CALL FMST2M('-.1763676575453492420538419950327976735749038866956001340593194717236122233799126229446e-2',B(19,16),QX)
      CALL FMST2M('7.641305480386987655630293108802376511851733678139370059818519661401442202665741111270',B(19,17),QX)
      CALL FMST2M('3.506020436597518349898960829497447109682129498933753736341591881470708008233521976557',B(19,18),QX)
      CALL FMST2M('11.95146506941206867993723858307164016744736108265535168242754934626543968357331742096',B(20,0),QX)
      CALL FMST2M('7.794809321081759687835167002317643882202842795989809549197917776161588225206322580459',B(20,12),QX)
      CALL FMST2M('-56.45013938673257925235609911209042814404681000613405538635967763011214022629172907669',B(20,13),QX)
      CALL FMST2M('.9123763069306449013445304492902766457096074504036737047499704936582270274950128398912e-1',B(20,14),QX)
      CALL FMST2M('-12.73362799254348862019455243091992750381627175299189605168457824373779389828110581300',B(20,15),QX)
      CALL FMST2M('-.3968959219047197123135428109397366747123830704331478729319411886202118671113516172493e-1',B(20,16),QX)
      CALL FMST2M('54.43921418835708869962257651553077918614383784233053341001985423053366890118247056463',B(20,17),QX)
      CALL FMST2M('-3.644116379215692368464069903613506458067214784092667356589342345057374050114156075061',B(20,18),QX)
      CALL FMST2M('-.8045032499105099108990307879585794993156949132107878807481027183961246894903442258757',B(20,19),QX)
      CALL FMST2M('-148.8094265071004884278388682686476255619306120821485965777899951377767737092911763254',B(21,0),QX)
      CALL FMST2M('-91.72952782912564843579356624023216234952287290363542836291360346578688265538801398361',B(21,12),QX)
      CALL FMST2M('707.6561449715983598345757192863357161548211289666495623584804744987957677893379157809',B(21,13),QX)
      CALL FMST2M('-1.10563611857482440905296961311590930801338308942637769555540',B(21,14),QX)
      CALL FMST2M('176.1345918838113725878598980760556604069995167623016865882869129962911416096097878945',B(21,15),QX)
      CALL FMST2M('.4913848242148806622688983451644545574168846314027647925019604519368994965045299923826',B(21,16),QX)
      CALL FMST2M('-684.2780004498149443582375356108950819560771678936002751371799726829821841834791232605',B(21,17),QX)
      CALL FMST2M('27.99106049983982589842243321243804074460025184006686868209688958109916979926727384229',B(21,18),QX)
      CALL FMST2M('13.19397100302823334436709643711532384350641596237449753683872220663989495376087330358',B(21,19),QX)
      CALL FMST2M('1.251287812839804454501149741480560063172688300773964063605141347518040989702499199856',B(21,20),QX)
      CALL FMST2M('-9.673079469481967636441261184332193958399514085718772596349277868068021458303626779169',B(22,0),QX)
      CALL FMST2M('-4.469901508585055314438462277019603604978306814087514357488023393670679083633020106516',B(22,12),QX)
      CALL FMST2M('45.51271286909526819682419504000527511789059078173984816890412459840121969200961260987',B(22,13),QX)
      CALL FMST2M('-.713085086183826912791492024438246129930559805352394367050813e-1',B(22,14),QX)
      CALL FMST2M('11.22736140684127415825906244799393842078268007767944830815221105133516977144595052189',B(22,15),QX)
      CALL FMST2M('.1262443767176227245162379129091388093617868898191054263714925416869147773104813482457',B(22,16),QX)
      CALL FMST2M('-43.54393395494833136058106249072421076238143044676214056937881652359375369765457150165',B(22,17),QX)
      CALL FMST2M('.7871743075430589783987929949965509020645460914432340378113766124779028133099797867162',B(22,18),QX)
      CALL FMST2M('.5322646967446842156693007086038866907853957768215038536520118921656033723449302296244',B(22,19),QX)
      CALL FMST2M('.4224227339963253260102251274713887725750865388096033468497941673910509540050957057177',B(22,20),QX)
      CALL FMST2M('.8591312495030671073084380314998594434411150562941549563989586466154235621165245563192e-1',B(22,21),QX)
      CALL FMST2M('-10.06640324470547024033966069004268914722028247579687652710623604380152449409080444899',B(23,0),QX)
      CALL FMST2M('-.3662532700490399702936857968489747917331190817335522078657913621382824038988807796287e-1',B(23,8),QX)
      CALL FMST2M('.3502549756362136819768494069798465243467890824711035742020654749717518291597210559354e-1',B(23,9),QX)
      CALL FMST2M('.3609460163621135089317866587583352398236899298642376718895880083960486970547825683491e-1',B(23,10),QX)
      CALL FMST2M('-.2652199675536811063515959468346019236496270124574642848667252606942739787160130682669e-1',B(23,11),QX)
      CALL FMST2M('-6.270889721814641435905531494788716038393561229573960230194057818533161624674313994502',B(23,12),QX)
      CALL FMST2M('48.20792374425629890907021030081950639234925931416361161278899187780407980462426656808',B(23,13),QX)
      CALL FMST2M('-.694471689136165640882395180583732834557754169149088630301342e-1',B(23,14),QX)
      CALL FMST2M('12.68106902048502956983413709136098070661084838114121251454273060707937017246509534894',B(23,15),QX)
      CALL FMST2M('.119671168968323754838161435501011294100927813964199613229864e-1',B(23,16),QX)
      CALL FMST2M('-46.72497649924824080033582682426626955932013216597956070401309263301039263373634230581',B(23,17),QX)
      CALL FMST2M('1.330296133266267113147100392982165913990335111912271192356479099067512051132965697343',B(23,18),QX)
      CALL FMST2M('1.007667875033982983534389036199266577711627177936617199056121787956529680139072027935',B(23,19),QX)
      CALL FMST2M('.2095120519336650916641223884754807028927707538644872411247284065032940106679251005781e-1',B(23,20),QX)
      CALL FMST2M('.2101347063312641773177354243313964074244121884437574908902263894855162847478911411134e-1',B(23,21),QX)
      CALL FMST2M('.9521960144171217941751015424545759073763602336583562405468424451848266905185171865534e-2',B(23,22),QX)
      CALL FMST2M('-409.4780816777437087725890974093703576244243416067520683455326035855162023776088699896',B(24,0),QX)
      CALL FMST2M('.2104519120236273856090970119990106557888074052256267000419050051487632641518018732685',B(24,8),QX)
      CALL FMST2M('1.034274520572304119364829268288257099386679996983247401666929134177931632176349026735',B(24,9),QX)
      CALL FMST2M('.6003036458644224870512404482066405749390780924061569454673075686417142117164254262878e-2',B(24,10),QX)
      CALL FMST2M('.8559381250996195375780121060024077289150626526164160058172684354881277648341960563008',B(24,11),QX)
      CALL FMST2M('-250.5169985474478604927776577293161303865840504207820779326393997812026874735614210230',B(24,12),QX)
      CALL FMST2M('1946.424666523884277660537503282647585958298508957614274560610260899186136259514015246',B(24,13),QX)
      CALL FMST2M('-3.045038821023103655061058090868608827869505440976021016842196622317831446605499698935',B(24,14),QX)
      CALL FMST2M('490.6263795282817135212082652991680838415985422740616633051003594128766152337185220086',B(24,15),QX)
      CALL FMST2M('1.566475895312709071154840670135974457395956152459667753199388690841173424714434871921',B(24,16),QX)
      CALL FMST2M('-1881.974289940111733622172673770358706192159066384530557689275696031792911993357071098',B(24,17),QX)
      CALL FMST2M('75.25922247248471752788377136433031498216206189142459440229301807516615379972994062700',B(24,18),QX)
      CALL FMST2M('34.57343569803310676224343447365546896967286447935510158001529990937243976348724448442',B(24,19),QX)
      CALL FMST2M('3.211476794409689614354173618470737551690229667488916278855754113243135684398993410117',B(24,20),QX)
      CALL FMST2M('-.4604080417384143913072014042370588488672450952653828208427296561415079214017074427602',B(24,21),QX)
      CALL FMST2M('-.8707183398418105224318841379579862457242520473889365722145748143125162133630944128398e-1',B(24,22),QX)
      CALL FMST2M('-7.393518141583030675670169521955210639991857732491329543926346613193825315394087286297',B(24,23),QX)
      CALL FMST2M('3.433474758535508789210934962575967811206238910720084588712755786644583035514752699598',B(25,0),QX)
      CALL FMST2M('.2491632048558174075389491488059951494598846535854176800982219995075912885766744587193e-2',B(25,8),QX)
      CALL FMST2M('.2301387878545931496383998463737427687720871226381422342236583655735620108657836993957e-1',B(25,9),QX)
      CALL FMST2M('-.3221559566929770987244760924671208781894636047606204610433085107190031098987004938258e-2',B(25,10),QX)
      CALL FMST2M('.9884425494476646689463354144878852560408199827860146481292993078049373245839618405001e-2',B(25,11),QX)
      CALL FMST2M('2.162527993779225077883078419047573540457592253357327094851479956564246957314476133478',B(25,12),QX)
      CALL FMST2M('-16.26998645464574213280656406601394890069875520402288517985775075363232756881970486667',B(25,13),QX)
      CALL FMST2M('-.1285345021205245528435834174709350105380290375426545062302651848844352856037884822181',B(25,14),QX)
      CALL FMST2M('-8.98915042666504253089307820833379330486511746063552853023189',B(25,15),QX)
      CALL FMST2M('-.3485953632320253333870802018510136501924017672505137649688730136175086767654181319387e-2',B(25,16),QX)
      CALL FMST2M('15.79361941133398075362351873886955741358533870251397376656158275266140525531011608606',B(25,17),QX)
      CALL FMST2M('-.5744033309140950656281654820173358201483836631956754708231458398423255984252281047127',B(25,18),QX)
      CALL FMST2M('-.3456020390213932966927224966081249825352372288276553067081833889419898565070467534157',B(25,19),QX)
      CALL FMST2M('-.6622414902065850917316199913837577811330679927074186873906450413385445874036001388495e-2',B(25,20),QX)
      CALL FMST2M('-.7777881292422041640325464586073643097593472096267591120155367761150273183248441708392e-2',B(25,21),QX)
      CALL FMST2M('-.3560841924022749133388272326974373646752408187917065879526063406092336300493607300593e-2',B(25,22),QX)
      CALL FMST2M('4.792825064499307996497977496298401894572969341393590555417712618624354747222657791607',B(25,23),QX)
      CALL FMST2M('.153725464873068577844576387402512082757034273069877432944621',B(25,24),QX)
      CALL FMST2M('32.30385208719854423269947344400315350913649750477846297617061421719281146058139852238',B(26,0),QX)
      CALL FMST2M('-.317987696266205093901912847692712407988609169703103952205634e-2',B(26,5),QX)
      CALL FMST2M('.8063977149061920772608217115203795063935431115674197501197468839656405367779525213500',B(26,6),QX)
      CALL FMST2M('.9759831264123889790935228506842888513146720480030545503571875185550549213299958241991e-1',B(26,7),QX)
      CALL FMST2M('.7785755781583989090275124464529272389997634605941819649588520345133050850477185489203',B(26,8),QX)
      CALL FMST2M('.2048904238315994281894992020981056033120292350814206535748293420400885242747823516625',B(26,9),QX)
      CALL FMST2M('-1.562615796274681883070709439505278252114628922364243608928053762634922556160297217820',B(26,10),QX)
      CALL FMST2M('16.34298918823105706485042439739271747087533535041545512917666902744198799725970841669',B(26,12),QX)
      CALL FMST2M('-154.5445552935436212307301896314710363993166836696091165017078152549564923882084122674',B(26,13),QX)
      CALL FMST2M('1.569710887033348726920342834176217614662635935824970859658624964687079589089479471888',B(26,14),QX)
      CALL FMST2M('3.276855450872481313214298172699007311655224049747336000450385269517693130775985884604',B(26,15),QX)
      CALL FMST2M('-.5034892451936531763480407271997836265340810956916323972462042700071863164675818955838e-1',B(26,16),QX)
      CALL FMST2M('153.3211518580416650705937678859146940112243631025945564907021486707139114294996134941',B(26,17),QX)
      CALL FMST2M('7.175681863277204958467664848147841435678263080348653386540185145833155908488128910568',B(26,18),QX)
      CALL FMST2M('-2.940367486753004819459176598969309892153205943807775979427615740476908865098135595635',B(26,19),QX)
      CALL FMST2M('-.6658459460768031444707496760226288702819204931972568878708744783028558369468497032253e-1',B(26,20),QX)
      CALL FMST2M('-.4623460549908436612292486685622172611769665140168592842374268449140643068786760618896e-1',B(26,21),QX)
      CALL FMST2M('-.2041987335856794015393882286172697788485797748215817776751235910664984352284968100100e-1',B(26,22),QX)
      CALL FMST2M('-53.35231064387358505159534411659981079740450904957915977996876390672711239156977103431',B(26,23),QX)
      CALL FMST2M('-1.355487147150786549787321867059964040175545016141913251148206738329360142936656282958',B(26,24),QX)
      CALL FMST2M('-1.571962758012327518829017351714592491776872191144425834618663282570958684038698495739',B(26,25),QX)
      CALL FMST2M('-16.64514674863415128720312944039317587645603711308189782044257016154825923946758475845',B(27,0),QX)
      CALL FMST2M('.5922327803245033080429900057980465247383895604442571368349896773084347972825775455007e-2',B(27,5),QX)
      CALL FMST2M('.4703261599638411122172243032058941134553625307461088250108483236601604516650193568134',B(27,6),QX)
      CALL FMST2M('.2996888638486790008539818370961923991368311216717812791841936858888827504094204242461',B(27,7),QX)
      CALL FMST2M('-.2476568775939949146899922763298108258539580692639470955481886317480090967647905771626',B(27,8),QX)
      CALL FMST2M('.1108950297714376828939998518390617145224451736006787182086245987785252503880550245038',B(27,9),QX)
      CALL FMST2M('-.4917190438462291470706666287041940976780819072106730449888664749836403474888832394921',B(27,11),QX)
      CALL FMST2M('-11.47431544272894969683894925643525363508424541308531757856483965863898534849416840511',B(27,12),QX)
      CALL FMST2M('80.25931665762302725417024858864844001527933666235899875893849400507278534931158408231',B(27,13),QX)
      CALL FMST2M('-.3841323039800428476253125267590291037469268413420882192068133107492120348263618466046',B(27,14),QX)
      CALL FMST2M('7.281476674681075834713269509261361157676125818628777243483988994104498714011047355205',B(27,15),QX)
      CALL FMST2M('-.1326993846122483795105717081760352748368273416167518843018178653526280269065470590467',B(27,16),QX)
      CALL FMST2M('-81.07998325257307266746792897522552400060707166336329885641562357237166810196760593013',B(27,17),QX)
      CALL FMST2M('-1.250374928356206395217681856561791199622537474924031863192434629401819729868852090550',B(27,18),QX)
      CALL FMST2M('2.592635949695436810237763795043773249942264473592968880837586883560068434349818491911',B(27,19),QX)
      CALL FMST2M('-.3014402983464045398301639972605268752644315372756414953420797074457552586137488110716',B(27,20),QX)
      CALL FMST2M('.2213844607898323374517064515727737916952468390573184143179573617704323166985265217363',B(27,21),QX)
      CALL FMST2M('.8275772747718929319559898709746931529962764354298098905497078729734353980896315305691e-1',B(27,22),QX)
      CALL FMST2M('18.99606620406115204646724500372432639981751614122371589366718674999943569769696943522',B(27,23),QX)
      CALL FMST2M('.2692319464096396856234680151283341674600519103489128451211866688910668614577677735665',B(27,24),QX)
      CALL FMST2M('1.626748274470665374629893649296289339881250292841836802790201430504847697803528636395',B(27,25),QX)
      CALL FMST2M('.4917190438462291470706666287041940976780819072106730449888664749836403474888832394921',B(27,26),QX)
      CALL FMST2M('.8384798124090526646169687913728140859805331392249111310693346670107922625197375034871e-1',B(28,0),QX)
      CALL FMST2M('-.1179493671009738143197550560312957753679619605907361507776128268875265788248790903515e-1',B(28,5),QX)
      CALL FMST2M('-.2472990205688126523394738387431945983259928403533401326974984247503501083158412965835',B(28,6),QX)
      CALL FMST2M('.9780808583677290122593130140812916655037406554767339407565991037499621093437371932341e-1',B(28,7),QX)
      CALL FMST2M('.2175906892434206313600086517678603183441681200247821768799893467069296630467914197921',B(28,8),QX)
      CALL FMST2M('.1375856067633252248656596321967877466474472229750848659754400903987833771639575727867',B(28,10),QX)
      CALL FMST2M('.4398702297150466850587900923415450260461038902942613590425808839943205635447284745074e-1',B(28,11),QX)
      CALL FMST2M('-.5137008137681933419570044566186303037387573636419640300869712169933398305905931343468',B(28,13),QX)
      CALL FMST2M('.8263556911513155086442113083991534587014231586161685769224194977471882335420141183213',B(28,14),QX)
      CALL FMST2M('25.70181397198118326258738829725199395111365563419600781824702737091645129169813134401',B(28,15),QX)
      CALL FMST2M('-25.70181397198118326258738829725199395111365563419600781824702737091645129169813134401',B(28,23),QX)
      CALL FMST2M('-.8263556911513155086442113083991534587014231586161685769224194977471882335420141183213',B(28,24),QX)
      CALL FMST2M('.5137008137681933419570044566186303037387573636419640300869712169933398305905931343468',B(28,25),QX)
      CALL FMST2M('-.4398702297150466850587900923415450260461038902942613590425808839943205635447284745074e-1',B(28,26),QX)
      CALL FMST2M('-.1375856067633252248656596321967877466474472229750848659754400903987833771639575727867',B(28,27),QX)
      CALL FMST2M('.1243805266540944128815164208687993162684914663596714231632892354628068537117612942798',B(29,0),QX)
      CALL FMST2M('.2261202821975843014222386629792029011967523207426331439651447460281196206643404356021',B(29,4),QX)
      CALL FMST2M('.1378858876180808806076958370164778145309694174914933853635428709475288586061552782365e-1',B(29,5),QX)
      CALL FMST2M('-.6722101339966844497493995074143058569500863415253821828561997825320849038679063596730e-1',B(29,6),QX)
      CALL FMST2M('-.8562389750854283547553497698795017721121215974115638028550665385850612741040225222977',B(29,9),QX)
      CALL FMST2M('-1.963375228668589089282628500280938139881804405182674045535756631526916950083353845169',B(29,10),QX)
      CALL FMST2M('-.2323328227241194012372462573089218472501081992304199949782180319905262045718872259601',B(29,11),QX)
      CALL FMST2M('4.306607190864533494616689368765629477724325620534780926267640393608500758570100495873',B(29,13),QX)
      CALL FMST2M('-2.927229632494654826597879112023904466876873949506336126307786635262992367484998786517',B(29,14),QX)
      CALL FMST2M('-82.31316663978589444544923341054587077357619664281386893950601309356417181948645997040',B(29,15),QX)
      CALL FMST2M('82.31316663978589444544923341054587077357619664281386893950601309356417181948645997040',B(29,23),QX)
      CALL FMST2M('2.927229632494654826597879112023904466876873949506336126307786635262992367484998786517',B(29,24),QX)
      CALL FMST2M('-4.306607190864533494616689368765629477724325620534780926267640393608500758570100495873',B(29,25),QX)
      CALL FMST2M('.2323328227241194012372462573089218472501081992304199949782180319905262045718872259601',B(29,26),QX)
      CALL FMST2M('1.963375228668589089282628500280938139881804405182674045535756631526916950083353845169',B(29,27),QX)
      CALL FMST2M('.8562389750854283547553497698795017721121215974115638028550665385850612741040225222977',B(29,28),QX)
      CALL FMST2M('.1034845616366797766729935465119103444997447982019713166066629728281981965079290745983',B(30,0),QX)
      CALL FMST2M('.1220688873064072225896440828689620771395927148341621347412746563709055937325311521675',B(30,3),QX)
      CALL FMST2M('.4825744903312466224751347801256881128659190238501680496794015023696413273862321544150',B(30,4),QX)
      CALL FMST2M('-.3814096000156069997308862400056202056641130724784114774219699240039767479629669855696e-1',B(30,5),QX)
      CALL FMST2M('-.5504995253108023241383885070205081774114143110000375617128363206424473498745141065969',B(30,7),QX)
      CALL FMST2M('-.7119158115851892278876482620437943875782918824067455704957652139710574799878630163853',B(30,9),QX)
      CALL FMST2M('-.5841296056715513404329887301584808720953353296452275957070524410065417676683463009109',B(30,10),QX)
      CALL FMST2M('2.110463081258649321287173000466227503003750542789369878507182287710881470618943318741',B(30,13),QX)
      CALL FMST2M('-.8374947367395721355257420230010379926952601753351235177405529298334532793741463162845e-1',B(30,14),QX)
      CALL FMST2M('5.100214990723209140752959690433441131075450608628042491597346388445135412965217165555',B(30,15),QX)
      CALL FMST2M('-5.100214990723209140752959690433441131075450608628042491597346388445135412965217165555',B(30,23),QX)
      CALL FMST2M('.8374947367395721355257420230010379926952601753351235177405529298334532793741463162845e-1',B(30,24),QX)
      CALL FMST2M('-2.110463081258649321287173000466227503003750542789369878507182287710881470618943318741',B(30,25),QX)
      CALL FMST2M('.5841296056715513404329887301584808720953353296452275957070524410065417676683463009109',B(30,27),QX)
      CALL FMST2M('.7119158115851892278876482620437943875782918824067455704957652139710574799878630163853',B(30,28),QX)
      CALL FMST2M('.5504995253108023241383885070205081774114143110000375617128363206424473498745141065969',B(30,29),QX)
      CALL FMST2M('29',B(31,0),QX)
      CALL FMDIVI_R1(B(31,0),150,QX)
      CALL FMST2M('11',B(31,2),QX)
      CALL FMDIVI_R1(B(31,2),50,QX)
      CALL FMST2M('-2',B(31,3),QX)
      CALL FMDIVI_R1(B(31,3),25,QX)
      CALL FMST2M('.1099934255807247039194624048650683408451190582958464264636524271459687549994002654752',B(31,6),QX)
      CALL FMST2M('-.2542970480762701613840685069971531221418356269767039208462421656164179875269042982442',B(31,7),QX)
      CALL FMST2M('.8655707771166942543437703438210982818328474012330118593467368132762510892051242759318',B(31,9),QX)
      CALL FMST2M('3.324164491140930831067995527865720183368600929369864071601998386039920635781409865040',B(31,10),QX)
      CALL FMST2M('-12.01022233159779338823523851486618412603019426339968151272769528462035002110216728101',B(31,13),QX)
      CALL FMST2M('.4766014662424932394304427768620618996029637820035802094825720242694315551196576125507',B(31,14),QX)
      CALL FMST2M('-29.02430112210363905258026232136540995962512213324709106915239870601916450708546744075',B(31,15),QX)
      CALL FMST2M('29.02430112210363905258026232136540995962512213324709106915239870601916450708546744075',B(31,23),QX)
      CALL FMST2M('-.4766014662424932394304427768620618996029637820035802094825720242694315551196576125507',B(31,24),QX)
      CALL FMST2M('12.01022233159779338823523851486618412603019426339968151272769528462035002110216728101',B(31,25),QX)
      CALL FMST2M('-3.324164491140930831067995527865720183368600929369864071601998386039920635781409865040',B(31,27),QX)
      CALL FMST2M('-.8655707771166942543437703438210982818328474012330118593467368132762510892051242759318',B(31,28),QX)
      CALL FMST2M('.2542970480762701613840685069971531221418356269767039208462421656164179875269042982442',B(31,29),QX)
      CALL FMST2M('-.1099934255807247039194624048650683408451190582958464264636524271459687549994002654752',B(31,30),QX)
      CALL FMST2M('-5',B(32,0),QX)
      CALL FMDIVI_R1(B(32,0),6,QX)
      CALL FMST2M('25',B(32,1),QX)
      CALL FMDIVI_R1(B(32,1),18,QX)
      CALL FMST2M('-3',B(32,4),QX)
      CALL FMDIVI_R1(B(32,4),4,QX)
      CALL FMST2M('-.4925295437180263044226820491140213202002146815806577847190740839644346370048749342561',B(32,6),QX)
      CALL FMST2M('.4925295437180263044226820491140213202002146815806577847190740839644346370048749342561',B(32,30),QX)
      CALL FMST2M('3',B(32,31),QX)
      CALL FMDIVI_R1(B(32,31),4,QX)
      CALL FMST2M('1',B(33,0),QX)
      CALL FMDIVI_R1(B(33,0),9,QX)
      CALL FMST2M('-2',B(33,2),QX)
      CALL FMDIVI_R1(B(33,2),9,QX)
      CALL FMST2M('2',B(33,32),QX)
      CALL FMDIVI_R1(B(33,32),9,QX)
      CALL FMST2M('.2858351403889715587960888421638364148529275378945964668924322897553490152559792262023',B(34,0),QX)
      CALL FMST2M('7',B(34,1),QX)
      CALL FMDIVI_R1(B(34,1),24,QX)
      CALL FMST2M('7',B(34,2),QX)
      CALL FMDIVI_R1(B(34,2),32,QX)
      CALL FMST2M('21',B(34,4),QX)
      CALL FMDIVI_R1(B(34,4),128,QX)
      CALL FMST2M('.2181943549455566583271882415813521070932888243221879411415164327116967439531911272777',B(34,6),QX)
      CALL FMST2M('.1803928984786977668636352219467754377196200536418492285624347210514163759703679527180',B(34,7),QX)
      CALL FMST2M('.2057138394048450188591207551229295422775700949828089053939914789386228504942804843989',B(34,9),QX)
      CALL FMST2M('.2427157915817702399702829279594465157627459713866705419485763522859549196625913978401',B(34,10),QX)
      CALL FMST2M('.2464657808136293058336092911818914077992281038693057051370210135284213379790417930740',B(34,11),QX)
      CALL FMST2M('-3.449919407908908249798341546016226620603704606149316442883265523381128452524989278943',B(34,12),QX)
      CALL FMST2M('.2288755621600360817607290607384585842942203725527402184592948392511281334278617959957',B(34,13),QX)
      CALL FMST2M('.2832905997021514153215274190567333359784365954938557898314048426595070708424182066065',B(34,14),QX)
      CALL FMST2M('3.210851258377666409601314905442367870055573203322387098512984999880577120008173123283',B(34,15),QX)
      CALL FMST2M('-.2235387773648456999202337562141625079641252300836740320899016275445898395177373582441',B(34,16),QX)
      CALL FMST2M('-.7071211572044190735187272862074872121300912319552061607910521928571247612111795934106',B(34,17),QX)
      CALL FMST2M('3.211233451502870804081747292028565008932600344430223743249588034157195885590228893622',B(34,18),QX)
      CALL FMST2M('1.409543483096697660304144743011231757690459455735489863573218752821178310978199657967',B(34,19),QX)
      CALL FMST2M('-.1513620534437426131216022767425181110909630262036760559494590353712667648924754181285',B(34,20),QX)
      CALL FMST2M('.3723505745270142764547240802146199843971210282021482987373568243836683323798121465643',B(34,21),QX)
      CALL FMST2M('.2529787464063613367221999077621412859157757281294143192610824780367182739421617243696',B(34,22),QX)
      CALL FMST2M('-3.210851258377666409601314905442367870055573203322387098512984999880577120008173123283',B(34,23),QX)
      CALL FMST2M('-.2832905997021514153215274190567333359784365954938557898314048426595070708424182066065',B(34,24),QX)
      CALL FMST2M('-.2288755621600360817607290607384585842942203725527402184592948392511281334278617959957',B(34,25),QX)
      CALL FMST2M('-.2464657808136293058336092911818914077992281038693057051370210135284213379790417930740',B(34,26),QX)
      CALL FMST2M('-.2427157915817702399702829279594465157627459713866705419485763522859549196625913978401',B(34,27),QX)
      CALL FMST2M('-.2057138394048450188591207551229295422775700949828089053939914789386228504942804843989',B(34,28),QX)
      CALL FMST2M('-.1803928984786977668636352219467754377196200536418492285624347210514163759703679527180',B(34,29),QX)
      CALL FMST2M('-.2181943549455566583271882415813521070932888243221879411415164327116967439531911272777',B(34,30),QX)
      CALL FMST2M('-21',B(34,31),QX)
      CALL FMDIVI_R1(B(34,31),128,QX)
      CALL FMST2M('-7',B(34,32),QX)
      CALL FMDIVI_R1(B(34,32),32,QX)
      CALL FMST2M('-7',B(34,33),QX)
      CALL FMDIVI_R1(B(34,33),24,QX)

      END SUBROUTINE FMRK14_COEFFS

      SUBROUTINE FM_SECANT(AX,BX,F,NF,ROOT,KPRT,KU)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  This routine finds a root of F(X,NF) = 0 using AX and BX as starting points.
!  AX and BX do not have to bracket a root in the sense that F(AX,NF) and F(BX,NF) have opposite
!  signs on input.  This means the search can fail if AX and BX are not close enough to any roots
!  or if the function has no real roots or is badly behaved.

!  When a root is found, FM_SECANT tries to return full accuracy even in the case of multiple
!  or closely-spaced roots, by raising precision above the user's level.

!  ROOT  is the value returned as the approximate root of the equation.

!  KPRT  controls printing within the routine:
!        KPRT = 0 for no output
!        KPRT = 1 for the approximation to the root and the function
!                 value to be printed once at the end of the routine.
!        KPRT = 2 for the approximation to the root and the function
!                 value to be printed each iteration.

!  KU    is the unit number for output.

      TYPE (FM)           :: AX, BX, ROOT
      TYPE (MULTI), EXTERNAL :: F
      CHARACTER (80) :: STR
      INTEGER :: J, KU, KPRT, KWARN_SAVE, MAXIT, NDSAVE, NF
      LOGICAL :: USE_F_OVER_FP
      TYPE (MULTI) :: ERR, ERR1, F1, F2, TOL, X1, X1OLD, X2, X3, MXY(4)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (MULTI), EXTERNAL :: FMFPRIME2
      TYPE(FM_SETTINGS) :: QX

      IF (KPRT == 2) THEN
          WRITE (KU,*) ' '
          WRITE (KU,*) ' FM_SECANT.  Begin trace of all iterations.'
      ENDIF

!             Raise precision slightly.

      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL FMEQU(AX%MFM,X1,NDSAVE,QX%NDIG,QX)
      CALL FMEQU(BX%MFM,X2,NDSAVE,QX%NDIG,QX)
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

      MAXIT = 1000
      CALL FMI2M(1,ERR,QX)
      CALL FMULP(ERR,MXY(1),QX)
      CALL FMMPYI(MXY(1),100,TOL,QX)
      USE_F_OVER_FP = .FALSE.
      F1 = F(X1,NF,QX)
      F2 = F(X2,NF,QX)

!             Check for legal function values.

      IF (F1%MP(2) == QX%MUNKNO .OR. F1%MP(2) == QX%MEXPOV) THEN
          DO J = 1, 3
             CALL FMI2M(4-J,MXY(1),QX)
             CALL FMDIVI(MXY(1),4,MXY(2),QX)
             CALL FMMPY(MXY(2),X1,X3,QX)
             CALL FMI2M(4-(4-J),MXY(1),QX)
             CALL FMDIVI(MXY(1),4,MXY(2),QX)
             CALL FMMPY(MXY(2),X2,MXY(1),QX)
             CALL FMADD_R1(X3,MXY(1),QX)
             F1 = F(X3,NF,QX)
             IF (.NOT. (F1%MP(2) == QX%MUNKNO .OR. F1%MP(2) == QX%MEXPOV)) THEN
                 X1 = X3
                 EXIT
             ENDIF
          ENDDO
          IF (F1%MP(2) == QX%MUNKNO .OR. F1%MP(2) == QX%MEXPOV) THEN
              DO J = 1, 3
                 CALL FMI2M(4+J,MXY(1),QX)
                 CALL FMDIVI(MXY(1),4,MXY(2),QX)
                 CALL FMMPY(MXY(2),X1,X3,QX)
                 CALL FMI2M(4-(4+J),MXY(1),QX)
                 CALL FMDIVI(MXY(1),4,MXY(2),QX)
                 CALL FMMPY(MXY(2),X2,MXY(1),QX)
                 CALL FMADD_R1(X3,MXY(1),QX)
                 F1 = F(X3,NF,QX)
                 IF (.NOT. (F1%MP(2) == QX%MUNKNO .OR. F1%MP(2) == QX%MEXPOV)) THEN
                     X1 = X3
                     EXIT
                 ENDIF
                 CALL FMI2M(4+J,MXY(1),QX)
                 CALL FMDIVI(MXY(1),4,MXY(2),QX)
                 CALL FMMPY(MXY(2),X2,X3,QX)
                 CALL FMI2M(4-(4+J),MXY(1),QX)
                 CALL FMDIVI(MXY(1),4,MXY(2),QX)
                 CALL FMMPY(MXY(2),X1,MXY(1),QX)
                 CALL FMADD_R1(X3,MXY(1),QX)
                 F1 = F(X3,NF,QX)
                 IF (.NOT. (F1%MP(2) == QX%MUNKNO .OR. F1%MP(2) == QX%MEXPOV)) THEN
                     X1 = X3
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (F1%MP(2) == QX%MUNKNO .OR. F1%MP(2) == QX%MEXPOV) THEN
          WRITE (KU,*) ' '
          WRITE (KU,*) ' Invalid input for FM_SECANT.  ',  &
                       'Unknown or overflowed function value for AX ='
          CALL FMPRINT(X1,QX)
          WRITE (KU,*) ' '
          J = 0
          CALL FMST2M('UNKNOWN',X2,QX)
          CALL FMST2M('UNKNOWN',ERR,QX)
          GO TO 110
      ENDIF

      IF (F2%MP(2) == QX%MUNKNO .OR. F2%MP(2) == QX%MEXPOV) THEN
          DO J = 1, 3
             CALL FMI2M(4-J,MXY(1),QX)
             CALL FMDIVI(MXY(1),4,MXY(2),QX)
             CALL FMMPY(MXY(2),X1,X3,QX)
             CALL FMI2M(4-(4-J),MXY(1),QX)
             CALL FMDIVI(MXY(1),4,MXY(2),QX)
             CALL FMMPY(MXY(2),X2,MXY(1),QX)
             CALL FMADD_R1(X3,MXY(1),QX)
             F2 = F(X3,NF,QX)
             IF (.NOT. (F2%MP(2) == QX%MUNKNO .OR. F2%MP(2) == QX%MEXPOV)) THEN
                 X2 = X3
                 EXIT
             ENDIF
          ENDDO
          IF (F2%MP(2) == QX%MUNKNO .OR. F2%MP(2) == QX%MEXPOV) THEN
              DO J = 1, 3
                 CALL FMI2M(4+J,MXY(1),QX)
                 CALL FMDIVI(MXY(1),4,MXY(2),QX)
                 CALL FMMPY(MXY(2),X1,X3,QX)
                 CALL FMI2M(4-(4+J),MXY(1),QX)
                 CALL FMDIVI(MXY(1),4,MXY(2),QX)
                 CALL FMMPY(MXY(2),X2,MXY(1),QX)
                 CALL FMADD_R1(X3,MXY(1),QX)
                 F2 = F(X3,NF,QX)
                 IF (.NOT. (F2%MP(2) == QX%MUNKNO .OR. F2%MP(2) == QX%MEXPOV)) THEN
                     X2 = X3
                     EXIT
                 ENDIF
                 CALL FMI2M(4+J,MXY(1),QX)
                 CALL FMDIVI(MXY(1),4,MXY(2),QX)
                 CALL FMMPY(MXY(2),X2,X3,QX)
                 CALL FMI2M(4-(4+J),MXY(1),QX)
                 CALL FMDIVI(MXY(1),4,MXY(2),QX)
                 CALL FMMPY(MXY(2),X1,MXY(1),QX)
                 CALL FMADD_R1(X3,MXY(1),QX)
                 F2 = F(X3,NF,QX)
                 IF (.NOT. (F2%MP(2) == QX%MUNKNO .OR. F2%MP(2) == QX%MEXPOV)) THEN
                     X2 = X3
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (F2%MP(2) == QX%MUNKNO .OR. F2%MP(2) == QX%MEXPOV) THEN
          WRITE (KU,*) ' '
          WRITE (KU,*) ' Invalid input for FM_SECANT.  ',  &
                       'Unknown or overflowed function value for BX ='
          CALL FMPRINT(X2,QX)
          WRITE (KU,*) ' '
          J = 0
          CALL FMST2M('UNKNOWN',X2,QX)
          CALL FMST2M('UNKNOWN',ERR,QX)
          GO TO 110
      ENDIF

      IF (KPRT == 2) THEN
          CALL FMFORM('ES20.10',F1,STR,QX)
          WRITE (KU,"('  J =',I3,3X,'f(AX) = ',A,'    x:')") 0,STR(1:25)
          CALL FMPRINT(X1,QX)
          CALL FMFORM('ES20.10',F2,STR,QX)
          WRITE (KU,"('  J =',I3,3X,'f(BX) = ',A,'    x:')") 0,STR(1:25)
          CALL FMPRINT(X2,QX)
      ENDIF

!             This loop does the iteration.

      DO J = 1, MAXIT

         CALL FMSUB(F2,F1,MXY(1),QX)
         IF (MXY(1)%MP(3) /= 0) THEN
             CALL FMSUB(X2,X1,MXY(2),QX)
             CALL FMMPY(F2,MXY(2),MXY(3),QX)
             CALL FMDIV(MXY(3),MXY(1),MXY(2),QX)
             CALL FMSUB(X2,MXY(2),X3,QX)
         ELSE
             CALL FMI2M(1,MXY(1),QX)
             CALL FMADD(X2,MXY(1),X3,QX)
         ENDIF

!             Multiple roots cause very slow convergence and loss of accuracy.
!             If the slope is very small, try to improve convergence and accuracy by using
!             the (slower) function  f(x)/f'(x)  which has no multiple roots.

         X1OLD = X1
         CALL FMSUB(F2,F1,MXY(1),QX)
         CALL FMSUB(X2,X1,MXY(2),QX)
         CALL FMDIV(MXY(1),MXY(2),MXY(3),QX)
         MXY(3)%MP(1) = 1
         CALL FMST2M('1.0E-2',MXY(1),QX)
         CALL FMABS(F2,MXY(2),QX)
         CALL FMST2M('1.0E-4',MXY(4),QX)
         IF ( (FMCOMP(MXY(3),'<',MXY(1),QX) .AND. FMCOMP(MXY(2),'<',MXY(4),QX)) .OR. USE_F_OVER_FP) THEN
             USE_F_OVER_FP = .TRUE.
             X1 = X2
             X2 = X3
             F1 = F2
             MXY(1) = FMFPRIME2(0,X3,F,NF,QX)
             MXY(2) = FMFPRIME2(1,X3,F,NF,QX)
             CALL FMDIV(MXY(1),MXY(2),F2,QX)
         ELSE
             X1 = X2
             X2 = X3
             F1 = F2
             F2 = F(X3,NF,QX)
         ENDIF

!             If F2 is one of the FM non-numbers, +-underflow, +-overflow, unknown,
!             then replace it by something representable, so that the next x3 will be
!             closer to x1.  Also swap x1 and x2, making the bad x go away first.

         IF (F2%MP(2) == QX%MUNKNO .OR. F2%MP(2) == QX%MEXPOV) THEN
             CALL FMMPYI(F1,-2,F2,QX)
             X3 = X1
             X1 = X2
             X2 = X3
             X3 = F1
             F1 = F2
             F2 = X3
         ENDIF

         IF (KPRT == 2) THEN
             CALL FMFORM('ES20.10',F2,STR,QX)
             WRITE (KU,"('  J =',I3,4X,'f(x) = ' ,A,'    x:')") J,STR(1:25)
             CALL FMPRINT(X2,QX)
         ENDIF

         ERR1 = ERR
         IF (X2%MP(3) /= 0) THEN
             CALL FMSUB(X2,X1,MXY(1),QX)
             CALL FMDIV(MXY(1),X2,ERR,QX)
             ERR%MP(1) = 1
         ELSE
             CALL FMSUB(X2,X1,ERR,QX)
             ERR%MP(1) = 1
         ENDIF

!             If the error is less than the tolerance, double check to make sure the previous
!             error was small along with the current function value.  Some divergent iterations
!             can get err < tol without being close to a root.

         IF (FMCOMP(ERR,'<',TOL,QX) .OR. F2%MP(3) == 0) THEN
             CALL FMSQRT(TOL,MXY(1),QX)
             CALL FMSQRT(MXY(1),MXY(2),QX)
             CALL FMABS(F2,MXY(3),QX)
             CALL FMI2M(1,MXY(1),QX)
             CALL FMULP(MXY(1),MXY(4),QX)
             CALL FMSQRT_R1(MXY(4),QX)
             IF (FMCOMP(ERR1,'>',MXY(2),QX) .AND. FMCOMP(MXY(3),'>',MXY(4),QX)) THEN
                 WRITE (KU,"(/' Possible false convergence in FM_SECANT after',I5,"//  &
                           "' iterations.  ','Last two approximations =')") J
                 CALL FMPRINT(X1,QX)
                 CALL FMPRINT(X2,QX)
                 WRITE (KU,"(/' These agree to the convergence tolerance, but the previous"//  &
                           " iteration was suspiciously far away:')")
                 CALL FMPRINT(X1OLD,QX)
                 WRITE (KU,"(/' and the function value of the last iteration was"//  &
                           " suspiciously far from zero:')")
                 CALL FMPRINT(F2,QX)
             ENDIF
             GO TO 110
         ENDIF

      ENDDO

!             No convergence after maxit iterations.

      WRITE (KU,"(/' No convergence in FM_SECANT after',I5,' iterations.  ',"//  &
                "'Last two approximations =')") MAXIT
      CALL FMPRINT(X1,QX)
      CALL FMPRINT(X2,QX)
      CALL FMST2M('UNKNOWN',X2,QX)
      WRITE (KU,"(/' Unknown has been returned.')")

!             The root was found.

  110 CALL FMEQU(X2,ROOT%MFM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      IF (KPRT >= 1) THEN
          CALL FMULP(X2,ERR1,QX)
          IF (.NOT.( ERR1%MP(2) == QX%MUNKNO .OR. ERR1%MP(2) == QX%MEXPUN )) THEN
              CALL FMDIV(ERR1,X2,MXY(1),QX)
              CALL FMDIVI(MXY(1),2,ERR1,QX)
              ERR1%MP(1) = 1
              IF (FMCOMP(ERR,'<',ERR1,QX)) ERR = ERR1
          ENDIF
          CALL FMFORM('ES16.6',ERR,STR,QX)
          WRITE (KU,*) ' '
          WRITE (KU,"('  FM_SECANT.   Function ',I3,I7,' iterations.'/17X"// &
                    "'Estimated relative error =',A,',    Root:')") NF,J,TRIM(STR)
          CALL FMPRINT(ROOT%MFM,QX)
          WRITE (KU,*) ' '
      ENDIF

      QX%KWARN = KWARN_SAVE
      END SUBROUTINE FM_SECANT


      FUNCTION FMFPRIME2(N,A,F,NF,QX)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  This routine finds the Nth derivative of F(X,NF), evaluated at A.
!  NF is passed on to function F to indicate which function to use in cases where several
!  different functions may be defined there.

!  F must be defined in an interval containing A, so that F can be sampled on both sides of A.

!  N may be zero, so that in cases where F suffers cancellation error at A, an accurate
!  function value is returned.

!  FMFPRIME2 in an internal version of FM_FPRIME that returns a type(multi) result,
!  instead of the type(fm) result of FM_FPRIME.

      TYPE (MULTI) :: A, RETURN_VALUE
      TYPE (MULTI), EXTERNAL :: F
      INTEGER :: J, K, KWARN_SAVE, NDSAVE, N, NF
      TYPE (MULTI) :: D1, D2, F1, F2, H, TOL, TOL2, X1, MXY(4)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

!             Raise precision slightly.

      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL FMEQU(A,X1,NDSAVE,QX%NDIG,QX)
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

      CALL FMI2M(0,D2,QX)
      F1 = F(X1,NF,QX)
      IF (FMCOMP(F1,'/=',D2,QX)) THEN
          CALL FMULP(F1,TOL,QX)
      ELSE
          CALL FMI2M(1,MXY(1),QX)
          CALL FMULP(MXY(1),TOL,QX)
      ENDIF
      CALL FMABS(TOL,MXY(2),QX)
      CALL FMEQ(MXY(2),TOL,QX)

!             Check for a legal function value.

      IF (F1%MP(2) == QX%MUNKNO .OR. F1%MP(2) == QX%MEXPOV .OR.  &
          F1%MP(2) == QX%MEXPUN .OR. N < 0) THEN
          CALL FMST2M(' UNKNOWN ',D2,QX)
          GO TO 110
      ENDIF
      F2 = F1

!             Loop at increasing precision until the difference formula is accurate.

      DO J = 1, 100

         IF (2*QX%NDIG <= 4*NDIG_MAX/5) THEN
             QX%NDIG = 2*QX%NDIG
         ELSE
             GO TO 110
         ENDIF


!             Define the variables used below at the new higher precision.

         CALL FMEQU(D2,D1,QX%NDIG/2,QX%NDIG,QX)
         CALL FMEQU(F2,F1,QX%NDIG/2,QX%NDIG,QX)
         CALL FMEQU(TOL,TOL2,NDSAVE,QX%NDIG,QX)
         CALL FMEQU(A,X1,NDSAVE,QX%NDIG,QX)

!             Special case for N = 0.

         IF (N == 0) THEN
             F2 = F(X1,NF,QX)
             D2 = F2
             CALL FMSUB(F2,F1,MXY(1),QX)
             CALL FMABS(MXY(1),MXY(2),QX)
             IF (FMCOMP(MXY(2),'<',TOL2,QX)) GO TO 110
             CYCLE
         ENDIF
         F2 = F1

!             Special case for N = 1.

         IF (N == 1) THEN
             IF (X1%MP(3) /= 0) THEN
                 CALL FMULP(X1,H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             H%MP(1) = 1
             CALL FMSQRT_R1(H,QX)
             CALL FMADD(X1,H,MXY(1),QX)
             MXY(2) = F(MXY(1),NF,QX)
             CALL FMSUB(X1,H,MXY(1),QX)
             MXY(3) = F(MXY(1),NF,QX)
             CALL FMSUB(MXY(2),MXY(3),D2,QX)
             CALL FMDIVI_R1(D2,2,QX)
             CALL FMDIV_R1(D2,H,QX)
             CALL FMSUB(D2,D1,MXY(1),QX)
             MXY(1)%MP(1) = 1
             IF (FMCOMP(MXY(1),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

!             General case for even N > 1.

         IF (MOD(N,2) == 0) THEN
             IF (X1%MP(3) /= 0) THEN
                 CALL FMULP(X1,H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMI2M(1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),N+2,QX)
             CALL FMABS(H,MXY(2),QX)
             CALL FMPWR(MXY(2),MXY(1),H,QX)
             MXY(4) = F(X1,NF,QX)
             CALL FMI2M(N,MXY(1),QX)
             CALL FMI2M(N/2,MXY(2),QX)
             CALL FMCOMB(MXY(1),MXY(2),MXY(3),QX)
             CALL FMMPY(MXY(3),MXY(4),D2,QX)
             CALL FMMPYI_R1(D2,(-1)**(N/2),QX)
             DO K = 0, N/2-1
                CALL FMMPYI(H,N/2-K,MXY(1),QX)
                CALL FMADD(X1,MXY(1),MXY(2),QX)
                MXY(3) = F(MXY(2),NF,QX)
                CALL FMSUB(X1,MXY(1),MXY(2),QX)
                MXY(4) = F(MXY(2),NF,QX)
                CALL FMADD_R2(MXY(3),MXY(4),QX)
                CALL FMI2M(N,MXY(1),QX)
                CALL FMI2M(K,MXY(2),QX)
                CALL FMCOMB(MXY(1),MXY(2),MXY(3),QX)
                CALL FMMPY_R2(MXY(3),MXY(4),QX)
                CALL FMMPYI_R1(MXY(4),(-1)**K,QX)
                CALL FMADD_R1(D2,MXY(4),QX)
             ENDDO
             CALL FMIPWR(H,N,MXY(1),QX)
             CALL FMDIV_R1(D2,MXY(1),QX)
             CALL FMSUB(D2,D1,MXY(1),QX)
             CALL FMABS(MXY(1),MXY(2),QX)
             IF (FMCOMP(MXY(2),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

!             General case for odd N > 1.

         IF (MOD(N,2) == 1) THEN
             IF (X1%MP(3) /= 0) THEN
                 CALL FMULP(X1,H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMI2M(1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),N+2,QX)
             CALL FMABS(H,MXY(2),QX)
             CALL FMPWR(MXY(2),MXY(1),H,QX)
             CALL FMI2M(0,D2,QX)
             DO K = 0, N/2
                CALL FMMPYI(H,N/2-K+1,MXY(1),QX)
                CALL FMADD(X1,MXY(1),MXY(2),QX)
                MXY(3) = F(MXY(2),NF,QX)
                CALL FMSUB(X1,MXY(1),MXY(2),QX)
                MXY(4) = F(MXY(2),NF,QX)
                CALL FMSUB_R2(MXY(3),MXY(4),QX)
                CALL FMI2M(N-1,MXY(1),QX)
                CALL FMI2M(K,MXY(2),QX)
                CALL FMCOMB(MXY(1),MXY(2),MXY(3),QX)
                CALL FMMPY_R2(MXY(3),MXY(4),QX)
                CALL FMMPYI_R1(MXY(4),(-1)**K,QX)
                CALL FMMPYI_R1(MXY(4),N*(N+1-2*K),QX)
                CALL FMDIVI_R1(MXY(4),(N-K)*(N+1-K),QX)
                CALL FMADD_R1(D2,MXY(4),QX)
             ENDDO
             CALL FMIPWR(H,N,MXY(1),QX)
             CALL FMMPYI_R1(MXY(1),2,QX)
             CALL FMDIV_R1(D2,MXY(1),QX)
             CALL FMSUB(D2,D1,MXY(1),QX)
             CALL FMABS(MXY(1),MXY(2),QX)
             IF (FMCOMP(MXY(2),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

      ENDDO

!             Round and return.

  110 CALL FMEQU(D2,RETURN_VALUE,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%KWARN = KWARN_SAVE
      END FUNCTION FMFPRIME2

      SUBROUTINE ZM_LIN_SOLVE(A,X,B,N,DET)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Gauss elimination to solve the linear system  A X = B, where:

!  A   is the matrix of the system, containing the  N x N coefficient matrix.

!  B   is the  N x 1  right-hand-side vector.

!  X   is the returned  N x 1  solution vector.

!  DET is returned as the determinant of A.
!      Nonzero DET means a solution was found.
!      DET = 0 is returned if the system is singular.

!  A,X,B,DET are all type (zm) complex multiprecision variables.

      INTEGER :: N
      TYPE (ZM) :: A(N,N), B(N), X(N), DET
      TYPE (MULTI) :: TOL, MXY(3)
      TYPE (ZM), ALLOCATABLE :: A1(:,:), A2(:,:), B1(:), R1(:), X1(:)
      TYPE (ZM) :: DET1
      INTEGER, ALLOCATABLE :: KSWAP(:)
      INTEGER :: I, J, NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      ALLOCATE(A1(N,N),A2(N,N),B1(N),R1(N),X1(N),KSWAP(N),STAT=J)
      IF (J /= 0) THEN
          WRITE (*,"(/' Error in ZM_LIN_SOLVE.  Unable to allocate arrays with N = ',I8/)") N
          STOP
      ENDIF

      CALL FMI2M(1,MXY(1),QX)
      CALL FMULP(MXY(1),MXY(2),QX)
      MXY(2)%MP(2) = MXY(2)%MP(2) - 1
      CALL FMST2M('1.0E10',MXY(3),QX)
      CALL FMDIV(MXY(2),MXY(3),TOL,QX)

      NDSAVE = QX%NDIG
      QX%NDIG = 2*QX%NDIG

!             Copy A and B to A1 and B1 with higher precision.

  110 CALL FMEQU_R1(TOL,NDSAVE,QX%NDIG,QX)
      DO I = 1, N
         DO J = 1, N
            CALL ZMEQU(A(I,J)%MZM,A1(I,J)%MZM,NDSAVE,QX%NDIG,QX)
            CALL ZMEQ(A1(I,J)%MZM,A2(I,J)%MZM,QX)
         ENDDO
         CALL ZMEQU(B(I)%MZM,B1(I)%MZM,NDSAVE,QX%NDIG,QX)
      ENDDO

!             Solve the system.

      CALL ZMFACTOR_LU(A1,N,DET1,KSWAP,QX)
      IF ( (DET1%MZM(1)%MP(3) == 0 .AND. DET1%MZM(2)%MP(3) == 0) .OR.  &
           (DET1%MZM(1)%MP(2) == QX%MUNKNO .OR. DET1%MZM(2)%MP(2) == QX%MUNKNO) ) THEN
          IF (QX%KWARN > 0) THEN
              WRITE (KW,"(/' Error in ZM_LIN_SOLVE.  The matrix is singular.'/)")
          ENDIF
          IF (QX%KWARN >= 2) STOP
          DO I = 1, N
             CALL ZMST2M('UNKNOWN + UNKNOWN i',X1(I)%MZM,QX)
          ENDDO
          GO TO 120
      ENDIF
      CALL ZMSOLVE_LU(A1,N,B1,X1,KSWAP,QX)

!             Do an iterative refinement.

      CALL ZMMATMUL21(N,A2,X1,R1,QX)
      DO I = 1, N
         CALL ZMSUB_R1(R1(I)%MZM,B1(I)%MZM,QX)
      ENDDO

      CALL ZMSOLVE_LU(A1,N,R1,B1,KSWAP,QX)
      DO I = 1, N
         CALL ZMSUB_R1(X1(I)%MZM,B1(I)%MZM,QX)
      ENDDO

!             Check for accuracy at the user's precision.

      CALL ZMNORM2(B1,N,MXY(2),QX)
      IF (FMCOMP(MXY(2),'>',TOL,QX)) THEN
          IF (2*QX%NDIG <= 4*NDIG_MAX/5) THEN
              QX%NDIG = 2*QX%NDIG
              GO TO 110
          ENDIF
      ENDIF

!             Round and return X and DET.

  120 DO I = 1, N
         CALL ZMEQU(X1(I)%MZM,X(I)%MZM,QX%NDIG,NDSAVE,QX)
      ENDDO
      CALL ZMEQU(DET1%MZM,DET%MZM,QX%NDIG,NDSAVE,QX)

      QX%NDIG = NDSAVE

      DEALLOCATE(A1,A2,B1,R1,X1,KSWAP)

      END SUBROUTINE ZM_LIN_SOLVE

      SUBROUTINE ZMMATMUL21(N,MA,MB,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N
      TYPE (ZM) :: MA(N,N),MB(N),MC(N)
      INTEGER :: J,K,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      TYPE(ZM) :: MTLVZM,MULVZM,MVLVZM,MTLV01
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(2*QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      DO J = 1, N
         QX%MXEXP = QX%MXEXP2
         CALL ZMI2M(0,MTLVZM%MZM,QX)
         DO K = 1, N
            CALL ZMEQU(MA(J,K)%MZM,MULVZM%MZM,NDSAVE,QX%NDIG,QX)
            CALL ZMEQU(MB(K)%MZM,MVLVZM%MZM,NDSAVE,QX%NDIG,QX)
            CALL ZMMPY(MULVZM%MZM,MVLVZM%MZM,MTLV01%MZM,QX)
            CALL ZMADD_R1(MTLVZM%MZM,MTLV01%MZM,QX)
         ENDDO
         QX%MXEXP = MXSAVE
         CALL ZMEQU(MTLVZM%MZM,MC(J)%MZM,QX%NDIG,NDSAVE,QX)
      ENDDO
      QX%NDIG = NDSAVE
      END SUBROUTINE ZMMATMUL21

      SUBROUTINE ZMNORM2(MA,N,MC,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTEGER :: N
      TYPE (ZM) :: MA(N)
      TYPE(MULTI) :: MC
      INTEGER :: J,MXSAVE,ND2,NDSAVE
      INTENT (IN) :: MA,N
      TYPE(MULTI) :: MULVFM,MVLVFM,M3LVFM
      TYPE(FM_SETTINGS) :: QX
      NDSAVE = QX%NDIG
      J = MAX(QX%NGRD52,2)
      ND2 = MAX(QX%NDIG+J,2)
      QX%NDIG = ND2
      MXSAVE = QX%MXEXP
      QX%MXEXP = QX%MXEXP2
      CALL FMI2M(0,M3LVFM,QX)
      DO J = 1, N
         CALL FMEQU(MA(J)%MZM(1),MULVFM,NDSAVE,QX%NDIG,QX)
         CALL FMSQR(MULVFM,MVLVFM,QX)
         CALL FMADD_R1(M3LVFM,MVLVFM,QX)
         CALL FMEQU(MA(J)%MZM(2),MULVFM,NDSAVE,QX%NDIG,QX)
         CALL FMSQR(MULVFM,MVLVFM,QX)
         CALL FMADD_R1(M3LVFM,MVLVFM,QX)
      ENDDO
      CALL FMSQRT_R1(M3LVFM,QX)
      QX%MXEXP = MXSAVE
      CALL FMEQU(M3LVFM,MC,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      END SUBROUTINE ZMNORM2

      SUBROUTINE ZMFACTOR_LU(A,N,DET,KSWAP,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Gauss elimination to factor the NxN matrix A (LU decomposition).

!  The time is proportional to  N**3.

!  Once this factorization has been done, a linear system  A x = b
!  with the same coefficient matrix A and Nx1 vector b can be solved
!  for x using routine ZMSOLVE_LU in time proportional to  N**2.

!  DET is returned as the determinant of A.
!      Nonzero DET means there is a unique solution.
!      DET = 0 is returned if the system is singular.

!  KSWAP is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase.

!  After returning, the values in matrix A have been replaced by the multipliers
!  used during elimination.  This is equivalent to factoring the A matrix into
!  a lower triangular matrix L times an upper triangular matrix U.

      INTEGER :: N
      INTEGER :: JCOL, JDIAG, JMAX, JROW, KSWAP(N)
      TYPE (ZM) :: A(N,N), DET
      TYPE (ZM) :: AMULT, TEMP
      TYPE (FM) :: AMAX, T
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      CALL ZMI2M(1,DET%MZM,QX)
      KSWAP(1:N) = 1
      IF (N <= 0) THEN
          CALL ZMI2M(0,DET%MZM,QX)
          RETURN
      ENDIF
      IF (N == 1) THEN
          KSWAP(1) = 1
          CALL ZMEQ(A(1,1)%MZM,DET%MZM,QX)
          RETURN
      ENDIF

!             Do the elimination phase.
!             JDIAG is the current diagonal element below which the elimination proceeds.

      DO JDIAG = 1, N-1

!             Pivot to put the element with the largest absolute value on the diagonal.

         CALL ZMABS(A(JDIAG,JDIAG)%MZM,AMAX%MFM,QX)
         JMAX = JDIAG
         DO JROW = JDIAG+1, N
            CALL ZMABS(A(JROW,JDIAG)%MZM,T%MFM,QX)
            IF (FMCOMP(T%MFM,'>',AMAX%MFM,QX)) THEN
                CALL FMEQ(T%MFM,AMAX%MFM,QX)
                JMAX = JROW
            ENDIF
         ENDDO

!             If AMAX is zero here then the system is singular.

         CALL FMI2M(0,T%MFM,QX)
         IF (FMCOMP(AMAX%MFM,'==',T%MFM,QX)) THEN
             CALL ZMI2M(0,DET%MZM,QX)
             RETURN
         ENDIF

!             Swap rows JDIAG and JMAX unless they are the same row.

         KSWAP(JDIAG) = JMAX
         IF (JMAX /= JDIAG) THEN
             CALL ZMMPYI_R1(DET%MZM,-1,QX)
             DO JCOL = JDIAG, N
                CALL ZMEQ(A(JDIAG,JCOL)%MZM,TEMP%MZM,QX)
                CALL ZMEQ(A(JMAX,JCOL)%MZM,A(JDIAG,JCOL)%MZM,QX)
                CALL ZMEQ(TEMP%MZM,A(JMAX,JCOL)%MZM,QX)
             ENDDO
         ENDIF
         CALL ZMMPY_R1(DET%MZM,A(JDIAG,JDIAG)%MZM,QX)

!             For JROW = JDIAG+1, ..., N, eliminate A(JROW,JDIAG) by replacing row JROW by
!                 row JROW - A(JROW,JDIAG) * row JDIAG / A(JDIAG,JDIAG)

         CALL FMI2M(0,T%MFM,QX)
         DO JROW = JDIAG+1, N
            IF (FMCOMP(A(JROW,JDIAG)%MZM(1),'==',T%MFM,QX) .AND.  &
                FMCOMP(A(JROW,JDIAG)%MZM(2),'==',T%MFM,QX)) CYCLE
            CALL ZMDIV(A(JROW,JDIAG)%MZM,A(JDIAG,JDIAG)%MZM,AMULT%MZM,QX)

!             Save the multiplier for use later by ZMSOLVE_LU.

            CALL ZMEQ(AMULT%MZM,A(JROW,JDIAG)%MZM,QX)
            DO JCOL = JDIAG+1, N
               CALL ZMMPY(AMULT%MZM,A(JDIAG,JCOL)%MZM,TEMP%MZM,QX)
               CALL ZMSUB_R1(A(JROW,JCOL)%MZM,TEMP%MZM,QX)
            ENDDO
         ENDDO
      ENDDO
      CALL ZMMPY_R1(DET%MZM,A(N,N)%MZM,QX)

      END SUBROUTINE ZMFACTOR_LU

      SUBROUTINE ZMSOLVE_LU(A,N,B,X,KSWAP,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Solve a linear system  A x = b.
!  A is the NxN coefficient matrix, after having been factored by ZMFACTOR_LU.
!  B is the Nx1 right-hand-side vector.
!  X is returned with the solution of the linear system.
!  KSWAP is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase in ZMFACTOR_LU.
!  Time for this call is proportional to  N**2.

      INTEGER :: N, KSWAP(N)
      TYPE (ZM) :: A(N,N), B(N), X(N)
      INTEGER :: J, JDIAG, JMAX
      TYPE (ZM) :: TEMP
      TYPE(FM_SETTINGS) :: QX

      IF (N <= 0) THEN
          RETURN
      ENDIF
      IF (N == 1) THEN
          CALL ZMDIV(B(1)%MZM,A(1,1)%MZM,X(1)%MZM,QX)
          RETURN
      ENDIF
      DO J = 1, N
         CALL ZMEQ(B(J)%MZM,X(J)%MZM,QX)
      ENDDO

!             Do the elimination phase operations only on X.
!             JDIAG is the current diagonal element below which the elimination proceeds.

      DO JDIAG = 1, N-1

!             Pivot to put the element with the largest absolute value on the diagonal.

         JMAX = KSWAP(JDIAG)

!             Swap rows JDIAG and JMAX unless they are the same row.

         IF (JMAX /= JDIAG) THEN
             CALL ZMEQ(X(JDIAG)%MZM,TEMP%MZM,QX)
             CALL ZMEQ(X(JMAX)%MZM,X(JDIAG)%MZM,QX)
             CALL ZMEQ(TEMP%MZM,X(JMAX)%MZM,QX)
         ENDIF

!             For JROW = JDIAG+1, ..., N, eliminate A(JROW,JDIAG) by replacing row JROW by
!                 row JROW - A(JROW,JDIAG) * row JDIAG / A(JDIAG,JDIAG)
!             After factoring, A(JROW,JDIAG) is the original A(JROW,JDIAG) / A(JDIAG,JDIAG).

         DO J = JDIAG+1, N
            CALL ZMMPY(A(J,JDIAG)%MZM,X(JDIAG)%MZM,TEMP%MZM,QX)
            CALL ZMSUB_R1(X(J)%MZM,TEMP%MZM,QX)
         ENDDO
      ENDDO

!             Do the back substitution.

      DO JDIAG = N, 1, -1

!             Divide row JDIAG by the diagonal element.

         CALL ZMDIV_R1(X(JDIAG)%MZM,A(JDIAG,JDIAG)%MZM,QX)

!             Zero above the diagonal in column JDIAG by replacing row JROW by
!                 row JROW - A(JROW,JDIAG) * row JDIAG
!             For JROW = 1, ..., JDIAG-1.

         IF (JDIAG == 1) EXIT
         DO J = 1, JDIAG-1
            CALL ZMMPY(A(J,JDIAG)%MZM,X(JDIAG)%MZM,TEMP%MZM,QX)
            CALL ZMSUB_R1(X(J)%MZM,TEMP%MZM,QX)
         ENDDO
      ENDDO

      END SUBROUTINE ZMSOLVE_LU

      SUBROUTINE ZM_INVERSE(A,N,B,DET)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  Return B as the inverse of the N x N matrix A, and DET as the determinant of A.

!  A and B are type (zm) (complex) multiprecision arrays.

      INTEGER :: N
      TYPE (ZM) :: A(N,N), B(N,N), DET
      TYPE (MULTI) :: TOL, MXY(3)
      TYPE (ZM), ALLOCATABLE :: A1(:,:), A2(:,:), B1(:), R1(:), X1(:)
      INTEGER, ALLOCATABLE :: KSWAP(:)
      INTEGER :: I, J, K, KWARN_SAVE, NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX


      ALLOCATE(A1(N,N),A2(N,N),B1(N),R1(N),X1(N),KSWAP(N),STAT=J)
      IF (J /= 0) THEN
          WRITE (*,"(/' Error in ZM_INVERSE.  Unable to allocate arrays with N = ',I8/)") N
          STOP
      ENDIF

      CALL FMI2M(1,MXY(1),QX)
      CALL FMULP(MXY(1),MXY(2),QX)
      MXY(2)%MP(2) = MXY(2)%MP(2) - 1
      CALL FMST2M('1.0E10',MXY(3),QX)
      CALL FMDIV(MXY(2),MXY(3),TOL,QX)

!             Raise precision.

      NDSAVE = QX%NDIG
      QX%NDIG = 2*QX%NDIG
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

!             Copy A to A1 with higher precision.

  110 CALL FMEQU_R1(TOL,NDSAVE,QX%NDIG,QX)
      DO I = 1, N
         DO J = 1, N
            CALL ZMEQU(A(I,J)%MZM,A1(I,J)%MZM,NDSAVE,QX%NDIG,QX)
            CALL ZMEQ(A1(I,J)%MZM,A2(I,J)%MZM,QX)
         ENDDO
      ENDDO

!             Factor A into L*U form.

      CALL ZMFACTOR_LU(A1,N,DET,KSWAP,QX)
      IF ( (DET%MZM(1)%MP(3) == 0 .AND. DET%MZM(2)%MP(3) == 0) .OR.  &
           (DET%MZM(1)%MP(2) == QX%MUNKNO .OR. DET%MZM(2)%MP(2) == QX%MUNKNO) ) THEN
          IF (QX%KWARN > 0) THEN
              WRITE (*,"(/' Error in ZM_INVERSE.  The matrix is singular.'/)")
          ENDIF
          IF (QX%KWARN >= 2) STOP
          DO I = 1, N
             DO J = 1, N
                CALL ZMST2M('UNKNOWN + UNKNOWN i',B(I,J)%MZM,QX)
             ENDDO
          ENDDO
          GO TO 120
      ENDIF

!             Solve for the inverse matrix one column at a time.

      DO K = 1, N
         DO I = 1, N
            CALL ZMI2M(0,B1(I)%MZM,QX)
         ENDDO
         CALL ZMI2M(1,B1(K)%MZM,QX)

         CALL ZMSOLVE_LU(A1,N,B1,X1,KSWAP,QX)

!             Do an iterative refinement.

         CALL ZMMATMUL21(N,A2,X1,R1,QX)
         DO I = 1, N
            CALL ZMSUB_R1(R1(I)%MZM,B1(I)%MZM,QX)
         ENDDO

         CALL ZMSOLVE_LU(A1,N,R1,B1,KSWAP,QX)

         DO I = 1, N
            CALL ZMSUB_R1(X1(I)%MZM,B1(I)%MZM,QX)
         ENDDO

!             Check for accuracy at the user's precision.

         CALL ZMNORM2(B1,N,MXY(2),QX)
         IF (FMCOMP(MXY(2),'>',TOL,QX)) THEN
             IF (2*QX%NDIG <= 4*NDIG_MAX/5) THEN
                 QX%NDIG = 2*QX%NDIG
                 GO TO 110
             ENDIF
         ENDIF

!             Round the result and store column K in the B matrix.

         DO I = 1, N
            CALL ZMEQU(X1(I)%MZM,B(I,K)%MZM,QX%NDIG,NDSAVE,QX)
         ENDDO
      ENDDO
  120 CALL ZMEQU_R1(DET%MZM,QX%NDIG,NDSAVE,QX)

      DEALLOCATE(A1,A2,B1,R1,X1,KSWAP)

      QX%NDIG = NDSAVE
      QX%KWARN = KWARN_SAVE
      END SUBROUTINE ZM_INVERSE


      FUNCTION ZM_FPRIME(N,A,F,NF)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE
    INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
    END INTERFACE

!  This routine finds the Nth derivative of F(X,NF), evaluated at A.
!  NF is passed on to function F to indicate which function to use in cases where several
!  different functions may be defined there.

!  F must be defined in an interval containing A, so that F can be sampled on both sides of A.

!  N may be zero, so that in cases where F suffers cancellation error at A, an accurate
!  function value is returned.

!  ZM_FPRIME tries to return full accuracy for the derivative, by raising precision above
!  the user's level and using difference formulas.

      TYPE (ZM)           :: A, RETURN_VALUE
      INTEGER :: J, K, KWARN_SAVE, NDSAVE, N, NF
      TYPE (MULTI) :: D1(2), D2(2), TZ(2), X1(2), MZ1(2), MZ2(2), MZ3(2)
      TYPE (MULTI) :: F1(2), F2(2)
      TYPE (MULTI) :: H, T, TOL, TOL2, MXY(2)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

!             Raise precision slightly.

      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL ZMEQU(A%MZM,X1,NDSAVE,QX%NDIG,QX)
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

      CALL ZMI2M(0,D2,QX)
      F1 = F(X1,NF,QX)
      CALL ZMABS(F1,T,QX)
      CALL FMI2M(0,MXY(1),QX)
      IF (FMCOMP(T,'/=',MXY(1),QX)) THEN
          CALL FMULP(T,TOL,QX)
      ELSE
          CALL FMI2M(1,T,QX)
          CALL FMULP(T,TOL,QX)
      ENDIF
      CALL FMABS(TOL,MXY(1),QX)
      CALL FMEQ(MXY(1),TOL,QX)

!             Check for a legal function value.

      CALL ZMABS(F1,T,QX)
      IF (T%MP(2) == QX%MUNKNO .OR. T%MP(2) == QX%MEXPOV .OR. T%MP(2) == QX%MEXPUN) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',D2,QX)
          GO TO 110
      ENDIF
      CALL ZMEQ(F1,F2,QX)

!             Loop at increasing precision until the difference formula is accurate.

      DO J = 1, 100

         IF (2*QX%NDIG <= 4*NDIG_MAX/5) THEN
             QX%NDIG = 2*QX%NDIG
         ELSE
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',D2,QX)
             GO TO 110
         ENDIF

!             Define the variables used below at the new higher precision.

         CALL ZMEQU(D2,D1,QX%NDIG/2,QX%NDIG,QX)
         CALL ZMEQU(F2,F1,QX%NDIG/2,QX%NDIG,QX)
         CALL FMEQU(TOL,TOL2,NDSAVE,QX%NDIG,QX)
         CALL ZMEQU(A%MZM,X1,NDSAVE,QX%NDIG,QX)

!             Special case for N = 0.

         IF (N == 0) THEN
             F2 = F(X1,NF,QX)
             CALL ZMEQ(F2,D2,QX)
             CALL ZMSUB(F2,F1,TZ,QX)
             CALL ZMABS(TZ,MXY(1),QX)
             IF (FMCOMP(MXY(1),'<',TOL2,QX)) GO TO 110
             CYCLE
         ENDIF
         CALL ZMEQ(F1,F2,QX)

!             Special case for N = 1.

         IF (N == 1) THEN
             CALL ZMABS(X1,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             IF (FMCOMP(MXY(1),'/=',MXY(2),QX)) THEN
                 CALL FMULP(MXY(1),H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMABS(H,MXY(1),QX)
             CALL FMSQRT(MXY(1),H,QX)
             CALL FMADD(X1(1),H,MZ1(1),QX)
             CALL FMEQ(X1(2),MZ1(2),QX)
             CALL FMSUB(X1(1),H,MZ2(1),QX)
             CALL FMEQ(X1(2),MZ2(2),QX)
             F1 = F(MZ1,NF,QX)
             F2 = F(MZ2,NF,QX)
             CALL ZMSUB(F1,F2,MZ3,QX)
             CALL FMMPYI(H,2,MZ1(1),QX)
             CALL FMI2M(0,MZ1(2),QX)
             CALL ZMDIV(MZ3,MZ1,D2,QX)
             CALL ZMSUB(D2,D1,MZ1,QX)
             CALL ZMABS(MZ1,MXY(1),QX)
             IF (FMCOMP(MXY(1),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

!             General case for even N > 1.

         IF (MOD(N,2) == 0) THEN
             CALL ZMABS(X1,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             IF (FMCOMP(MXY(1),'/=',MXY(2),QX)) THEN
                 CALL FMULP(MXY(1),H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMI2M(1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),N+2,QX)
             CALL FMABS(H,MXY(2),QX)
             CALL FMPWR(MXY(2),MXY(1),H,QX)
             CALL FMCMBI(N,N/2,MXY(1),QX)
             CALL FMMPYI_R1(MXY(1),(-1)**(N/2),QX)
             CALL FMI2M(0,MXY(2),QX)
             CALL ZMCMPX(MXY(1),MXY(2),MZ1,QX)
             F1 = F(X1,NF,QX)
             CALL ZMMPY(MZ1,F1,D2,QX)
             DO K = 0, N/2-1
                CALL FMCMBI(N,K,MXY(1),QX)
                CALL FMMPYI_R1(MXY(1),(-1)**K,QX)
                CALL FMMPYI(H,N/2-K,MXY(2),QX)
                CALL FMADD(X1(1),MXY(2),MZ1(1),QX)
                CALL FMEQ(X1(2),MZ1(2),QX)
                CALL FMSUB(X1(1),MXY(2),MZ2(1),QX)
                CALL FMEQ(X1(2),MZ2(2),QX)
                F1 = F(MZ1,NF,QX)
                F2 = F(MZ2,NF,QX)
                CALL ZMADD(F1,F2,MZ3,QX)
                CALL FMMPY_R1(MZ3(1),MXY(1),QX)
                CALL FMMPY_R1(MZ3(2),MXY(1),QX)
                CALL ZMADD_R1(D2,MZ3,QX)
             ENDDO
             CALL FMIPWR(H,N,MXY(1),QX)
             CALL FMDIV_R1(D2(1),MXY(1),QX)
             CALL FMDIV_R1(D2(2),MXY(1),QX)
             CALL ZMSUB(D2,D1,MZ1,QX)
             CALL ZMABS(MZ1,MXY(1),QX)
             IF (FMCOMP(MXY(1),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

!             General case for odd N > 1.

         IF (MOD(N,2) == 1) THEN
             CALL ZMABS(X1,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             IF (FMCOMP(MXY(1),'/=',MXY(2),QX)) THEN
                 CALL FMULP(MXY(1),H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMI2M(1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),N+2,QX)
             CALL FMABS(H,MXY(2),QX)
             CALL FMPWR(MXY(2),MXY(1),H,QX)
             CALL ZMI2M(0,D2,QX)
             DO K = 0, N/2
                CALL FMCMBI(N-1,K,MXY(1),QX)
                CALL FMMPYI_R1(MXY(1),(-1)**K,QX)
                CALL FMMPYI(H,N/2-K+1,MXY(2),QX)
                CALL FMADD(X1(1),MXY(2),MZ1(1),QX)
                CALL FMEQ(X1(2),MZ1(2),QX)
                CALL FMSUB(X1(1),MXY(2),MZ2(1),QX)
                CALL FMEQ(X1(2),MZ2(2),QX)
                F1 = F(MZ1,NF,QX)
                F2 = F(MZ2,NF,QX)
                CALL ZMSUB(F1,F2,MZ3,QX)
                CALL FMMPYI_R1(MXY(1),N*(N+1-2*K),QX)
                CALL FMDIVI_R1(MXY(1),(N-K)*(N+1-K),QX)
                CALL FMMPY_R1(MZ3(1),MXY(1),QX)
                CALL FMMPY_R1(MZ3(2),MXY(1),QX)
                CALL ZMADD_R1(D2,MZ3,QX)
             ENDDO
             CALL FMIPWR(H,N,MXY(1),QX)
             CALL FMMPYI_R1(MXY(1),2,QX)
             CALL FMDIV_R1(D2(1),MXY(1),QX)
             CALL FMDIV_R1(D2(2),MXY(1),QX)
             CALL ZMSUB(D2,D1,MZ1,QX)
             CALL ZMABS(MZ1,MXY(1),QX)
             IF (FMCOMP(MXY(1),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

      ENDDO

!             Round and return.

  110 CALL ZMEQU(D2,RETURN_VALUE%MZM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%KWARN = KWARN_SAVE
      END FUNCTION ZM_FPRIME

      SUBROUTINE ZM_SECANT(AX,BX,F,NF,ROOT,KPRT,KU)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  This routine searches for a root of F(X,NF) = 0 using AX and BX as starting points.
!  AX and BX are complex, and the search can fail if AX and BX are not close enough to any roots
!  or if the function is badly behaved.

!  When a root is found, ZM_SECANT tries to return full accuracy even in the case of multiple
!  or closely-spaced roots, by raising precision above the user's level.

!  ROOT  is the value returned as the approximate root of the equation.

!  KPRT  controls printing within the routine:
!        KPRT = -1 for no output
!        KPRT =  0 for no output except warning and error messages.
!        KPRT =  1 for the approximation to the root and the function
!                  value to be printed once at the end of the routine.
!        KPRT =  2 for the approximation to the root and the function
!                  value to be printed each iteration.

!  KU    is the unit number for output.

    INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
    END INTERFACE

    INTERFACE
      FUNCTION ZMFPRIME2(N,A,F,NF,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
      END INTERFACE
      TYPE (MULTI) :: A(2)
      INTEGER :: N,NF
      TYPE (MULTI), DIMENSION(2) :: ZMFPRIME2
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION ZMFPRIME2
    END INTERFACE

      TYPE (ZM) :: AX, BX, ROOT
      CHARACTER (80) :: STR
      DOUBLE PRECISION :: VALUE
      INTEGER :: J, JSET, KPRT, KU, KWARN_SAVE, MAXIT, NDSAVE, NF
      LOGICAL :: USE_F_OVER_FP
      TYPE (MULTI) :: F1(2), F1OLD(2), F2(2), X1(2), X1OLD(2), X2(2), X3(2), MZ1(2), MZ2(2)
      TYPE (MULTI) :: ERR, ERR1, T, TOL, MXY(6)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      IF (KPRT == 2) THEN
          WRITE (KU,*) ' '
          WRITE (KU,*) ' ZM_SECANT.  Begin trace of all iterations.'
      ENDIF

!             Raise precision slightly.

      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL ZMEQU(AX%MZM,X1,NDSAVE,QX%NDIG,QX)
      CALL ZMEQU(BX%MZM,X2,NDSAVE,QX%NDIG,QX)
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

      MAXIT = 1000
      JSET = 50
      CALL FMI2M(1,ERR,QX)
      CALL FMULP(ERR,MXY(1),QX)
      CALL FMMPYI(MXY(1),100,TOL,QX)
      USE_F_OVER_FP = .FALSE.
      F1 = F(X1,NF,QX)
      F2 = F(X2,NF,QX)

!             Check for legal function values.

      CALL ZMABS(F1,MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
          DO J = 1, 3
             CALL ZMMPYI(X1,4-J,MZ1,QX)
             CALL ZMDIVI_R1(MZ1,4,QX)
             CALL ZMMPYI(X2,J,MZ2,QX)
             CALL ZMDIVI_R1(MZ2,4,QX)
             CALL ZMADD(MZ1,MZ2,X3,QX)
             F1 = F(X3,NF,QX)
             CALL ZMABS(F1,MXY(1),QX)
             IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                 CALL ZMEQ(X3,X1,QX)
                 EXIT
             ENDIF
          ENDDO
          CALL ZMABS(F1,MXY(1),QX)
          IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
              DO J = 1, 3
                 CALL ZMMPYI(X1,4+J,MZ1,QX)
                 CALL ZMDIVI_R1(MZ1,4,QX)
                 CALL ZMMPYI(X2,-J,MZ2,QX)
                 CALL ZMDIVI_R1(MZ2,4,QX)
                 CALL ZMADD(MZ1,MZ2,X3,QX)
                 F1 = F(X3,NF,QX)
                 CALL ZMABS(F1,MXY(1),QX)
                 IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                     CALL ZMEQ(X3,X1,QX)
                     EXIT
                 ENDIF
                 CALL ZMMPYI(X1,-J,MZ1,QX)
                 CALL ZMDIVI_R1(MZ1,4,QX)
                 CALL ZMMPYI(X2,4+J,MZ2,QX)
                 CALL ZMDIVI_R1(MZ2,4,QX)
                 CALL ZMADD(MZ1,MZ2,X3,QX)
                 F1 = F(X3,NF,QX)
                 CALL ZMABS(F1,MXY(1),QX)
                 IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                     CALL ZMEQ(X3,X1,QX)
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      CALL ZMABS(F1,MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
          IF (KPRT >= 0) THEN
              WRITE (KU,*) ' '
              WRITE (KU,*) ' Invalid input for ZM_SECANT. ',  &
                           ' Unknown or overflowed function value for AX ='
              CALL ZMPRINT(X1,QX)
              WRITE (KU,*) ' '
          ENDIF
          J = 0
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',X2,QX)
          CALL FMST2M(' UNKNOWN ',ERR,QX)
          GO TO 110
      ENDIF

      CALL ZMABS(F2,MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
          DO J = 1, 3
             CALL ZMMPYI(X1,4-J,MZ1,QX)
             CALL ZMDIVI_R1(MZ1,4,QX)
             CALL ZMMPYI(X2,J,MZ2,QX)
             CALL ZMDIVI_R1(MZ2,4,QX)
             CALL ZMADD(MZ1,MZ2,X3,QX)
             F2 = F(X3,NF,QX)
             CALL ZMABS(F2,MXY(1),QX)
             IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                 CALL ZMEQ(X3,X2,QX)
                 EXIT
             ENDIF
          ENDDO
          CALL ZMABS(F2,MXY(1),QX)
          IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
              DO J = 1, 3
                 CALL ZMMPYI(X1,4+J,MZ1,QX)
                 CALL ZMDIVI_R1(MZ1,4,QX)
                 CALL ZMMPYI(X2,-J,MZ2,QX)
                 CALL ZMDIVI_R1(MZ2,4,QX)
                 CALL ZMADD(MZ1,MZ2,X3,QX)
                 F2 = F(X3,NF,QX)
                 CALL ZMABS(F2,MXY(1),QX)
                 IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                     CALL ZMEQ(X3,X2,QX)
                     EXIT
                 ENDIF
                 CALL ZMMPYI(X1,-J,MZ1,QX)
                 CALL ZMDIVI_R1(MZ1,4,QX)
                 CALL ZMMPYI(X2,4+J,MZ2,QX)
                 CALL ZMDIVI_R1(MZ2,4,QX)
                 CALL ZMADD(MZ1,MZ2,X3,QX)
                 F2 = F(X3,NF,QX)
                 CALL ZMABS(F2,MXY(1),QX)
                 IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                     CALL ZMEQ(X3,X2,QX)
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      CALL ZMABS(F2,MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
          IF (KPRT >= 0) THEN
              WRITE (KU,*) ' '
              WRITE (KU,*) ' Invalid input for ZM_SECANT. ',  &
                           ' Unknown or overflowed function value for BX ='
              CALL ZMPRINT(X2,QX)
              WRITE (KU,*) ' '
          ENDIF
          J = 0
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',X2,QX)
          CALL FMST2M(' UNKNOWN ',ERR,QX)
          GO TO 110
      ENDIF

!             Secant does not do well if the magnitude of the two starting function values differ
!             by too much.  Adjust if necessary.

      DO J = 1, 10
         CALL ZMDIV(F2,F1,MZ1,QX)
         CALL ZMABS(MZ1,MXY(1),QX)
         CALL ZMDIV(F1,F2,MZ1,QX)
         CALL ZMABS(MZ1,MXY(2),QX)
         CALL FMI2M(10,MXY(3),QX)
         IF (FMCOMP(MXY(1),'>',MXY(3),QX)) THEN
             CALL ZMADD(X1,X2,MZ1,QX)
             CALL ZMDIVI(MZ1,2,X2,QX)
             F2 = F(X2,NF,QX)
         ELSE IF (FMCOMP(MXY(2),'>',MXY(3),QX)) THEN
             CALL ZMADD(X1,X2,MZ1,QX)
             CALL ZMDIVI(MZ1,2,X1,QX)
             F1 = F(X1,NF,QX)
         ELSE
             EXIT
         ENDIF
      ENDDO

      IF (KPRT == 2) THEN
          CALL ZMFORM('ES20.10','ES20.10',F1,STR,QX)
          WRITE (KU,"('  J =',I3,3X,'f(AX) = ',A,'    x:')") 0,TRIM(STR)
          CALL ZMPRINT(X1,QX)
          CALL ZMFORM('ES20.10','ES20.10',F2,STR,QX)
          WRITE (KU,"('  J =',I3,3X,'f(BX) = ',A,'    x:')") 0,TRIM(STR)
          CALL ZMPRINT(X2,QX)
      ENDIF

!             This loop does the iteration.

      DO J = 1, MAXIT

         CALL ZMSUB(F2,F1,MZ1,QX)
         CALL ZMABS(MZ1,MXY(1),QX)
         IF (MXY(1)%MP(3) /= 0) THEN
             CALL ZMSUB(X2,X1,MZ1,QX)
             CALL ZMSUB(F2,F1,MZ2,QX)
             CALL ZMDIV_R1(MZ1,MZ2,QX)
             CALL ZMMPY_R1(MZ1,F2,QX)
             CALL ZMSUB(X2,MZ1,X3,QX)
         ELSE
             CALL ZMI2M(1,MZ1,QX)
             CALL ZMADD(X2,MZ1,X3,QX)
         ENDIF

!             Multiple roots cause very slow convergence and loss of accuracy.
!             If the slope is very small, try to improve convergence and accuracy by using
!             the (slower) function  f(x)/f'(x)  which has no multiple roots.

         CALL ZMEQ(X1,X1OLD,QX)
         CALL ZMEQ(F1,F1OLD,QX)
         CALL ZMSUB(X2,X1,MZ1,QX)
         CALL ZMSUB(F2,F1,MZ2,QX)
         CALL ZMDIV_R1(MZ2,MZ1,QX)
         CALL ZMABS(MZ2,MXY(1),QX)
         CALL FMST2M('1.0D-2',MXY(2),QX)
         CALL ZMABS(F2,MXY(3),QX)
         CALL FMST2M('1.0D-4',MXY(4),QX)
         CALL ZMDIV(F2,MZ2,MZ1,QX)
         CALL ZMABS(MZ1,MXY(5),QX)
         CALL ZMDIVI(X2,10000,MZ1,QX)
         CALL ZMABS(MZ1,MXY(6),QX)
         IF ( (FMCOMP(MXY(1),'<',MXY(2),QX) .AND. FMCOMP(MXY(3),'<',MXY(4),QX) .AND.  &
               FMCOMP(MXY(5),'<',MXY(6),QX)) .OR. USE_F_OVER_FP) THEN
             USE_F_OVER_FP = .TRUE.
             CALL ZMEQ(X2,X1,QX)
             CALL ZMEQ(X3,X2,QX)
             CALL ZMEQ(F2,F1,QX)
             MZ1 = ZMFPRIME2(0,X3,F,NF,QX)
             MZ2 = ZMFPRIME2(1,X3,F,NF,QX)
             CALL ZMDIV(MZ1,MZ2,F2,QX)
         ELSE
             CALL ZMEQ(X2,X1,QX)
             CALL ZMEQ(X3,X2,QX)
             CALL ZMEQ(F2,F1,QX)
             F2 = F(X3,NF,QX)
         ENDIF

!             If F2 is one of the FM non-numbers, +-underflow, +-overflow, unknown,
!             then replace it by something representable, so that the next x3 will be
!             closer to x1.  Also swap x1 and x2, making the bad x go away first.

         CALL ZMABS(F2,MXY(1),QX)
         IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
             CALL ZMMPYI(F1,-2,F2,QX)
             CALL ZMEQ(X1,X3,QX)
             CALL ZMEQ(X2,X1,QX)
             CALL ZMEQ(X3,X2,QX)
             CALL ZMEQ(F1,X3,QX)
             CALL ZMEQ(F2,F1,QX)
             CALL ZMEQ(X3,F2,QX)
         ENDIF

!             A common failure mode for secant is to get into a pattern that repeats x1 and x2
!             close together with nearly equal function values and x3 farther away with much
!             larger function value.  Check for this, and re-start the iteration by choosing
!             a different x3.

         CALL ZMABS(F2,MXY(1),QX)
         CALL ZMABS(F1OLD,MXY(2),QX)
         CALL ZMABS(F1,MXY(3),QX)
         CALL FMMAX(MXY(2),MXY(3),MXY(4),QX)
         CALL FMMPYI(MXY(4),100,MXY(2),QX)
         IF (FMCOMP(MXY(1),'>',MXY(2),QX) .AND. J >= JSET) THEN
             JSET = JSET + 5
             VALUE = (MOD(277*J,1001) + 1) / 1002.0D0
             VALUE = 9*VALUE - 4
             CALL FMDP2M(VALUE,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             CALL ZMCMPX(MXY(1),MXY(2),MZ1,QX)
             CALL ZMI2M(1,MZ2,QX)
             CALL ZMSUB_R1(MZ2,MZ1,QX)
             CALL ZMMPY_R1(MZ1,X1,QX)
             CALL ZMMPY_R1(MZ2,X2,QX)
             CALL ZMADD(MZ1,MZ2,X2,QX)
             F2 = F(X2,NF,QX)
         ENDIF

         IF (KPRT == 2) THEN
             CALL ZMFORM('ES20.10','ES20.10',F2,STR,QX)
             WRITE (KU,"('  J =',I3,4X,'f(x) = ' ,A,'    x:')") J,TRIM(STR)
             CALL ZMPRINT(X2,QX)
         ENDIF

         CALL FMEQ(ERR,ERR1,QX)
         CALL ZMABS(X2,MXY(1),QX)
         IF (MXY(1)%MP(3) /= 0) THEN
             CALL ZMSUB(X2,X1,MZ1,QX)
             CALL ZMDIV_R1(MZ1,X2,QX)
             CALL ZMABS(MZ1,ERR,QX)
         ELSE
             CALL ZMSUB(X2,X1,MZ1,QX)
             CALL ZMABS(MZ1,ERR,QX)
         ENDIF

!             If the error is less than the tolerance, double check to make sure the previous
!             error was small along with the current function value.  Some divergent iterations
!             can get err < tol without being close to a root.

         CALL ZMABS(F2,MXY(1),QX)
         IF (FMCOMP(ERR,'<',TOL,QX) .OR. MXY(1)%MP(3) == 0) THEN
             CALL FMSQRT(TOL,MXY(3),QX)
             CALL FMSQRT(MXY(3),MXY(2),QX)
             CALL FMI2M(1,MXY(3),QX)
             CALL FMULP(MXY(3),MXY(4),QX)
             CALL FMSQRT(MXY(4),MXY(3),QX)
             IF (FMCOMP(ERR1,'>',MXY(2),QX) .AND. FMCOMP(MXY(1),'>',MXY(3),QX)) THEN
                 IF (KPRT >= 0) THEN
                     WRITE (KU,"(/' Possible false convergence in ZM_SECANT after',I5,"//  &
                               "' iterations.  ','Last two approximations =')") J
                     CALL ZMPRINT(X1,QX)
                     CALL ZMPRINT(X2,QX)
                     WRITE (KU,"(/' These agree to the convergence tolerance, but the previous"//  &
                               " iteration was suspiciously far away:')")
                     CALL ZMPRINT(X1OLD,QX)
                     WRITE (KU,"(/' and the function value of the last iteration was"//  &
                               " suspiciously far from zero:')")
                     CALL ZMPRINT(F2,QX)
                     WRITE (KU,"(/' Unknown has been returned.')")
                 ENDIF
                 CALL ZMST2M(' UNKNOWN + UNKNOWN i ',X2,QX)
             ENDIF
             GO TO 110
         ENDIF

      ENDDO

!             No convergence after maxit iterations.

      IF (KPRT >= 0) THEN
          WRITE (KU,"(/' No convergence in ZM_SECANT after',I5,' iterations.  ',"//  &
                    "'Last two approximations =')") MAXIT
          CALL ZMPRINT(X1,QX)
          CALL ZMPRINT(X2,QX)
          WRITE (KU,"(/' Unknown has been returned.')")
      ENDIF
      CALL ZMST2M(' UNKNOWN + UNKNOWN i ',X2,QX)

!             The root was found.

  110 CALL ZMEQU(X2,ROOT%MZM,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      IF (KPRT >= 1) THEN
          CALL ZMABS(X2,T,QX)
          CALL FMULP(T,ERR1,QX)
          IF (.NOT. (ERR1%MP(2) == QX%MUNKNO .OR. ERR1%MP(2) == QX%MEXPUN)) THEN
              CALL FMDIV(ERR1,T,MXY(1),QX)
              CALL FMDIVI(MXY(1),2,ERR1,QX)
              IF (FMCOMP(ERR,'<',ERR1,QX)) CALL FMEQ(ERR1,ERR,QX)
          ENDIF
          CALL FMFORM('ES16.6',ERR,STR,QX)
          WRITE (KU,*) ' '
          WRITE (KU,"('  ZM_SECANT.   Function ',I3,I7,' iterations.'/17X"// &
                    "'Estimated relative error =',A,',    Root:')") NF,J,TRIM(STR)
          CALL ZMPRINT(ROOT%MZM,QX)
          WRITE (KU,*) ' '
      ENDIF

      QX%KWARN = KWARN_SAVE
      END SUBROUTINE ZM_SECANT

      FUNCTION ZMFPRIME2(N,A,F,NF,QX)     RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE
    INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
    END INTERFACE

!  This routine finds the Nth derivative of F(X,NF), evaluated at A.
!  NF is passed on to function F to indicate which function to use in cases where several
!  different functions may be defined there.

!  F must be defined in an interval containing A, so that F can be sampled on both sides of A.

!  N may be zero, so that in cases where F suffers cancellation error at A, an accurate
!  function value is returned.

!  ZMFPRIME2 tries to return full accuracy for the derivative, by raising precision above
!  the user's level and using difference formulas.

!  ZMFPRIME2 in an internal version of ZM_FPRIME that returns a type(multi) result,
!  instead of the type(zm) result of ZM_FPRIME.

      TYPE (MULTI)           :: A(2), RETURN_VALUE(2)
      INTEGER :: J, K, KWARN_SAVE, NDSAVE, N, NF
      TYPE (MULTI) :: D1(2), D2(2), TZ(2), X1(2), MZ1(2), MZ2(2), MZ3(2)
      TYPE (MULTI) :: F1(2), F2(2)
      TYPE (MULTI) :: H, T, TOL, TOL2, MXY(2)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

!             Raise precision slightly.

      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL ZMEQU(A,X1,NDSAVE,QX%NDIG,QX)
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

      CALL ZMI2M(0,D2,QX)
      F1 = F(X1,NF,QX)
      CALL ZMABS(F1,T,QX)
      CALL FMI2M(0,MXY(1),QX)
      IF (FMCOMP(T,'/=',MXY(1),QX)) THEN
          CALL FMULP(T,TOL,QX)
      ELSE
          CALL FMI2M(1,T,QX)
          CALL FMULP(T,TOL,QX)
      ENDIF
      CALL FMABS(TOL,MXY(1),QX)
      CALL FMEQ(MXY(1),TOL,QX)

!             Check for a legal function value.

      CALL ZMABS(F1,T,QX)
      IF (T%MP(2) == QX%MUNKNO .OR. T%MP(2) == QX%MEXPOV .OR. T%MP(2) == QX%MEXPUN) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',D2,QX)
          GO TO 110
      ENDIF
      CALL ZMEQ(F1,F2,QX)

!             Loop at increasing precision until the difference formula is accurate.

      DO J = 1, 100

         IF ((5*QX%NDIG)/4 <= 4*NDIG_MAX/5) THEN
             QX%NDIG = (5*QX%NDIG)/4
         ELSE
             CALL ZMST2M(' UNKNOWN + UNKNOWN i ',D2,QX)
             GO TO 110
         ENDIF

!             Define the variables used below at the new higher precision.

         CALL ZMEQU(D2,D1,QX%NDIG/2,QX%NDIG,QX)
         CALL ZMEQU(F2,F1,QX%NDIG/2,QX%NDIG,QX)
         CALL FMEQU(TOL,TOL2,NDSAVE,QX%NDIG,QX)
         CALL ZMEQU(A,X1,NDSAVE,QX%NDIG,QX)

!             Special case for N = 0.

         IF (N == 0) THEN
             F2 = F(X1,NF,QX)
             CALL ZMEQ(F2,D2,QX)
             CALL ZMSUB(F2,F1,TZ,QX)
             CALL ZMABS(TZ,MXY(1),QX)
             IF (FMCOMP(MXY(1),'<',TOL2,QX)) GO TO 110
             CYCLE
         ENDIF
         CALL ZMEQ(F1,F2,QX)

!             Special case for N = 1.

         IF (N == 1) THEN
             CALL ZMABS(X1,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             IF (FMCOMP(MXY(1),'/=',MXY(2),QX)) THEN
                 CALL FMULP(MXY(1),H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMABS(H,MXY(1),QX)
             CALL FMSQRT(MXY(1),H,QX)
             CALL FMADD(X1(1),H,MZ1(1),QX)
             CALL FMEQ(X1(2),MZ1(2),QX)
             CALL FMSUB(X1(1),H,MZ2(1),QX)
             CALL FMEQ(X1(2),MZ2(2),QX)
             F1 = F(MZ1,NF,QX)
             F2 = F(MZ2,NF,QX)
             CALL ZMSUB(F1,F2,MZ3,QX)
             CALL FMMPYI(H,2,MZ1(1),QX)
             CALL FMI2M(0,MZ1(2),QX)
             CALL ZMDIV(MZ3,MZ1,D2,QX)
             CALL ZMSUB(D2,D1,MZ1,QX)
             CALL ZMABS(MZ1,MXY(1),QX)
             IF (FMCOMP(MXY(1),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

!             General case for even N > 1.

         IF (MOD(N,2) == 0) THEN
             CALL ZMABS(X1,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             IF (FMCOMP(MXY(1),'/=',MXY(2),QX)) THEN
                 CALL FMULP(MXY(1),H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMI2M(1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),N+2,QX)
             CALL FMABS(H,MXY(2),QX)
             CALL FMPWR(MXY(2),MXY(1),H,QX)
             CALL FMCMBI(N,N/2,MXY(1),QX)
             CALL FMMPYI_R1(MXY(1),(-1)**(N/2),QX)
             CALL FMI2M(0,MXY(2),QX)
             CALL ZMCMPX(MXY(1),MXY(2),MZ1,QX)
             F1 = F(X1,NF,QX)
             CALL ZMMPY(MZ1,F1,D2,QX)
             DO K = 0, N/2-1
                CALL FMCMBI(N,K,MXY(1),QX)
                CALL FMMPYI_R1(MXY(1),(-1)**K,QX)
                CALL FMMPYI(H,N/2-K,MXY(2),QX)
                CALL FMADD(X1(1),MXY(2),MZ1(1),QX)
                CALL FMEQ(X1(2),MZ1(2),QX)
                CALL FMSUB(X1(1),MXY(2),MZ2(1),QX)
                CALL FMEQ(X1(2),MZ2(2),QX)
                F1 = F(MZ1,NF,QX)
                F2 = F(MZ2,NF,QX)
                CALL ZMADD(F1,F2,MZ3,QX)
                CALL FMMPY_R1(MZ3(1),MXY(1),QX)
                CALL FMMPY_R1(MZ3(2),MXY(1),QX)
                CALL ZMADD_R1(D2,MZ3,QX)
             ENDDO
             CALL FMIPWR(H,N,MXY(1),QX)
             CALL FMDIV_R1(D2(1),MXY(1),QX)
             CALL FMDIV_R1(D2(2),MXY(1),QX)
             CALL ZMSUB(D2,D1,MZ1,QX)
             CALL ZMABS(MZ1,MXY(1),QX)
             IF (FMCOMP(MXY(1),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

!             General case for odd N > 1.

         IF (MOD(N,2) == 1) THEN
             CALL ZMABS(X1,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             IF (FMCOMP(MXY(1),'/=',MXY(2),QX)) THEN
                 CALL FMULP(MXY(1),H,QX)
             ELSE
                 CALL FMI2M(1,MXY(1),QX)
                 CALL FMULP(MXY(1),H,QX)
             ENDIF
             CALL FMI2M(1,MXY(1),QX)
             CALL FMDIVI_R1(MXY(1),N+2,QX)
             CALL FMABS(H,MXY(2),QX)
             CALL FMPWR(MXY(2),MXY(1),H,QX)
             CALL ZMI2M(0,D2,QX)
             DO K = 0, N/2
                CALL FMCMBI(N-1,K,MXY(1),QX)
                CALL FMMPYI_R1(MXY(1),(-1)**K,QX)
                CALL FMMPYI(H,N/2-K+1,MXY(2),QX)
                CALL FMADD(X1(1),MXY(2),MZ1(1),QX)
                CALL FMEQ(X1(2),MZ1(2),QX)
                CALL FMSUB(X1(1),MXY(2),MZ2(1),QX)
                CALL FMEQ(X1(2),MZ2(2),QX)
                F1 = F(MZ1,NF,QX)
                F2 = F(MZ2,NF,QX)
                CALL ZMSUB(F1,F2,MZ3,QX)
                CALL FMMPYI_R1(MXY(1),N*(N+1-2*K),QX)
                CALL FMDIVI_R1(MXY(1),(N-K)*(N+1-K),QX)
                CALL FMMPY_R1(MZ3(1),MXY(1),QX)
                CALL FMMPY_R1(MZ3(2),MXY(1),QX)
                CALL ZMADD_R1(D2,MZ3,QX)
             ENDDO
             CALL FMIPWR(H,N,MXY(1),QX)
             CALL FMMPYI_R1(MXY(1),2,QX)
             CALL FMDIV_R1(D2(1),MXY(1),QX)
             CALL FMDIV_R1(D2(2),MXY(1),QX)
             CALL ZMSUB(D2,D1,MZ1,QX)
             CALL ZMABS(MZ1,MXY(1),QX)
             IF (FMCOMP(MXY(1),'<',TOL2,QX) .AND. J > 1) GO TO 110
             CYCLE
         ENDIF

      ENDDO

!             Round and return.

  110 CALL ZMEQU(D2,RETURN_VALUE,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      QX%KWARN = KWARN_SAVE
      END FUNCTION ZMFPRIME2

      SUBROUTINE ZM_ROOTS(NR,F,NF,N_FOUND,LIST_OF_ROOTS,KPRT,KU)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  This routine searches for NR roots of F(X,NF) = 0.
!  NF is the function number in case roots to several functions are needed.

!  N_FOUND is returned as the number of roots found.
!  LIST_OF_ROOTS is an array returned with the roots found.  They are complex type (zm) numbers,
!                even when the actual root is real.

!  KPRT  controls printing within the routine:
!        KPRT = 0 for no output
!        KPRT = 1 for the approximation to each root to be printed as they are found.

!  KU    is the unit number for output.

!  The search for roots begins with fairly small magnitude complex values, so small roots are
!  often found before larger roots, but there is no guarantee of this, and the order in which
!  the roots are found is fairly random.  The user can sort LIST_OF_ROOTS and print them after
!  all have been found.

!  The secant method often fails to converge to any root for a given pair of starting points.
!  This routine may call ZMROOT1 many more than NR times before NR roots are found.  It can
!  also happen that ZM_ROOTS eventually gives up and returns N_FOUND < NR roots.

!  The user's function F is divided by the product of (X - LIST_OF_ROOTS(j)) over the roots that
!  have been found so far.  This tries keep the ZMROOT1 routine from returning to a root that is
!  already on the list (unless it is a root of multiplicity M > 1).

    INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
    END INTERFACE
      INTEGER :: J, KU, KPRT, KWARN_SAVE, NDIG_OF_ROOTS, NDSAVE, NF, NR, N_FOUND
      DOUBLE PRECISION :: VALUE
      LOGICAL :: REMOVE_PREVIOUS_ROOTS, RETRY
      TYPE (ZM) :: LIST_OF_ROOTS(NR)
      TYPE (MULTI) :: AX(2), BX(2), X1(2), MXY(4), MZ1(2), MZ2(2)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX


!             Raise precision slightly.

      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0
      RETRY = .FALSE.

      N_FOUND = 0
      DO J = 1, NR
         CALL ZMST2M(' UNKNOWN + UNKNOWN i ',LIST_OF_ROOTS(J)%MZM,QX)
      ENDDO
      NDIG_OF_ROOTS = QX%NDIG

      DO J = 1, 10*NR
         IF (RETRY) THEN
             VALUE = (MOD(277*J,1001) + 1) / 1002.0D0
             IF (MOD(J,4) == 0) THEN
                 CALL ZMST2M(' 1.1 + 1.2 i ',MZ1,QX)
                 CALL FMDP2M((2+J)*VALUE+1,MXY(1),QX)
                 CALL FMI2M(0,MXY(2),QX)
                 CALL ZMCMPX(MXY(1),MXY(2),MZ2,QX)
                 CALL ZMMPY(MZ1,MZ2,AX,QX)
             ELSE IF (MOD(J,4) == 1) THEN
                 CALL ZMST2M(' 1.1 - 0.8 i ',MZ1,QX)
                 CALL FMDP2M((2+J)*VALUE+1,MXY(1),QX)
                 CALL FMI2M(0,MXY(2),QX)
                 CALL ZMCMPX(MXY(1),MXY(2),MZ2,QX)
                 CALL ZMMPY(MZ1,MZ2,AX,QX)
             ELSE IF (MOD(J,4) == 2) THEN
                 CALL ZMST2M(' -0.8 - 1.2 i ',MZ1,QX)
                 CALL FMDP2M((2+J)*VALUE+1,MXY(1),QX)
                 CALL FMI2M(0,MXY(2),QX)
                 CALL ZMCMPX(MXY(1),MXY(2),MZ2,QX)
                 CALL ZMMPY(MZ1,MZ2,AX,QX)
             ELSE IF (MOD(J,4) == 3) THEN
                 CALL ZMST2M(' -1.1 + 0.8 i ',MZ1,QX)
                 CALL FMDP2M((2+J)*VALUE+1,MXY(1),QX)
                 CALL FMI2M(0,MXY(2),QX)
                 CALL ZMCMPX(MXY(1),MXY(2),MZ2,QX)
                 CALL ZMMPY(MZ1,MZ2,AX,QX)
             ENDIF
             CALL ZMST2M(' 0.87 + 0.5 i ',MZ1,QX)
             CALL ZMMPY(MZ1,AX,BX,QX)
         ELSE
                 CALL ZMST2M(' 1.1 + 1.2 i ',AX,QX)
                 CALL ZMST2M(' 3.4 + 4.5 i ',BX,QX)
         ENDIF
         REMOVE_PREVIOUS_ROOTS = .TRUE.
         CALL ZMROOT1(AX,BX,NR,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,  &
                      NDIG_OF_ROOTS,X1,-1,KU,QX)
         CALL ZMABS(X1,MXY(1),QX)
         IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
             N_FOUND = N_FOUND + 1
             CALL ZMEQ(X1,LIST_OF_ROOTS(N_FOUND)%MZM,QX)

!             Some roots, primarily multiple roots, may have lost some accuracy due to the
!             divisions by previously found roots.  Refine them using F without dividing.

             CALL FMDP2M(1+1.0D-10,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             CALL ZMCMPX(MXY(1),MXY(2),MZ2,QX)
             CALL ZMMPY(LIST_OF_ROOTS(N_FOUND)%MZM,MZ2,AX,QX)
             CALL FMDP2M(1+1.0D-15,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             CALL ZMCMPX(MXY(1),MXY(2),MZ2,QX)
             CALL ZMMPY(LIST_OF_ROOTS(N_FOUND)%MZM,MZ2,BX,QX)
             REMOVE_PREVIOUS_ROOTS = .FALSE.
             CALL ZMROOT1(AX,BX,NR,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,  &
                          LIST_OF_ROOTS,NDIG_OF_ROOTS,X1,-1,KU,QX)
             CALL FMABS(X1(1),MXY(1),QX)
             CALL FMI2M(1,MXY(3),QX)
             CALL FMULP(MXY(3),MXY(2),QX)
             CALL ZMABS(X1,MXY(4),QX)
             CALL FMMPY_R1(MXY(2),MXY(4),QX)
             IF (FMCOMP(MXY(1),'<',MXY(2),QX)) THEN
                 CALL FMI2M(0,X1(1),QX)
             ENDIF
             CALL FMABS(X1(2),MXY(1),QX)
             CALL FMI2M(1,MXY(3),QX)
             CALL FMULP(MXY(3),MXY(2),QX)
             CALL ZMABS(X1,MXY(4),QX)
             CALL FMMPY_R1(MXY(2),MXY(4),QX)
             IF (FMCOMP(MXY(1),'<',MXY(2),QX)) THEN
                 CALL FMI2M(0,X1(2),QX)
             ENDIF
             CALL ZMEQ(X1,LIST_OF_ROOTS(N_FOUND)%MZM,QX)

             IF (KPRT > 0) THEN
                 WRITE (*,"(A,I9,A,I6,A)") ' ZM_ROOTS.  Function ',NF,' Root ',N_FOUND,' ='
                 CALL ZMPRINT(X1,QX)
             ENDIF
             IF (N_FOUND == NR) EXIT

!             Check to see if the conjugate of this root is also a root.

             CALL FMABS(X1(2),MXY(1),QX)
             CALL FMI2M(1,MXY(3),QX)
             CALL FMULP(MXY(3),MXY(2),QX)
             CALL FMMPYI_R1(MXY(2),100,QX)
             IF (FMCOMP(MXY(1),'<',MXY(2),QX)) CYCLE
             CALL FMMPYI_R1(AX(2),-1,QX)
             CALL FMMPYI_R1(BX(2),-1,QX)
             REMOVE_PREVIOUS_ROOTS = .TRUE.
             CALL ZMROOT1(AX,BX,NR,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,  &
                           LIST_OF_ROOTS,NDIG_OF_ROOTS,X1,-1,KU,QX)
             CALL ZMABS(X1,MXY(1),QX)
             IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                 N_FOUND = N_FOUND + 1
                 CALL ZMEQ(X1,LIST_OF_ROOTS(N_FOUND)%MZM,QX)
                 CALL FMDP2M(1+1.0D-10,MXY(1),QX)
                 CALL FMI2M(0,MXY(2),QX)
                 CALL ZMCMPX(MXY(1),MXY(2),MZ2,QX)
                 CALL ZMMPY(LIST_OF_ROOTS(N_FOUND)%MZM,MZ2,AX,QX)
                 CALL FMDP2M(1+1.0D-15,MXY(1),QX)
                 CALL FMI2M(0,MXY(2),QX)
                 CALL ZMCMPX(MXY(1),MXY(2),MZ2,QX)
                 CALL ZMMPY(LIST_OF_ROOTS(N_FOUND)%MZM,MZ2,BX,QX)
                 REMOVE_PREVIOUS_ROOTS = .FALSE.
                 CALL ZMROOT1(AX,BX,NR,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,  &
                              LIST_OF_ROOTS,NDIG_OF_ROOTS,X1,-1,KU,QX)
                 CALL FMABS(X1(1),MXY(1),QX)
                 CALL FMI2M(1,MXY(3),QX)
                 CALL FMULP(MXY(3),MXY(2),QX)
                 CALL ZMABS(X1,MXY(4),QX)
                 CALL FMMPY_R1(MXY(2),MXY(4),QX)
                 IF (FMCOMP(MXY(1),'<',MXY(2),QX)) THEN
                     CALL FMI2M(0,X1(1),QX)
                 ENDIF
                 CALL FMABS(X1(2),MXY(1),QX)
                 CALL FMI2M(1,MXY(3),QX)
                 CALL FMULP(MXY(3),MXY(2),QX)
                 CALL ZMABS(X1,MXY(4),QX)
                 CALL FMMPY_R1(MXY(2),MXY(4),QX)
                 IF (FMCOMP(MXY(1),'<',MXY(2),QX)) THEN
                     CALL FMI2M(0,X1(2),QX)
                 ENDIF
                 CALL ZMEQ(X1,LIST_OF_ROOTS(N_FOUND)%MZM,QX)
                 IF (KPRT > 0) THEN
                     WRITE (*,"(A,I9,A,I6,A)") ' ZM_ROOTS.  Function ',NF,' Root ',N_FOUND,' ='
                     CALL ZMPRINT(X1,QX)
                 ENDIF
                 IF (N_FOUND == NR) EXIT
             ENDIF
             RETRY = .FALSE.
         ELSE
             RETRY = .TRUE.
         ENDIF
      ENDDO

!             Round the roots to the user's precision.

      DO J = 1, N_FOUND
         CALL ZMEQ(LIST_OF_ROOTS(J)%MZM,X1,QX)
         CALL ZMEQU(X1,LIST_OF_ROOTS(J)%MZM,QX%NDIG,NDSAVE,QX)
      ENDDO

      QX%NDIG = NDSAVE
      QX%KWARN = KWARN_SAVE
      END SUBROUTINE ZM_ROOTS

      SUBROUTINE ZMROOT1(AX,BX,NR,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,  &
                         LIST_OF_ROOTS,NDIG_OF_ROOTS,ROOT,KPRT,KU,QX)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  This is a special version of ZM_SECANT, modified to work with ZM_ROOTS so that some calls
!  will use F and others will use F divided by all the (x - r) terms of the roots found so far.

!  REMOVE_PREVIOUS_ROOTS is a logical input variable telling this routine whether or not to
!  divide F by the product of (X - LIST_OF_ROOTS(j)) over the roots that have been found so far.
!  This tries keep the ZMROOT1 routine from returning to a root that is already on the list
!  (unless it is a root of multiplicity M > 1).

!  This routine searches for a root of F(X,NF) = 0 using AX and BX as starting points.
!  AX and BX are complex, and the search can fail if AX and BX are not close enough to any roots
!  or if the function is badly behaved.

!  When a root is found, ZMROOT1 tries to return full accuracy even in the case of multiple
!  or closely-spaced roots, by raising precision above the user's level.

!  ROOT  is the value returned as the approximate root of the equation.

!  KPRT  controls printing within the routine:
!        KPRT = -1 for no output
!        KPRT =  0 for no output except warning and error messages.
!        KPRT =  1 for the approximation to the root and the function
!                  value to be printed once at the end of the routine.
!        KPRT =  2 for the approximation to the root and the function
!                  value to be printed each iteration.

!  KU    is the unit number for output.


    INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
    END INTERFACE

    INTERFACE
      FUNCTION ZMFPRIME2(N,A,F,NF,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
      END INTERFACE
      TYPE (MULTI) :: A(2)
      INTEGER :: N,NF
      TYPE (MULTI), DIMENSION(2) :: ZMFPRIME2
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION ZMFPRIME2
    END INTERFACE

    INTERFACE
      FUNCTION ZMROOT_F(X,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
      END INTERFACE
      INTEGER :: NDIG_OF_ROOTS, NF, N_FOUND
      LOGICAL :: REMOVE_PREVIOUS_ROOTS
      TYPE (ZM) :: LIST_OF_ROOTS(N_FOUND)
      TYPE (MULTI) :: ZMROOT_F(2), X(2)
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION ZMROOT_F
    END INTERFACE

      TYPE (MULTI)           :: AX(2), BX(2), ROOT(2)
      CHARACTER (80) :: STR
      DOUBLE PRECISION :: VALUE
      INTEGER :: J, JSET, K, KU, KPRT, KWARN_SAVE, MAXIT, N_FOUND, NDIG_OF_ROOTS, NDSAVE, NF, NR
      LOGICAL :: REMOVE_PREVIOUS_ROOTS, USE_F_OVER_FP
      TYPE (ZM) :: LIST_OF_ROOTS(NR)
      TYPE (MULTI) :: F1(2), F1OLD(2), F2(2), FP0(2), FP1(2), FS(2), S(2), X1(2), X1OLD(2),  &
                      X2(2), X3(2), MZ1(2), MZ2(2)
      TYPE (MULTI) :: ERR, ERR1, T, TOL, MXY(6)
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(FM_SETTINGS) :: QX

      IF (KPRT == 2) THEN
          WRITE (KU,"(A)") ' '
          WRITE (KU,"(A)") ' ZMROOT1.  Begin trace of all iterations.'
      ENDIF

!             Raise precision slightly.

      NDSAVE = QX%NDIG
      QX%NDIG = QX%NDIG + QX%NGRD52
      CALL ZMEQU(AX,X1,NDSAVE,QX%NDIG,QX)
      CALL ZMEQU(BX,X2,NDSAVE,QX%NDIG,QX)
      KWARN_SAVE = QX%KWARN
      QX%KWARN = 0

      MAXIT = 1000
      JSET = 50
      CALL FMI2M(1,ERR,QX)
      CALL FMULP(ERR,MXY(1),QX)
      CALL FMMPYI(MXY(1),100,TOL,QX)
      USE_F_OVER_FP = .FALSE.
      F1 = ZMROOT_F(X1,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
      F2 = ZMROOT_F(X2,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)

!             Check for legal function values.

      CALL ZMABS(F1,MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
          DO J = 1, 3
             CALL ZMMPYI(X1,4-J,MZ1,QX)
             CALL ZMDIVI_R1(MZ1,4,QX)
             CALL ZMMPYI(X2,J,MZ2,QX)
             CALL ZMDIVI_R1(MZ2,4,QX)
             CALL ZMADD(MZ1,MZ2,X3,QX)
             F1 = ZMROOT_F(X3,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
             CALL ZMABS(F1,MXY(1),QX)
             IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                 CALL ZMEQ(X3,X1,QX)
                 EXIT
             ENDIF
          ENDDO
          CALL ZMABS(F1,MXY(1),QX)
          IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
              DO J = 1, 3
                 CALL ZMMPYI(X1,4+J,MZ1,QX)
                 CALL ZMDIVI_R1(MZ1,4,QX)
                 CALL ZMMPYI(X2,-J,MZ2,QX)
                 CALL ZMDIVI_R1(MZ2,4,QX)
                 CALL ZMADD(MZ1,MZ2,X3,QX)
                 F1 = ZMROOT_F(X3,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
                 CALL ZMABS(F1,MXY(1),QX)
                 IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                     CALL ZMEQ(X3,X1,QX)
                     EXIT
                 ENDIF
                 CALL ZMMPYI(X1,-J,MZ1,QX)
                 CALL ZMDIVI_R1(MZ1,4,QX)
                 CALL ZMMPYI(X2,4+J,MZ2,QX)
                 CALL ZMDIVI_R1(MZ2,4,QX)
                 CALL ZMADD(MZ1,MZ2,X3,QX)
                 F1 = ZMROOT_F(X3,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
                 CALL ZMABS(F1,MXY(1),QX)
                 IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                     CALL ZMEQ(X3,X1,QX)
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      CALL ZMABS(F1,MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
          IF (KPRT >= 0) THEN
              WRITE (KU,"(A)") ' '
              WRITE (KU,"(A,A)") ' Invalid input for ZMROOT1. ',  &
                                 ' Unknown or overflowed function value for AX ='
              CALL ZMPRINT(X1,QX)
              WRITE (KU,"(A)") ' '
          ENDIF
          J = 0
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',X2,QX)
          CALL FMST2M(' UNKNOWN ',ERR,QX)
          GO TO 110
      ENDIF

      CALL ZMABS(F2,MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
          DO J = 1, 3
             CALL ZMMPYI(X1,4-J,MZ1,QX)
             CALL ZMDIVI_R1(MZ1,4,QX)
             CALL ZMMPYI(X2,J,MZ2,QX)
             CALL ZMDIVI_R1(MZ2,4,QX)
             CALL ZMADD(MZ1,MZ2,X3,QX)
             F2 = ZMROOT_F(X3,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
             CALL ZMABS(F2,MXY(1),QX)
             IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                 CALL ZMEQ(X3,X2,QX)
                 EXIT
             ENDIF
          ENDDO
          CALL ZMABS(F2,MXY(1),QX)
          IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
              DO J = 1, 3
                 CALL ZMMPYI(X1,4+J,MZ1,QX)
                 CALL ZMDIVI_R1(MZ1,4,QX)
                 CALL ZMMPYI(X2,-J,MZ2,QX)
                 CALL ZMDIVI_R1(MZ2,4,QX)
                 CALL ZMADD(MZ1,MZ2,X3,QX)
                 F2 = ZMROOT_F(X3,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
                 CALL ZMABS(F2,MXY(1),QX)
                 IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                     CALL ZMEQ(X3,X2,QX)
                     EXIT
                 ENDIF
                 CALL ZMMPYI(X1,-J,MZ1,QX)
                 CALL ZMDIVI_R1(MZ1,4,QX)
                 CALL ZMMPYI(X2,4+J,MZ2,QX)
                 CALL ZMDIVI_R1(MZ2,4,QX)
                 CALL ZMADD(MZ1,MZ2,X3,QX)
                 F2 = ZMROOT_F(X3,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
                 CALL ZMABS(F2,MXY(1),QX)
                 IF (.NOT. (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV)) THEN
                     CALL ZMEQ(X3,X2,QX)
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      CALL ZMABS(F2,MXY(1),QX)
      IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
          IF (KPRT >= 0) THEN
              WRITE (KU,"(A)") ' '
              WRITE (KU,"(A,A)") ' Invalid input for ZMROOT1. ',  &
                                 ' Unknown or overflowed function value for BX ='
              CALL ZMPRINT(X2,QX)
              WRITE (KU,"(A)") ' '
          ENDIF
          J = 0
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',X2,QX)
          CALL FMST2M(' UNKNOWN ',ERR,QX)
          GO TO 110
      ENDIF

!             Secant does not do well if the magnitudes of the two starting function values differ
!             by too much.  Adjust if necessary.

      DO J = 1, 10
         CALL ZMDIV(F2,F1,MZ1,QX)
         CALL ZMABS(MZ1,MXY(1),QX)
         CALL ZMDIV(F1,F2,MZ1,QX)
         CALL ZMABS(MZ1,MXY(2),QX)
         CALL FMI2M(10,MXY(3),QX)
         IF (FMCOMP(MXY(1),'>',MXY(3),QX)) THEN
             CALL ZMADD(X1,X2,MZ1,QX)
             CALL ZMDIVI(MZ1,2,X2,QX)
             F2 = ZMROOT_F(X2,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
         ELSE IF (FMCOMP(MXY(2),'>',MXY(3),QX)) THEN
             CALL ZMADD(X1,X2,MZ1,QX)
             CALL ZMDIVI(MZ1,2,X1,QX)
             F1 = ZMROOT_F(X1,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
         ELSE
             EXIT
         ENDIF
      ENDDO

      IF (KPRT == 2) THEN
          CALL ZMFORM('ES20.10','ES20.10',F1,STR,QX)
          WRITE (KU,"('  J =',I3,3X,'f(AX) = ',A,'    x:')") 0,TRIM(STR)
          CALL ZMPRINT(X1,QX)
          CALL ZMFORM('ES20.10','ES20.10',F2,STR,QX)
          WRITE (KU,"('  J =',I3,3X,'f(BX) = ',A,'    x:')") 0,TRIM(STR)
          CALL ZMPRINT(X2,QX)
      ENDIF

!             This loop does the iteration.

      DO J = 1, MAXIT

         CALL ZMSUB(F2,F1,MZ1,QX)
         CALL ZMABS(MZ1,MXY(1),QX)
         IF (MXY(1)%MP(3) /= 0) THEN
             CALL ZMSUB(X2,X1,MZ1,QX)
             CALL ZMSUB(F2,F1,MZ2,QX)
             CALL ZMDIV_R1(MZ1,MZ2,QX)
             CALL ZMMPY_R1(MZ1,F2,QX)
             CALL ZMSUB(X2,MZ1,X3,QX)
         ELSE
             CALL ZMI2M(1,MZ1,QX)
             CALL ZMADD(X2,MZ1,X3,QX)
         ENDIF

!             Multiple roots cause very slow convergence and loss of accuracy.
!             If the slope is very small, try to improve convergence and accuracy by using
!             the (slower) function  f(x)/f'(x)  which has no multiple roots.

         CALL ZMEQ(X1,X1OLD,QX)
         CALL ZMEQ(F1,F1OLD,QX)
         CALL ZMSUB(X2,X1,MZ1,QX)
         CALL ZMSUB(F2,F1,MZ2,QX)
         CALL ZMDIV_R1(MZ2,MZ1,QX)
         CALL ZMABS(MZ2,MXY(1),QX)
         CALL FMST2M('1.0D-2',MXY(2),QX)
         CALL ZMABS(F2,MXY(3),QX)
         CALL FMST2M('1.0D-4',MXY(4),QX)
         CALL ZMDIV(F2,MZ2,MZ1,QX)
         CALL ZMABS(MZ1,MXY(5),QX)
         CALL ZMDIVI(X2,10000,MZ1,QX)
         CALL ZMABS(MZ1,MXY(6),QX)
         IF ( (FMCOMP(MXY(1),'<',MXY(2),QX) .AND. FMCOMP(MXY(3),'<',MXY(4),QX) .AND.  &
               FMCOMP(MXY(5),'<',MXY(6),QX)) .OR. USE_F_OVER_FP) THEN
             USE_F_OVER_FP = .TRUE.
             CALL ZMEQ(X2,X1,QX)
             CALL ZMEQ(X3,X2,QX)
             CALL ZMEQ(F2,F1,QX)
             IF (REMOVE_PREVIOUS_ROOTS) THEN
                 FP0 = ZMFPRIME2(0,X3,F,NF,QX)
                 FP1 = ZMFPRIME2(1,X3,F,NF,QX)
                 CALL ZMI2M(0,S,QX)
                 CALL ZMI2M(1,MZ1,QX)
                 DO K = 1, N_FOUND
                    CALL ZMSUB(X3,LIST_OF_ROOTS(K)%MZM,MZ2,QX)
                    CALL ZMDIV_R2(MZ1,MZ2,QX)
                    CALL ZMADD_R1(S,MZ2,QX)
                 ENDDO
                 CALL ZMMPY(FP0,S,MZ1,QX)
                 CALL ZMSUB(FP1,MZ1,MZ2,QX)
                 CALL ZMDIV(FP0,MZ2,F2,QX)
             ELSE
                 MZ1 = ZMFPRIME2(0,X3,F,NF,QX)
                 MZ2 = ZMFPRIME2(1,X3,F,NF,QX)
                 CALL ZMDIV(MZ1,MZ2,F2,QX)
             ENDIF
         ELSE
             CALL ZMEQ(X2,X1,QX)
             CALL ZMEQ(X3,X2,QX)
             CALL ZMEQ(F2,F1,QX)
             F2 = ZMROOT_F(X3,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)

!             If the function has a large number of roots, like a high-degree polynomial, then
!             from a distance the function looks like it has multiple roots even though once we
!             get closer the roots appear distinct.  This can slow the rate of convergence in
!             the early iterations.  Try an Aitken extrapolation once every few steps to try to
!             speed up this initial phase of convergence.

             CALL ZMMPYI(X1,2,MZ1,QX)
             CALL ZMSUB(X2,MZ1,MZ2,QX)
             CALL ZMADD(MZ2,X1OLD,MZ1,QX)
             CALL ZMABS(MZ1,MXY(1),QX)
             IF (MOD(J,5) == 0 .AND. MXY(1)%MP(3) /= 0) THEN
                 CALL ZMSUB(X2,X1,MZ2,QX)
                 CALL ZMDIV_R1(MZ2,MZ1,QX)
                 CALL ZMSUB(X2,MZ2,S,QX)
                 FS = ZMROOT_F(S,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
                 CALL ZMABS(F1,MXY(1),QX)
                 CALL ZMABS(F2,MXY(2),QX)
                 CALL FMMAX(MXY(1),MXY(2),MXY(3),QX)
                 CALL ZMABS(FS,MXY(1),QX)
                 IF (FMCOMP(MXY(1),'<',MXY(3),QX)) THEN
                     CALL ZMEQ(X2,X1,QX)
                     CALL ZMEQ(F2,F1,QX)
                     CALL ZMEQ(S,X2,QX)
                     CALL ZMEQ(FS,F2,QX)
                 ENDIF
             ENDIF
         ENDIF

!             If F2 is one of the FM non-numbers, +-underflow, +-overflow, unknown,
!             then replace it by something representable, so that the next x3 will be
!             closer to x1.  Also swap x1 and x2, making the bad x go away first.

         CALL ZMABS(F2,MXY(1),QX)
         IF (MXY(1)%MP(2) == QX%MUNKNO .OR. MXY(1)%MP(2) == QX%MEXPOV) THEN
             CALL ZMMPYI(F1,-2,F2,QX)
             CALL ZMEQ(X1,X3,QX)
             CALL ZMEQ(X2,X1,QX)
             CALL ZMEQ(X3,X2,QX)
             CALL ZMEQ(F1,X3,QX)
             CALL ZMEQ(F2,F1,QX)
             CALL ZMEQ(X3,F2,QX)
         ENDIF

!             A common failure mode for secant is to get into a pattern that repeats x1 and x2
!             close together with nearly equal function values and x3 farther away with much
!             larger function value.  Check for this, and re-start the iteration by choosing
!             a different x3.

         CALL ZMABS(F2,MXY(1),QX)
         CALL ZMABS(F1OLD,MXY(2),QX)
         CALL ZMABS(F1,MXY(3),QX)
         CALL FMMAX(MXY(2),MXY(3),MXY(4),QX)
         CALL FMMPYI(MXY(4),100,MXY(2),QX)
         IF (FMCOMP(MXY(1),'>',MXY(2),QX) .AND. J >= JSET) THEN
             JSET = JSET + 5
             VALUE = (MOD(277*J,1001) + 1) / 1002.0D0
             VALUE = 9*VALUE - 4
             CALL FMDP2M(VALUE,MXY(1),QX)
             CALL FMI2M(0,MXY(2),QX)
             CALL ZMCMPX(MXY(1),MXY(2),MZ1,QX)
             CALL ZMI2M(1,MZ2,QX)
             CALL ZMSUB_R1(MZ2,MZ1,QX)
             CALL ZMMPY_R1(MZ1,X1,QX)
             CALL ZMMPY_R1(MZ2,X2,QX)
             CALL ZMADD(MZ1,MZ2,X2,QX)
             F2 = ZMROOT_F(X2,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)
         ENDIF

         IF (KPRT == 2) THEN
             CALL ZMFORM('ES20.10','ES20.10',F2,STR,QX)
             WRITE (KU,"('  J =',I3,4X,'f(x) = ' ,A,'    x:')") J,TRIM(STR)
             CALL ZMPRINT(X2,QX)
         ENDIF

         CALL FMEQ(ERR,ERR1,QX)
         CALL ZMABS(X2,MXY(1),QX)
         IF (MXY(1)%MP(3) /= 0) THEN
             CALL ZMSUB(X2,X1,MZ1,QX)
             CALL ZMDIV_R1(MZ1,X2,QX)
             CALL ZMABS(MZ1,ERR,QX)
         ELSE
             CALL ZMSUB(X2,X1,MZ1,QX)
             CALL ZMABS(MZ1,ERR,QX)
         ENDIF

!             If the error is less than the tolerance, double check to make sure the previous
!             error was small along with the current function value.  Some divergent iterations
!             can get err < tol without being close to a root.

         CALL ZMABS(F2,MXY(1),QX)
         IF (FMCOMP(ERR,'<',TOL,QX) .OR. MXY(1)%MP(3) == 0) THEN
             CALL FMSQRT(TOL,MXY(3),QX)
             CALL FMSQRT(MXY(3),MXY(2),QX)
             CALL FMI2M(1,MXY(3),QX)
             CALL FMULP(MXY(3),MXY(4),QX)
             CALL FMSQRT(MXY(4),MXY(3),QX)
             IF (FMCOMP(ERR1,'>',MXY(2),QX) .AND. FMCOMP(MXY(1),'>',MXY(3),QX)) THEN
                 IF (KPRT >= 0) THEN
                     WRITE (KU,"(/' Possible false convergence in ZMROOT1 after',I5,"//  &
                               "' iterations.  ','Last two approximations =')") J
                     CALL ZMPRINT(X1,QX)
                     CALL ZMPRINT(X2,QX)
                     WRITE (KU,"(/' These agree to the convergence tolerance, but the previous"//  &
                               " iteration was suspiciously far away:')")
                     CALL ZMPRINT(X1OLD,QX)
                     WRITE (KU,"(/' and the function value of the last iteration was"//  &
                               " suspiciously far from zero:')")
                     CALL ZMPRINT(F2,QX)
                     WRITE (KU,"(/' Unknown has been returned.')")
                 ENDIF
                 CALL ZMST2M(' UNKNOWN + UNKNOWN i ',X2,QX)
             ENDIF
             GO TO 110
         ENDIF

      ENDDO

!             No convergence after maxit iterations.

      IF (KPRT >= 0) THEN
          WRITE (KU,"(/' No convergence in ZMROOT1 after',I5,' iterations.  ',"//  &
                    "'Last two approximations =')") MAXIT
          CALL ZMPRINT(X1,QX)
          CALL ZMPRINT(X2,QX)
          WRITE (KU,"(/' Unknown has been returned.')")
      ENDIF
      CALL ZMST2M(' UNKNOWN + UNKNOWN i ',X2,QX)

!             The root was found.

  110 CALL ZMEQU(X2,ROOT,QX%NDIG,NDSAVE,QX)
      QX%NDIG = NDSAVE
      IF (KPRT >= 1) THEN
          CALL ZMABS(X2,T,QX)
          CALL FMULP(T,ERR1,QX)
          IF (.NOT. (ERR1%MP(2) == QX%MUNKNO .OR. ERR1%MP(2) == QX%MEXPUN)) THEN
              CALL FMDIV(ERR1,T,MXY(1),QX)
              CALL FMDIVI(MXY(1),2,ERR1,QX)
              IF (FMCOMP(ERR,'<',ERR1,QX)) CALL FMEQ(ERR1,ERR,QX)
          ENDIF
          CALL FMFORM('ES16.6',ERR,STR,QX)
          WRITE (KU,"(A)") ' '
          WRITE (KU,"('  ZMROOT1.   Function ',I3,I7,' iterations.'/17X"// &
                    "'Estimated relative error =',A,',    Root:')") NF,J,TRIM(STR)
          CALL ZMPRINT(ROOT,QX)
          WRITE (KU,"(A)") ' '
      ENDIF

      QX%KWARN = KWARN_SAVE
      END SUBROUTINE ZMROOT1

      FUNCTION ZMROOT_F(X,F,NF,REMOVE_PREVIOUS_ROOTS,N_FOUND,LIST_OF_ROOTS,NDIG_OF_ROOTS,QX)  &
                        RESULT (RETURN_VALUE)
      USE FMVALS_PARALLEL
      USE FMZM_PARALLEL
      IMPLICIT NONE

!  ZMROOT_F is used here to evaluate the user's function F and divide F by the product of
!  (X - LIST_OF_ROOTS(j)) over the roots that have been found so far.  This should keep the
!  ZMROOT1 routine from returning to a root that is already on the list (unless it is a
!  root of multiplicity M > 1).

!  When REMOVE_PREVIOUS_ROOTS is false, just evaluate F without doing the division.

!  X  is the argument to the function.
!  NF is the function number.

    INTERFACE
      FUNCTION F(XI,NI,QX)
      USE FMVALS_PARALLEL
      IMPLICIT NONE
      TYPE (MULTI) :: XI(2)
      INTEGER :: NI
      TYPE (MULTI), DIMENSION(2) :: F
      TYPE(FM_SETTINGS) :: QX
      END FUNCTION F
    END INTERFACE
      INTEGER :: J, NDIG_OF_ROOTS, NF, N_FOUND
      LOGICAL :: REMOVE_PREVIOUS_ROOTS
      TYPE (ZM) :: LIST_OF_ROOTS(N_FOUND)
      TYPE (MULTI) :: RETURN_VALUE(2), X(2)
      TYPE (MULTI) :: D(2), S(2), MXY
      TYPE(FM_SETTINGS) :: QX

      IF (REMOVE_PREVIOUS_ROOTS) THEN
          S = F(X,NF,QX)
          DO J = 1, N_FOUND
             CALL ZMEQU(LIST_OF_ROOTS(J)%MZM,D,NDIG_OF_ROOTS,QX%NDIG,QX)
             CALL ZMSUB_R2(X,D,QX)
             CALL ZMABS(D,MXY,QX)
             IF (MXY%MP(3) /= 0) THEN
                 CALL ZMDIV_R1(S,D,QX)
             ENDIF
          ENDDO
          RETURN_VALUE = S
      ELSE
          S = F(X,NF,QX)
          RETURN_VALUE = S
      ENDIF

      END FUNCTION ZMROOT_F
