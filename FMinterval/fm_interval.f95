
 MODULE FM_INTERVAL_ARITHMETIC_1


!  FM_interval 1.4                        David M. Smith                        Interval Arithmetic

!  This module extends the definition of the basic Fortran arithmetic and function operations so
!  they also apply to multiple precision intervals, using version 1.4 of FM.
!  The multiple precision interval data type is called
!    TYPE (FM_INTERVAL)

!  Each FM interval consists of two endpoints, with each endpoint being a TYPE(FM) multiple
!  precision number.  The first of these endpoints defines the left endpoint of an interval,
!  and the second defines the right endpoint of the interval.

!  Most of the functions defined in this module are multiple precision interval versions of standard
!  Fortran functions.  In addition, there are functions for direct conversion, formatting, and some
!  mathematical special functions.

!  TO_FM_INTERVAL is a function for converting other types of numbers to type FM_INTERVAL.
!  Like the TO_FM function in module FMZM, TO_FM_INTERVAL(3.12) converts the REAL constant
!  to an FM interval, but it is accurate only to single precision.  TO_FM_INTERVAL(3.12D0)
!  agrees with 3.12 to double precision accuracy, and TO_FM_INTERVAL('3.12') or
!  TO_FM_INTERVAL(312)/TO_FM_INTERVAL(100) agrees to full FM accuracy.


    USE FMZM


!  For all comparisons except == and /=, the order is not well defined if intervals overlap.
!  In those cases, the midpoints of the intervals are compared.

    TYPE FM_INTERVAL
         TYPE(MULTI) :: LEFT
         TYPE(MULTI) :: RIGHT
    END TYPE

!             Work variables for derived type operations.

    TYPE (FM_INTERVAL), SAVE :: MTFM_I, MUFM_I, MVFM_I, MWFM_I, M0FM_I, M1FM_I, M2FM_I, M3FM_I
    TYPE (FM_INTERVAL), SAVE :: M4FM_I, M5FM_I, M6FM_I, M7FM_I, M8FM_I, M9FM_I
    TYPE (FM), SAVE :: M_1, M_2, M_3, M_4, M_5, M_6, M_7, M_8, M_9, M_10, M_11, M_12,  &
                       X_EDGE, Y_EDGE, XY_EDGE, F_LEFT, F_RIGHT
    TYPE (ZM), SAVE :: MZ_1
    TYPE(MULTI), SAVE :: MTIM_I, MTZM_I(2)
    INTEGER, PARAMETER :: N_PREV = 10
    INTEGER, SAVE :: NDIG_XY_EDGE, KXY_EDGE, K_ROUTINE_EDGE, KROUND_PREV(0:N_PREV-1),  &
                     ROUTINE_PREV(0:N_PREV-1), NUM_PREV = 0
    TYPE (FM), SAVE :: M1_PREV(0:N_PREV-1), M2_PREV(0:N_PREV-1),  &
                       M3_PREV(0:N_PREV-1)

   INTERFACE TO_FM_INTERVAL

!             Create an interval by giving both endpoints.

      MODULE PROCEDURE INTERVAL_FM_I
      MODULE PROCEDURE INTERVAL_FM_R
      MODULE PROCEDURE INTERVAL_FM_D
      MODULE PROCEDURE INTERVAL_FM_Z
      MODULE PROCEDURE INTERVAL_FM_ZD
      MODULE PROCEDURE INTERVAL_FM_FM
      MODULE PROCEDURE INTERVAL_FM_IM
      MODULE PROCEDURE INTERVAL_FM_ZM
      MODULE PROCEDURE INTERVAL_FM_ST

!             Convert single values to intervals with both endpoints the same.

      MODULE PROCEDURE FM_INTERVAL_I
      MODULE PROCEDURE FM_INTERVAL_R
      MODULE PROCEDURE FM_INTERVAL_D
      MODULE PROCEDURE FM_INTERVAL_Z
      MODULE PROCEDURE FM_INTERVAL_ZD
      MODULE PROCEDURE FM_INTERVAL_FM
      MODULE PROCEDURE FM_INTERVAL_FMA
      MODULE PROCEDURE FM_INTERVAL_IM
      MODULE PROCEDURE FM_INTERVAL_ZM
      MODULE PROCEDURE FM_INTERVAL_ST
      MODULE PROCEDURE FM_INTERVAL_I1
      MODULE PROCEDURE FM_INTERVAL_R1
      MODULE PROCEDURE FM_INTERVAL_D1
      MODULE PROCEDURE FM_INTERVAL_Z1
      MODULE PROCEDURE FM_INTERVAL_ZD1
      MODULE PROCEDURE FM_INTERVAL_FM1
      MODULE PROCEDURE FM_INTERVAL_FMA1
      MODULE PROCEDURE FM_INTERVAL_IM1
      MODULE PROCEDURE FM_INTERVAL_ZM1
      MODULE PROCEDURE FM_INTERVAL_ST1
      MODULE PROCEDURE FM_INTERVAL_I2
      MODULE PROCEDURE FM_INTERVAL_R2
      MODULE PROCEDURE FM_INTERVAL_D2
      MODULE PROCEDURE FM_INTERVAL_Z2
      MODULE PROCEDURE FM_INTERVAL_ZD2
      MODULE PROCEDURE FM_INTERVAL_FM2
      MODULE PROCEDURE FM_INTERVAL_FMA2
      MODULE PROCEDURE FM_INTERVAL_IM2
      MODULE PROCEDURE FM_INTERVAL_ZM2
      MODULE PROCEDURE FM_INTERVAL_ST2
   END INTERFACE

!             Return the left or right endpoint of an interval as a type (fm) number.

   INTERFACE LEFT_ENDPOINT
      MODULE PROCEDURE LEFT_ENDPOINT_INTERVAL_FM
   END INTERFACE

   INTERFACE RIGHT_ENDPOINT
      MODULE PROCEDURE RIGHT_ENDPOINT_INTERVAL_FM
   END INTERFACE

   INTERFACE TO_FM
      MODULE PROCEDURE FM_FM_INTERVAL
      MODULE PROCEDURE FM_FM_INTERVAL1
      MODULE PROCEDURE FM_FM_INTERVAL2
   END INTERFACE

   INTERFACE TO_IM
      MODULE PROCEDURE IM_FM_INTERVAL
      MODULE PROCEDURE IM_FM_INTERVAL1
      MODULE PROCEDURE IM_FM_INTERVAL2
   END INTERFACE

   INTERFACE TO_ZM
      MODULE PROCEDURE ZM_FM_INTERVAL
      MODULE PROCEDURE ZM_FM_INTERVAL1
      MODULE PROCEDURE ZM_FM_INTERVAL2
   END INTERFACE

   INTERFACE TO_INT
      MODULE PROCEDURE FM_INTERVAL_2INT
      MODULE PROCEDURE FM_INTERVAL_2INT1
      MODULE PROCEDURE FM_INTERVAL_2INT2
   END INTERFACE

   INTERFACE TO_SP
      MODULE PROCEDURE FM_INTERVAL_2SP
      MODULE PROCEDURE FM_INTERVAL_2SP1
      MODULE PROCEDURE FM_INTERVAL_2SP2
   END INTERFACE

   INTERFACE TO_DP
      MODULE PROCEDURE FM_INTERVAL_2DP
      MODULE PROCEDURE FM_INTERVAL_2DP1
      MODULE PROCEDURE FM_INTERVAL_2DP2
   END INTERFACE

   INTERFACE TO_SPZ
      MODULE PROCEDURE FM_INTERVAL_2SPZ
      MODULE PROCEDURE FM_INTERVAL_2SPZ1
      MODULE PROCEDURE FM_INTERVAL_2SPZ2
   END INTERFACE

   INTERFACE TO_DPZ
      MODULE PROCEDURE FM_INTERVAL_2DPZ
      MODULE PROCEDURE FM_INTERVAL_2DPZ1
      MODULE PROCEDURE FM_INTERVAL_2DPZ2
   END INTERFACE

   INTERFACE IS_OVERFLOW
      MODULE PROCEDURE FM_INTERVAL_IS_OVERFLOW
      MODULE PROCEDURE FM_INTERVAL_IS_OVERFLOW1
      MODULE PROCEDURE FM_INTERVAL_IS_OVERFLOW2
   END INTERFACE

   INTERFACE IS_UNDERFLOW
      MODULE PROCEDURE FM_INTERVAL_IS_UNDERFLOW
      MODULE PROCEDURE FM_INTERVAL_IS_UNDERFLOW1
      MODULE PROCEDURE FM_INTERVAL_IS_UNDERFLOW2
   END INTERFACE

   INTERFACE IS_UNKNOWN
      MODULE PROCEDURE FM_INTERVAL_IS_UNKNOWN
      MODULE PROCEDURE FM_INTERVAL_IS_UNKNOWN1
      MODULE PROCEDURE FM_INTERVAL_IS_UNKNOWN2
   END INTERFACE

   INTERFACE FM_INTERVAL_UNDEF_INP
      MODULE PROCEDURE FM_UNDEF_INP_INTERVAL_FM0
      MODULE PROCEDURE FM_UNDEF_INP_INTERVAL_FM1
      MODULE PROCEDURE FM_UNDEF_INP_INTERVAL_FM2
   END INTERFACE

 CONTAINS

!                                                      TO_FM_INTERVAL

   FUNCTION FM_INTERVAL_I(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      CALL FMI2M_INTERVAL(IVAL,RETURN_VALUE)
   END FUNCTION FM_INTERVAL_I

   FUNCTION FM_INTERVAL_R(R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R
      CALL FMSP2M_INTERVAL(R,RETURN_VALUE)
   END FUNCTION FM_INTERVAL_R

   FUNCTION FM_INTERVAL_D(D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D
      CALL FMDP2M_INTERVAL(D,RETURN_VALUE)
   END FUNCTION FM_INTERVAL_D

   FUNCTION FM_INTERVAL_Z(Z)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      COMPLEX :: Z
      INTENT (IN) :: Z
      CALL FMSP2M_INTERVAL(REAL(Z),RETURN_VALUE)
   END FUNCTION FM_INTERVAL_Z

   FUNCTION FM_INTERVAL_ZD(C)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C
      CALL FMDP2M_INTERVAL(REAL(C,KIND(0.0D0)),RETURN_VALUE)
   END FUNCTION FM_INTERVAL_ZD

   FUNCTION FM_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMMIN(MA%LEFT,MA%RIGHT,RETURN_VALUE%LEFT)
      CALL FMMAX(MA%LEFT,MA%RIGHT,RETURN_VALUE%RIGHT)
   END FUNCTION FM_INTERVAL_FM

   FUNCTION FM_INTERVAL_FMA(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      TYPE (FM) :: MA
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      CALL FMEQ(MA%MFM,RETURN_VALUE%LEFT)
      CALL FMEQ(MA%MFM,RETURN_VALUE%RIGHT)
   END FUNCTION FM_INTERVAL_FMA

   FUNCTION FM_INTERVAL_IM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      CALL IMI2FM(MA%MIM,RETURN_VALUE%LEFT)
      CALL IMI2FM(MA%MIM,RETURN_VALUE%RIGHT)
   END FUNCTION FM_INTERVAL_IM

   FUNCTION FM_INTERVAL_ZM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      TYPE (ZM) :: MA
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      CALL ZMREAL_INTERVAL(MA%MZM,RETURN_VALUE)
   END FUNCTION FM_INTERVAL_ZM

   FUNCTION FM_INTERVAL_ST(ST)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      CHARACTER(*) :: ST
      INTENT (IN) :: ST
      CALL FMST2M_INTERVAL(ST,RETURN_VALUE)
   END FUNCTION FM_INTERVAL_ST

   FUNCTION FM_INTERVAL_I1(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: IVAL
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_I1

   FUNCTION FM_INTERVAL_R1(R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: R
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_R1

   FUNCTION FM_INTERVAL_D1(D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: D
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_D1

   FUNCTION FM_INTERVAL_Z1(Z)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      COMPLEX, DIMENSION(:) :: Z
      TYPE (FM_INTERVAL), DIMENSION(SIZE(Z)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: Z
      N = SIZE(Z)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(REAL(Z(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_Z1

   FUNCTION FM_INTERVAL_ZD1(C)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      TYPE (FM_INTERVAL), DIMENSION(SIZE(C)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: C
      N = SIZE(C)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(REAL(C(J),KIND(0.0D0)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_ZD1

   FUNCTION FM_INTERVAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_FM1

   FUNCTION FM_INTERVAL_FMA1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEQ(MA(J)%MFM,RETURN_VALUE(J)%LEFT)
         CALL FMEQ(MA(J)%MFM,RETURN_VALUE(J)%RIGHT)
      ENDDO
   END FUNCTION FM_INTERVAL_FMA1

   FUNCTION FM_INTERVAL_IM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_IM1

   FUNCTION FM_INTERVAL_ZM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMREAL_INTERVAL(MA(J)%MZM,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_ZM1

   FUNCTION FM_INTERVAL_ST1(ST)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*), DIMENSION(:) :: ST
      TYPE (FM_INTERVAL), DIMENSION(SIZE(ST)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: ST
      N = SIZE(ST)
      DO J = 1, N
         CALL FMST2M_INTERVAL(ST(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_ST1

   FUNCTION FM_INTERVAL_I2(IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: IVAL
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_I2

   FUNCTION FM_INTERVAL_R2(R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: R
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_R2

   FUNCTION FM_INTERVAL_D2(D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: D
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_D2

   FUNCTION FM_INTERVAL_Z2(Z)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      COMPLEX, DIMENSION(:,:) :: Z
      TYPE (FM_INTERVAL), DIMENSION(SIZE(Z,DIM=1),SIZE(Z,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: Z
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            CALL FMSP2M_INTERVAL(REAL(Z(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_Z2

   FUNCTION FM_INTERVAL_ZD2(C)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      TYPE (FM_INTERVAL), DIMENSION(SIZE(C,DIM=1),SIZE(C,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: C
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            CALL FMDP2M_INTERVAL(REAL(C(J,K),KIND(0.0D0)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_ZD2

   FUNCTION FM_INTERVAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_FM2

   FUNCTION FM_INTERVAL_FMA2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MA(J,K)%MFM,RETURN_VALUE(J,K)%LEFT)
            CALL FMEQ(MA(J,K)%MFM,RETURN_VALUE(J,K)%RIGHT)
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_FMA2

   FUNCTION FM_INTERVAL_IM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_IM2

   FUNCTION FM_INTERVAL_ZM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL_INTERVAL(MA(J,K)%MZM,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_ZM2

   FUNCTION FM_INTERVAL_ST2(ST)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*), DIMENSION(:,:) :: ST
      TYPE (FM_INTERVAL), DIMENSION(SIZE(ST,DIM=1),SIZE(ST,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: ST
      DO J = 1, SIZE(ST,DIM=1)
         DO K = 1, SIZE(ST,DIM=2)
            CALL FMST2M_INTERVAL(ST(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_ST2

   FUNCTION INTERVAL_FM_I(IVAL1,IVAL2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      INTEGER :: IVAL1,IVAL2,IV1,IV2
      INTENT (IN) :: IVAL1,IVAL2
      IV1 = MIN(IVAL1,IVAL2)
      IV2 = MAX(IVAL1,IVAL2)
      CALL FMI2M(IV1,RETURN_VALUE%LEFT)
      CALL FMI2M(IV2,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_I

   FUNCTION INTERVAL_FM_R(R1,R2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      REAL :: R1,R2,RV1,RV2
      INTENT (IN) :: R1,R2
      RV1 = MIN(R1,R2)
      RV2 = MAX(R1,R2)
      CALL FMSP2M(RV1,RETURN_VALUE%LEFT)
      CALL FMSP2M(RV2,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_R

   FUNCTION INTERVAL_FM_D(D1,D2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      DOUBLE PRECISION :: D1,D2,DV1,DV2
      INTENT (IN) :: D1,D2
      DV1 = MIN(D1,D2)
      DV2 = MAX(D1,D2)
      CALL FMDP2M(DV1,RETURN_VALUE%LEFT)
      CALL FMDP2M(DV2,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_D

   FUNCTION INTERVAL_FM_Z(Z1,Z2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      COMPLEX :: Z1,Z2
      REAL :: RV1,RV2
      INTENT (IN) :: Z1,Z2
      RV1 = MIN(REAL(Z1),REAL(Z2))
      RV2 = MAX(REAL(Z1),REAL(Z2))
      CALL FMSP2M(RV1,RETURN_VALUE%LEFT)
      CALL FMSP2M(RV2,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_Z

   FUNCTION INTERVAL_FM_ZD(C1,C2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      COMPLEX (KIND(0.0D0)) :: C1,C2
      DOUBLE PRECISION :: DV1,DV2
      INTENT (IN) :: C1,C2
      DV1 = MIN(REAL(C1,KIND(0.0D0)),REAL(C2,KIND(0.0D0)))
      DV2 = MAX(REAL(C1,KIND(0.0D0)),REAL(C2,KIND(0.0D0)))
      CALL FMDP2M(DV1,RETURN_VALUE%LEFT)
      CALL FMDP2M(DV2,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_ZD

   FUNCTION INTERVAL_FM_FM(M1,M2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      TYPE (FM) :: M1,M2
      INTENT (IN) :: M1,M2
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM
      CALL FM_UNDEF_INP(M1)
      CALL FM_UNDEF_INP(M2)
      CALL FMMIN(M1%MFM,M2%MFM,MTLVFM)
      CALL FMMAX(M1%MFM,M2%MFM,MULVFM)
      CALL FMEQ(MTLVFM,RETURN_VALUE%LEFT)
      CALL FMEQ(MULVFM,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_FM

   FUNCTION INTERVAL_FM_IM(M1,M2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      TYPE (IM) :: M1,M2
      INTENT (IN) :: M1,M2
      TYPE(MULTI), SAVE :: MTLVIM,MULVIM
      CALL FM_UNDEF_INP(M1)
      CALL FM_UNDEF_INP(M2)
      CALL IMMIN(M1%MIM,M2%MIM,MTLVIM)
      CALL IMMAX(M1%MIM,M2%MIM,MULVIM)
      CALL IMI2FM(MTLVIM,RETURN_VALUE%LEFT)
      CALL IMI2FM(MULVIM,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_IM

   FUNCTION INTERVAL_FM_ZM(M1,M2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      TYPE (ZM) :: M1,M2
      INTENT (IN) :: M1,M2
      TYPE(MULTI), SAVE :: M1LVFM,M2LVFM
      CALL FM_UNDEF_INP(M1)
      CALL FM_UNDEF_INP(M2)
      CALL ZMREAL(M1%MZM,M1LVFM)
      CALL ZMREAL(M2%MZM,M2LVFM)
      CALL FMMIN(M1LVFM,M2LVFM,RETURN_VALUE%LEFT)
      CALL FMMAX(M1LVFM,M2LVFM,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_ZM

   FUNCTION INTERVAL_FM_ST(S1,S2)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: RETURN_VALUE
      CHARACTER(*) :: S1,S2
      INTENT (IN) :: S1,S2
      TYPE(MULTI), SAVE :: M1LVFM,M2LVFM
      CALL FMST2M(S1,M1LVFM)
      CALL FMST2M(S2,M2LVFM)
      CALL FMMIN(M1LVFM,M2LVFM,RETURN_VALUE%LEFT)
      CALL FMMAX(M1LVFM,M2LVFM,RETURN_VALUE%RIGHT)
   END FUNCTION INTERVAL_FM_ST

!                                                               LEFT_ENDPOINT

   FUNCTION LEFT_ENDPOINT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FMEQ(MA%LEFT,RETURN_VALUE%MFM)
   END FUNCTION LEFT_ENDPOINT_INTERVAL_FM

!                                                               RIGHT_ENDPOINT

   FUNCTION RIGHT_ENDPOINT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FMEQ(MA%RIGHT,RETURN_VALUE%MFM)
   END FUNCTION RIGHT_ENDPOINT_INTERVAL_FM

!                                                               TO_FM

   FUNCTION FM_FM_INTERVAL(MA)     RESULT (RETURN_VALUE)

!  When converting an interval to a non-interval value, use the midpoint.

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: RETURN_VALUE
      INTENT (IN) :: MA
      TYPE(MULTI), SAVE :: MTLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSUB(MA%RIGHT,MA%LEFT,MTLVFM)
      CALL FMDIVI_R1(MTLVFM,2)
      CALL FMADD(MA%LEFT,MTLVFM,RETURN_VALUE%MFM)
   END FUNCTION FM_FM_INTERVAL

   FUNCTION FM_FM_INTERVAL1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      TYPE(MULTI), SAVE :: MTLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB(MA(J)%RIGHT,MA(J)%LEFT,MTLVFM)
         CALL FMDIVI_R1(MTLVFM,2)
         CALL FMADD(MA(J)%LEFT,MTLVFM,RETURN_VALUE(J)%MFM)
      ENDDO
   END FUNCTION FM_FM_INTERVAL1

   FUNCTION FM_FM_INTERVAL2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      TYPE(MULTI), SAVE :: MTLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB(MA(J,K)%RIGHT,MA(J,K)%LEFT,MTLVFM)
            CALL FMDIVI_R1(MTLVFM,2)
            CALL FMADD(MA(J,K)%LEFT,MTLVFM,RETURN_VALUE(J,K)%MFM)
         ENDDO
      ENDDO
   END FUNCTION FM_FM_INTERVAL2

!                                                               TO_IM

   FUNCTION IM_FM_INTERVAL(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL IMFM2I_INTERVAL(MA,RETURN_VALUE%MIM)
   END FUNCTION IM_FM_INTERVAL

   FUNCTION IM_FM_INTERVAL1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL IMFM2I_INTERVAL(MA(J),RETURN_VALUE(J)%MIM)
      ENDDO
   END FUNCTION IM_FM_INTERVAL1

   FUNCTION IM_FM_INTERVAL2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMFM2I_INTERVAL(MA(J,K),RETURN_VALUE(J,K)%MIM)
         ENDDO
      ENDDO
   END FUNCTION IM_FM_INTERVAL2

!                                                               TO_ZM

   FUNCTION ZM_FM_INTERVAL(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (ZM) :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(0,MUFM_I)
      CALL ZMCMPX_INTERVAL(MA,MUFM_I,RETURN_VALUE)
   END FUNCTION ZM_FM_INTERVAL

   FUNCTION ZM_FM_INTERVAL1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(0,MUFM_I)
      DO J = 1, N
         CALL ZMCMPX_INTERVAL(MA(J),MUFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION ZM_FM_INTERVAL1

   FUNCTION ZM_FM_INTERVAL2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(0,MUFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX_INTERVAL(MA(J,K),MUFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION ZM_FM_INTERVAL2

!                                                              TO_INT

   FUNCTION FM_INTERVAL_2INT(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2I_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FM_INTERVAL_2INT

   FUNCTION FM_INTERVAL_2INT1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2I_INTERVAL(MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_2INT1

   FUNCTION FM_INTERVAL_2INT2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2I_INTERVAL(MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_2INT2

!                                                               TO_SP

   FUNCTION FM_INTERVAL_2SP(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2SP_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FM_INTERVAL_2SP

   FUNCTION FM_INTERVAL_2SP1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      REAL, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2SP_INTERVAL(MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_2SP1

   FUNCTION FM_INTERVAL_2SP2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      REAL, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP_INTERVAL(MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_2SP2

!                                                               TO_DP

   FUNCTION FM_INTERVAL_2DP(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2DP_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FM_INTERVAL_2DP

   FUNCTION FM_INTERVAL_2DP1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2DP_INTERVAL(MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FM_INTERVAL_2DP1

   FUNCTION FM_INTERVAL_2DP2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP_INTERVAL(MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_2DP2

!                                                              TO_SPZ

   FUNCTION FM_INTERVAL_2SPZ(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX :: RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2SP_INTERVAL(MA,R)
      RETURN_VALUE = CMPLX( R , 0.0 )
   END FUNCTION FM_INTERVAL_2SPZ

   FUNCTION FM_INTERVAL_2SPZ1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2SP_INTERVAL(MA(J),R)
         RETURN_VALUE(J) = CMPLX( R , 0.0 )
      ENDDO
   END FUNCTION FM_INTERVAL_2SPZ1

   FUNCTION FM_INTERVAL_2SPZ2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP_INTERVAL(MA(J,K),R)
            RETURN_VALUE(J,K) = CMPLX( R , 0.0 )
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_2SPZ2

!                                                              TO_DPZ

   FUNCTION FM_INTERVAL_2DPZ(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)) :: RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2DP_INTERVAL(MA,D)
      RETURN_VALUE = CMPLX( D , 0.0D0 , KIND(0.0D0) )
   END FUNCTION FM_INTERVAL_2DPZ

   FUNCTION FM_INTERVAL_2DPZ1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMM2DP_INTERVAL(MA(J),D)
         RETURN_VALUE(J) = CMPLX( D , 0.0D0 , KIND(0.0D0) )
      ENDDO
   END FUNCTION FM_INTERVAL_2DPZ1

   FUNCTION FM_INTERVAL_2DPZ2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP_INTERVAL(MA(J,K),D)
            RETURN_VALUE(J,K) = CMPLX( D , 0.0D0 , KIND(0.0D0) )
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_2DPZ2

!                                                         IS_OVERFLOW

   FUNCTION FM_INTERVAL_IS_OVERFLOW(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = .FALSE.
      IF (MA%LEFT%MP(2) == MEXPOV) RETURN_VALUE = .TRUE.
      IF (MA%RIGHT%MP(2) == MEXPOV) RETURN_VALUE = .TRUE.
   END FUNCTION FM_INTERVAL_IS_OVERFLOW

   FUNCTION FM_INTERVAL_IS_OVERFLOW1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%LEFT%MP(2) == MEXPOV) RETURN_VALUE = .TRUE.
         IF (MA(J)%RIGHT%MP(2) == MEXPOV) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION FM_INTERVAL_IS_OVERFLOW1

   FUNCTION FM_INTERVAL_IS_OVERFLOW2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%LEFT%MP(2) == MEXPOV) RETURN_VALUE = .TRUE.
            IF (MA(J,K)%RIGHT%MP(2) == MEXPOV) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_IS_OVERFLOW2

!                                                        IS_UNDERFLOW

   FUNCTION FM_INTERVAL_IS_UNDERFLOW(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = .FALSE.
      IF (MA%LEFT%MP(2) == MEXPUN) RETURN_VALUE = .TRUE.
      IF (MA%RIGHT%MP(2) == MEXPUN) RETURN_VALUE = .TRUE.
   END FUNCTION FM_INTERVAL_IS_UNDERFLOW

!  The integer versions are included for completeness, but type (im) numbers can't underflow.

   FUNCTION FM_INTERVAL_IS_UNDERFLOW1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%LEFT%MP(2) == MEXPUN) RETURN_VALUE = .TRUE.
         IF (MA(J)%RIGHT%MP(2) == MEXPUN) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION FM_INTERVAL_IS_UNDERFLOW1

   FUNCTION FM_INTERVAL_IS_UNDERFLOW2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%LEFT%MP(2) == MEXPUN) RETURN_VALUE = .TRUE.
            IF (MA(J,K)%RIGHT%MP(2) == MEXPUN) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_IS_UNDERFLOW2

!                                                          IS_UNKNOWN

   FUNCTION FM_INTERVAL_IS_UNKNOWN(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      LOGICAL :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = .FALSE.
      IF (MA%LEFT%MP(2) == MUNKNO) RETURN_VALUE = .TRUE.
      IF (MA%RIGHT%MP(2) == MUNKNO) RETURN_VALUE = .TRUE.
   END FUNCTION FM_INTERVAL_IS_UNKNOWN

   FUNCTION FM_INTERVAL_IS_UNKNOWN1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, N
         IF (MA(J)%LEFT%MP(2) == MUNKNO) RETURN_VALUE = .TRUE.
         IF (MA(J)%RIGHT%MP(2) == MUNKNO) RETURN_VALUE = .TRUE.
      ENDDO
   END FUNCTION FM_INTERVAL_IS_UNKNOWN1

   FUNCTION FM_INTERVAL_IS_UNKNOWN2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      LOGICAL :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = .FALSE.
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (MA(J,K)%LEFT%MP(2) == MUNKNO) RETURN_VALUE = .TRUE.
            IF (MA(J,K)%RIGHT%MP(2) == MUNKNO) RETURN_VALUE = .TRUE.
         ENDDO
      ENDDO
   END FUNCTION FM_INTERVAL_IS_UNKNOWN2

   SUBROUTINE FM_TO_FMA(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA
      TYPE(MULTI), SAVE :: MTLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSUB(MA%RIGHT,MA%LEFT,MTLVFM)
      CALL FMDIVI_R1(MTLVFM,2)
      CALL FMADD(MA%LEFT,MTLVFM,MB%MFM)
   END SUBROUTINE FM_TO_FMA

   SUBROUTINE FM_UNDEF_INP_INTERVAL_FM0(MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      IF (.NOT. ALLOCATED(MA%LEFT%MP)) CALL FM_INPUT_ERROR
      IF (.NOT. ALLOCATED(MA%RIGHT%MP)) CALL FM_INPUT_ERROR
   END SUBROUTINE FM_UNDEF_INP_INTERVAL_FM0

   SUBROUTINE FM_UNDEF_INP_INTERVAL_FM1(MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J
      INTENT (IN) :: MA
      DO J = 1, SIZE(MA)
         IF (.NOT. ALLOCATED(MA(J)%LEFT%MP)) CALL FM_INPUT_ERROR1(J)
         IF (.NOT. ALLOCATED(MA(J)%RIGHT%MP)) CALL FM_INPUT_ERROR1(J)
      ENDDO
   END SUBROUTINE FM_UNDEF_INP_INTERVAL_FM1

   SUBROUTINE FM_UNDEF_INP_INTERVAL_FM2(MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      INTENT (IN) :: MA
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            IF (.NOT. ALLOCATED(MA(J,K)%LEFT%MP)) CALL FM_INPUT_ERROR2(J,K)
            IF (.NOT. ALLOCATED(MA(J,K)%RIGHT%MP)) CALL FM_INPUT_ERROR2(J,K)
         ENDDO
      ENDDO
   END SUBROUTINE FM_UNDEF_INP_INTERVAL_FM2

   SUBROUTINE FMABS_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE
      TYPE(MULTI), SAVE :: MTLVFM
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(1) >= 0) THEN
          CALL FMEQ(MA%LEFT,MB%LEFT)
          CALL FMEQ(MA%RIGHT,MB%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) <= 0) THEN
          CALL FMABS(MA%RIGHT,MB%LEFT)
          CALL FMABS(MA%LEFT,MB%RIGHT)
      ELSE
          CALL FMI2M(0,MB%LEFT)
          CALL FMABS(MA%LEFT,MTLVFM)
          CALL FMMAX(MTLVFM,MA%RIGHT,MB%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
   END SUBROUTINE FMABS_INTERVAL

   SUBROUTINE FMADD_INTERVAL(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO .OR.  &
          MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
          GO TO 110
      ENDIF
      KROUND = -1
      CALL FMADD(MA%LEFT,MB%LEFT,MC%LEFT)
      KROUND = 2
      CALL FMADD(MA%RIGHT,MB%RIGHT,MC%RIGHT)
      IF (MC%LEFT%MP(2) /= MUNKNO .AND. MC%RIGHT%MP(2) /= MUNKNO) THEN
          IF (MA%LEFT%MP(2) == MEXPOV .AND.  &
              MA%LEFT%MP(1) > 0 .AND. MB%LEFT%MP(1) < 0) CALL FMBIG(MC%LEFT)
          IF (MB%LEFT%MP(2) == MEXPOV .AND.  &
              MB%LEFT%MP(1) > 0 .AND. MA%LEFT%MP(1) < 0) CALL FMBIG(MC%LEFT)
          IF (MA%RIGHT%MP(2) == MEXPOV .AND.  &
              MA%RIGHT%MP(1) < 0 .AND. MB%RIGHT%MP(1) > 0) THEN
              CALL FMBIG(MC%RIGHT)
              CALL FMMPYI_R1(MC%RIGHT,-1)
          ENDIF
          IF (MB%RIGHT%MP(2) == MEXPOV .AND.  &
              MB%RIGHT%MP(1) < 0 .AND. MA%RIGHT%MP(1) > 0) THEN
              CALL FMBIG(MC%RIGHT)
              CALL FMMPYI_R1(MC%RIGHT,-1)
          ENDIF
      ENDIF
      IF (MC%LEFT%MP(2) == MUNKNO) THEN
          KROUND = -1
          IF (MA%LEFT%MP(2) == MEXPUN .AND. MB%LEFT%MP(2) == MEXPUN) THEN
              IF (MA%LEFT%MP(1) > 0 .AND. MB%LEFT%MP(1) > 0) THEN
                  CALL FMST2M('UNDERFLOW',MC%LEFT)
              ELSE IF (MA%LEFT%MP(1) < 0 .AND. MB%LEFT%MP(1) < 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI(M_12%MFM,-2,MC%LEFT)
              ELSE
                  CALL FMST2M('-UNDERFLOW',MC%LEFT)
              ENDIF
          ENDIF
          IF (MA%LEFT%MP(2) == MEXPUN .AND. MB%LEFT%MP(2) > MEXPUN .AND.  &
              MB%LEFT%MP(2) < MEXPOV) THEN
              IF (MA%LEFT%MP(1) > 0) THEN
                  CALL FMEQ(MB%LEFT,MC%LEFT)
              ELSE
                  CALL FMTINY(M_12%MFM)
                  CALL FMSUB(MB%LEFT,M_12%MFM,MC%LEFT)
                  IF (MC%LEFT%MP(3) == 0) THEN
                      CALL FMDIVI(MB%LEFT,2,MC%LEFT)
                  ENDIF
              ENDIF
          ENDIF
          IF (MB%LEFT%MP(2) == MEXPUN .AND. MA%LEFT%MP(2) > MEXPUN .AND.  &
              MA%LEFT%MP(2) < MEXPOV) THEN
              IF (MB%LEFT%MP(1) > 0) THEN
                  CALL FMEQ(MA%LEFT,MC%LEFT)
              ELSE
                  CALL FMTINY(M_12%MFM)
                  CALL FMSUB(MA%LEFT,M_12%MFM,MC%LEFT)
                  IF (MC%LEFT%MP(3) == 0) THEN
                      CALL FMDIVI(MA%LEFT,2,MC%LEFT)
                  ENDIF
              ENDIF
          ENDIF
          IF (MA%LEFT%MP(2) == MEXPOV .AND. MB%LEFT%MP(2) == MEXPOV) THEN
              CALL FMST2M('-OVERFLOW',MC%LEFT)
          ENDIF
          IF (MA%LEFT%MP(2) == MEXPOV .AND. MB%LEFT%MP(2) > MEXPUN .AND.  &
              MB%LEFT%MP(2) < MEXPOV) THEN
              IF (MA%LEFT%MP(1) > 0) THEN
                  CALL FMBIG(M_11%MFM)
                  CALL FMULP(M_11%MFM,MC%LEFT)
              ELSE
                  CALL FMST2M('-OVERFLOW',MC%LEFT)
              ENDIF
          ENDIF
          IF (MB%LEFT%MP(2) == MEXPOV .AND. MA%LEFT%MP(2) > MEXPUN .AND.  &
              MA%LEFT%MP(2) < MEXPOV) THEN
              IF (MB%LEFT%MP(1) > 0) THEN
                  CALL FMBIG(M_11%MFM)
                  CALL FMULP(M_11%MFM,MC%LEFT)
              ELSE
                  CALL FMST2M('-OVERFLOW',MC%LEFT)
              ENDIF
          ENDIF
      ENDIF
      IF (MC%RIGHT%MP(2) == MUNKNO) THEN
          KROUND = 2
          IF (MA%RIGHT%MP(2) == MEXPUN .AND. MB%RIGHT%MP(2) == MEXPUN) THEN
              IF (MA%RIGHT%MP(1) > 0 .AND. MB%RIGHT%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI(M_12%MFM,2,MC%RIGHT)
              ELSE IF (MA%RIGHT%MP(1) < 0 .AND. MB%RIGHT%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC%RIGHT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC%RIGHT)
              ENDIF
          ENDIF
          IF (MA%RIGHT%MP(2) == MEXPUN .AND. MB%RIGHT%MP(2) > MEXPUN .AND.  &
              MB%RIGHT%MP(2) < MEXPOV) THEN
              IF (MA%RIGHT%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMADD(MB%RIGHT,M_12%MFM,MC%RIGHT)
                  IF (MC%RIGHT%MP(3) == 0) THEN
                      CALL FMDIVI(MB%RIGHT,2,MC%RIGHT)
                  ENDIF
              ELSE
                  CALL FMEQ(MB%RIGHT,MC%RIGHT)
              ENDIF
          ENDIF
          IF (MB%RIGHT%MP(2) == MEXPUN .AND. MA%RIGHT%MP(2) > MEXPUN .AND.  &
              MA%RIGHT%MP(2) < MEXPOV) THEN
              IF (MB%RIGHT%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMADD(MA%RIGHT,M_12%MFM,MC%RIGHT)
                  IF (MC%RIGHT%MP(3) == 0) THEN
                      CALL FMDIVI(MA%RIGHT,2,MC%RIGHT)
                  ENDIF
              ELSE
                  CALL FMEQ(MA%RIGHT,MC%RIGHT)
              ENDIF
          ENDIF
          IF (MA%RIGHT%MP(2) == MEXPOV .AND. MB%RIGHT%MP(2) == MEXPOV) THEN
              CALL FMST2M('+OVERFLOW',MC%RIGHT)
          ENDIF
          IF (MA%RIGHT%MP(2) == MEXPOV .AND. MB%RIGHT%MP(2) > MEXPUN .AND.  &
              MB%RIGHT%MP(2) < MEXPOV) THEN
              IF (MA%RIGHT%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC%RIGHT)
              ELSE
                  CALL FMBIG(M_11%MFM)
                  CALL FMMPYI_R1(M_11%MFM,-1)
                  CALL FMULP(M_11%MFM,MC%RIGHT)
              ENDIF
          ENDIF
          IF (MB%RIGHT%MP(2) == MEXPOV .AND. MA%RIGHT%MP(2) > MEXPUN .AND.  &
              MA%RIGHT%MP(2) < MEXPOV) THEN
              IF (MB%RIGHT%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC%RIGHT)
              ELSE
                  CALL FMBIG(M_11%MFM)
                  CALL FMMPYI_R1(M_11%MFM,-1)
                  CALL FMULP(M_11%MFM,MC%RIGHT)
              ENDIF
          ENDIF
      ENDIF
      IF (MC%LEFT%MP(2) == MUNKNO .OR. MC%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END SUBROUTINE FMADD_INTERVAL

   SUBROUTINE FMADD_INTERVAL_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      CALL FMADD_INTERVAL(MA,MB,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MA)
   END SUBROUTINE FMADD_INTERVAL_R1

   SUBROUTINE FMADD_INTERVAL_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FMADD_INTERVAL(MA,MB,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MB)
   END SUBROUTINE FMADD_INTERVAL_R2

   FUNCTION FMCOMP_INTERVAL(MA,LREL,MB)     RESULT (RETURN_VALUE)

!  When comparing intervals, the result could be invalid if the two intervals overlap.

      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      CHARACTER(*) :: LREL
      INTENT (IN) :: LREL
      IF (LREL == '==' .OR. LREL == 'EQ' .OR. LREL == 'eq') THEN
          RETURN_VALUE = FMCOMP(MA%LEFT,LREL,MB%LEFT) .AND. FMCOMP(MA%RIGHT,LREL,MB%RIGHT)
      ELSE IF (LREL == '/=' .OR. LREL == 'NE' .OR. LREL == 'ne') THEN
          RETURN_VALUE = FMCOMP(MA%LEFT,LREL,MB%LEFT) .OR. FMCOMP(MA%RIGHT,LREL,MB%RIGHT)
      ELSE
          RETURN_VALUE = FM_COMP(TO_FM(MA),LREL,TO_FM(MB))
      ENDIF
   END FUNCTION FMCOMP_INTERVAL

   SUBROUTINE FMDIV_INTERVAL(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO .OR.  &
          MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
          GO TO 110
      ENDIF
      IF (MB%LEFT%MP(1) <= 0 .AND. MB%RIGHT%MP(1) >= 0) THEN
          CALL FMST2M('-OVERFLOW',MC%LEFT)
          CALL FMST2M('+OVERFLOW',MC%RIGHT)
          GO TO 110
      ENDIF
      KROUND = -1
      IF (MA%LEFT%MP(1) >= 0 .AND. MB%LEFT%MP(1) >= 0) THEN
          CALL FMDIV(MA%LEFT,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMDIV(MA%RIGHT,MB%LEFT,MC%RIGHT)
          CALL FMDIV_INTERVAL_SPECIAL(MA%LEFT,MB%RIGHT,MC%LEFT,MA%RIGHT,MB%LEFT,MC%RIGHT)
      ELSE IF (MA%LEFT%MP(1) >= 0 .AND. MB%RIGHT%MP(1) < 0) THEN
          CALL FMDIV(MA%RIGHT,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMDIV(MA%LEFT,MB%LEFT,MC%RIGHT)
          CALL FMDIV_INTERVAL_SPECIAL(MA%RIGHT,MB%RIGHT,MC%LEFT,MA%LEFT,MB%LEFT,MC%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          MB%LEFT%MP(1) >= 0) THEN
          CALL FMDIV(MA%LEFT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMDIV(MA%RIGHT,MB%LEFT,MC%RIGHT)
          CALL FMDIV_INTERVAL_SPECIAL(MA%LEFT,MB%LEFT,MC%LEFT,MA%RIGHT,MB%LEFT,MC%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          MB%RIGHT%MP(1) < 0) THEN
          CALL FMDIV(MA%RIGHT,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMDIV(MA%LEFT,MB%RIGHT,MC%RIGHT)
          CALL FMDIV_INTERVAL_SPECIAL(MA%RIGHT,MB%RIGHT,MC%LEFT,MA%LEFT,MB%RIGHT,MC%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. MB%LEFT%MP(1) >= 0) THEN
          CALL FMDIV(MA%LEFT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMDIV(MA%RIGHT,MB%RIGHT,MC%RIGHT)
          CALL FMDIV_INTERVAL_SPECIAL(MA%LEFT,MB%LEFT,MC%LEFT,MA%RIGHT,MB%RIGHT,MC%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. MB%RIGHT%MP(1) < 0) THEN
          CALL FMDIV(MA%RIGHT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMDIV(MA%LEFT,MB%RIGHT,MC%RIGHT)
          CALL FMDIV_INTERVAL_SPECIAL(MA%RIGHT,MB%LEFT,MC%LEFT,MA%LEFT,MB%RIGHT,MC%RIGHT)
      ELSE
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
      ENDIF
  110 IF (MC%LEFT%MP(2) == MUNKNO .OR. MC%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
      ENDIF
      KWARN = KWRNSV
      KROUND = KRSAVE
   END SUBROUTINE FMDIV_INTERVAL

   SUBROUTINE FMDIV_INTERVAL_SPECIAL(M1A,M1B,MC_LEFT,M2A,M2B,MC_RIGHT)
      USE FMVALS
      IMPLICIT NONE
      TYPE(MULTI) :: M1A,M1B,MC_LEFT,M2A,M2B,MC_RIGHT
      INTENT (IN) :: M1A,M1B,M2A,M2B
      INTENT (INOUT) :: MC_LEFT,MC_RIGHT
      IF (MC_LEFT%MP(2) == MUNKNO) THEN
          KROUND = -1
          IF (M1A%MP(2) == MEXPUN .AND. M1B%MP(2) == MEXPUN) THEN
              IF (M1A%MP(1) > 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) < 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) > 0 .AND. M1B%MP(1) < 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ENDIF
          ENDIF
          IF (M1A%MP(2) == MEXPOV .AND. M1B%MP(2) == MEXPOV) THEN
              IF (M1A%MP(1) > 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) < 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) > 0 .AND. M1B%MP(1) < 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ENDIF
          ENDIF
          IF (M1A%MP(2) == MEXPUN .AND. M1B%MP(2) > MEXPUN .AND.  &
              M1B%MP(2) < MEXPOV) THEN
              IF (M1A%MP(1) > 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) < 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMDIV(M_12%MFM,M1B,MC_LEFT)
              ELSE IF (M1A%MP(1) > 0 .AND. M1B%MP(1) < 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMDIV(M_12%MFM,M1B,MC_LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ENDIF
          ENDIF
          IF (M1B%MP(2) == MEXPUN .AND. M1A%MP(2) > MEXPUN .AND.  &
              M1A%MP(2) < MEXPOV) THEN
              IF (M1B%MP(1) > 0 .AND. M1A%MP(1) > 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPY(M1A,M_12%MFM,MC_LEFT)
              ELSE IF (M1B%MP(1) < 0 .AND. M1A%MP(1) > 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE IF (M1B%MP(1) > 0 .AND. M1A%MP(1) < 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M1A,M_12%MFM,MC_LEFT)
              ENDIF
          ENDIF
          IF (M1A%MP(2) == MEXPOV .AND. M1B%MP(2) > MEXPUN .AND.  &
              M1B%MP(2) < MEXPOV) THEN
              IF (M1A%MP(1) > 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMDIV(M_12%MFM,M1B,MC_LEFT)
              ELSE IF (M1A%MP(1) < 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) > 0 .AND. M1B%MP(1) < 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMDIV(M_12%MFM,M1B,MC_LEFT)
              ENDIF
          ENDIF
          IF (M1B%MP(2) == MEXPOV .AND. M1A%MP(2) > MEXPUN .AND.  &
              M1A%MP(2) < MEXPOV) THEN
              IF (M1B%MP(1) > 0 .AND. M1A%MP(1) > 0) THEN
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ELSE IF (M1B%MP(1) < 0 .AND. M1A%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M_12%MFM,M1A,MC_LEFT)
              ELSE IF (M1B%MP(1) > 0 .AND. M1A%MP(1) < 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPY(M_12%MFM,M1A,MC_LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ENDIF
          ENDIF
      ENDIF
      IF (MC_RIGHT%MP(2) == MUNKNO) THEN
          KROUND = 2
          IF (M2A%MP(2) == MEXPUN .AND. M2B%MP(2) == MEXPUN) THEN
              IF (M2A%MP(1) > 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) < 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) > 0 .AND. M2B%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2A%MP(2) == MEXPOV .AND. M2B%MP(2) == MEXPOV) THEN
              IF (M2A%MP(1) > 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) < 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) > 0 .AND. M2B%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2A%MP(2) == MEXPUN .AND. M2B%MP(2) > MEXPUN .AND.  &
              M2B%MP(2) < MEXPOV) THEN
              IF (M2A%MP(1) > 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMDIV(M_12%MFM,M2B,MC_RIGHT)
              ELSE IF (M2A%MP(1) < 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) > 0 .AND. M2B%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMDIV(M_12%MFM,M2B,MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2B%MP(2) == MEXPUN .AND. M2A%MP(2) > MEXPUN .AND.  &
              M2A%MP(2) < MEXPOV) THEN
              IF (M2B%MP(1) > 0 .AND. M2A%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ELSE IF (M2B%MP(1) < 0 .AND. M2A%MP(1) > 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M2A,M_12%MFM,MC_RIGHT)
              ELSE IF (M2B%MP(1) > 0 .AND. M2A%MP(1) < 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPY(M2A,M_12%MFM,MC_RIGHT)
              ELSE
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2A%MP(2) == MEXPOV .AND. M2B%MP(2) > MEXPUN .AND.  &
              M2B%MP(2) < MEXPOV) THEN
              IF (M2A%MP(1) > 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) < 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMDIV(M_12%MFM,M2B,MC_RIGHT)
              ELSE IF (M2A%MP(1) > 0 .AND. M2B%MP(1) < 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMDIV(M_12%MFM,M2B,MC_RIGHT)
              ELSE
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2B%MP(2) == MEXPOV .AND. M2A%MP(2) > MEXPUN .AND.  &
              M2A%MP(2) < MEXPOV) THEN
              IF (M2B%MP(1) > 0 .AND. M2A%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPY(M2A,M_12%MFM,MC_RIGHT)
              ELSE IF (M2B%MP(1) < 0 .AND. M2A%MP(1) > 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE IF (M2B%MP(1) > 0 .AND. M2A%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M2A,M_12%MFM,MC_RIGHT)
              ENDIF
          ENDIF
      ENDIF
   END SUBROUTINE FMDIV_INTERVAL_SPECIAL

   SUBROUTINE FMDIV_INTERVAL_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      CALL FMDIV_INTERVAL(MA,MB,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MA)
   END SUBROUTINE FMDIV_INTERVAL_R1

   SUBROUTINE FMDIV_INTERVAL_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FMDIV_INTERVAL(MA,MB,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MB)
   END SUBROUTINE FMDIV_INTERVAL_R2

   SUBROUTINE FMDIVI_INTERVAL(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
          GO TO 110
      ENDIF
      KROUND = -1
      IF (MA%LEFT%MP(1) >= 0 .AND. IVAL >= 0) THEN
          CALL FMDIVI(MA%LEFT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMDIVI(MA%RIGHT,IVAL,MB%RIGHT)
      ELSE IF (MA%LEFT%MP(1) >= 0 .AND. IVAL < 0) THEN
          CALL FMDIVI(MA%RIGHT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMDIVI(MA%LEFT,IVAL,MB%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          IVAL >= 0) THEN
          CALL FMDIVI(MA%LEFT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMDIVI(MA%RIGHT,IVAL,MB%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          IVAL < 0) THEN
          CALL FMDIVI(MA%RIGHT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMDIVI(MA%LEFT,IVAL,MB%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. IVAL >= 0) THEN
          CALL FMDIVI(MA%LEFT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMDIVI(MA%RIGHT,IVAL,MB%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. IVAL < 0) THEN
          CALL FMDIVI(MA%RIGHT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMDIVI(MA%LEFT,IVAL,MB%RIGHT)
      ELSE
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
      ENDIF
      IF (MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(IVAL,IVAL),M0FM_I)
          CALL FMDIV_INTERVAL(MA,M0FM_I,MB)
      ENDIF
      IF (MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END SUBROUTINE FMDIVI_INTERVAL

   SUBROUTINE FMDIVI_INTERVAL_R1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      CALL FMDIVI_INTERVAL(MA,IVAL,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MA)
   END SUBROUTINE FMDIVI_INTERVAL_R1

   SUBROUTINE FMDP2M_INTERVAL(X,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      DOUBLE PRECISION :: X
      INTENT (IN) :: X
      INTEGER :: KRSAVE
      KRSAVE = KROUND
      KROUND = -1
      CALL FMDP2M(X,MA%LEFT)
      KROUND = 2
      CALL FMDP2M(X,MA%RIGHT)
      KROUND = KRSAVE
   END SUBROUTINE FMDP2M_INTERVAL

   SUBROUTINE FMEQ_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FMEQ(MA%LEFT,MB%LEFT)
      CALL FMEQ(MA%RIGHT,MB%RIGHT)
   END SUBROUTINE FMEQ_INTERVAL

   SUBROUTINE FMEQU_INTERVAL(MA,MB,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTEGER :: KRSAVE,NCSAVE,NDA,NDB
      INTENT (IN) :: MA,NDA,NDB
      INTENT (INOUT) :: MB
      KRSAVE = KROUND
      NCSAVE = NCALL
      NCALL = 1
      KROUND = -1
      CALL FMEQU(MA%LEFT,MB%LEFT,NDA,NDB)
      KROUND = 2
      CALL FMEQU(MA%RIGHT,MB%RIGHT,NDA,NDB)
      KROUND = KRSAVE
      NCALL = NCSAVE
   END SUBROUTINE FMEQU_INTERVAL

   SUBROUTINE FMEQU_INTERVAL_R1(MA,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: KRSAVE,NCSAVE,NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (INOUT) :: MA
      KRSAVE = KROUND
      NCSAVE = NCALL
      NCALL = 1
      KROUND = -1
      CALL FMEQU_R1(MA%LEFT,NDA,NDB)
      KROUND = 2
      CALL FMEQU_R1(MA%RIGHT,NDA,NDB)
      KROUND = KRSAVE
      NCALL = NCSAVE
   END SUBROUTINE FMEQU_INTERVAL_R1

   SUBROUTINE FMI2M_INTERVAL(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTEGER :: KRSAVE
      KRSAVE = KROUND
      KROUND = -1
      CALL FMI2M(IVAL,MA%LEFT)
      KROUND = 2
      CALL FMI2M(IVAL,MA%RIGHT)
      KROUND = KRSAVE
   END SUBROUTINE FMI2M_INTERVAL

   SUBROUTINE FMINT_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FMINT(MA%LEFT,MB%LEFT)
      CALL FMINT(MA%RIGHT,MB%RIGHT)
   END SUBROUTINE FMINT_INTERVAL

   SUBROUTINE FMM2DP_INTERVAL(MA,X)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      DOUBLE PRECISION :: X
      INTENT (INOUT) :: X
      CALL FM_M2DP(TO_FM(MA),X)
   END SUBROUTINE FMM2DP_INTERVAL

   SUBROUTINE FMM2I_INTERVAL(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: IVAL
      CALL FM_M2I(TO_FM(MA),IVAL)
   END SUBROUTINE FMM2I_INTERVAL

   SUBROUTINE FMM2SP_INTERVAL(MA,X)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      REAL :: X
      INTENT (INOUT) :: X
      CALL FM_M2SP(TO_FM(MA),X)
   END SUBROUTINE FMM2SP_INTERVAL

   SUBROUTINE FMMPY_INTERVAL(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KRSAVE,KWRNSV
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM,MVLVFM
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO .OR.  &
          MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
          GO TO 110
      ENDIF
      KROUND = -1
      IF (MA%LEFT%MP(1) >= 0 .AND. MB%LEFT%MP(1) >= 0) THEN
          CALL FMMPY(MA%LEFT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%RIGHT,MB%RIGHT,MC%RIGHT)
          CALL FMMPY_INTERVAL_SPECIAL(MA%LEFT,MB%LEFT,MC%LEFT,MA%RIGHT,MB%RIGHT,MC%RIGHT)
      ELSE IF (MA%LEFT%MP(1) >= 0 .AND. MB%LEFT%MP(1) < 0 .AND.  &
          MB%RIGHT%MP(1) >= 0) THEN
          CALL FMMPY(MA%RIGHT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%RIGHT,MB%RIGHT,MC%RIGHT)
          CALL FMMPY_INTERVAL_SPECIAL(MA%RIGHT,MB%LEFT,MC%LEFT,MA%RIGHT,MB%RIGHT,MC%RIGHT)
      ELSE IF (MA%LEFT%MP(1) >= 0 .AND. MB%RIGHT%MP(1) < 0) THEN
          CALL FMMPY(MA%RIGHT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%LEFT,MB%RIGHT,MC%RIGHT)
          CALL FMMPY_INTERVAL_SPECIAL(MA%RIGHT,MB%LEFT,MC%LEFT,MA%LEFT,MB%RIGHT,MC%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          MB%LEFT%MP(1) >= 0) THEN
          CALL FMMPY(MA%LEFT,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%RIGHT,MB%RIGHT,MC%RIGHT)
          CALL FMMPY_INTERVAL_SPECIAL(MA%LEFT,MB%RIGHT,MC%LEFT,MA%RIGHT,MB%RIGHT,MC%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          MB%LEFT%MP(1) < 0 .AND. MB%RIGHT%MP(1) >= 0) THEN
          CALL FMMPY(MA%LEFT,MB%RIGHT,MTLVFM)
          CALL FMMPY(MA%RIGHT,MB%LEFT,MULVFM)
          CALL FMI2M(0,MVLVFM)
          CALL FMMPY_INTERVAL_SPECIAL(MA%LEFT,MB%RIGHT,MTLVFM,MA%LEFT,MB%RIGHT,MVLVFM)
          CALL FMMPY_INTERVAL_SPECIAL(MA%RIGHT,MB%LEFT,MULVFM,MA%RIGHT,MB%LEFT,MVLVFM)
          CALL FMMIN(MTLVFM,MULVFM,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%LEFT,MB%LEFT,MTLVFM)
          CALL FMMPY(MA%RIGHT,MB%RIGHT,MULVFM)
          CALL FMMPY_INTERVAL_SPECIAL(MA%LEFT,MB%LEFT,MVLVFM,MA%LEFT,MB%LEFT,MTLVFM)
          CALL FMMPY_INTERVAL_SPECIAL(MA%RIGHT,MB%RIGHT,MVLVFM,MA%RIGHT,MB%RIGHT,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MC%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          MB%RIGHT%MP(1) < 0) THEN
          CALL FMMPY(MA%RIGHT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%LEFT,MB%LEFT,MC%RIGHT)
          CALL FMMPY_INTERVAL_SPECIAL(MA%RIGHT,MB%LEFT,MC%LEFT,MA%LEFT,MB%LEFT,MC%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. MB%LEFT%MP(1) >= 0) THEN
          CALL FMMPY(MA%LEFT,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%RIGHT,MB%LEFT,MC%RIGHT)
          CALL FMMPY_INTERVAL_SPECIAL(MA%LEFT,MB%RIGHT,MC%LEFT,MA%RIGHT,MB%LEFT,MC%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. MB%LEFT%MP(1) < 0 .AND.  &
          MB%RIGHT%MP(1) >= 0) THEN
          CALL FMMPY(MA%LEFT,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%LEFT,MB%LEFT,MC%RIGHT)
          CALL FMMPY_INTERVAL_SPECIAL(MA%LEFT,MB%RIGHT,MC%LEFT,MA%LEFT,MB%LEFT,MC%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. MB%RIGHT%MP(1) < 0) THEN
          CALL FMMPY(MA%RIGHT,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMMPY(MA%LEFT,MB%LEFT,MC%RIGHT)
          CALL FMMPY_INTERVAL_SPECIAL(MA%RIGHT,MB%RIGHT,MC%LEFT,MA%LEFT,MB%LEFT,MC%RIGHT)
      ELSE
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
      ENDIF
      IF (MC%LEFT%MP(2) == MUNKNO .OR. MC%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END SUBROUTINE FMMPY_INTERVAL

   SUBROUTINE FMMPY_INTERVAL_SPECIAL(M1A,M1B,MC_LEFT,M2A,M2B,MC_RIGHT)
      USE FMVALS
      IMPLICIT NONE
      TYPE(MULTI) :: M1A,M1B,MC_LEFT,M2A,M2B,MC_RIGHT
      INTENT (IN) :: M1A,M1B,M2A,M2B
      INTENT (INOUT) :: MC_LEFT,MC_RIGHT
      IF (MC_LEFT%MP(2) == MUNKNO) THEN
          KROUND = -1
          IF (M1A%MP(2) == MEXPUN .AND. M1B%MP(2) == MEXPOV) THEN
              IF (M1A%MP(1) > 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) < 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) > 0 .AND. M1B%MP(1) < 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ENDIF
          ENDIF
          IF (M1A%MP(2) == MEXPOV .AND. M1B%MP(2) == MEXPUN) THEN
              IF (M1A%MP(1) > 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) < 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) > 0 .AND. M1B%MP(1) < 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ENDIF
          ENDIF
          IF (M1A%MP(2) == MEXPUN .AND. M1B%MP(2) > MEXPUN .AND.  &
              M1B%MP(2) < MEXPOV) THEN
              IF (M1A%MP(1) > 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) < 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M_12%MFM,M1B,MC_LEFT)
              ELSE IF (M1A%MP(1) > 0 .AND. M1B%MP(1) < 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPY(M_12%MFM,M1B,MC_LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ENDIF
          ENDIF
          IF (M1B%MP(2) == MEXPUN .AND. M1A%MP(2) > MEXPUN .AND.  &
              M1A%MP(2) < MEXPOV) THEN
              IF (M1B%MP(1) > 0 .AND. M1A%MP(1) > 0) THEN
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ELSE IF (M1B%MP(1) < 0 .AND. M1A%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M1A,M_12%MFM,MC_LEFT)
              ELSE IF (M1B%MP(1) > 0 .AND. M1A%MP(1) < 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPY(M1A,M_12%MFM,MC_LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',MC_LEFT)
              ENDIF
          ENDIF
          IF (M1A%MP(2) == MEXPOV .AND. M1B%MP(2) > MEXPUN .AND.  &
              M1B%MP(2) < MEXPOV) THEN
              IF (M1A%MP(1) > 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPY(M_12%MFM,M1B,MC_LEFT)
              ELSE IF (M1A%MP(1) < 0 .AND. M1B%MP(1) > 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE IF (M1A%MP(1) > 0 .AND. M1B%MP(1) < 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M_12%MFM,M1B,MC_LEFT)
              ENDIF
          ENDIF
          IF (M1B%MP(2) == MEXPOV .AND. M1A%MP(2) > MEXPUN .AND.  &
              M1A%MP(2) < MEXPOV) THEN
              IF (M1B%MP(1) > 0 .AND. M1A%MP(1) > 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPY(M1A,M_12%MFM,MC_LEFT)
              ELSE IF (M1B%MP(1) < 0 .AND. M1A%MP(1) > 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE IF (M1B%MP(1) > 0 .AND. M1A%MP(1) < 0) THEN
                  CALL FMST2M('-OVERFLOW',MC_LEFT)
              ELSE
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M1A,M_12%MFM,MC_LEFT)
              ENDIF
          ENDIF
      ENDIF
      IF (MC_RIGHT%MP(2) == MUNKNO) THEN
          KROUND = 2
          IF (M2A%MP(2) == MEXPUN .AND. M2B%MP(2) == MEXPOV) THEN
              IF (M2A%MP(1) > 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) < 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) > 0 .AND. M2B%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2A%MP(2) == MEXPOV .AND. M2B%MP(2) == MEXPUN) THEN
              IF (M2A%MP(1) > 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) < 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) > 0 .AND. M2B%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2A%MP(2) == MEXPUN .AND. M2B%MP(2) > MEXPUN .AND.  &
              M2B%MP(2) < MEXPOV) THEN
              IF (M2A%MP(1) > 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPY(M_12%MFM,M2B,MC_RIGHT)
              ELSE IF (M2A%MP(1) < 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) > 0 .AND. M2B%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M_12%MFM,M2B,MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2B%MP(2) == MEXPUN .AND. M2A%MP(2) > MEXPUN .AND.  &
              M2A%MP(2) < MEXPOV) THEN
              IF (M2B%MP(1) > 0 .AND. M2A%MP(1) > 0) THEN
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPY(M2A,M_12%MFM,MC_RIGHT)
              ELSE IF (M2B%MP(1) < 0 .AND. M2A%MP(1) > 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE IF (M2B%MP(1) > 0 .AND. M2A%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',MC_RIGHT)
              ELSE
                  CALL FMTINY(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M2A,M_12%MFM,MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2A%MP(2) == MEXPOV .AND. M2B%MP(2) > MEXPUN .AND.  &
              M2B%MP(2) < MEXPOV) THEN
              IF (M2A%MP(1) > 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ELSE IF (M2A%MP(1) < 0 .AND. M2B%MP(1) > 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M_12%MFM,M2B,MC_RIGHT)
              ELSE IF (M2A%MP(1) > 0 .AND. M2B%MP(1) < 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPY(M_12%MFM,M2B,MC_RIGHT)
              ELSE
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ENDIF
          ENDIF
          IF (M2B%MP(2) == MEXPOV .AND. M2A%MP(2) > MEXPUN .AND.  &
              M2A%MP(2) < MEXPOV) THEN
              IF (M2B%MP(1) > 0 .AND. M2A%MP(1) > 0) THEN
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ELSE IF (M2B%MP(1) < 0 .AND. M2A%MP(1) > 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPYI_R1(M_12%MFM,-1)
                  CALL FMMPY(M2A,M_12%MFM,MC_RIGHT)
              ELSE IF (M2B%MP(1) > 0 .AND. M2A%MP(1) < 0) THEN
                  CALL FMBIG(M_12%MFM)
                  CALL FMMPY(M2A,M_12%MFM,MC_RIGHT)
              ELSE
                  CALL FMST2M('+OVERFLOW',MC_RIGHT)
              ENDIF
          ENDIF
      ENDIF
   END SUBROUTINE FMMPY_INTERVAL_SPECIAL

   SUBROUTINE FMMPY_INTERVAL_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      CALL FMMPY_INTERVAL(MA,MB,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MA)
   END SUBROUTINE FMMPY_INTERVAL_R1

   SUBROUTINE FMMPY_INTERVAL_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FMMPY_INTERVAL(MA,MB,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MB)
   END SUBROUTINE FMMPY_INTERVAL_R2

   SUBROUTINE FMMPYI_INTERVAL(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
          GO TO 110
      ENDIF
      KROUND = -1
      IF (MA%LEFT%MP(1) >= 0 .AND. IVAL >= 0) THEN
          CALL FMMPYI(MA%LEFT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMMPYI(MA%RIGHT,IVAL,MB%RIGHT)
      ELSE IF (MA%LEFT%MP(1) >= 0 .AND. IVAL < 0) THEN
          CALL FMMPYI(MA%RIGHT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMMPYI(MA%LEFT,IVAL,MB%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          IVAL >= 0) THEN
          CALL FMMPYI(MA%LEFT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMMPYI(MA%RIGHT,IVAL,MB%RIGHT)
      ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0 .AND.  &
          IVAL < 0) THEN
          CALL FMMPYI(MA%RIGHT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMMPYI(MA%LEFT,IVAL,MB%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. IVAL >= 0) THEN
          CALL FMMPYI(MA%LEFT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMMPYI(MA%RIGHT,IVAL,MB%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0 .AND. IVAL < 0) THEN
          CALL FMMPYI(MA%RIGHT,IVAL,MB%LEFT)
          KROUND = 2
          CALL FMMPYI(MA%LEFT,IVAL,MB%RIGHT)
      ELSE
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
      ENDIF
      IF (MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(IVAL,IVAL),M0FM_I)
          CALL FMMPY_INTERVAL(MA,M0FM_I,MB)
      ENDIF
      IF (MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END SUBROUTINE FMMPYI_INTERVAL

   SUBROUTINE FMMPYI_INTERVAL_R1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      CALL FMMPYI_INTERVAL(MA,IVAL,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MA)
   END SUBROUTINE FMMPYI_INTERVAL_R1

   SUBROUTINE FMSP2M_INTERVAL(X,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      REAL :: X
      INTENT (IN) :: X
      INTEGER :: KRSAVE
      KRSAVE = KROUND
      KROUND = -1
      CALL FMSP2M(X,MA%LEFT)
      KROUND = 2
      CALL FMSP2M(X,MA%RIGHT)
      KROUND = KRSAVE
   END SUBROUTINE FMSP2M_INTERVAL

   SUBROUTINE FMSQRT_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE,KWRNSV
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(3) == 0 .AND. MA%RIGHT%MP(3) == 0) THEN
          CALL FMI2M(0,MB%LEFT)
          CALL FMI2M(0,MB%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%RIGHT%MP(1) < 0 .OR. MA%RIGHT%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(1) < 0 .OR. MA%LEFT%MP(3) == 0) THEN
          CALL FMI2M(0,MB%LEFT)
      ELSE
          IF (MA%LEFT%MP(2) == MEXPOV) THEN
              CALL FMBIG(M_12%MFM)
              KROUND = -1
              CALL FMSQRT(M_12%MFM,MB%LEFT)
          ELSE IF (MA%LEFT%MP(2) == MEXPUN) THEN
              CALL FMST2M('+UNDERFLOW',MB%LEFT)
          ELSE
              KROUND = -1
              CALL FMSQRT(MA%LEFT,MB%LEFT)
          ENDIF
      ENDIF
      IF (MA%RIGHT%MP(2) == MEXPOV) THEN
          CALL FMST2M('+OVERFLOW',MB%RIGHT)
      ELSE IF (MA%RIGHT%MP(2) == MEXPUN) THEN
          CALL FMBIG(M_12%MFM)
          KROUND = 2
          CALL FMRPWR(M_12%MFM,-1,2,MB%RIGHT)
      ELSE
          KROUND = 2
          CALL FMSQRT(MA%RIGHT,MB%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END SUBROUTINE FMSQRT_INTERVAL

   SUBROUTINE FMSQRT_INTERVAL_R1(MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      CALL FMSQRT_INTERVAL(MA,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MA)
   END SUBROUTINE FMSQRT_INTERVAL_R1

   SUBROUTINE FMST2M_INTERVAL(STRING,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      INTEGER :: KRSAVE
      KRSAVE = KROUND
      KROUND = -1
      CALL FMST2M(STRING,MA%LEFT)
      KROUND = 2
      CALL FMST2M(STRING,MA%RIGHT)
      KROUND = KRSAVE
   END SUBROUTINE FMST2M_INTERVAL

   SUBROUTINE FMSUB_INTERVAL(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO .OR.  &
          MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
          GO TO 110
      ENDIF
      KROUND = -1
      CALL FMSUB(MA%LEFT,MB%RIGHT,MC%LEFT)
      KROUND = 2
      CALL FMSUB(MA%RIGHT,MB%LEFT,MC%RIGHT)
      IF (MC%LEFT%MP(2) /= MUNKNO .AND. MC%RIGHT%MP(2) /= MUNKNO) THEN
          IF (MA%LEFT%MP(2) == MEXPOV .AND.  &
              MA%LEFT%MP(1) > 0 .AND. MB%LEFT%MP(1) > 0) CALL FMBIG(MC%LEFT)
          IF (MB%LEFT%MP(2) == MEXPOV .AND.  &
              MB%LEFT%MP(1) > 0 .AND. MA%LEFT%MP(1) > 0) THEN
              CALL FMBIG(MC%RIGHT)
              CALL FMMPYI_R1(MC%RIGHT,-1)
          ENDIF
          IF (MA%RIGHT%MP(2) == MEXPOV .AND.  &
              MA%RIGHT%MP(1) < 0 .AND. MB%RIGHT%MP(1) < 0) THEN
              CALL FMBIG(MC%RIGHT)
              CALL FMMPYI_R1(MC%RIGHT,-1)
          ENDIF
          IF (MB%RIGHT%MP(2) == MEXPOV .AND.  &
              MB%RIGHT%MP(1) < 0 .AND. MA%RIGHT%MP(1) < 0) CALL FMBIG(MC%LEFT)
      ENDIF
      IF (MC%LEFT%MP(2) == MUNKNO .OR. MC%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(-RIGHT_ENDPOINT(MB),-LEFT_ENDPOINT(MB)),M0FM_I)
          CALL FMADD_INTERVAL(MA,M0FM_I,MC)
      ENDIF
      IF (MC%LEFT%MP(2) == MUNKNO .OR. MC%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END SUBROUTINE FMSUB_INTERVAL

   SUBROUTINE FMSUB_INTERVAL_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      CALL FMSUB_INTERVAL(MA,MB,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MA)
   END SUBROUTINE FMSUB_INTERVAL_R1

   SUBROUTINE FMSUB_INTERVAL_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FMSUB_INTERVAL(MA,MB,MWFM_I)
      CALL FMEQ_INTERVAL(MWFM_I,MB)
   END SUBROUTINE FMSUB_INTERVAL_R2


   SUBROUTINE FMULP_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FMULP(MA%LEFT,MB%LEFT)
      CALL FMULP(MA%RIGHT,MB%RIGHT)
   END SUBROUTINE FMULP_INTERVAL

   SUBROUTINE IMFM2I_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      TYPE(MULTI) :: MB
      INTENT (INOUT) :: MB
      CALL FM_TO_FMA(MA,M_1)
      CALL IMFM2I(M_1%MFM,MB)
   END SUBROUTINE IMFM2I_INTERVAL

   SUBROUTINE IMI2FM_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE(MULTI) :: MA
      INTENT (IN) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE
      KRSAVE = KROUND
      KROUND = -1
      CALL IMI2FM(MA,MB%LEFT)
      KROUND = 2
      CALL IMI2FM(MA,MB%RIGHT)
      KROUND = KRSAVE
   END SUBROUTINE IMI2FM_INTERVAL

   SUBROUTINE ZMCMPX_INTERVAL(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE (ZM) :: MC
      INTENT (INOUT) :: MC
      CALL ZM_CMPX(TO_FM(MA),TO_FM(MB),MC)
   END SUBROUTINE ZMCMPX_INTERVAL

   SUBROUTINE ZMREAL_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE(MULTI) :: MA(2)
      INTENT (IN) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (INOUT) :: MB
      CALL ZMREAL(MA,MB%LEFT)
      CALL ZMREAL(MA,MB%RIGHT)
   END SUBROUTINE ZMREAL_INTERVAL

   SUBROUTINE FM_INTERVAL_F_FM(FM_F,MA,MB)

!  General interval evaluation for a special function of one FM variable:
!      CALL FM_F(MA,MB)

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: I,KRSAVE,L
      EXTERNAL :: FM_F
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MVLVFM,M1LVFM,M2LVFM
      KRSAVE = KROUND
      IF ( ABS(RIGHT_ENDPOINT(MA)-LEFT_ENDPOINT(MA)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))) /  &
           (100*SQRT(EPSILON(TO_FM(1))))) GO TO 110
      CALL FMST2M(' OVERFLOW',M_4%MFM)
      CALL FMST2M('-OVERFLOW',M_5%MFM)
      DO I = 1, 9
         CALL FMSUB(MA%RIGHT,MA%LEFT,M1LVFM)
         CALL FMMPYI_R1(M1LVFM,I)
         CALL FMDIVI_R1(M1LVFM,10)
         CALL FMADD(MA%LEFT,M1LVFM,M_1%MFM)
         CALL FM_F(M_1%MFM,MVLVFM)
         IF (FMCOMP(MVLVFM,'<',M_4%MFM)) THEN
             CALL FMEQ(MVLVFM,M_4%MFM)
         ENDIF
         IF (FMCOMP(MVLVFM,'>',M_5%MFM)) THEN
             CALL FMEQ(MVLVFM,M_5%MFM)
         ENDIF
      ENDDO
      CALL FM_F(MA%LEFT,M1LVFM)
      CALL FM_F(MA%RIGHT,M2LVFM)
      IF (LEFT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( LEFT_ENDPOINT(MA) + ABS(LEFT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_3)
      ENDIF
      CALL FM_F(M_3%MFM,M_1%MFM)
      IF (RIGHT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - ABS(RIGHT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( -SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 < LEFT_ENDPOINT(MA)) THEN
              CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_3)
      ENDIF
      CALL FM_F(M_3%MFM,M_2%MFM)
      IF ( (FMCOMP(M_4%MFM,'<',M1LVFM) .AND. FMCOMP(M_4%MFM,'<',M2LVFM)) .OR.  &
           (FMCOMP(M_1%MFM,'<=',M1LVFM) .AND. FMCOMP(M_2%MFM,'<=',M2LVFM)) ) THEN
          CALL FM_FIND_EXTREME_POINT(1,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,FM_F)
          KROUND = -1
          CALL FM_F(M_1%MFM,MB%LEFT)
          IF (FMCOMP(M_5%MFM,'>',M1LVFM) .AND. FMCOMP(M_5%MFM,'>',M2LVFM)) THEN
              CALL FM_FIND_EXTREME_POINT(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),  &
                                         MAX(SPACING(RIGHT_ENDPOINT(MA)),         &
                                             SPACING(LEFT_ENDPOINT(MA))),         &
                                         M_1,M_2,FM_F)
              KROUND = 2
              CALL FM_F(M_1%MFM,MB%RIGHT)
          ELSE
              KROUND = 2
              CALL FM_F(MA%LEFT,M_4%MFM)
              CALL FM_F(MA%RIGHT,M_5%MFM)
              IF (FMCOMP(M_4%MFM,'>',M_5%MFM)) THEN
                  CALL FMEQ(M_4%MFM,MB%RIGHT)
              ELSE
                  CALL FMEQ(M_5%MFM,MB%RIGHT)
              ENDIF
          ENDIF
          GO TO 120
      ELSE IF ( (FMCOMP(M_5%MFM,'>',M1LVFM) .AND. FMCOMP(M_5%MFM,'>',M2LVFM)) .OR.  &
                (FMCOMP(M_1%MFM,'>=',M1LVFM) .AND. FMCOMP(M_2%MFM,'>=',M2LVFM)) ) THEN
          CALL FM_FIND_EXTREME_POINT(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,FM_F)
          KROUND = 2
          CALL FM_F(M_1%MFM,MB%RIGHT)
          KROUND = -1
          CALL FM_F(MA%LEFT,M_4%MFM)
          CALL FM_F(MA%RIGHT,M_5%MFM)
          IF (FMCOMP(M_4%MFM,'<',M_5%MFM)) THEN
              CALL FMEQ(M_4%MFM,MB%LEFT)
          ELSE
              CALL FMEQ(M_5%MFM,MB%LEFT)
          ENDIF
          GO TO 120
      ENDIF
  110 KROUND = -1
      CALL FM_F(MA%LEFT,M_4%MFM)
      CALL FM_F(MA%RIGHT,M_5%MFM)
      CALL FMEQ(M_4%MFM,MB%LEFT)
      IF (FMCOMP(MB%LEFT,'>',M_5%MFM)) THEN
          CALL FMEQ(M_5%MFM,MB%LEFT)
      ENDIF
      L = 1
      IF (FMCOMP(M_4%MFM,'<',M_5%MFM)) THEN
          L = 2
      ENDIF
      KROUND = 2
      IF (L == 1) THEN
          CALL FM_F(MA%LEFT,MB%RIGHT)
      ELSE IF (L == 2) THEN
          CALL FM_F(MA%RIGHT,MB%RIGHT)
      ENDIF
  120 KROUND = KRSAVE
   END SUBROUTINE FM_INTERVAL_F_FM

   SUBROUTINE FM_FIND_EXTREME_POINT(MIN_OR_MAX,AX,BX,TOL,XVAL,FVAL,F)

!  MIN_OR_MAX having value 1 means minimize the function, otherwise maximize.
!  AX, BX     define the endpoints of an interval in which the search takes place.
!  TOL        is the tolerance for the minimum.  Usually TOL should be no less than
!             sqrt(epsilon(ax)), meaning the x-coordinate XVAL of the extreme point will
!             be accurate to only about half the digits carried.  The y-coordinate FVAL
!             should be accurate to nearly full precision.
!             This happens because the typical graph is nearly parabolic near the minimum,
!             and within sqrt(epsilon(ax)) of the minimum all the function values are
!             essentially identical at the current precision.
!  XVAL       is returned as the value of X that minimizes (or maximizes) function F(X).
!             It is a relative extreme point, and may not be the global extreme point if the
!             function has more than one extremum on the interval.
!  FVAL       is returned as the function value at XVAL.
!  F(X,Y)     is a subroutine where X is the input and Y is the output of the function to be
!             minimized.

!  The method used is a combination of golden section search and successive parabolic interpolation.
!  Convergence is never much slower than that for a fibonacci search.  If f has a continuous second
!  derivative which is positive at the minimum (which is not at ax or bx), then convergence is
!  superlinear, and usually of the order of about 1.324....

!  The function f is never evaluated at two points closer together than eps*abs(FVAL)+(tol/3),
!  where eps is approximately the square root of the relative machine precision.  If f is a
!  unimodal function and the computed values of f are always unimodal when separated by at least
!  eps*abs(x)+(tol/3), then FVAL approximates the abscissa of the global minimum of f on the
!  interval ax,bx with an error less than 3*eps*abs(FVAL)+tol.  If f is not unimodal, then FVAL
!  may approximate a local, but perhaps non-global, minimum to the same accuracy.

!  This routine is a slightly modified translation of function FVAL from netlib, which was adapted
!  from the algol 60 procedure localmin given by Richard Brent in Algorithms For Minimization
!  Without Derivatives, Prentice-Hall (1973).

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MINV,MIN_OR_MAX,NDSAVE
      TYPE (FM) :: AX,BX,TOL,XVAL,FVAL
      EXTERNAL :: F

      TYPE (FM), SAVE :: A, B, C, D, E, EPS, XM, P, Q, R, T2, U, V, W, FU, FV, FW, FX, X, TOL1, TOL3

      NDSAVE = NDIG
      NDIG = MAX(NDIG+NGRD52,2)
      MINV = 1
      IF (MIN_OR_MAX /= 1) MINV = -1
      IF (AX < BX) THEN
          CALL FM_EQU(AX,A,NDSAVE,NDIG)
          CALL FM_EQU(BX,B,NDSAVE,NDIG)
      ELSE
          CALL FM_EQU(AX,B,NDSAVE,NDIG)
          CALL FM_EQU(BX,A,NDSAVE,NDIG)
      ENDIF

!             C is the squared inverse of the golden ratio.

      C = (3-SQRT(TO_FM('5.0D0')))/2

!             EPS is approximately the square root of the relative machine precision.

      EPS = EPSILON(A)
      TOL1 = EPS + 1
      EPS = SQRT(EPS)
      V = A + C*(B-A)
      W = V
      X = V
      E = 0
      FX = 0
      CALL F(X%MFM,FX%MFM)
      FX = FX*MINV
      FV = FX
      FW = FX
      TOL3 = 0
      CALL FM_EQU(TOL,TOL3,NDSAVE,NDIG)
      TOL3 = TOL3/3

!             The main loop starts here.

  110 XM = A + (B-A)/2
      TOL1 = EPS*ABS(X) + TOL3
      T2 = 2*TOL1

!             Check the stopping criterion.

      IF (ABS(X-XM) <= (T2-(B-A)/2)) GO TO 160
      P = 0
      Q = 0
      R = 0
      IF (ABS(E) > TOL1) THEN
          R = (X-W)*(FX-FV)    !     Fit a parabola.
          Q = (X-V)*(FX-FW)
          P = (X-V)*Q-(X-W)*R
          Q = 2*(Q-R)
          IF (Q > 0) THEN
              P = -P
          ELSE
              Q = -Q
          ENDIF
          R = E
          E = D
      ENDIF

      IF ((ABS(P) >= ABS(Q*R/2)) .OR. (P <= Q*(A-X)) .OR. (P >= Q*(B-X))) GO TO 120

!             Make a parabolic-interpolation step.

      D = P/Q
      U = X + D

!             f must not be evaluated too close to ax or bx.

      IF (((U-A) >= T2) .AND. ((B-U) >= T2)) GO TO 130
      D = TOL1
      IF (X >= XM) D = -D
      GO TO 130

!             Make a golden-section step.

  120 IF (X < XM) THEN
          E = B - X
      ELSE
          E = A - X
      ENDIF
      D = C*E

!             f must not be evaluated too close to x.

  130 IF (ABS(D) >= TOL1) THEN
          U = X + D
      ELSE
          IF (D > 0) THEN
              U = X + TOL1
          ELSE
              U = X - TOL1
          ENDIF
      ENDIF
      FU = 0
      CALL F(U%MFM,FU%MFM)
      FU = FU*MINV

!             update  a, b, v, w, and x.

      IF (FX <= FU) THEN
          IF (U < X) THEN
              A = U
          ELSE
              B = U
          ENDIF
      ENDIF
      IF (FU > FX) GO TO 140
      IF (U < X) THEN
          B = X
      ELSE
          A = X
      ENDIF
      V = W
      FV = FW
      W = X
      FW = FX
      X = U
      FX = FU
      GO TO 110

  140 IF ((FU > FW) .AND. (W /= X)) GO TO 150
      V = W
      FV = FW
      W = U
      FW = FU
      GO TO 110

  150 IF ((FU > FV) .AND. (V /= X) .AND. (V /= W)) GO TO 110
      V = U
      FV = FU
      GO TO 110

!  end of main loop

  160 CALL FM_EQU(X,XVAL,NDIG,NDSAVE)
      CALL FM_EQU(FX*MINV,FVAL,NDIG,NDSAVE)
      NDIG = NDSAVE

   END SUBROUTINE FM_FIND_EXTREME_POINT

   SUBROUTINE FM_INTERVAL_F_IFM(FM_F,N,MA,MB)

!  General interval evaluation for a special function of one FM variable:
!      CALL FM_F(N,MA,MB)

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: I,KRSAVE,L,N
      EXTERNAL :: FM_F
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MVLVFM,M1LVFM,M2LVFM
      KRSAVE = KROUND
      IF ( ABS(RIGHT_ENDPOINT(MA)-LEFT_ENDPOINT(MA)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))) /  &
           (100*SQRT(EPSILON(TO_FM(1))))) GO TO 110
      CALL FMST2M(' OVERFLOW',M_4%MFM)
      CALL FMST2M('-OVERFLOW',M_5%MFM)
      DO I = 1, 9
         CALL FMSUB(MA%RIGHT,MA%LEFT,M1LVFM)
         CALL FMMPYI_R1(M1LVFM,I)
         CALL FMDIVI_R1(M1LVFM,10)
         CALL FMADD(MA%LEFT,M1LVFM,M_1%MFM)
         CALL FM_F(N,M_1%MFM,MVLVFM)
         IF (FMCOMP(MVLVFM,'<',M_4%MFM)) THEN
             CALL FMEQ(MVLVFM,M_4%MFM)
         ENDIF
         IF (FMCOMP(MVLVFM,'>',M_5%MFM)) THEN
             CALL FMEQ(MVLVFM,M_5%MFM)
         ENDIF
      ENDDO
      CALL FM_F(N,MA%LEFT,M1LVFM)
      CALL FM_F(N,MA%RIGHT,M2LVFM)
      IF (LEFT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( LEFT_ENDPOINT(MA) + ABS(LEFT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_3)
      ENDIF
      CALL FM_F(N,M_3%MFM,M_1%MFM)
      IF (RIGHT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - ABS(RIGHT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( -SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 < LEFT_ENDPOINT(MA)) THEN
              CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_3)
      ENDIF
      CALL FM_F(N,M_3%MFM,M_2%MFM)
      IF ( (FMCOMP(M_4%MFM,'<',M1LVFM) .AND. FMCOMP(M_4%MFM,'<',M2LVFM)) .OR.  &
           (FMCOMP(M_1%MFM,'<=',M1LVFM) .AND. FMCOMP(M_2%MFM,'<=',M2LVFM)) ) THEN
          CALL FM_FIND_EXTREME_POINT_IFM(1,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                   &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,N,FM_F)
          KROUND = -1
          CALL FM_F(N,M_1%MFM,MB%LEFT)
          IF (FMCOMP(M_5%MFM,'>',M1LVFM) .AND. FMCOMP(M_5%MFM,'>',M2LVFM)) THEN
              CALL FM_FIND_EXTREME_POINT_IFM(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),  &
                                             MAX(SPACING(RIGHT_ENDPOINT(MA)),         &
                                                 SPACING(LEFT_ENDPOINT(MA))),         &
                                             M_1,M_2,N,FM_F)
              KROUND = 2
              CALL FM_F(N,M_1%MFM,MB%RIGHT)
          ELSE
              KROUND = 2
              CALL FM_F(N,MA%LEFT,M_4%MFM)
              CALL FM_F(N,MA%RIGHT,M_5%MFM)
              IF (FMCOMP(M_4%MFM,'>',M_5%MFM)) THEN
                  CALL FMEQ(M_4%MFM,MB%RIGHT)
              ELSE
                  CALL FMEQ(M_5%MFM,MB%RIGHT)
              ENDIF
          ENDIF
          GO TO 120
      ELSE IF ( (FMCOMP(M_5%MFM,'>',M1LVFM) .AND. FMCOMP(M_5%MFM,'>',M2LVFM)) .OR.  &
                (FMCOMP(M_1%MFM,'>=',M1LVFM) .AND. FMCOMP(M_2%MFM,'>=',M2LVFM)) ) THEN
          CALL FM_FIND_EXTREME_POINT_IFM(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                   &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,N,FM_F)
          KROUND = 2
          CALL FM_F(N,M_1%MFM,MB%RIGHT)
          KROUND = -1
          CALL FM_F(N,MA%LEFT,M_4%MFM)
          CALL FM_F(N,MA%RIGHT,M_5%MFM)
          IF (FMCOMP(M_4%MFM,'<',M_5%MFM)) THEN
              CALL FMEQ(M_4%MFM,MB%LEFT)
          ELSE
              CALL FMEQ(M_5%MFM,MB%LEFT)
          ENDIF
          GO TO 120
      ENDIF
  110 KROUND = -1
      CALL FM_F(N,MA%LEFT,M_4%MFM)
      CALL FM_F(N,MA%RIGHT,M_5%MFM)
      CALL FMEQ(M_4%MFM,MB%LEFT)
      IF (FMCOMP(MB%LEFT,'>',M_5%MFM)) THEN
          CALL FMEQ(M_5%MFM,MB%LEFT)
      ENDIF
      L = 1
      IF (FMCOMP(M_4%MFM,'<',M_5%MFM)) THEN
          L = 2
      ENDIF
      KROUND = 2
      IF (L == 1) THEN
          CALL FM_F(N,MA%LEFT,MB%RIGHT)
      ELSE IF (L == 2) THEN
          CALL FM_F(N,MA%RIGHT,MB%RIGHT)
      ENDIF
  120 KROUND = KRSAVE
   END SUBROUTINE FM_INTERVAL_F_IFM

   SUBROUTINE FM_FIND_EXTREME_POINT_IFM(MIN_OR_MAX,AX,BX,TOL,XVAL,FVAL,N,F)

!  Same routine as FM_FIND_EXTREME_POINT, except the function includes an integer argument:  F(N,X)

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MINV,MIN_OR_MAX,N,NDSAVE
      TYPE (FM) :: AX,BX,TOL,XVAL,FVAL
      EXTERNAL :: F

      TYPE (FM), SAVE :: A, B, C, D, E, EPS, XM, P, Q, R, T2, U, V, W, FU, FV, FW, FX, X, TOL1, TOL3

      NDSAVE = NDIG
      NDIG = MAX(NDIG+NGRD52,2)
      MINV = 1
      IF (MIN_OR_MAX /= 1) MINV = -1
      IF (AX < BX) THEN
          CALL FM_EQU(AX,A,NDSAVE,NDIG)
          CALL FM_EQU(BX,B,NDSAVE,NDIG)
      ELSE
          CALL FM_EQU(AX,B,NDSAVE,NDIG)
          CALL FM_EQU(BX,A,NDSAVE,NDIG)
      ENDIF

!             C is the squared inverse of the golden ratio.

      C = (3-SQRT(TO_FM('5.0D0')))/2

!             EPS is approximately the square root of the relative machine precision.

      EPS = EPSILON(A)
      TOL1 = EPS + 1
      EPS = SQRT(EPS)
      V = A + C*(B-A)
      W = V
      X = V
      E = 0
      FX = 0
      CALL F(N,X%MFM,FX%MFM)
      FX = FX*MINV
      FV = FX
      FW = FX
      TOL3 = 0
      CALL FM_EQU(TOL,TOL3,NDSAVE,NDIG)
      TOL3 = TOL3/3

!             The main loop starts here.

  110 XM = A + (B-A)/2
      TOL1 = EPS*ABS(X) + TOL3
      T2 = 2*TOL1

!             Check the stopping criterion.

      IF (ABS(X-XM) <= (T2-(B-A)/2)) GO TO 160
      P = 0
      Q = 0
      R = 0
      IF (ABS(E) > TOL1) THEN
          R = (X-W)*(FX-FV)    !     Fit a parabola.
          Q = (X-V)*(FX-FW)
          P = (X-V)*Q-(X-W)*R
          Q = 2*(Q-R)
          IF (Q > 0) THEN
              P = -P
          ELSE
              Q = -Q
          ENDIF
          R = E
          E = D
      ENDIF

      IF ((ABS(P) >= ABS(Q*R/2)) .OR. (P <= Q*(A-X)) .OR. (P >= Q*(B-X))) GO TO 120

!             Make a parabolic-interpolation step.

      D = P/Q
      U = X + D

!             f must not be evaluated too close to ax or bx.

      IF (((U-A) >= T2) .AND. ((B-U) >= T2)) GO TO 130
      D = TOL1
      IF (X >= XM) D = -D
      GO TO 130

!             Make a golden-section step.

  120 IF (X < XM) THEN
          E = B - X
      ELSE
          E = A - X
      ENDIF
      D = C*E

!             f must not be evaluated too close to x.

  130 IF (ABS(D) >= TOL1) THEN
          U = X + D
      ELSE
          IF (D > 0) THEN
              U = X + TOL1
          ELSE
              U = X - TOL1
          ENDIF
      ENDIF
      FU = 0
      CALL F(N,U%MFM,FU%MFM)
      FU = FU*MINV

!             update  a, b, v, w, and x.

      IF (FX <= FU) THEN
          IF (U < X) THEN
              A = U
          ELSE
              B = U
          ENDIF
      ENDIF
      IF (FU > FX) GO TO 140
      IF (U < X) THEN
          B = X
      ELSE
          A = X
      ENDIF
      V = W
      FV = FW
      W = X
      FW = FX
      X = U
      FX = FU
      GO TO 110

  140 IF ((FU > FW) .AND. (W /= X)) GO TO 150
      V = W
      FV = FW
      W = U
      FW = FU
      GO TO 110

  150 IF ((FU > FV) .AND. (V /= X) .AND. (V /= W)) GO TO 110
      V = U
      FV = FU
      GO TO 110

!  end of main loop

  160 CALL FM_EQU(X,XVAL,NDIG,NDSAVE)
      CALL FM_EQU(FX*MINV,FVAL,NDIG,NDSAVE)
      NDIG = NDSAVE

   END SUBROUTINE FM_FIND_EXTREME_POINT_IFM

   SUBROUTINE FM_INTERVAL_F_FMI(FM_F,MA,N,MB)

!  General interval evaluation for a special function of one FM variable:
!      CALL FM_F(MA,N,MB)

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: I,KRSAVE,L,N
      EXTERNAL :: FM_F
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MVLVFM,M1LVFM,M2LVFM
      KRSAVE = KROUND
      IF ( ABS(RIGHT_ENDPOINT(MA)-LEFT_ENDPOINT(MA)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))) /  &
           (100*SQRT(EPSILON(TO_FM(1))))) GO TO 110
      CALL FMST2M(' OVERFLOW',M_4%MFM)
      CALL FMST2M('-OVERFLOW',M_5%MFM)
      DO I = 1, 9
         CALL FMSUB(MA%RIGHT,MA%LEFT,M1LVFM)
         CALL FMMPYI_R1(M1LVFM,I)
         CALL FMDIVI_R1(M1LVFM,10)
         CALL FMADD(MA%LEFT,M1LVFM,M_1%MFM)
         CALL FM_F(M_1%MFM,N,MVLVFM)
         IF (FMCOMP(MVLVFM,'<',M_4%MFM)) THEN
             CALL FMEQ(MVLVFM,M_4%MFM)
         ENDIF
         IF (FMCOMP(MVLVFM,'>',M_5%MFM)) THEN
             CALL FMEQ(MVLVFM,M_5%MFM)
         ENDIF
      ENDDO
      CALL FM_F(MA%LEFT,N,M1LVFM)
      CALL FM_F(MA%RIGHT,N,M2LVFM)
      IF (LEFT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( LEFT_ENDPOINT(MA) + ABS(LEFT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_3)
      ENDIF
      CALL FM_F(M_3%MFM,N,M_1%MFM)
      IF (RIGHT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - ABS(RIGHT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( -SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 < LEFT_ENDPOINT(MA)) THEN
              CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_3)
      ENDIF
      CALL FM_F(M_3%MFM,N,M_2%MFM)
      IF ( (FMCOMP(M_4%MFM,'<',M1LVFM) .AND. FMCOMP(M_4%MFM,'<',M2LVFM)) .OR.  &
           (FMCOMP(M_1%MFM,'<=',M1LVFM) .AND. FMCOMP(M_2%MFM,'<=',M2LVFM)) ) THEN
          CALL FM_FIND_EXTREME_POINT_FMI(1,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                   &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,N,FM_F)
          KROUND = -1
          CALL FM_F(M_1%MFM,N,MB%LEFT)
          IF (FMCOMP(M_5%MFM,'>',M1LVFM) .AND. FMCOMP(M_5%MFM,'>',M2LVFM)) THEN
              CALL FM_FIND_EXTREME_POINT_FMI(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),  &
                                             MAX(SPACING(RIGHT_ENDPOINT(MA)),         &
                                                 SPACING(LEFT_ENDPOINT(MA))),         &
                                             M_1,M_2,N,FM_F)
              KROUND = 2
              CALL FM_F(M_1%MFM,N,MB%RIGHT)
          ELSE
              KROUND = 2
              CALL FM_F(MA%LEFT,N,M_4%MFM)
              CALL FM_F(MA%RIGHT,N,M_5%MFM)
              IF (FMCOMP(M_4%MFM,'>',M_5%MFM)) THEN
                  CALL FMEQ(M_4%MFM,MB%RIGHT)
              ELSE
                  CALL FMEQ(M_5%MFM,MB%RIGHT)
              ENDIF
          ENDIF
          GO TO 120
      ELSE IF ( (FMCOMP(M_5%MFM,'>',M1LVFM) .AND. FMCOMP(M_5%MFM,'>',M2LVFM)) .OR.  &
                (FMCOMP(M_1%MFM,'>=',M1LVFM) .AND. FMCOMP(M_2%MFM,'>=',M2LVFM)) ) THEN
          CALL FM_FIND_EXTREME_POINT_FMI(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                   &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,N,FM_F)
          KROUND = 2
          CALL FM_F(M_1%MFM,N,MB%RIGHT)
          KROUND = -1
          CALL FM_F(MA%LEFT,N,M_4%MFM)
          CALL FM_F(MA%RIGHT,N,M_5%MFM)
          IF (FMCOMP(M_4%MFM,'<',M_5%MFM)) THEN
              CALL FMEQ(M_4%MFM,MB%LEFT)
          ELSE
              CALL FMEQ(M_5%MFM,MB%LEFT)
          ENDIF
          GO TO 120
      ENDIF
  110 KROUND = -1
      CALL FM_F(MA%LEFT,N,M_4%MFM)
      CALL FM_F(MA%RIGHT,N,M_5%MFM)
      CALL FMEQ(M_4%MFM,MB%LEFT)
      IF (FMCOMP(MB%LEFT,'>',M_5%MFM)) THEN
          CALL FMEQ(M_5%MFM,MB%LEFT)
      ENDIF
      L = 1
      IF (FMCOMP(M_4%MFM,'<',M_5%MFM)) THEN
          L = 2
      ENDIF
      KROUND = 2
      IF (L == 1) THEN
          CALL FM_F(MA%LEFT,N,MB%RIGHT)
      ELSE IF (L == 2) THEN
          CALL FM_F(MA%RIGHT,N,MB%RIGHT)
      ENDIF
  120 KROUND = KRSAVE
   END SUBROUTINE FM_INTERVAL_F_FMI

   SUBROUTINE FM_FIND_EXTREME_POINT_FMI(MIN_OR_MAX,AX,BX,TOL,XVAL,FVAL,N,F)

!  Same routine as FM_FIND_EXTREME_POINT, except the function includes an integer argument:  F(X,N)

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MINV,MIN_OR_MAX,N,NDSAVE
      TYPE (FM) :: AX,BX,TOL,XVAL,FVAL
      EXTERNAL :: F

      TYPE (FM), SAVE :: A, B, C, D, E, EPS, XM, P, Q, R, T2, U, V, W, FU, FV, FW, FX, X, TOL1, TOL3

      NDSAVE = NDIG
      NDIG = MAX(NDIG+NGRD52,2)
      MINV = 1
      IF (MIN_OR_MAX /= 1) MINV = -1
      IF (AX < BX) THEN
          CALL FM_EQU(AX,A,NDSAVE,NDIG)
          CALL FM_EQU(BX,B,NDSAVE,NDIG)
      ELSE
          CALL FM_EQU(AX,B,NDSAVE,NDIG)
          CALL FM_EQU(BX,A,NDSAVE,NDIG)
      ENDIF

!             C is the squared inverse of the golden ratio.

      C = (3-SQRT(TO_FM('5.0D0')))/2

!             EPS is approximately the square root of the relative machine precision.

      EPS = EPSILON(A)
      TOL1 = EPS + 1
      EPS = SQRT(EPS)
      V = A + C*(B-A)
      W = V
      X = V
      E = 0
      FX = 0
      CALL F(X%MFM,N,FX%MFM)
      FX = FX*MINV
      FV = FX
      FW = FX
      TOL3 = 0
      CALL FM_EQU(TOL,TOL3,NDSAVE,NDIG)
      TOL3 = TOL3/3

!             The main loop starts here.

  110 XM = A + (B-A)/2
      TOL1 = EPS*ABS(X) + TOL3
      T2 = 2*TOL1

!             Check the stopping criterion.

      IF (ABS(X-XM) <= (T2-(B-A)/2)) GO TO 160
      P = 0
      Q = 0
      R = 0
      IF (ABS(E) > TOL1) THEN
          R = (X-W)*(FX-FV)    !     Fit a parabola.
          Q = (X-V)*(FX-FW)
          P = (X-V)*Q-(X-W)*R
          Q = 2*(Q-R)
          IF (Q > 0) THEN
              P = -P
          ELSE
              Q = -Q
          ENDIF
          R = E
          E = D
      ENDIF

      IF ((ABS(P) >= ABS(Q*R/2)) .OR. (P <= Q*(A-X)) .OR. (P >= Q*(B-X))) GO TO 120

!             Make a parabolic-interpolation step.

      D = P/Q
      U = X + D

!             f must not be evaluated too close to ax or bx.

      IF (((U-A) >= T2) .AND. ((B-U) >= T2)) GO TO 130
      D = TOL1
      IF (X >= XM) D = -D
      GO TO 130

!             Make a golden-section step.

  120 IF (X < XM) THEN
          E = B - X
      ELSE
          E = A - X
      ENDIF
      D = C*E

!             f must not be evaluated too close to x.

  130 IF (ABS(D) >= TOL1) THEN
          U = X + D
      ELSE
          IF (D > 0) THEN
              U = X + TOL1
          ELSE
              U = X - TOL1
          ENDIF
      ENDIF
      FU = 0
      CALL F(U%MFM,N,FU%MFM)
      FU = FU*MINV

!             update  a, b, v, w, and x.

      IF (FX <= FU) THEN
          IF (U < X) THEN
              A = U
          ELSE
              B = U
          ENDIF
      ENDIF
      IF (FU > FX) GO TO 140
      IF (U < X) THEN
          B = X
      ELSE
          A = X
      ENDIF
      V = W
      FV = FW
      W = X
      FW = FX
      X = U
      FX = FU
      GO TO 110

  140 IF ((FU > FW) .AND. (W /= X)) GO TO 150
      V = W
      FV = FW
      W = U
      FW = FU
      GO TO 110

  150 IF ((FU > FV) .AND. (V /= X) .AND. (V /= W)) GO TO 110
      V = U
      FV = FU
      GO TO 110

!  end of main loop

  160 CALL FM_EQU(X,XVAL,NDIG,NDSAVE)
      CALL FM_EQU(FX*MINV,FVAL,NDIG,NDSAVE)
      NDIG = NDSAVE

   END SUBROUTINE FM_FIND_EXTREME_POINT_FMI

   SUBROUTINE FMEDGE_INTERVAL_FM(MA,MB,LEFT,RIGHT)

!  Check for extreme function values on the edges of the rectangle MA x MB.
!  K_ROUTINE_EDGE identifies the function being evaluated.
!  The output interval is [ LEFT , RIGHT ].

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      TYPE(MULTI) :: LEFT,RIGHT
      INTEGER :: J
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: LEFT,RIGHT
      TYPE (FM), SAVE :: DF1,DF2,F,FMAX,FMIN,  &
                         LAST_M_1,M_1A,M_1B,X0,         &
                         X,Y0,Y
      EXTERNAL :: F_EDGE
      IF (K_ROUTINE_EDGE == 1) THEN
          CALL FM_EQ(BETA(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB)),F)
      ELSE IF (K_ROUTINE_EDGE == 2) THEN
          CALL FM_EQ(BINOMIAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB)),F)
      ENDIF
      CALL FM_EQ(F,FMIN)
      CALL FM_EQ(F,FMAX)
      IF (K_ROUTINE_EDGE == 1) THEN
          CALL FM_EQ(BETA(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MB)),F)
      ELSE IF (K_ROUTINE_EDGE == 2) THEN
          CALL FM_EQ(BINOMIAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MB)),F)
      ENDIF
      CALL FM_EQ(MIN( FMIN , F ),FMIN)
      CALL FM_EQ(MAX( FMAX , F ),FMAX)
      IF (K_ROUTINE_EDGE == 1) THEN
          CALL FM_EQ(BETA(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB)),F)
      ELSE IF (K_ROUTINE_EDGE == 2) THEN
          CALL FM_EQ(BINOMIAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB)),F)
      ENDIF
      CALL FM_EQ(MIN( FMIN , F ),FMIN)
      CALL FM_EQ(MAX( FMAX , F ),FMAX)
      IF (K_ROUTINE_EDGE == 1) THEN
          CALL FM_EQ(BETA(RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB)),F)
      ELSE IF (K_ROUTINE_EDGE == 2) THEN
          CALL FM_EQ(BINOMIAL(RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB)),F)
      ENDIF
      CALL FM_EQ(MIN( FMIN , F ),FMIN)
      CALL FM_EQ(MAX( FMAX , F ),FMAX)
      IF ( ABS(RIGHT_ENDPOINT(MA)-LEFT_ENDPOINT(MA)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))) /  &
           (100*SQRT(EPSILON(TO_FM(1)))) .AND.                            &
           ABS(RIGHT_ENDPOINT(MB)-LEFT_ENDPOINT(MB)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MB)),SPACING(LEFT_ENDPOINT(MB))) /  &
           (100*SQRT(EPSILON(TO_FM(1))))) GO TO 110
      IF (K_ROUTINE_EDGE == 1) THEN
          IF (LEFT_ENDPOINT(MA) + LEFT_ENDPOINT(MB) >= 0) THEN
              CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),  &
                                     FMIN,FMAX)
          ELSE
              CALL FM_EQ(CEILING(LEFT_ENDPOINT(MA)+LEFT_ENDPOINT(MB))-LEFT_ENDPOINT(MB),M_1)
              IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),M_1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1+1,M_1)
                  IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                      CALL FMEDGE_HORIZONTAL(M_1-1,M_1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                      CALL FM_EQ(M_1+1,M_1)
                      IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                          CALL FMEDGE_HORIZONTAL(M_1-1,M_1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),  &
                                         FMIN,FMAX)
              ENDIF
              CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)+LEFT_ENDPOINT(MB))-LEFT_ENDPOINT(MB),M_1)
              IF (M_1+LEFT_ENDPOINT(MB) > 0) THEN
                  CALL FM_EQ(-LEFT_ENDPOINT(MB),M_1)
              ENDIF
              IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                  CALL FMEDGE_HORIZONTAL(M_1,RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1-1,M_1)
                  IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                      CALL FMEDGE_HORIZONTAL(M_1,M_1+1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                      CALL FM_EQ(M_1-1,M_1)
                      IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                          CALL FMEDGE_HORIZONTAL(M_1,M_1+1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),  &
                                         FMIN,FMAX)
              ENDIF
              DO J = 0, 10
                 IF (J > 0) CALL FM_EQ(X,X0)
                 CALL FM_EQ((10-J)*LEFT_ENDPOINT(MA)/10 + J*RIGHT_ENDPOINT(MA)/10,X)
                 CALL FM_EQ(LEFT_ENDPOINT(MB),Y)
                 CALL FM_EQ(BETA(X,Y),F)
                 IF (J == 0) THEN
                     CALL FM_EQ(F*(POLYGAMMA(0,X)-POLYGAMMA(0,X+Y)),DF2)
                     CYCLE
                 ELSE
                     CALL FM_EQ(DF2,DF1)
                     CALL FM_EQ(F*(POLYGAMMA(0,X)-POLYGAMMA(0,X+Y)),DF2)
                 ENDIF
                 IF (DF1 < 0 .AND. DF2 > 0 .AND. KROUND == -1) THEN
                     KXY_EDGE = 1
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(Y,Y_EDGE)
                     CALL FM_FIND_EXTREME_POINT(1,X0,X,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MIN(F,FMIN),FMIN)
                 ENDIF
                 IF (DF1 > 0 .AND. DF2 < 0 .AND. KROUND == 2) THEN
                     KXY_EDGE = 1
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(Y,Y_EDGE)
                     CALL FM_FIND_EXTREME_POINT(2,X0,X,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MAX(F,FMAX),FMAX)
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 2) THEN
          IF (LEFT_ENDPOINT(MA) - LEFT_ENDPOINT(MB) > -1) THEN
              CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),  &
                                     FMIN,FMAX)
          ELSE
              CALL FM_EQ(CEILING( LEFT_ENDPOINT(MA) - LEFT_ENDPOINT(MB) ),M_1)
              IF (M_1 < 0) THEN
                  CALL FM_EQ(LEFT_ENDPOINT(MB) + M_1,M_1)
              ELSE
                  CALL FM_EQ(TO_FM('+OVERFLOW'),M_1)
              ENDIF
              IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),M_1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1+1,M_1)
                  IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                      CALL FMEDGE_HORIZONTAL(M_1-1,M_1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                      CALL FM_EQ(M_1+1,M_1)
                      IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                          CALL FMEDGE_HORIZONTAL(M_1-1,M_1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),  &
                                         FMIN,FMAX)
              ENDIF
              CALL FM_EQ(FLOOR( RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MB) ),M_1)
              IF (M_1 < 0) THEN
                  CALL FM_EQ(LEFT_ENDPOINT(MB) + M_1,M_1)
                  IF (M_1 > RIGHT_ENDPOINT(MA)) CALL FM_EQ(TO_FM('-OVERFLOW'),M_1)
              ELSE
                  CALL FM_EQ(LEFT_ENDPOINT(MB) - 1,M_1)
                  IF (M_1 > RIGHT_ENDPOINT(MA)) CALL FM_EQ(TO_FM('-OVERFLOW'),M_1)
              ENDIF
              IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                  CALL FMEDGE_HORIZONTAL(M_1,RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1-1,M_1)
                  IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                      CALL FMEDGE_HORIZONTAL(M_1,M_1+1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                      CALL FM_EQ(M_1-1,M_1)
                      IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                          CALL FMEDGE_HORIZONTAL(M_1,M_1+1,LEFT_ENDPOINT(MB),FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),  &
                                         FMIN,FMAX)
              ENDIF
              DO J = 0, 10
                 IF (J > 0) CALL FM_EQ(X,X0)
                 CALL FM_EQ((10-J)*LEFT_ENDPOINT(MA)/10 + J*RIGHT_ENDPOINT(MA)/10,X)
                 CALL FM_EQ(LEFT_ENDPOINT(MB),Y)
                 CALL FM_EQ(BINOMIAL(X,Y),F)
                 IF (J == 0) THEN
                     CALL FM_EQ(F*(POLYGAMMA(0,1+X)-POLYGAMMA(0,1+X-Y)),DF2)
                     CYCLE
                 ELSE
                     CALL FM_EQ(DF2,DF1)
                     CALL FM_EQ(F*(POLYGAMMA(0,1+X)-POLYGAMMA(0,1+X-Y)),DF2)
                 ENDIF
                 IF (DF1 < 0 .AND. DF2 > 0 .AND. KROUND == -1) THEN
                     KXY_EDGE = 1
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(Y,Y_EDGE)
                     CALL FM_FIND_EXTREME_POINT(1,X0,X,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MIN(F,FMIN),FMIN)
                 ENDIF
                 IF (DF1 > 0 .AND. DF2 < 0 .AND. KROUND == 2) THEN
                     KXY_EDGE = 1
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(Y,Y_EDGE)
                     CALL FM_FIND_EXTREME_POINT(2,X0,X,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MAX(F,FMAX),FMAX)
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 1) THEN
          IF (LEFT_ENDPOINT(MA) + LEFT_ENDPOINT(MB) >= 0) THEN
              CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB),  &
                                     FMIN,FMAX)
          ELSE
              CALL FM_EQ(CEILING(LEFT_ENDPOINT(MA)+RIGHT_ENDPOINT(MB))-RIGHT_ENDPOINT(MB),M_1)
              IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1+1,M_1)
                  IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                      CALL FMEDGE_HORIZONTAL(M_1-1,M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                      CALL FM_EQ(M_1+1,M_1)
                      IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                          CALL FMEDGE_HORIZONTAL(M_1-1,M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB),  &
                                         FMIN,FMAX)
              ENDIF
              CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)+RIGHT_ENDPOINT(MB))-RIGHT_ENDPOINT(MB),M_1)
              IF (M_1+RIGHT_ENDPOINT(MB) > 0) THEN
                  CALL FM_EQ(-RIGHT_ENDPOINT(MB),M_1)
              ENDIF
              IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                  CALL FMEDGE_HORIZONTAL(M_1,RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1-1,M_1)
                  IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                      CALL FMEDGE_HORIZONTAL(M_1,M_1+1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                      CALL FM_EQ(M_1-1,M_1)
                      IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                          CALL FMEDGE_HORIZONTAL(M_1,M_1+1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB),  &
                                         FMIN,FMAX)
              ENDIF
              DO J = 0, 10
                 IF (J > 0) CALL FM_EQ(X,X0)
                 CALL FM_EQ((10-J)*LEFT_ENDPOINT(MA)/10 + J*RIGHT_ENDPOINT(MA)/10,X)
                 CALL FM_EQ(RIGHT_ENDPOINT(MB),Y)
                 CALL FM_EQ(BETA(X,Y),F)
                 IF (J == 0) THEN
                     CALL FM_EQ(F*(POLYGAMMA(0,X)-POLYGAMMA(0,X+Y)),DF2)
                     CYCLE
                 ELSE
                     CALL FM_EQ(DF2,DF1)
                     CALL FM_EQ(F*(POLYGAMMA(0,X)-POLYGAMMA(0,X+Y)),DF2)
                 ENDIF
                 IF (DF1 < 0 .AND. DF2 > 0 .AND. KROUND == -1) THEN
                     KXY_EDGE = 1
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(Y,Y_EDGE)
                     CALL FM_FIND_EXTREME_POINT(1,X0,X,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MIN(F,FMIN),FMIN)
                 ENDIF
                 IF (DF1 > 0 .AND. DF2 < 0 .AND. KROUND == 2) THEN
                     KXY_EDGE = 1
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(Y,Y_EDGE)
                     CALL FM_FIND_EXTREME_POINT(2,X0,X,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MAX(F,FMAX),FMAX)
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 2) THEN
          IF (LEFT_ENDPOINT(MA) - RIGHT_ENDPOINT(MB) > -1) THEN
              CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB),  &
                                     FMIN,FMAX)
          ELSE
              CALL FM_EQ(CEILING( LEFT_ENDPOINT(MA) - RIGHT_ENDPOINT(MB) ),M_1)
              IF (M_1 < 0) THEN
                  CALL FM_EQ(RIGHT_ENDPOINT(MB) + M_1,M_1)
              ELSE
                  CALL FM_EQ(TO_FM('+OVERFLOW'),M_1)
              ENDIF
              IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1+1,M_1)
                  IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                      CALL FMEDGE_HORIZONTAL(M_1-1,M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                      CALL FM_EQ(M_1+1,M_1)
                      IF (M_1 <= RIGHT_ENDPOINT(MA)) THEN
                          CALL FMEDGE_HORIZONTAL(M_1-1,M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB),  &
                                         FMIN,FMAX)
              ENDIF
              CALL FM_EQ(FLOOR( RIGHT_ENDPOINT(MA) - RIGHT_ENDPOINT(MB) ),M_1)
              IF (M_1 < 0) THEN
                  CALL FM_EQ(RIGHT_ENDPOINT(MB) + M_1,M_1)
                  IF (M_1 > RIGHT_ENDPOINT(MA)) CALL FM_EQ(TO_FM('-OVERFLOW'),M_1)
              ELSE
                  CALL FM_EQ(RIGHT_ENDPOINT(MB) - 1,M_1)
                  IF (M_1 > RIGHT_ENDPOINT(MA)) CALL FM_EQ(TO_FM('-OVERFLOW'),M_1)
              ENDIF
              IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                  CALL FMEDGE_HORIZONTAL(M_1,RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1-1,M_1)
                  IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                      CALL FMEDGE_HORIZONTAL(M_1,M_1+1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                      CALL FM_EQ(M_1-1,M_1)
                      IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
                          CALL FMEDGE_HORIZONTAL(M_1,M_1+1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_HORIZONTAL(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB),  &
                                         FMIN,FMAX)
              ENDIF
              DO J = 0, 10
                 IF (J > 0) CALL FM_EQ(X,X0)
                 CALL FM_EQ((10-J)*LEFT_ENDPOINT(MA)/10 + J*RIGHT_ENDPOINT(MA)/10,X)
                 CALL FM_EQ(RIGHT_ENDPOINT(MB),Y)
                 CALL FM_EQ(BINOMIAL(X,Y),F)
                 IF (J == 0) THEN
                     CALL FM_EQ(F*(POLYGAMMA(0,1+X)-POLYGAMMA(0,1+X-Y)),DF2)
                     CYCLE
                 ELSE
                     CALL FM_EQ(DF2,DF1)
                     CALL FM_EQ(F*(POLYGAMMA(0,1+X)-POLYGAMMA(0,1+X-Y)),DF2)
                 ENDIF
                 IF (DF1 < 0 .AND. DF2 > 0 .AND. KROUND == -1) THEN
                     KXY_EDGE = 1
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(Y,Y_EDGE)
                     CALL FM_FIND_EXTREME_POINT(1,X0,X,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MIN(F,FMIN),FMIN)
                 ENDIF
                 IF (DF1 > 0 .AND. DF2 < 0 .AND. KROUND == 2) THEN
                     KXY_EDGE = 1
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(Y,Y_EDGE)
                     CALL FM_FIND_EXTREME_POINT(2,X0,X,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MAX(F,FMAX),FMAX)
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 1) THEN
          IF (LEFT_ENDPOINT(MA) + LEFT_ENDPOINT(MB) >= 0) THEN
              CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                   FMIN,FMAX)
          ELSE
              CALL FM_EQ(CEILING(LEFT_ENDPOINT(MB)+LEFT_ENDPOINT(MA))-LEFT_ENDPOINT(MA),M_1)
              IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                  CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB),M_1,FMIN,FMAX)
                  CALL FM_EQ(M_1+1,M_1)
                  IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                      CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),M_1-1,M_1,FMIN,FMAX)
                      CALL FM_EQ(M_1+1,M_1)
                      IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                          CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),M_1-1,M_1,FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                       FMIN,FMAX)
              ENDIF
              CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MB)+LEFT_ENDPOINT(MA))-LEFT_ENDPOINT(MA),M_1)
              IF (M_1+LEFT_ENDPOINT(MA) > 0) THEN
                  CALL FM_EQ(-LEFT_ENDPOINT(MA),M_1)
              ENDIF
              IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                  CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1-1,M_1)
                  IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                      CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),M_1,M_1+1,FMIN,FMAX)
                      CALL FM_EQ(M_1-1,M_1)
                      IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                          CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),M_1,M_1+1,FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                       FMIN,FMAX)
              ENDIF
              DO J = 0, 10
                 IF (J > 0) CALL FM_EQ(Y,Y0)
                 CALL FM_EQ(LEFT_ENDPOINT(MA),X)
                 CALL FM_EQ((10-J)*LEFT_ENDPOINT(MB)/10 + J*RIGHT_ENDPOINT(MB)/10,Y)
                 CALL FM_EQ(BETA(X,Y),F)
                 IF (J == 0) THEN
                     CALL FM_EQ(F*(POLYGAMMA(0,Y)-POLYGAMMA(0,X+Y)),DF2)
                     CYCLE
                 ELSE
                     CALL FM_EQ(DF2,DF1)
                     CALL FM_EQ(F*(POLYGAMMA(0,Y)-POLYGAMMA(0,X+Y)),DF2)
                 ENDIF
                 IF (DF1 < 0 .AND. DF2 > 0 .AND. KROUND == -1) THEN
                     KXY_EDGE = 2
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(X,X_EDGE)
                     CALL FM_FIND_EXTREME_POINT(1,Y0,Y,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MIN(F,FMIN),FMIN)
                 ENDIF
                 IF (DF1 > 0 .AND. DF2 < 0 .AND. KROUND == 2) THEN
                     KXY_EDGE = 2
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(X,X_EDGE)
                     CALL FM_FIND_EXTREME_POINT(2,Y0,Y,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MAX(F,FMAX),FMAX)
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 2) THEN
          IF (LEFT_ENDPOINT(MB) > -1 .AND. LEFT_ENDPOINT(MA) - RIGHT_ENDPOINT(MB) > -1) THEN
              CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                   FMIN,FMAX)
          ELSE
              CALL FM_EQ(FLOOR( LEFT_ENDPOINT(MA) - LEFT_ENDPOINT(MB) ),M_1A)
              IF (M_1A < 0) THEN
                  CALL FM_EQ(LEFT_ENDPOINT(MA) - M_1A,M_1A)
                  IF (M_1A > RIGHT_ENDPOINT(MB)) CALL FM_EQ(TO_FM('+OVERFLOW'),M_1A)
              ELSE
                  CALL FM_EQ(LEFT_ENDPOINT(MA) + 1,M_1A)
                  IF (M_1A > RIGHT_ENDPOINT(MB)) CALL FM_EQ(TO_FM('+OVERFLOW'),M_1A)
              ENDIF
              CALL FM_EQ(CEILING(LEFT_ENDPOINT(MB)),M_1B)
              IF (M_1B == LEFT_ENDPOINT(MB)) THEN
                  CALL FM_EQ(M_1B+1,M_1B)
              ENDIF
              IF (M_1B > -0.5) CALL FM_EQ(TO_FM('+OVERFLOW'),M_1B)
              IF (M_1A < M_1B) THEN
                  CALL FM_EQ(M_1A,M_1)
              ELSE
                  CALL FM_EQ(M_1B,M_1)
              ENDIF
              IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                  CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB),M_1,FMIN,FMAX)
                  CALL FM_EQ(M_1,LAST_M_1)
                  IF (M_1A < M_1B) THEN
                      CALL FM_EQ(M_1A+1,M_1A)
                  ELSE
                      CALL FM_EQ(M_1B+1,M_1B)
                  ENDIF
                  IF (M_1A < M_1B) THEN
                      CALL FM_EQ(M_1A,M_1)
                  ELSE
                      CALL FM_EQ(M_1B,M_1)
                  ENDIF
                  IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                      CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LAST_M_1,M_1,FMIN,FMAX)
                      CALL FM_EQ(M_1,LAST_M_1)
                      IF (M_1A < M_1B) THEN
                          CALL FM_EQ(M_1A+1,M_1A)
                      ELSE
                          CALL FM_EQ(M_1B+1,M_1B)
                      ENDIF
                      IF (M_1A < M_1B) THEN
                          CALL FM_EQ(M_1A,M_1)
                      ELSE
                          CALL FM_EQ(M_1B,M_1)
                      ENDIF
                      IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                          CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LAST_M_1,M_1,FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                       FMIN,FMAX)
              ENDIF
              CALL FM_EQ(FLOOR( RIGHT_ENDPOINT(MB) - LEFT_ENDPOINT(MA) ),M_1A)
              IF (M_1A > 0) THEN
                  CALL FM_EQ(LEFT_ENDPOINT(MA) + M_1A,M_1A)
                  IF (M_1A > RIGHT_ENDPOINT(MB)) CALL FM_EQ(TO_FM('-OVERFLOW'),M_1A)
              ELSE
                  CALL FM_EQ(TO_FM('-OVERFLOW'),M_1A)
              ENDIF
              CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MB)),M_1B)
              IF (M_1B == RIGHT_ENDPOINT(MB)) THEN
                  CALL FM_EQ(M_1B-1,M_1B)
              ENDIF
              IF (M_1B > -0.5) CALL FM_EQ(TO_FM('-OVERFLOW'),M_1B)
              IF (M_1A > M_1B) THEN
                  CALL FM_EQ(M_1A,M_1)
              ELSE
                  CALL FM_EQ(M_1B,M_1)
              ENDIF
              IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                  CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1,LAST_M_1)
                  IF (M_1A > M_1B) THEN
                      CALL FM_EQ(M_1A-1,M_1A)
                  ELSE
                      CALL FM_EQ(M_1B-1,M_1B)
                  ENDIF
                  IF (M_1A > M_1B) THEN
                      CALL FM_EQ(M_1A,M_1)
                  ELSE
                      CALL FM_EQ(M_1B,M_1)
                  ENDIF
                  IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                      CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),M_1,LAST_M_1,FMIN,FMAX)
                      CALL FM_EQ(M_1,LAST_M_1)
                  IF (M_1A > M_1B) THEN
                      CALL FM_EQ(M_1A-1,M_1A)
                  ELSE
                      CALL FM_EQ(M_1B-1,M_1B)
                  ENDIF
                  IF (M_1A > M_1B) THEN
                      CALL FM_EQ(M_1A,M_1)
                  ELSE
                      CALL FM_EQ(M_1B,M_1)
                  ENDIF
                      IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                          CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),M_1,LAST_M_1,FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_VERTICAL(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                       FMIN,FMAX)
              ENDIF
              DO J = 0, 10
                 IF (J > 0) CALL FM_EQ(Y,Y0)
                 CALL FM_EQ(LEFT_ENDPOINT(MA),X)
                 CALL FM_EQ((10-J)*LEFT_ENDPOINT(MB)/10 + J*RIGHT_ENDPOINT(MB)/10,Y)
                 CALL FM_EQ(BINOMIAL(X,Y),F)
                 IF (J == 0) THEN
                     CALL FM_EQ(F*(POLYGAMMA(0,1+X-Y)-POLYGAMMA(0,1+Y)),DF2)
                     CYCLE
                 ELSE
                     CALL FM_EQ(DF2,DF1)
                     CALL FM_EQ(F*(POLYGAMMA(0,1+X-Y)-POLYGAMMA(0,1+Y)),DF2)
                 ENDIF
                 IF (DF1 < 0 .AND. DF2 > 0 .AND. KROUND == -1) THEN
                     KXY_EDGE = 2
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(X,X_EDGE)
                     CALL FM_FIND_EXTREME_POINT(1,Y0,Y,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MIN(F,FMIN),FMIN)
                 ENDIF
                 IF (DF1 > 0 .AND. DF2 < 0 .AND. KROUND == 2) THEN
                     KXY_EDGE = 2
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(X,X_EDGE)
                     CALL FM_FIND_EXTREME_POINT(2,Y0,Y,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MAX(F,FMAX),FMAX)
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 1) THEN
          IF (LEFT_ENDPOINT(MA) + LEFT_ENDPOINT(MB) >= 0) THEN
              CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                   FMIN,FMAX)
          ELSE
              CALL FM_EQ(CEILING(LEFT_ENDPOINT(MB)+RIGHT_ENDPOINT(MA))-RIGHT_ENDPOINT(MA),M_1)
              IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                  CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),M_1,FMIN,FMAX)
                  CALL FM_EQ(M_1+1,M_1)
                  IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                      CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),M_1-1,M_1,FMIN,FMAX)
                      CALL FM_EQ(M_1+1,M_1)
                      IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                          CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),M_1-1,M_1,FMIN,FMAX)
                      ENDIF
                  ELSE
                      CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),  &
                                           RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  ENDIF
              ENDIF
              CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MB)+RIGHT_ENDPOINT(MA))-RIGHT_ENDPOINT(MA),M_1)
              IF (M_1+RIGHT_ENDPOINT(MA) > 0) THEN
                  CALL FM_EQ(-RIGHT_ENDPOINT(MA),M_1)
              ENDIF
              IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                  CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1-1,M_1)
                  IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                      CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),M_1,M_1+1,FMIN,FMAX)
                      CALL FM_EQ(M_1-1,M_1)
                      IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                          CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),M_1,M_1+1,FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                       FMIN,FMAX)
              ENDIF
              DO J = 0, 10
                 IF (J > 0) CALL FM_EQ(Y,Y0)
                 CALL FM_EQ(RIGHT_ENDPOINT(MA),X)
                 CALL FM_EQ((10-J)*LEFT_ENDPOINT(MB)/10 + J*RIGHT_ENDPOINT(MB)/10,Y)
                 CALL FM_EQ(BETA(X,Y),F)
                 IF (J == 0) THEN
                     CALL FM_EQ(F*(POLYGAMMA(0,Y)-POLYGAMMA(0,X+Y)),DF2)
                     CYCLE
                 ELSE
                     CALL FM_EQ(DF2,DF1)
                     CALL FM_EQ(F*(POLYGAMMA(0,Y)-POLYGAMMA(0,X+Y)),DF2)
                 ENDIF
                 IF (DF1 < 0 .AND. DF2 > 0 .AND. KROUND == -1) THEN
                     KXY_EDGE = 2
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(X,X_EDGE)
                     CALL FM_FIND_EXTREME_POINT(1,Y0,Y,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MIN(F,FMIN),FMIN)
                 ENDIF
                 IF (DF1 > 0 .AND. DF2 < 0 .AND. KROUND == 2) THEN
                     KXY_EDGE = 2
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(X,X_EDGE)
                     CALL FM_FIND_EXTREME_POINT(2,Y0,Y,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MAX(F,FMAX),FMAX)
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 2) THEN
          IF (LEFT_ENDPOINT(MB) > -1 .AND. RIGHT_ENDPOINT(MA) - RIGHT_ENDPOINT(MB) > -1) THEN
              CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                   FMIN,FMAX)
          ELSE
              CALL FM_EQ(FLOOR( RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MB) ),M_1A)
              IF (M_1A < 0) THEN
                  CALL FM_EQ(RIGHT_ENDPOINT(MA) - M_1A,M_1A)
                  IF (M_1A > RIGHT_ENDPOINT(MB)) CALL FM_EQ(TO_FM('+OVERFLOW'),M_1A)
              ELSE
                  CALL FM_EQ(RIGHT_ENDPOINT(MA) + 1,M_1A)
                  IF (M_1A > RIGHT_ENDPOINT(MB)) CALL FM_EQ(TO_FM('+OVERFLOW'),M_1A)
              ENDIF
              CALL FM_EQ(CEILING(LEFT_ENDPOINT(MB)),M_1B)
              IF (M_1B == LEFT_ENDPOINT(MB)) THEN
                  CALL FM_EQ(M_1B+1,M_1B)
              ENDIF
              IF (M_1B > -0.5) CALL FM_EQ(TO_FM('+OVERFLOW'),M_1B)
              IF (M_1A < M_1B) THEN
                  CALL FM_EQ(M_1A,M_1)
              ELSE
                  CALL FM_EQ(M_1B,M_1)
              ENDIF
              IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                  CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),M_1,FMIN,FMAX)
                  CALL FM_EQ(M_1,LAST_M_1)
                  IF (M_1A < M_1B) THEN
                      CALL FM_EQ(M_1A+1,M_1A)
                  ELSE
                      CALL FM_EQ(M_1B+1,M_1B)
                  ENDIF
                  IF (M_1A < M_1B) THEN
                      CALL FM_EQ(M_1A,M_1)
                  ELSE
                      CALL FM_EQ(M_1B,M_1)
                  ENDIF
                  IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                      CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LAST_M_1,M_1,FMIN,FMAX)
                      CALL FM_EQ(M_1,LAST_M_1)
                      IF (M_1A < M_1B) THEN
                          CALL FM_EQ(M_1A+1,M_1A)
                      ELSE
                          CALL FM_EQ(M_1B+1,M_1B)
                      ENDIF
                      IF (M_1A < M_1B) THEN
                          CALL FM_EQ(M_1A,M_1)
                      ELSE
                          CALL FM_EQ(M_1B,M_1)
                      ENDIF
                      IF (M_1 <= RIGHT_ENDPOINT(MB)) THEN
                          CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LAST_M_1,M_1,FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                       FMIN,FMAX)
              ENDIF
              CALL FM_EQ(FLOOR( RIGHT_ENDPOINT(MB) - RIGHT_ENDPOINT(MA) ),M_1A)
              IF (M_1A > 0) THEN
                  CALL FM_EQ(RIGHT_ENDPOINT(MA) + M_1A,M_1A)
                  IF (M_1A > RIGHT_ENDPOINT(MB)) CALL FM_EQ(TO_FM('-OVERFLOW'),M_1A)
              ELSE
                  CALL FM_EQ(TO_FM('-OVERFLOW'),M_1A)
              ENDIF
              CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MB)),M_1B)
              IF (M_1B == RIGHT_ENDPOINT(MB)) THEN
                  CALL FM_EQ(M_1B-1,M_1B)
              ENDIF
              IF (M_1B > -0.5) CALL FM_EQ(TO_FM('-OVERFLOW'),M_1B)
              IF (M_1A > M_1B) THEN
                  CALL FM_EQ(M_1A,M_1)
              ELSE
                  CALL FM_EQ(M_1B,M_1)
              ENDIF
              IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                  CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),M_1,RIGHT_ENDPOINT(MB),FMIN,FMAX)
                  CALL FM_EQ(M_1,LAST_M_1)
                  IF (M_1A > M_1B) THEN
                      CALL FM_EQ(M_1A-1,M_1A)
                  ELSE
                      CALL FM_EQ(M_1B-1,M_1B)
                  ENDIF
                  IF (M_1A > M_1B) THEN
                      CALL FM_EQ(M_1A,M_1)
                  ELSE
                      CALL FM_EQ(M_1B,M_1)
                  ENDIF
                  IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                      CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),M_1,LAST_M_1,FMIN,FMAX)
                      CALL FM_EQ(M_1,LAST_M_1)
                      IF (M_1A > M_1B) THEN
                          CALL FM_EQ(M_1A-1,M_1A)
                      ELSE
                          CALL FM_EQ(M_1B-1,M_1B)
                      ENDIF
                      IF (M_1A > M_1B) THEN
                          CALL FM_EQ(M_1A,M_1)
                      ELSE
                          CALL FM_EQ(M_1B,M_1)
                      ENDIF
                      IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
                          CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),M_1,LAST_M_1,FMIN,FMAX)
                      ENDIF
                  ENDIF
              ELSE
                  CALL FMEDGE_VERTICAL(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB),RIGHT_ENDPOINT(MB),  &
                                       FMIN,FMAX)
              ENDIF
              DO J = 0, 10
                 IF (J > 0) CALL FM_EQ(Y,Y0)
                 CALL FM_EQ(RIGHT_ENDPOINT(MA),X)
                 CALL FM_EQ((10-J)*LEFT_ENDPOINT(MB)/10 + J*RIGHT_ENDPOINT(MB)/10,Y)
                 CALL FM_EQ(BINOMIAL(X,Y),F)
                 IF (J == 0) THEN
                     CALL FM_EQ(F*(POLYGAMMA(0,1+X-Y)-POLYGAMMA(0,1+Y)),DF2)
                     CYCLE
                 ELSE
                     CALL FM_EQ(DF2,DF1)
                     CALL FM_EQ(F*(POLYGAMMA(0,1+X-Y)-POLYGAMMA(0,1+Y)),DF2)
                 ENDIF
                 IF (DF1 < 0 .AND. DF2 > 0 .AND. KROUND == -1) THEN
                     KXY_EDGE = 2
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(X,X_EDGE)
                     CALL FM_FIND_EXTREME_POINT(1,Y0,Y,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MIN(F,FMIN),FMIN)
                 ENDIF
                 IF (DF1 > 0 .AND. DF2 < 0 .AND. KROUND == 2) THEN
                     KXY_EDGE = 2
                     NDIG_XY_EDGE = NDIG
                     CALL FM_EQ(X,X_EDGE)
                     CALL FM_FIND_EXTREME_POINT(2,Y0,Y,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                     CALL FM_EQ(MAX(F,FMAX),FMAX)
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
  110 CALL FMEQ(FMIN%MFM,LEFT)
      CALL FMEQ(FMAX%MFM,RIGHT)
   END SUBROUTINE FMEDGE_INTERVAL_FM

   SUBROUTINE FMEDGE_HORIZONTAL(MA1,MA2,MB,FMIN,FMAX)

!  Check for extreme function values on the horizontal edge of the rectangle MA x MB.
!  K_ROUTINE_EDGE identifies the function being evaluated.
!  Any new extreme values are used to update FMIN and FMAX.

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA1,MA2,MB,FMAX,FMIN
      INTENT (IN) :: MB,MA1,MA2
      INTENT (INOUT) :: FMAX,FMIN
      TYPE (FM), SAVE :: F,FMIN0,FMAX0,X
      INTEGER :: J
      EXTERNAL :: F_EDGE

      DO J = 0, N_PREV-1
         IF (K_ROUTINE_EDGE == ROUTINE_PREV(J) .AND. KROUND == KROUND_PREV(J)) THEN
             IF (MA1 == M1_PREV(J) .AND. MA2 == M2_PREV(J) .AND. MB == M3_PREV(J)) THEN
                 RETURN
             ENDIF
         ENDIF
      ENDDO
      NUM_PREV = MOD(NUM_PREV+1,N_PREV)
      ROUTINE_PREV(NUM_PREV) = K_ROUTINE_EDGE
      KROUND_PREV(NUM_PREV) = KROUND
      CALL FM_EQ(MA1,M1_PREV(NUM_PREV))
      CALL FM_EQ(MA2,M2_PREV(NUM_PREV))
      CALL FM_EQ(MB,M3_PREV(NUM_PREV))

      CALL FM_EQ(FMIN,FMIN0)
      CALL FM_EQ(FMAX,FMAX0)
      CALL FM_EQ(TO_FM('+OVERFLOW'),FMIN)
      CALL FM_EQ(TO_FM('-OVERFLOW'),FMAX)
      IF (K_ROUTINE_EDGE == 1) THEN
          CALL FM_EQ(BETA(MA1,MB),M_2)
          CALL FM_EQ(MA1+MAX(SPACING(MA1),EPSILON(TO_FM(1)))/(100*SQRT(EPSILON(TO_FM(1)))),M_3)
          IF (M_3 > MA1 .AND. M_3 < MA2) THEN
              CALL FM_EQ(BETA(M_3,MB),M_3)
          ELSE
              CALL FM_EQ(M_2,M_3)
          ENDIF
          CALL FM_EQ(BETA(MA2,MB),M_5)
          CALL FM_EQ(MA2-MAX(SPACING(MA2),EPSILON(TO_FM(1)))/(100*SQRT(EPSILON(TO_FM(1)))),M_4)
          IF (M_4 > MA1 .AND. M_4 < MA2) THEN
              CALL FM_EQ(BETA(M_4,MB),M_4)
          ELSE
              CALL FM_EQ(M_5,M_4)
          ENDIF
          CALL FM_EQ(MIN(FMIN,M_2,M_3,M_4,M_5),FMIN)
          CALL FM_EQ(MAX(FMAX,M_2,M_3,M_4,M_5),FMAX)
          IF (M_3-M_2 > 0 .AND. M_5-M_4 < 0) THEN
              KXY_EDGE = 1
              NDIG_XY_EDGE = NDIG
              CALL FM_EQ(MB,Y_EDGE)
              IF (KROUND == 2) THEN
                  CALL FM_FIND_EXTREME_POINT(2,MA1,MA2,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                  CALL FM_EQ(MAX(F,FMAX),FMAX)
              ENDIF
          ELSE IF (M_3-M_2 < 0 .AND. M_5-M_4 > 0) THEN
              KXY_EDGE = 1
              NDIG_XY_EDGE = NDIG
              CALL FM_EQ(MB,Y_EDGE)
              IF (KROUND == -1) THEN
                  CALL FM_FIND_EXTREME_POINT(1,MA1,MA2,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                  CALL FM_EQ(MIN(F,FMIN),FMIN)
              ENDIF
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 2 .AND. MB == 0) THEN
          FMIN = 1
          FMAX = 1
      ELSE IF (K_ROUTINE_EDGE == 2) THEN
          CALL FM_EQ(BINOMIAL(MA1,MB),M_2)
          CALL FM_EQ(MA1+MAX(SPACING(MA1),EPSILON(TO_FM(1)))/(100*SQRT(EPSILON(TO_FM(1)))),M_3)
          IF (M_3 > MA1 .AND. M_3 < MA2) THEN
              CALL FM_EQ(BINOMIAL(M_3,MB),M_3)
          ELSE
              CALL FM_EQ(M_2,M_3)
          ENDIF
          CALL FM_EQ(BINOMIAL(MA2,MB),M_5)
          CALL FM_EQ(MA2-MAX(SPACING(MA2),EPSILON(TO_FM(1)))/(100*SQRT(EPSILON(TO_FM(1)))),M_4)
          IF (M_4 > MA1 .AND. M_4 < MA2) THEN
              CALL FM_EQ(BINOMIAL(M_4,MB),M_4)
          ELSE
              CALL FM_EQ(M_5,M_4)
          ENDIF
          CALL FM_EQ(MIN(FMIN,M_2,M_3,M_4,M_5),FMIN)
          CALL FM_EQ(MAX(FMAX,M_2,M_3,M_4,M_5),FMAX)
          IF (M_3-M_2 > 0 .AND. M_5-M_4 < 0) THEN
              KXY_EDGE = 1
              NDIG_XY_EDGE = NDIG
              CALL FM_EQ(MB,Y_EDGE)
              IF (KROUND == 2) THEN
                  CALL FM_FIND_EXTREME_POINT(2,MA1,MA2,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                  CALL FM_EQ(MAX(F,FMAX),FMAX)
              ENDIF
          ELSE IF (M_3-M_2 < 0 .AND. M_5-M_4 > 0) THEN
              KXY_EDGE = 1
              NDIG_XY_EDGE = NDIG
              CALL FM_EQ(MB,Y_EDGE)
              IF (KROUND == -1) THEN
                  CALL FM_FIND_EXTREME_POINT(1,MA1,MA2,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                  CALL FM_EQ(MIN(F,FMIN),FMIN)
              ENDIF
          ENDIF
      ENDIF
      CALL FM_EQ(MIN(FMIN0,FMIN),FMIN)
      CALL FM_EQ(MAX(FMAX0,FMAX),FMAX)
   END SUBROUTINE FMEDGE_HORIZONTAL

   SUBROUTINE FMEDGE_VERTICAL(MA,MB1,MB2,FMIN,FMAX)

!  Check for extreme function values on the vertical edge of the rectangle MA x MB.
!  K_ROUTINE_EDGE identifies the function being evaluated.
!  Any new extreme values are used to update FMIN and FMAX.

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA,MB1,MB2,FMAX,FMIN
      INTENT (IN) :: MA,MB1,MB2
      INTENT (INOUT) :: FMAX,FMIN
      TYPE (FM), SAVE :: F,FMIN0,FMAX0,X
      INTEGER :: J
      EXTERNAL :: F_EDGE

      DO J = 0, N_PREV-1
         IF (K_ROUTINE_EDGE == ROUTINE_PREV(J) .AND. KROUND == KROUND_PREV(J)) THEN
             IF (MA == M1_PREV(J) .AND. MB1 == M2_PREV(J) .AND. MB2 == M3_PREV(J)) THEN
                 RETURN
             ENDIF
         ENDIF
      ENDDO
      NUM_PREV = MOD(NUM_PREV+1,N_PREV)
      ROUTINE_PREV(NUM_PREV) = K_ROUTINE_EDGE
      KROUND_PREV(NUM_PREV) = KROUND
      CALL FM_EQ(MA,M1_PREV(NUM_PREV))
      CALL FM_EQ(MB1,M2_PREV(NUM_PREV))
      CALL FM_EQ(MB2,M3_PREV(NUM_PREV))

      CALL FM_EQ(FMIN,FMIN0)
      CALL FM_EQ(FMAX,FMAX0)
      CALL FM_EQ(TO_FM('+OVERFLOW'),FMIN)
      CALL FM_EQ(TO_FM('-OVERFLOW'),FMAX)
      IF (K_ROUTINE_EDGE == 1) THEN
          CALL FM_EQ(BETA(MA,MB1),M_2)
          CALL FM_EQ(MB1+MAX(SPACING(MB1),EPSILON(TO_FM(1)))/(100*SQRT(EPSILON(TO_FM(1)))),M_3)
          IF (M_3 > MB1 .AND. M_3 < MB2) THEN
              CALL FM_EQ(BETA(MA,M_3),M_3)
          ELSE
              CALL FM_EQ(M_2,M_3)
          ENDIF
          CALL FM_EQ(BETA(MA,MB2),M_5)
          CALL FM_EQ(MB2-MAX(SPACING(MB2),EPSILON(TO_FM(1)))/(100*SQRT(EPSILON(TO_FM(1)))),M_4)
          IF (M_4 > MB1 .AND. M_4 < MB2) THEN
              CALL FM_EQ(BETA(MA,M_4),M_4)
          ELSE
              CALL FM_EQ(M_5,M_4)
          ENDIF
          CALL FM_EQ(MIN(FMIN,M_2,M_3,M_4,M_5),FMIN)
          CALL FM_EQ(MAX(FMAX,M_2,M_3,M_4,M_5),FMAX)
          IF (M_3-M_2 > 0 .AND. M_5-M_4 < 0) THEN
              KXY_EDGE = 2
              NDIG_XY_EDGE = NDIG
              CALL FM_EQ(MA,X_EDGE)
              IF (KROUND == 2) THEN
                  CALL FM_FIND_EXTREME_POINT(2,MB1,MB2,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                  CALL FM_EQ(MAX(F,FMAX),FMAX)
              ENDIF
          ELSE IF (M_3-M_2 < 0 .AND. M_5-M_4 > 0) THEN
              KXY_EDGE = 2
              NDIG_XY_EDGE = NDIG
              CALL FM_EQ(MA,X_EDGE)
              IF (KROUND == -1) THEN
                  CALL FM_FIND_EXTREME_POINT(1,MB1,MB2,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                  CALL FM_EQ(MIN(F,FMIN),FMIN)
              ENDIF
          ENDIF
      ENDIF
      IF (K_ROUTINE_EDGE == 2) THEN
          CALL FM_EQ(BINOMIAL(MA,MB1),M_2)
          CALL FM_EQ(MB1+MAX(SPACING(MB1),EPSILON(TO_FM(1)))/(100*SQRT(EPSILON(TO_FM(1)))),M_3)
          IF (M_3 > MB1 .AND. M_3 < MB2) THEN
              CALL FM_EQ(BINOMIAL(MA,M_3),M_3)
          ELSE
              CALL FM_EQ(M_2,M_3)
          ENDIF
          CALL FM_EQ(BINOMIAL(MA,MB2),M_5)
          CALL FM_EQ(MB2-MAX(SPACING(MB2),EPSILON(TO_FM(1)))/(100*SQRT(EPSILON(TO_FM(1)))),M_4)
          IF (M_4 > MB1 .AND. M_4 < MB2) THEN
              CALL FM_EQ(BINOMIAL(MA,M_4),M_4)
          ELSE
              CALL FM_EQ(M_5,M_4)
          ENDIF
          CALL FM_EQ(MIN(FMIN,M_2,M_3,M_4,M_5),FMIN)
          CALL FM_EQ(MAX(FMAX,M_2,M_3,M_4,M_5),FMAX)
          IF (M_3-M_2 > 0 .AND. M_5-M_4 < 0) THEN
              KXY_EDGE = 2
              NDIG_XY_EDGE = NDIG
              CALL FM_EQ(MA,X_EDGE)
              IF (KROUND == 2) THEN
                  CALL FM_FIND_EXTREME_POINT(2,MB1,MB2,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                  CALL FM_EQ(MAX(F,FMAX),FMAX)
              ENDIF
          ELSE IF (M_3-M_2 < 0 .AND. M_5-M_4 > 0) THEN
              KXY_EDGE = 2
              NDIG_XY_EDGE = NDIG
              CALL FM_EQ(MA,X_EDGE)
              IF (KROUND == -1) THEN
                  CALL FM_FIND_EXTREME_POINT(1,MB1,MB2,SQRT(EPSILON(TO_FM(1))),X,F,F_EDGE)
                  CALL FM_EQ(MIN(F,FMIN),FMIN)
              ENDIF
          ENDIF
      ENDIF
      CALL FM_EQ(MIN(FMIN0,FMIN),FMIN)
      CALL FM_EQ(MAX(FMAX0,FMAX),FMAX)
   END SUBROUTINE FMEDGE_VERTICAL


   SUBROUTINE FM_INTERVAL_F_FMFM(FM_F,MA,MB,MC)

!  General interval evaluation for a special function of two FM variables:
!      CALL FM_F(MA,MB,MC)

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KRSAVE,L
      EXTERNAL :: FM_F
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM,M1LVFM,M2LVFM
      KRSAVE = KROUND
      KROUND = -1
      CALL FM_F(MA%LEFT,MB%LEFT,MTLVFM)
      CALL FM_F(MA%RIGHT,MB%LEFT,MULVFM)
      CALL FM_F(MA%LEFT,MB%RIGHT,M1LVFM)
      CALL FM_F(MA%RIGHT,MB%RIGHT,M2LVFM)
      CALL FMEQ(MTLVFM,MC%LEFT)
      IF (FMCOMP(MC%LEFT,'>',MULVFM)) THEN
          CALL FMEQ(MULVFM,MC%LEFT)
      ENDIF
      IF (FMCOMP(MC%LEFT,'>',M1LVFM)) THEN
          CALL FMEQ(M1LVFM,MC%LEFT)
      ENDIF
      IF (FMCOMP(MC%LEFT,'>',M2LVFM)) THEN
          CALL FMEQ(M2LVFM,MC%LEFT)
      ENDIF
      L = 1
      CALL FMEQ(MTLVFM,MC%RIGHT)
      IF (FMCOMP(MC%RIGHT,'<',MULVFM)) THEN
          L = 2
          CALL FMEQ(MULVFM,MC%RIGHT)
      ENDIF
      IF (FMCOMP(MC%RIGHT,'<',M1LVFM)) THEN
          L = 3
          CALL FMEQ(M1LVFM,MC%RIGHT)
      ENDIF
      IF (FMCOMP(MC%RIGHT,'<',M2LVFM)) THEN
          L = 4
      ENDIF
      KROUND = 2
      IF (L == 1) THEN
          CALL FM_F(MA%LEFT,MB%LEFT,MC%RIGHT)
      ELSE IF (L == 2) THEN
          CALL FM_F(MA%RIGHT,MB%LEFT,MC%RIGHT)
      ELSE IF (L == 3) THEN
          CALL FM_F(MA%LEFT,MB%RIGHT,MC%RIGHT)
      ELSE
          CALL FM_F(MA%RIGHT,MB%RIGHT,MC%RIGHT)
      ENDIF
      KROUND = KRSAVE
   END SUBROUTINE FM_INTERVAL_F_FMFM

   SUBROUTINE FM_INTERVAL_F_FMFMFM(FM_F,MA,MB,MC,MD)

!  General interval evaluation for a special function of three FM variables:
!      CALL FM_F(MA,MB,MC,MD)

      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      INTEGER :: KRSAVE,L
      EXTERNAL :: FM_F
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MTLVZM(2),MULVZM(2),M1LVZM(2),M2LVZM(2)
      KRSAVE = KROUND
      KROUND = -1
      CALL FM_F(MA%LEFT,MB%LEFT,MC%LEFT,MTLVZM(1))
      CALL FM_F(MA%RIGHT,MB%LEFT,MC%LEFT,MTLVZM(2))
      CALL FM_F(MA%LEFT,MB%RIGHT,MC%LEFT,MULVZM(1))
      CALL FM_F(MA%RIGHT,MB%RIGHT,MC%LEFT,MULVZM(2))
      CALL FM_F(MA%LEFT,MB%LEFT,MC%RIGHT,M1LVZM(1))
      CALL FM_F(MA%RIGHT,MB%LEFT,MC%RIGHT,M1LVZM(2))
      CALL FM_F(MA%LEFT,MB%RIGHT,MC%RIGHT,M2LVZM(1))
      CALL FM_F(MA%RIGHT,MB%RIGHT,MC%RIGHT,M2LVZM(2))
      CALL FMEQ(MTLVZM(1),MD%LEFT)
      IF (FMCOMP(MD%LEFT,'>',MTLVZM(2))) THEN
          CALL FMEQ(MTLVZM(2),MD%LEFT)
      ENDIF
      IF (FMCOMP(MD%LEFT,'>',MULVZM(1))) THEN
          CALL FMEQ(MULVZM(1),MD%LEFT)
      ENDIF
      IF (FMCOMP(MD%LEFT,'>',MULVZM(2))) THEN
          CALL FMEQ(MULVZM(2),MD%LEFT)
      ENDIF
      IF (FMCOMP(MD%LEFT,'>',M1LVZM(1))) THEN
          CALL FMEQ(M1LVZM(1),MD%LEFT)
      ENDIF
      IF (FMCOMP(MD%LEFT,'>',M1LVZM(2))) THEN
          CALL FMEQ(M1LVZM(2),MD%LEFT)
      ENDIF
      IF (FMCOMP(MD%LEFT,'>',M2LVZM(1))) THEN
          CALL FMEQ(M2LVZM(1),MD%LEFT)
      ENDIF
      IF (FMCOMP(MD%LEFT,'>',M2LVZM(2))) THEN
          CALL FMEQ(M2LVZM(2),MD%LEFT)
      ENDIF
      L = 1
      CALL FMEQ(MTLVZM(1),MD%RIGHT)
      IF (FMCOMP(MD%RIGHT,'<',MTLVZM(2))) THEN
          L = 2
          CALL FMEQ(MTLVZM(2),MD%RIGHT)
      ENDIF
      IF (FMCOMP(MD%RIGHT,'<',MULVZM(1))) THEN
          L = 3
          CALL FMEQ(MULVZM(1),MD%RIGHT)
      ENDIF
      IF (FMCOMP(MD%RIGHT,'<',MULVZM(2))) THEN
          L = 4
          CALL FMEQ(MULVZM(2),MD%RIGHT)
      ENDIF
      IF (FMCOMP(MD%RIGHT,'<',M1LVZM(1))) THEN
          L = 5
          CALL FMEQ(M1LVZM(1),MD%RIGHT)
      ENDIF
      IF (FMCOMP(MD%RIGHT,'<',M1LVZM(2))) THEN
          L = 6
          CALL FMEQ(M1LVZM(2),MD%RIGHT)
      ENDIF
      IF (FMCOMP(MD%RIGHT,'<',M2LVZM(1))) THEN
          L = 7
          CALL FMEQ(M2LVZM(1),MD%RIGHT)
      ENDIF
      IF (FMCOMP(MD%RIGHT,'<',M2LVZM(2))) THEN
          L = 8
          CALL FMEQ(M2LVZM(2),MD%RIGHT)
      ENDIF
      KROUND = 2
      IF (L == 1) THEN
          CALL FM_F(MA%LEFT,MB%LEFT,MC%LEFT,MD%RIGHT)
      ELSE IF (L == 2) THEN
          CALL FM_F(MA%RIGHT,MB%LEFT,MC%LEFT,MD%RIGHT)
      ELSE IF (L == 3) THEN
          CALL FM_F(MA%LEFT,MB%RIGHT,MC%LEFT,MD%RIGHT)
      ELSE IF (L == 4) THEN
          CALL FM_F(MA%RIGHT,MB%RIGHT,MC%LEFT,MD%RIGHT)
      ELSE IF (L == 5) THEN
          CALL FM_F(MA%LEFT,MB%LEFT,MC%RIGHT,MD%RIGHT)
      ELSE IF (L == 6) THEN
          CALL FM_F(MA%RIGHT,MB%LEFT,MC%RIGHT,MD%RIGHT)
      ELSE IF (L == 7) THEN
          CALL FM_F(MA%LEFT,MB%RIGHT,MC%RIGHT,MD%RIGHT)
      ELSE
          CALL FM_F(MA%RIGHT,MB%RIGHT,MC%RIGHT,MD%RIGHT)
      ENDIF
      KROUND = KRSAVE
   END SUBROUTINE FM_INTERVAL_F_FMFMFM

 END MODULE FM_INTERVAL_ARITHMETIC_1

 MODULE FM_INTERVAL_ARITHMETIC_2
    USE FM_INTERVAL_ARITHMETIC_1

    INTERFACE ASSIGNMENT (=)
       MODULE PROCEDURE FMEQ_INTERVAL_IFM
       MODULE PROCEDURE FMEQ_INTERVAL_RFM
       MODULE PROCEDURE FMEQ_INTERVAL_DFM
       MODULE PROCEDURE FMEQ_INTERVAL_ZFM
       MODULE PROCEDURE FMEQ_INTERVAL_CFM
       MODULE PROCEDURE FMEQ_INTERVAL_FMI
       MODULE PROCEDURE FMEQ_INTERVAL_FMR
       MODULE PROCEDURE FMEQ_INTERVAL_FMD
       MODULE PROCEDURE FMEQ_INTERVAL_FMZ
       MODULE PROCEDURE FMEQ_INTERVAL_FMC
       MODULE PROCEDURE FMEQ_INTERVAL_FMFM
       MODULE PROCEDURE FMEQ_INTERVAL_FMFMA
       MODULE PROCEDURE FMEQ_INTERVAL_FMAFM
       MODULE PROCEDURE FMEQ_INTERVAL_FMIM
       MODULE PROCEDURE FMEQ_INTERVAL_FMZM
       MODULE PROCEDURE FMEQ_INTERVAL_IMFM
       MODULE PROCEDURE FMEQ_INTERVAL_ZMFM
       MODULE PROCEDURE FMEQ_INTERVAL_FM1I
       MODULE PROCEDURE FMEQ_INTERVAL_FM1R
       MODULE PROCEDURE FMEQ_INTERVAL_FM1D
       MODULE PROCEDURE FMEQ_INTERVAL_FM1Z
       MODULE PROCEDURE FMEQ_INTERVAL_FM1C
       MODULE PROCEDURE FMEQ_INTERVAL_I1FM
       MODULE PROCEDURE FMEQ_INTERVAL_R1FM
       MODULE PROCEDURE FMEQ_INTERVAL_D1FM
       MODULE PROCEDURE FMEQ_INTERVAL_Z1FM
       MODULE PROCEDURE FMEQ_INTERVAL_C1FM
       MODULE PROCEDURE FMEQ_INTERVAL_FM1FM
       MODULE PROCEDURE FMEQ_INTERVAL_FM1FMA
       MODULE PROCEDURE FMEQ_INTERVAL_FMA1FM
       MODULE PROCEDURE FMEQ_INTERVAL_FM1IM
       MODULE PROCEDURE FMEQ_INTERVAL_FM1ZM
       MODULE PROCEDURE FMEQ_INTERVAL_IM1FM
       MODULE PROCEDURE FMEQ_INTERVAL_ZM1FM
       MODULE PROCEDURE FMEQ_INTERVAL_FM1I1
       MODULE PROCEDURE FMEQ_INTERVAL_FM1R1
       MODULE PROCEDURE FMEQ_INTERVAL_FM1D1
       MODULE PROCEDURE FMEQ_INTERVAL_FM1Z1
       MODULE PROCEDURE FMEQ_INTERVAL_FM1C1
       MODULE PROCEDURE FMEQ_INTERVAL_I1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_R1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_D1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_Z1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_C1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_FM1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_FM1FMA1
       MODULE PROCEDURE FMEQ_INTERVAL_FMA1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_FM1IM1
       MODULE PROCEDURE FMEQ_INTERVAL_FM1ZM1
       MODULE PROCEDURE FMEQ_INTERVAL_IM1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_ZM1FM1
       MODULE PROCEDURE FMEQ_INTERVAL_FM2I
       MODULE PROCEDURE FMEQ_INTERVAL_FM2R
       MODULE PROCEDURE FMEQ_INTERVAL_FM2D
       MODULE PROCEDURE FMEQ_INTERVAL_FM2Z
       MODULE PROCEDURE FMEQ_INTERVAL_FM2C
       MODULE PROCEDURE FMEQ_INTERVAL_I2FM
       MODULE PROCEDURE FMEQ_INTERVAL_R2FM
       MODULE PROCEDURE FMEQ_INTERVAL_D2FM
       MODULE PROCEDURE FMEQ_INTERVAL_Z2FM
       MODULE PROCEDURE FMEQ_INTERVAL_C2FM
       MODULE PROCEDURE FMEQ_INTERVAL_FM2FM
       MODULE PROCEDURE FMEQ_INTERVAL_FM2FMA
       MODULE PROCEDURE FMEQ_INTERVAL_FMA2FM
       MODULE PROCEDURE FMEQ_INTERVAL_FM2IM
       MODULE PROCEDURE FMEQ_INTERVAL_FM2ZM
       MODULE PROCEDURE FMEQ_INTERVAL_IM2FM
       MODULE PROCEDURE FMEQ_INTERVAL_ZM2FM
       MODULE PROCEDURE FMEQ_INTERVAL_FM2I2
       MODULE PROCEDURE FMEQ_INTERVAL_FM2R2
       MODULE PROCEDURE FMEQ_INTERVAL_FM2D2
       MODULE PROCEDURE FMEQ_INTERVAL_FM2Z2
       MODULE PROCEDURE FMEQ_INTERVAL_FM2C2
       MODULE PROCEDURE FMEQ_INTERVAL_I2FM2
       MODULE PROCEDURE FMEQ_INTERVAL_R2FM2
       MODULE PROCEDURE FMEQ_INTERVAL_D2FM2
       MODULE PROCEDURE FMEQ_INTERVAL_Z2FM2
       MODULE PROCEDURE FMEQ_INTERVAL_C2FM2
       MODULE PROCEDURE FMEQ_INTERVAL_FM2FM2
       MODULE PROCEDURE FMEQ_INTERVAL_FM2FMA2
       MODULE PROCEDURE FMEQ_INTERVAL_FMA2FM2
       MODULE PROCEDURE FMEQ_INTERVAL_FM2IM2
       MODULE PROCEDURE FMEQ_INTERVAL_FM2ZM2
       MODULE PROCEDURE FMEQ_INTERVAL_IM2FM2
       MODULE PROCEDURE FMEQ_INTERVAL_ZM2FM2
    END INTERFACE

    INTERFACE OPERATOR (==)
       MODULE PROCEDURE FMLEQ_INTERVAL_IFM
       MODULE PROCEDURE FMLEQ_INTERVAL_RFM
       MODULE PROCEDURE FMLEQ_INTERVAL_DFM
       MODULE PROCEDURE FMLEQ_INTERVAL_ZFM
       MODULE PROCEDURE FMLEQ_INTERVAL_CFM
       MODULE PROCEDURE FMLEQ_INTERVAL_FMI
       MODULE PROCEDURE FMLEQ_INTERVAL_FMR
       MODULE PROCEDURE FMLEQ_INTERVAL_FMD
       MODULE PROCEDURE FMLEQ_INTERVAL_FMZ
       MODULE PROCEDURE FMLEQ_INTERVAL_FMC
       MODULE PROCEDURE FMLEQ_INTERVAL_FMFM
       MODULE PROCEDURE FMLEQ_INTERVAL_FMFMA
       MODULE PROCEDURE FMLEQ_INTERVAL_FMAFM
       MODULE PROCEDURE FMLEQ_INTERVAL_FMIM
       MODULE PROCEDURE FMLEQ_INTERVAL_FMZM
       MODULE PROCEDURE FMLEQ_INTERVAL_IMFM
       MODULE PROCEDURE FMLEQ_INTERVAL_ZMFM
    END INTERFACE

 CONTAINS

   SUBROUTINE FMDEFINE_INTERVAL(MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      IF (.NOT. ALLOCATED(MA%LEFT%MP)) THEN
          ALLOCATE(MA%LEFT%MP(NDIG+2),STAT=K_STAT)
          IF (K_STAT /= 0) CALL FMDEFINE_ERROR
      ELSE IF (SIZE(MA%LEFT%MP) < NDIG+2) THEN
          DEALLOCATE(MA%LEFT%MP)
          ALLOCATE(MA%LEFT%MP(NDIG+2),STAT=K_STAT)
          IF (K_STAT /= 0) CALL FMDEFINE_ERROR
      ENDIF
      IF (.NOT. ALLOCATED(MA%RIGHT%MP)) THEN
          ALLOCATE(MA%RIGHT%MP(NDIG+2),STAT=K_STAT)
          IF (K_STAT /= 0) CALL FMDEFINE_ERROR
      ELSE IF (SIZE(MA%RIGHT%MP) < NDIG+2) THEN
          DEALLOCATE(MA%RIGHT%MP)
          ALLOCATE(MA%RIGHT%MP(NDIG+2),STAT=K_STAT)
          IF (K_STAT /= 0) CALL FMDEFINE_ERROR
      ENDIF

   END SUBROUTINE FMDEFINE_INTERVAL

!                                                                   =

   SUBROUTINE FMEQ_INTERVAL_IFM(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2I_INTERVAL(MA,IVAL)
   END SUBROUTINE FMEQ_INTERVAL_IFM

   SUBROUTINE FMEQ_INTERVAL_RFM(R,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2SP_INTERVAL(MA,R)
   END SUBROUTINE FMEQ_INTERVAL_RFM

   SUBROUTINE FMEQ_INTERVAL_DFM(D,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2DP_INTERVAL(MA,D)
   END SUBROUTINE FMEQ_INTERVAL_DFM

   SUBROUTINE FMEQ_INTERVAL_ZFM(Z,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX :: Z
      REAL :: R
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2SP_INTERVAL(MA,R)
      Z = CMPLX( R , 0.0 )
   END SUBROUTINE FMEQ_INTERVAL_ZFM

   SUBROUTINE FMEQ_INTERVAL_CFM(C,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2DP_INTERVAL(MA,D)
      C = CMPLX( D , 0.0D0 , KIND(0.0D0) )
   END SUBROUTINE FMEQ_INTERVAL_CFM

   SUBROUTINE FMEQ_INTERVAL_FMI(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      CALL FMI2M_INTERVAL(IVAL,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMI

   SUBROUTINE FMEQ_INTERVAL_FMR(MA,R)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      CALL FMSP2M_INTERVAL(R,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMR

   SUBROUTINE FMEQ_INTERVAL_FMD(MA,D)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      CALL FMDP2M_INTERVAL(D,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMD

   SUBROUTINE FMEQ_INTERVAL_FMZ(MA,Z)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX :: Z
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      R = REAL(Z)
      CALL FMSP2M_INTERVAL(R,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMZ

   SUBROUTINE FMEQ_INTERVAL_FMC(MA,C)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      D = REAL(C,KIND(0.0D0))
      CALL FMDP2M_INTERVAL(D,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMC

   SUBROUTINE FMEQ_INTERVAL_FMFM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMEQ_INTERVAL(MB,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMFM

   SUBROUTINE FMEQ_INTERVAL_FMFMA(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      CALL FMEQ(MB%MFM,MA%LEFT)
      CALL FMEQ(MB%MFM,MA%RIGHT)
   END SUBROUTINE FMEQ_INTERVAL_FMFMA

   SUBROUTINE FMEQ_INTERVAL_FMAFM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM) :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FM_TO_FMA(MB,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMAFM

   SUBROUTINE FMEQ_INTERVAL_FMIM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM) :: MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMIM

   SUBROUTINE FMEQ_INTERVAL_FMZM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (ZM) :: MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      CALL ZMREAL_INTERVAL(MB%MZM,MA)
   END SUBROUTINE FMEQ_INTERVAL_FMZM

   SUBROUTINE FMEQ_INTERVAL_IMFM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMFM2I_INTERVAL(MB,MA%MIM)
   END SUBROUTINE FMEQ_INTERVAL_IMFM

   SUBROUTINE FMEQ_INTERVAL_ZMFM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MB
      TYPE (ZM) :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMEQ_INTERVAL(MB,MTFM_I)
      CALL FMI2M_INTERVAL(0,MUFM_I)
      CALL ZMCMPX_INTERVAL(MTFM_I,MUFM_I,MA)
   END SUBROUTINE FMEQ_INTERVAL_ZMFM


!             Array equal assignments for FM.

!             (1) rank 1  =  rank 0

   SUBROUTINE FMEQ_INTERVAL_FM1I(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: IVAL,J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MTFM_I,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1I

   SUBROUTINE FMEQ_INTERVAL_FM1R(MA,R)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J,N
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MTFM_I,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1R

   SUBROUTINE FMEQ_INTERVAL_FM1D(MA,D)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MTFM_I,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1D

   SUBROUTINE FMEQ_INTERVAL_FM1Z(MA,Z)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(REAL(Z),MTFM_I)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MTFM_I,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1Z

   SUBROUTINE FMEQ_INTERVAL_FM1C(MA,C)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(REAL(C,KIND(0.0D0)),MTFM_I)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MTFM_I,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1C

   SUBROUTINE FMEQ_INTERVAL_I1FM(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,K,N
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      CALL FMM2I_INTERVAL(MA,K)
      DO J = 1, N
         IVAL(J) = K
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_I1FM

   SUBROUTINE FMEQ_INTERVAL_R1FM(R,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      REAL :: R2
      INTEGER :: J,N
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      CALL FMM2SP_INTERVAL(MA,R2)
      DO J = 1, N
         R(J) = R2
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_R1FM

   SUBROUTINE FMEQ_INTERVAL_D1FM(D,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      DOUBLE PRECISION :: D2
      INTEGER :: J,N
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      CALL FMM2DP_INTERVAL(MA,D2)
      DO J = 1, N
         D(J) = D2
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_D1FM

   SUBROUTINE FMEQ_INTERVAL_Z1FM(Z,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX, DIMENSION(:) :: Z
      REAL :: R2
      INTEGER :: J,N
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(Z)
      CALL FMM2SP_INTERVAL(MA,R2)
      DO J = 1, N
         Z(J) = R2
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_Z1FM

   SUBROUTINE FMEQ_INTERVAL_C1FM(C,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      DOUBLE PRECISION :: D2
      INTEGER :: J,N
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(C)
      CALL FMM2DP_INTERVAL(MA,D2)
      DO J = 1, N
         C(J) = D2
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_C1FM

   SUBROUTINE FMEQ_INTERVAL_FM1FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL FMEQ_INTERVAL(MB,MTFM_I)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MTFM_I,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1FM

   SUBROUTINE FMEQ_INTERVAL_FM1FMA(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEQ(MB%MFM,MA(J)%LEFT)
         CALL FMEQ(MB%MFM,MA(J)%RIGHT)
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1FMA

   SUBROUTINE FMEQ_INTERVAL_FMA1FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FM_TO_FMA(MB,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FMA1FM

   SUBROUTINE FMEQ_INTERVAL_FM1IM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MTFM_I,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1IM

   SUBROUTINE FMEQ_INTERVAL_FM1ZM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (ZM) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL ZMREAL_INTERVAL(MB%MZM,MTFM_I)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MTFM_I,MA(J))
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM1ZM

   SUBROUTINE FMEQ_INTERVAL_IM1FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI), SAVE :: MTLVIM
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL IMFM2I_INTERVAL(MB,MTLVIM)
      DO J = 1, N
         CALL IMEQ(MTLVIM,MA(J)%MIM)
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_IM1FM

   SUBROUTINE FMEQ_INTERVAL_ZM1FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(0,MTFM_I)
      CALL ZMCMPX_INTERVAL(MB,MTFM_I,MZ_1)
      DO J = 1, N
         CALL ZMEQ(MZ_1%MZM,MA(J)%MZM)
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_ZM1FM

!             (2) rank 1  =  rank 1

   SUBROUTINE FMEQ_INTERVAL_FM1I1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1I1

   SUBROUTINE FMEQ_INTERVAL_FM1R1(MA,R)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      IF (SIZE(MA) /= SIZE(R)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1R1

   SUBROUTINE FMEQ_INTERVAL_FM1D1(MA,D)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      IF (SIZE(MA) /= SIZE(D)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1D1

   SUBROUTINE FMEQ_INTERVAL_FM1Z1(MA,Z)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX, DIMENSION(:) :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      IF (SIZE(MA) /= SIZE(Z)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(REAL(Z(J)),MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1Z1

   SUBROUTINE FMEQ_INTERVAL_FM1C1(MA,C)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER :: J,N
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      IF (SIZE(MA) /= SIZE(C)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(REAL(C(J),KIND(0.0D0)),MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1C1

   SUBROUTINE FMEQ_INTERVAL_I1FM1(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(IVAL)
             IVAL(J) = IUNKNO
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMM2I_INTERVAL(MA(J),IVAL(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_I1FM1

   SUBROUTINE FMEQ_INTERVAL_R1FM1(R,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      INTEGER :: J,N
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(R)
             R(J) = RUNKNO
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMM2SP_INTERVAL(MA(J),R(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_R1FM1

   SUBROUTINE FMEQ_INTERVAL_D1FM1(D,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTEGER :: J,N
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(D)
             D(J) = RUNKNO
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMM2DP_INTERVAL(MA(J),D(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_D1FM1

   SUBROUTINE FMEQ_INTERVAL_Z1FM1(Z,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      COMPLEX, DIMENSION(:) :: Z
      REAL :: R
      INTEGER :: J,N
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(Z)) THEN
          DO J = 1, SIZE(Z)
             Z(J) = CMPLX(RUNKNO,RUNKNO)
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(Z)
      DO J = 1, N
         CALL FMM2SP_INTERVAL(MA(J),R)
         Z(J) = CMPLX(R,0.0)
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_Z1FM1

   SUBROUTINE FMEQ_INTERVAL_C1FM1(C,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:) :: C
      REAL (KIND(0.0D0)) :: D
      INTEGER :: J,N
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(C)) THEN
          DO J = 1, SIZE(C)
             D = RUNKNO
             C(J) = CMPLX(D,D , KIND(0.0D0))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(C)
      DO J = 1, N
         CALL FMM2DP_INTERVAL(MA(J),D)
         C(J) = CMPLX(D,0.0D0 , KIND(0.0D0))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_C1FM1

   SUBROUTINE FMEQ_INTERVAL_FM1FM1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MB(J),MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1FM1

   SUBROUTINE FMEQ_INTERVAL_FM1FMA1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEQ(MB(J)%MFM,MA(J)%LEFT)
         CALL FMEQ(MB(J)%MFM,MA(J)%RIGHT)
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1FMA1

   SUBROUTINE FMEQ_INTERVAL_FMA1FM1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI), SAVE :: MTLVFM
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM)
          DO J = 1, SIZE(MA)
             CALL FMEQ(MTLVFM,MA(J)%MFM)
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FM_TO_FMA(MB(J),MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FMA1FM1

   SUBROUTINE FMEQ_INTERVAL_FM1IM1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1IM1

   SUBROUTINE FMEQ_INTERVAL_FM1ZM1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (ZM), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA)
             CALL FMEQ_INTERVAL(MTFM_I,MA(J))
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL ZMREAL_INTERVAL(MB(J)%MZM,MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM1ZM1

   SUBROUTINE FMEQ_INTERVAL_IM1FM1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI), SAVE :: MTLVIM
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL IMST2M(' UNKNOWN ',MTLVIM)
          DO J = 1, SIZE(MA)
             CALL IMEQ(MTLVIM,MA(J)%MIM)
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMFM2I_INTERVAL(MB(J),MA(J)%MIM)
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_IM1FM1

   SUBROUTINE FMEQ_INTERVAL_ZM1FM1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      INTEGER :: J,N
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTZM_I)
          DO J = 1, SIZE(MA)
             CALL ZMEQ(MTZM_I,MA(J)%MZM)
          ENDDO
          GO TO 10
      ENDIF
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(0,MTFM_I)
      DO J = 1, N
         CALL ZMCMPX_INTERVAL(MB(J),MTFM_I,MA(J))
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_ZM1FM1

!             (3) rank 2  =  rank 0

   SUBROUTINE FMEQ_INTERVAL_FM2I(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: IVAL,J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2I

   SUBROUTINE FMEQ_INTERVAL_FM2R(MA,R)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      REAL :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2R

   SUBROUTINE FMEQ_INTERVAL_FM2D(MA,D)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2D

   SUBROUTINE FMEQ_INTERVAL_FM2Z(MA,Z)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      CALL FMSP2M_INTERVAL(REAL(Z),MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2Z

   SUBROUTINE FMEQ_INTERVAL_FM2C(MA,C)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      CALL FMDP2M_INTERVAL(REAL(C,KIND(0.0D0)),MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2C

   SUBROUTINE FMEQ_INTERVAL_I2FM(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K,L
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2I_INTERVAL(MA,L)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            IVAL(J,K) = L
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_I2FM

   SUBROUTINE FMEQ_INTERVAL_R2FM(R,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      REAL :: R2
      INTEGER :: J,K
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2SP_INTERVAL(MA,R2)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            R(J,K) = R2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_R2FM

   SUBROUTINE FMEQ_INTERVAL_D2FM(D,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      DOUBLE PRECISION :: D2
      INTEGER :: J,K
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2DP_INTERVAL(MA,D2)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            D(J,K) = D2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_D2FM

   SUBROUTINE FMEQ_INTERVAL_Z2FM(Z,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      REAL :: R2
      INTEGER :: J,K
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2SP_INTERVAL(MA,R2)
      DO J = 1, SIZE(Z,DIM=1)
         DO K = 1, SIZE(Z,DIM=2)
            Z(J,K) = R2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_Z2FM

   SUBROUTINE FMEQ_INTERVAL_C2FM(C,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      DOUBLE PRECISION :: D2
      INTEGER :: J,K
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMM2DP_INTERVAL(MA,D2)
      DO J = 1, SIZE(C,DIM=1)
         DO K = 1, SIZE(C,DIM=2)
            C(J,K) = D2
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_C2FM

   SUBROUTINE FMEQ_INTERVAL_FM2FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMEQ_INTERVAL(MB,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2FM

   SUBROUTINE FMEQ_INTERVAL_FM2FMA(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MB%MFM,MA(J,K)%LEFT)
            CALL FMEQ(MB%MFM,MA(J,K)%RIGHT)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2FMA

   SUBROUTINE FMEQ_INTERVAL_FMA2FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FM_TO_FMA(MB,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FMA2FM

   SUBROUTINE FMEQ_INTERVAL_FM2IM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2IM

   SUBROUTINE FMEQ_INTERVAL_FM2ZM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (ZM) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      CALL ZMREAL_INTERVAL(MB%MZM,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_FM2ZM

   SUBROUTINE FMEQ_INTERVAL_IM2FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI), SAVE :: MTLVIM
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMFM2I_INTERVAL(MB,MTLVIM)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMEQ(MTLVIM,MA(J,K)%MIM)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_IM2FM

   SUBROUTINE FMEQ_INTERVAL_ZM2FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMI2M_INTERVAL(0,MTFM_I)
      CALL ZMCMPX_INTERVAL(MB,MTFM_I,MZ_1)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMEQ(MZ_1%MZM,MA(J,K)%MZM)
         ENDDO
      ENDDO
   END SUBROUTINE FMEQ_INTERVAL_ZM2FM

!             (4) rank 2  =  rank 2

   SUBROUTINE FMEQ_INTERVAL_FM2I2(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2I2

   SUBROUTINE FMEQ_INTERVAL_FM2R2(MA,R)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (INOUT) :: MA
      INTENT (IN) :: R
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2R2

   SUBROUTINE FMEQ_INTERVAL_FM2D2(MA,D)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (INOUT) :: MA
      INTENT (IN) :: D
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2D2

   SUBROUTINE FMEQ_INTERVAL_FM2Z2(MA,Z)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX, DIMENSION(:,:) :: Z
      INTENT (INOUT) :: MA
      INTENT (IN) :: Z
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(REAL(Z(J,K)),MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2Z2

   SUBROUTINE FMEQ_INTERVAL_FM2C2(MA,C)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER :: J,K
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      INTENT (INOUT) :: MA
      INTENT (IN) :: C
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(REAL(C(J,K),KIND(0.0D0)),MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2C2

   SUBROUTINE FMEQ_INTERVAL_I2FM2(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (INOUT) :: IVAL
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(IVAL,DIM=1)
             DO K = 1, SIZE(IVAL,DIM=2)
                IVAL(J,K) = IUNKNO
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2I_INTERVAL(MA(J,K),IVAL(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_I2FM2

   SUBROUTINE FMEQ_INTERVAL_R2FM2(R,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      INTEGER :: J,K
      INTENT (INOUT) :: R
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(R,DIM=1)
             DO K = 1, SIZE(R,DIM=2)
                R(J,K) = RUNKNO
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP_INTERVAL(MA(J,K),R(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_R2FM2

   SUBROUTINE FMEQ_INTERVAL_D2FM2(D,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTEGER :: J,K
      INTENT (INOUT) :: D
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(D,DIM=1)
             DO K = 1, SIZE(D,DIM=2)
                D(J,K) = RUNKNO
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP_INTERVAL(MA(J,K),D(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_D2FM2

   SUBROUTINE FMEQ_INTERVAL_Z2FM2(Z,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      COMPLEX, DIMENSION(:,:) :: Z
      REAL :: R
      INTEGER :: J,K
      INTENT (INOUT) :: Z
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(Z,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(Z,DIM=2)) THEN
          DO J = 1, SIZE(Z,DIM=1)
             DO K = 1, SIZE(Z,DIM=2)
                Z(J,K) = CMPLX(RUNKNO,RUNKNO)
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2SP_INTERVAL(MA(J,K),R)
            Z(J,K) = CMPLX(R,0.0)
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_Z2FM2

   SUBROUTINE FMEQ_INTERVAL_C2FM2(C,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      COMPLEX (KIND(0.0D0)), DIMENSION(:,:) :: C
      REAL (KIND(0.0D0)) :: D
      INTEGER :: J,K
      INTENT (INOUT) :: C
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(C,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(C,DIM=2)) THEN
          DO J = 1, SIZE(C,DIM=1)
             DO K = 1, SIZE(C,DIM=2)
                D = RUNKNO
                C(J,K) = CMPLX(D,D , KIND(0.0D0))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMM2DP_INTERVAL(MA(J,K),D)
            C(J,K) = CMPLX(D,0.0D0 , KIND(0.0D0))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_C2FM2

   SUBROUTINE FMEQ_INTERVAL_FM2FM2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MB(J,K),MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2FM2

   SUBROUTINE FMEQ_INTERVAL_FM2FMA2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ(MB(J,K)%MFM,MA(J,K)%LEFT)
            CALL FMEQ(MB(J,K)%MFM,MA(J,K)%RIGHT)
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2FMA2

   SUBROUTINE FMEQ_INTERVAL_FMA2FM2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TYPE(MULTI), SAVE :: MTLVFM
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL FMST2M(' UNKNOWN ',MTLVFM)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ(MTLVFM,MA(J,K)%MFM)
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FM_TO_FMA(MB(J,K),MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FMA2FM2

   SUBROUTINE FMEQ_INTERVAL_FM2IM2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2IM2

   SUBROUTINE FMEQ_INTERVAL_FM2ZM2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (ZM), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL FMST2M_INTERVAL(' UNKNOWN ',MTFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMEQ_INTERVAL(MTFM_I,MA(J,K))
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMREAL_INTERVAL(MB(J,K)%MZM,MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_FM2ZM2

   SUBROUTINE FMEQ_INTERVAL_IM2FM2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL IMST2M(' UNKNOWN ',MTIM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL IMEQ(MTIM_I,MA(J,K)%MIM)
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMFM2I_INTERVAL(MB(J,K),MA(J,K)%MIM)
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_IM2FM2

   SUBROUTINE FMEQ_INTERVAL_ZM2FM2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (ZM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      INTEGER :: J,K
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          CALL ZMST2M(' UNKNOWN + UNKNOWN i ',MTZM_I)
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL ZMEQ(MTZM_I,MA(J,K)%MZM)
             ENDDO
          ENDDO
          GO TO 10
      ENDIF
      CALL FMI2M_INTERVAL(0,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL ZMCMPX_INTERVAL(MB(J,K),MTFM_I,MA(J,K))
         ENDDO
      ENDDO
   10 RETURN
   END SUBROUTINE FMEQ_INTERVAL_ZM2FM2

!                                                                  ==

   FUNCTION FMLEQ_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'EQ',MA)
   END FUNCTION FMLEQ_INTERVAL_IFM

   FUNCTION FMLEQ_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'EQ',MA)
   END FUNCTION FMLEQ_INTERVAL_RFM

   FUNCTION FMLEQ_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'EQ',MA)
   END FUNCTION FMLEQ_INTERVAL_DFM

   FUNCTION FMLEQ_INTERVAL_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(REAL(Z),MTFM_I)
      L1 = FMCOMP_INTERVAL(MTFM_I,'EQ',MA)
      L2 = .TRUE.
      IF (AIMAG(Z) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_INTERVAL_ZFM

   FUNCTION FMLEQ_INTERVAL_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(REAL(C,KIND(0.0D0)),MTFM_I)
      L1 = FMCOMP_INTERVAL(MTFM_I,'EQ',MA)
      L2 = .TRUE.
      IF (AIMAG(C) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_INTERVAL_CFM

   FUNCTION FMLEQ_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'EQ',MTFM_I)
   END FUNCTION FMLEQ_INTERVAL_FMI

   FUNCTION FMLEQ_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'EQ',MTFM_I)
   END FUNCTION FMLEQ_INTERVAL_FMR

   FUNCTION FMLEQ_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'EQ',MTFM_I)
   END FUNCTION FMLEQ_INTERVAL_FMD

   FUNCTION FMLEQ_INTERVAL_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(REAL(Z),MTFM_I)
      L1 = FMCOMP_INTERVAL(MA,'EQ',MTFM_I)
      L2 = .TRUE.
      IF (AIMAG(Z) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_INTERVAL_FMZ

   FUNCTION FMLEQ_INTERVAL_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(REAL(C,KIND(0.0D0)),MTFM_I)
      L1 = FMCOMP_INTERVAL(MA,'EQ',MTFM_I)
      L2 = .TRUE.
      IF (AIMAG(C) /= 0.0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_INTERVAL_FMC

   FUNCTION FMLEQ_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'EQ',MB)
   END FUNCTION FMLEQ_INTERVAL_FMFM

   FUNCTION FMLEQ_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'EQ',TO_FM_INTERVAL(MB))
   END FUNCTION FMLEQ_INTERVAL_FMFMA

   FUNCTION FMLEQ_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(TO_FM_INTERVAL(MA),'EQ',MB)
   END FUNCTION FMLEQ_INTERVAL_FMAFM

   FUNCTION FMLEQ_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL FMINT_INTERVAL(MA,MTFM_I)
      IF (FMCOMP_INTERVAL(MA,'EQ',MTFM_I)) THEN
          CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
          RETURN_VALUE = FMCOMP_INTERVAL(MA,'EQ',MTFM_I)
      ELSE
          RETURN_VALUE = .FALSE.
      ENDIF
   END FUNCTION FMLEQ_INTERVAL_FMIM

   FUNCTION FMLEQ_INTERVAL_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      TYPE (ZM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL ZMREAL_INTERVAL(MB%MZM,MTFM_I)
      L1 = FMCOMP_INTERVAL(MA,'EQ',MTFM_I)
      L2 = .TRUE.
      IF (MB%MZM(2)%MP(3) /= 0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_INTERVAL_FMZM

   FUNCTION FMLEQ_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMINT_INTERVAL(MB,MTFM_I)
      IF (FMCOMP_INTERVAL(MB,'EQ',MTFM_I)) THEN
          CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
          RETURN_VALUE = FMCOMP_INTERVAL(MB,'EQ',MTFM_I)
      ELSE
          RETURN_VALUE = .FALSE.
      ENDIF
   END FUNCTION FMLEQ_INTERVAL_IMFM

   FUNCTION FMLEQ_INTERVAL_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MB
      TYPE (ZM) :: MA
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL ZMREAL_INTERVAL(MA%MZM,MTFM_I)
      L1 = FMCOMP_INTERVAL(MB,'EQ',MTFM_I)
      L2 = .TRUE.
      IF (MA%MZM(2)%MP(3) /= 0) L2 = .FALSE.
      RETURN_VALUE = L1.AND.L2
   END FUNCTION FMLEQ_INTERVAL_ZMFM

 END MODULE FM_INTERVAL_ARITHMETIC_2

 MODULE FM_INTERVAL_ARITHMETIC_3
    USE FM_INTERVAL_ARITHMETIC_1

    INTERFACE OPERATOR (/=)
       MODULE PROCEDURE FMLNE_INTERVAL_IFM
       MODULE PROCEDURE FMLNE_INTERVAL_RFM
       MODULE PROCEDURE FMLNE_INTERVAL_DFM
       MODULE PROCEDURE FMLNE_INTERVAL_ZFM
       MODULE PROCEDURE FMLNE_INTERVAL_CFM
       MODULE PROCEDURE FMLNE_INTERVAL_FMI
       MODULE PROCEDURE FMLNE_INTERVAL_FMR
       MODULE PROCEDURE FMLNE_INTERVAL_FMD
       MODULE PROCEDURE FMLNE_INTERVAL_FMZ
       MODULE PROCEDURE FMLNE_INTERVAL_FMC
       MODULE PROCEDURE FMLNE_INTERVAL_FMFM
       MODULE PROCEDURE FMLNE_INTERVAL_FMFMA
       MODULE PROCEDURE FMLNE_INTERVAL_FMAFM
       MODULE PROCEDURE FMLNE_INTERVAL_FMIM
       MODULE PROCEDURE FMLNE_INTERVAL_FMZM
       MODULE PROCEDURE FMLNE_INTERVAL_IMFM
       MODULE PROCEDURE FMLNE_INTERVAL_ZMFM
    END INTERFACE

    INTERFACE OPERATOR (>)
       MODULE PROCEDURE FMLGT_INTERVAL_IFM
       MODULE PROCEDURE FMLGT_INTERVAL_RFM
       MODULE PROCEDURE FMLGT_INTERVAL_DFM
       MODULE PROCEDURE FMLGT_INTERVAL_FMI
       MODULE PROCEDURE FMLGT_INTERVAL_FMR
       MODULE PROCEDURE FMLGT_INTERVAL_FMD
       MODULE PROCEDURE FMLGT_INTERVAL_FMFM
       MODULE PROCEDURE FMLGT_INTERVAL_FMFMA
       MODULE PROCEDURE FMLGT_INTERVAL_FMAFM
       MODULE PROCEDURE FMLGT_INTERVAL_FMIM
       MODULE PROCEDURE FMLGT_INTERVAL_IMFM
    END INTERFACE

    INTERFACE OPERATOR (>=)
       MODULE PROCEDURE FMLGE_INTERVAL_IFM
       MODULE PROCEDURE FMLGE_INTERVAL_RFM
       MODULE PROCEDURE FMLGE_INTERVAL_DFM
       MODULE PROCEDURE FMLGE_INTERVAL_FMI
       MODULE PROCEDURE FMLGE_INTERVAL_FMR
       MODULE PROCEDURE FMLGE_INTERVAL_FMD
       MODULE PROCEDURE FMLGE_INTERVAL_FMFM
       MODULE PROCEDURE FMLGE_INTERVAL_FMFMA
       MODULE PROCEDURE FMLGE_INTERVAL_FMAFM
       MODULE PROCEDURE FMLGE_INTERVAL_FMIM
       MODULE PROCEDURE FMLGE_INTERVAL_IMFM
    END INTERFACE

    INTERFACE OPERATOR (<)
       MODULE PROCEDURE FMLLT_INTERVAL_IFM
       MODULE PROCEDURE FMLLT_INTERVAL_RFM
       MODULE PROCEDURE FMLLT_INTERVAL_DFM
       MODULE PROCEDURE FMLLT_INTERVAL_FMI
       MODULE PROCEDURE FMLLT_INTERVAL_FMR
       MODULE PROCEDURE FMLLT_INTERVAL_FMD
       MODULE PROCEDURE FMLLT_INTERVAL_FMFM
       MODULE PROCEDURE FMLLT_INTERVAL_FMFMA
       MODULE PROCEDURE FMLLT_INTERVAL_FMAFM
       MODULE PROCEDURE FMLLT_INTERVAL_FMIM
       MODULE PROCEDURE FMLLT_INTERVAL_IMFM
    END INTERFACE

    INTERFACE OPERATOR (<=)
       MODULE PROCEDURE FMLLE_INTERVAL_IFM
       MODULE PROCEDURE FMLLE_INTERVAL_RFM
       MODULE PROCEDURE FMLLE_INTERVAL_DFM
       MODULE PROCEDURE FMLLE_INTERVAL_FMI
       MODULE PROCEDURE FMLLE_INTERVAL_FMR
       MODULE PROCEDURE FMLLE_INTERVAL_FMD
       MODULE PROCEDURE FMLLE_INTERVAL_FMFM
       MODULE PROCEDURE FMLLE_INTERVAL_FMFMA
       MODULE PROCEDURE FMLLE_INTERVAL_FMAFM
       MODULE PROCEDURE FMLLE_INTERVAL_FMIM
       MODULE PROCEDURE FMLLE_INTERVAL_IMFM
    END INTERFACE

 CONTAINS

!                                                                  /=

   FUNCTION FMLNE_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'NE',MA)
   END FUNCTION FMLNE_INTERVAL_IFM

   FUNCTION FMLNE_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'NE',MA)
   END FUNCTION FMLNE_INTERVAL_RFM

   FUNCTION FMLNE_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'NE',MA)
   END FUNCTION FMLNE_INTERVAL_DFM

   FUNCTION FMLNE_INTERVAL_ZFM(Z,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      COMPLEX :: Z
      INTENT (IN) :: Z,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(REAL(Z),MTFM_I)
      L1 = FMCOMP_INTERVAL(MTFM_I,'NE',MA)
      L2 = .FALSE.
      IF (AIMAG(Z) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_INTERVAL_ZFM

   FUNCTION FMLNE_INTERVAL_CFM(C,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: C,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(REAL(C,KIND(0.0D0)),MTFM_I)
      L1 = FMCOMP_INTERVAL(MTFM_I,'NE',MA)
      L2 = .FALSE.
      IF (AIMAG(C) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_INTERVAL_CFM

   FUNCTION FMLNE_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'NE',MTFM_I)
   END FUNCTION FMLNE_INTERVAL_FMI

   FUNCTION FMLNE_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'NE',MTFM_I)
   END FUNCTION FMLNE_INTERVAL_FMR

   FUNCTION FMLNE_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'NE',MTFM_I)
   END FUNCTION FMLNE_INTERVAL_FMD

   FUNCTION FMLNE_INTERVAL_FMZ(MA,Z)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      COMPLEX :: Z
      INTENT (IN) :: MA,Z
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(REAL(Z),MTFM_I)
      L1 = FMCOMP_INTERVAL(MA,'NE',MTFM_I)
      L2 = .FALSE.
      IF (AIMAG(Z) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_INTERVAL_FMZ

   FUNCTION FMLNE_INTERVAL_FMC(MA,C)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      COMPLEX (KIND(0.0D0)) :: C
      INTENT (IN) :: MA,C
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(REAL(C,KIND(0.0D0)),MTFM_I)
      L1 = FMCOMP_INTERVAL(MA,'NE',MTFM_I)
      L2 = .FALSE.
      IF (AIMAG(C) /= 0.0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_INTERVAL_FMC

   FUNCTION FMLNE_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'NE',MB)
   END FUNCTION FMLNE_INTERVAL_FMFM

   FUNCTION FMLNE_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'NE',TO_FM_INTERVAL(MB))
   END FUNCTION FMLNE_INTERVAL_FMFMA

   FUNCTION FMLNE_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(TO_FM_INTERVAL(MA),'NE',MB)
   END FUNCTION FMLNE_INTERVAL_FMAFM

   FUNCTION FMLNE_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL FMINT_INTERVAL(MA,MTFM_I)
      IF (FMCOMP_INTERVAL(MA,'EQ',MTFM_I)) THEN
          CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
          RETURN_VALUE = FMCOMP_INTERVAL(MA,'NE',MTFM_I)
      ELSE
          RETURN_VALUE = .TRUE.
      ENDIF
   END FUNCTION FMLNE_INTERVAL_FMIM

   FUNCTION FMLNE_INTERVAL_FMZM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MA
      TYPE (ZM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL ZMREAL_INTERVAL(MB%MZM,MTFM_I)
      L1 = FMCOMP_INTERVAL(MA,'NE',MTFM_I)
      L2 = .FALSE.
      IF (MB%MZM(2)%MP(3) /= 0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_INTERVAL_FMZM

   FUNCTION FMLNE_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMINT_INTERVAL(MB,MTFM_I)
      IF (FMCOMP_INTERVAL(MB,'EQ',MTFM_I)) THEN
          CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
          RETURN_VALUE = FMCOMP_INTERVAL(MB,'NE',MTFM_I)
      ELSE
          RETURN_VALUE = .TRUE.
      ENDIF
   END FUNCTION FMLNE_INTERVAL_IMFM

   FUNCTION FMLNE_INTERVAL_ZMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE,L1,L2
      TYPE (FM_INTERVAL) :: MB
      TYPE (ZM) :: MA
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL ZMREAL_INTERVAL(MA%MZM,MTFM_I)
      L1 = FMCOMP_INTERVAL(MB,'NE',MTFM_I)
      L2 = .FALSE.
      IF (MA%MZM(2)%MP(3) /= 0) L2 = .TRUE.
      RETURN_VALUE = L1.OR.L2
   END FUNCTION FMLNE_INTERVAL_ZMFM

!                                                                   >

   FUNCTION FMLGT_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'GT',MA)
   END FUNCTION FMLGT_INTERVAL_IFM

   FUNCTION FMLGT_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'GT',MA)
   END FUNCTION FMLGT_INTERVAL_RFM

   FUNCTION FMLGT_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'GT',MA)
   END FUNCTION FMLGT_INTERVAL_DFM

   FUNCTION FMLGT_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GT',MTFM_I)
   END FUNCTION FMLGT_INTERVAL_FMI

   FUNCTION FMLGT_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GT',MTFM_I)
   END FUNCTION FMLGT_INTERVAL_FMR

   FUNCTION FMLGT_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GT',MTFM_I)
   END FUNCTION FMLGT_INTERVAL_FMD

   FUNCTION FMLGT_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GT',MB)
   END FUNCTION FMLGT_INTERVAL_FMFM

   FUNCTION FMLGT_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GT',TO_FM_INTERVAL(MB))
   END FUNCTION FMLGT_INTERVAL_FMFMA

   FUNCTION FMLGT_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(TO_FM_INTERVAL(MA),'GT',MB)
   END FUNCTION FMLGT_INTERVAL_FMAFM

   FUNCTION FMLGT_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      NDSAVE = NDIG
      KA = MB%MIM%MP(2)
      NDIG = MAX(KA+NGRD52,NDIG)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GT',MTFM_I)
      NDIG = NDSAVE
   END FUNCTION FMLGT_INTERVAL_FMIM

   FUNCTION FMLGT_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      NDSAVE = NDIG
      KA = MA%MIM%MP(2)
      NDIG = MAX(KA+NGRD52,NDIG)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'GT',MB)
      NDIG = NDSAVE
   END FUNCTION FMLGT_INTERVAL_IMFM

!                                                                  >=

   FUNCTION FMLGE_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'GE',MA)
   END FUNCTION FMLGE_INTERVAL_IFM

   FUNCTION FMLGE_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'GE',MA)
   END FUNCTION FMLGE_INTERVAL_RFM

   FUNCTION FMLGE_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'GE',MA)
   END FUNCTION FMLGE_INTERVAL_DFM

   FUNCTION FMLGE_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GE',MTFM_I)
   END FUNCTION FMLGE_INTERVAL_FMI

   FUNCTION FMLGE_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GE',MTFM_I)
   END FUNCTION FMLGE_INTERVAL_FMR

   FUNCTION FMLGE_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GE',MTFM_I)
   END FUNCTION FMLGE_INTERVAL_FMD

   FUNCTION FMLGE_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GE',MB)
   END FUNCTION FMLGE_INTERVAL_FMFM

   FUNCTION FMLGE_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GE',TO_FM_INTERVAL(MB))
   END FUNCTION FMLGE_INTERVAL_FMFMA

   FUNCTION FMLGE_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(TO_FM_INTERVAL(MA),'GE',MB)
   END FUNCTION FMLGE_INTERVAL_FMAFM

   FUNCTION FMLGE_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      NDSAVE = NDIG
      KA = MB%MIM%MP(2)
      NDIG = MAX(KA+NGRD52,NDIG)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'GE',MTFM_I)
      NDIG = NDSAVE
   END FUNCTION FMLGE_INTERVAL_FMIM

   FUNCTION FMLGE_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      NDSAVE = NDIG
      KA = MA%MIM%MP(2)
      NDIG = MAX(KA+NGRD52,NDIG)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'GE',MB)
      NDIG = NDSAVE
   END FUNCTION FMLGE_INTERVAL_IMFM

!                                                                   <

   FUNCTION FMLLT_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'LT',MA)
   END FUNCTION FMLLT_INTERVAL_IFM

   FUNCTION FMLLT_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'LT',MA)
   END FUNCTION FMLLT_INTERVAL_RFM

   FUNCTION FMLLT_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'LT',MA)
   END FUNCTION FMLLT_INTERVAL_DFM

   FUNCTION FMLLT_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LT',MTFM_I)
   END FUNCTION FMLLT_INTERVAL_FMI

   FUNCTION FMLLT_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LT',MTFM_I)
   END FUNCTION FMLLT_INTERVAL_FMR

   FUNCTION FMLLT_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LT',MTFM_I)
   END FUNCTION FMLLT_INTERVAL_FMD

   FUNCTION FMLLT_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LT',MB)
   END FUNCTION FMLLT_INTERVAL_FMFM

   FUNCTION FMLLT_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LT',TO_FM_INTERVAL(MB))
   END FUNCTION FMLLT_INTERVAL_FMFMA

   FUNCTION FMLLT_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(TO_FM_INTERVAL(MA),'LT',MB)
   END FUNCTION FMLLT_INTERVAL_FMAFM

   FUNCTION FMLLT_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      NDSAVE = NDIG
      KA = MB%MIM%MP(2)
      NDIG = MAX(KA+NGRD52,NDIG)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LT',MTFM_I)
      NDIG = NDSAVE
   END FUNCTION FMLLT_INTERVAL_FMIM

   FUNCTION FMLLT_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      NDSAVE = NDIG
      KA = MA%MIM%MP(2)
      NDIG = MAX(KA+NGRD52,NDIG)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'LT',MB)
      NDIG = NDSAVE
   END FUNCTION FMLLT_INTERVAL_IMFM

!                                                                  <=

   FUNCTION FMLLE_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'LE',MA)
   END FUNCTION FMLLE_INTERVAL_IFM

   FUNCTION FMLLE_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'LE',MA)
   END FUNCTION FMLLE_INTERVAL_RFM

   FUNCTION FMLLE_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'LE',MA)
   END FUNCTION FMLLE_INTERVAL_DFM

   FUNCTION FMLLE_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LE',MTFM_I)
   END FUNCTION FMLLE_INTERVAL_FMI

   FUNCTION FMLLE_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LE',MTFM_I)
   END FUNCTION FMLLE_INTERVAL_FMR

   FUNCTION FMLLE_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LE',MTFM_I)
   END FUNCTION FMLLE_INTERVAL_FMD

   FUNCTION FMLLE_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LE',MB)
   END FUNCTION FMLLE_INTERVAL_FMFM

   FUNCTION FMLLE_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LE',TO_FM_INTERVAL(MB))
   END FUNCTION FMLLE_INTERVAL_FMFMA

   FUNCTION FMLLE_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      RETURN_VALUE = FMCOMP_INTERVAL(TO_FM_INTERVAL(MA),'LE',MB)
   END FUNCTION FMLLE_INTERVAL_FMAFM

   FUNCTION FMLLE_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      NDSAVE = NDIG
      KA = MB%MIM%MP(2)
      NDIG = MAX(KA+NGRD52,NDIG)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MA,'LE',MTFM_I)
      NDIG = NDSAVE
   END FUNCTION FMLLE_INTERVAL_FMIM

   FUNCTION FMLLE_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: RETURN_VALUE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTEGER :: KA,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      NDSAVE = NDIG
      KA = MA%MIM%MP(2)
      NDIG = MAX(KA+NGRD52,NDIG)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      RETURN_VALUE = FMCOMP_INTERVAL(MTFM_I,'LE',MB)
      NDIG = NDSAVE
   END FUNCTION FMLLE_INTERVAL_IMFM

 END MODULE FM_INTERVAL_ARITHMETIC_3

 MODULE FM_INTERVAL_ARITHMETIC_4
    USE FM_INTERVAL_ARITHMETIC_1

    INTERFACE OPERATOR (+)
       MODULE PROCEDURE FMADD_INTERVAL_IFM
       MODULE PROCEDURE FMADD_INTERVAL_RFM
       MODULE PROCEDURE FMADD_INTERVAL_DFM
       MODULE PROCEDURE FMADD_INTERVAL_FMI
       MODULE PROCEDURE FMADD_INTERVAL_FMR
       MODULE PROCEDURE FMADD_INTERVAL_FMD
       MODULE PROCEDURE FMADD_INTERVAL_FMFM
       MODULE PROCEDURE FMADD_INTERVAL_FMFMA
       MODULE PROCEDURE FMADD_INTERVAL_FMAFM
       MODULE PROCEDURE FMADD_INTERVAL_FMIM
       MODULE PROCEDURE FMADD_INTERVAL_IMFM
       MODULE PROCEDURE FMADD_INTERVAL_FM
       MODULE PROCEDURE FMADD_INTERVAL_IFM1
       MODULE PROCEDURE FMADD_INTERVAL_RFM1
       MODULE PROCEDURE FMADD_INTERVAL_DFM1
       MODULE PROCEDURE FMADD_INTERVAL_FMI1
       MODULE PROCEDURE FMADD_INTERVAL_FMR1
       MODULE PROCEDURE FMADD_INTERVAL_FMD1
       MODULE PROCEDURE FMADD_INTERVAL_FMFM1
       MODULE PROCEDURE FMADD_INTERVAL_FMFMA1
       MODULE PROCEDURE FMADD_INTERVAL_FMAFM1
       MODULE PROCEDURE FMADD_INTERVAL_IMFM1
       MODULE PROCEDURE FMADD_INTERVAL_FMIM1
       MODULE PROCEDURE FMADD_INTERVAL_FM1I
       MODULE PROCEDURE FMADD_INTERVAL_FM1R
       MODULE PROCEDURE FMADD_INTERVAL_FM1D
       MODULE PROCEDURE FMADD_INTERVAL_I1FM
       MODULE PROCEDURE FMADD_INTERVAL_R1FM
       MODULE PROCEDURE FMADD_INTERVAL_D1FM
       MODULE PROCEDURE FMADD_INTERVAL_FM1FM
       MODULE PROCEDURE FMADD_INTERVAL_FM1FMA
       MODULE PROCEDURE FMADD_INTERVAL_FMA1FM
       MODULE PROCEDURE FMADD_INTERVAL_FM1IM
       MODULE PROCEDURE FMADD_INTERVAL_IM1FM
       MODULE PROCEDURE FMADD_INTERVAL_I1FM1
       MODULE PROCEDURE FMADD_INTERVAL_R1FM1
       MODULE PROCEDURE FMADD_INTERVAL_D1FM1
       MODULE PROCEDURE FMADD_INTERVAL_FM1I1
       MODULE PROCEDURE FMADD_INTERVAL_FM1R1
       MODULE PROCEDURE FMADD_INTERVAL_FM1D1
       MODULE PROCEDURE FMADD_INTERVAL_FM1FM1
       MODULE PROCEDURE FMADD_INTERVAL_FM1FMA1
       MODULE PROCEDURE FMADD_INTERVAL_FMA1FM1
       MODULE PROCEDURE FMADD_INTERVAL_IM1FM1
       MODULE PROCEDURE FMADD_INTERVAL_FM1IM1
       MODULE PROCEDURE FMADD_INTERVAL_IFM2
       MODULE PROCEDURE FMADD_INTERVAL_RFM2
       MODULE PROCEDURE FMADD_INTERVAL_DFM2
       MODULE PROCEDURE FMADD_INTERVAL_FMI2
       MODULE PROCEDURE FMADD_INTERVAL_FMR2
       MODULE PROCEDURE FMADD_INTERVAL_FMD2
       MODULE PROCEDURE FMADD_INTERVAL_FMFM2
       MODULE PROCEDURE FMADD_INTERVAL_FMFMA2
       MODULE PROCEDURE FMADD_INTERVAL_FMAFM2
       MODULE PROCEDURE FMADD_INTERVAL_IMFM2
       MODULE PROCEDURE FMADD_INTERVAL_FMIM2
       MODULE PROCEDURE FMADD_INTERVAL_FM2I
       MODULE PROCEDURE FMADD_INTERVAL_FM2R
       MODULE PROCEDURE FMADD_INTERVAL_FM2D
       MODULE PROCEDURE FMADD_INTERVAL_I2FM
       MODULE PROCEDURE FMADD_INTERVAL_R2FM
       MODULE PROCEDURE FMADD_INTERVAL_D2FM
       MODULE PROCEDURE FMADD_INTERVAL_FM2FM
       MODULE PROCEDURE FMADD_INTERVAL_FM2FMA
       MODULE PROCEDURE FMADD_INTERVAL_FMA2FM
       MODULE PROCEDURE FMADD_INTERVAL_FM2IM
       MODULE PROCEDURE FMADD_INTERVAL_IM2FM
       MODULE PROCEDURE FMADD_INTERVAL_I2FM2
       MODULE PROCEDURE FMADD_INTERVAL_R2FM2
       MODULE PROCEDURE FMADD_INTERVAL_D2FM2
       MODULE PROCEDURE FMADD_INTERVAL_FM2I2
       MODULE PROCEDURE FMADD_INTERVAL_FM2R2
       MODULE PROCEDURE FMADD_INTERVAL_FM2D2
       MODULE PROCEDURE FMADD_INTERVAL_FM2FM2
       MODULE PROCEDURE FMADD_INTERVAL_FM2FMA2
       MODULE PROCEDURE FMADD_INTERVAL_FMA2FM2
       MODULE PROCEDURE FMADD_INTERVAL_IM2FM2
       MODULE PROCEDURE FMADD_INTERVAL_FM2IM2
       MODULE PROCEDURE FMADD_INTERVAL_FM1
       MODULE PROCEDURE FMADD_INTERVAL_FM2
    END INTERFACE

 CONTAINS

!                                                                   +

   FUNCTION FMADD_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_IFM

   FUNCTION FMADD_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_RFM

   FUNCTION FMADD_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_DFM

   FUNCTION FMADD_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_FMI

   FUNCTION FMADD_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_FMR

   FUNCTION FMADD_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_FMD

   FUNCTION FMADD_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMADD_INTERVAL(MA,MB,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_FMFM

   FUNCTION FMADD_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL FMADD_INTERVAL(MA,TO_FM_INTERVAL(MB),RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_FMFMA

   FUNCTION FMADD_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      TYPE (FM) :: MA
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMADD_INTERVAL(TO_FM_INTERVAL(MA),MB,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_FMAFM

   FUNCTION FMADD_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_FMIM

   FUNCTION FMADD_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      CALL FMADD_INTERVAL(MTFM_I,MB,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_IMFM

   FUNCTION FMADD_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMADD_INTERVAL_FM

!             Array addition operations for FM.

!             (1) rank 0  +  rank 1

   FUNCTION FMADD_INTERVAL_IFM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMADD_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_IFM1

   FUNCTION FMADD_INTERVAL_RFM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMADD_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_RFM1

   FUNCTION FMADD_INTERVAL_DFM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMADD_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_DFM1

   FUNCTION FMADD_INTERVAL_FMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMI1

   FUNCTION FMADD_INTERVAL_FMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMR1

   FUNCTION FMADD_INTERVAL_FMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMD1

   FUNCTION FMADD_INTERVAL_FMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMFM1

   FUNCTION FMADD_INTERVAL_FMFMA1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA,TO_FM_INTERVAL(MB(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMFMA1

   FUNCTION FMADD_INTERVAL_FMAFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMADD_INTERVAL(TO_FM_INTERVAL(MA),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMAFM1

   FUNCTION FMADD_INTERVAL_IMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      DO J = 1, N
         CALL FMADD_INTERVAL(MTFM_I,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_IMFM1

   FUNCTION FMADD_INTERVAL_FMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MTFM_I)
         CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMIM1

!             (2) rank 1  +  rank 0

   FUNCTION FMADD_INTERVAL_FM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1I

   FUNCTION FMADD_INTERVAL_FM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1R

   FUNCTION FMADD_INTERVAL_FM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1D

   FUNCTION FMADD_INTERVAL_I1FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_I1FM

   FUNCTION FMADD_INTERVAL_R1FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_R1FM

   FUNCTION FMADD_INTERVAL_D1FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_D1FM

   FUNCTION FMADD_INTERVAL_FM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA(J),MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1FM

   FUNCTION FMADD_INTERVAL_FM1FMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA(J),TO_FM_INTERVAL(MB),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1FMA

   FUNCTION FMADD_INTERVAL_FMA1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMADD_INTERVAL(TO_FM_INTERVAL(MA(J)),MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMA1FM

   FUNCTION FMADD_INTERVAL_FM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1IM

   FUNCTION FMADD_INTERVAL_IM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,MTFM_I)
         CALL FMADD_INTERVAL(MTFM_I,MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_IM1FM

!             (3) rank 1  +  rank 1

   FUNCTION FMADD_INTERVAL_FM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMADD_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1I1

   FUNCTION FMADD_INTERVAL_FM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMADD_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1R1

   FUNCTION FMADD_INTERVAL_FM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMADD_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1D1

   FUNCTION FMADD_INTERVAL_I1FM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMADD_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_I1FM1

   FUNCTION FMADD_INTERVAL_R1FM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMADD_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_R1FM1

   FUNCTION FMADD_INTERVAL_D1FM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMADD_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_D1FM1

   FUNCTION FMADD_INTERVAL_FM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA(J),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1FM1

   FUNCTION FMADD_INTERVAL_FM1FMA1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMADD_INTERVAL(MA(J),TO_FM_INTERVAL(MB(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1FMA1

   FUNCTION FMADD_INTERVAL_FMA1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMADD_INTERVAL(TO_FM_INTERVAL(MA(J)),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMA1FM1

   FUNCTION FMADD_INTERVAL_FM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MTFM_I)
         CALL FMADD_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1IM1

   FUNCTION FMADD_INTERVAL_IM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,MTFM_I)
         CALL FMADD_INTERVAL(MTFM_I,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_IM1FM1

!             (4) rank 0  +  rank 2

   FUNCTION FMADD_INTERVAL_IFM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_IFM2

   FUNCTION FMADD_INTERVAL_RFM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_RFM2

   FUNCTION FMADD_INTERVAL_DFM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_DFM2

   FUNCTION FMADD_INTERVAL_FMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMI2

   FUNCTION FMADD_INTERVAL_FMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMR2

   FUNCTION FMADD_INTERVAL_FMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMD2

   FUNCTION FMADD_INTERVAL_FMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMADD_INTERVAL(MA,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMFM2

   FUNCTION FMADD_INTERVAL_FMFMA2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMADD_INTERVAL(MA,TO_FM_INTERVAL(MB(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMFMA2

   FUNCTION FMADD_INTERVAL_FMAFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMADD_INTERVAL(TO_FM_INTERVAL(MA),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMAFM2

   FUNCTION FMADD_INTERVAL_IMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMADD_INTERVAL(MTFM_I,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_IMFM2

   FUNCTION FMADD_INTERVAL_FMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MTFM_I)
            CALL FMADD_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMIM2

!             (5) rank 2  +  rank 0

   FUNCTION FMADD_INTERVAL_FM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2I

   FUNCTION FMADD_INTERVAL_FM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2R

   FUNCTION FMADD_INTERVAL_FM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2D

   FUNCTION FMADD_INTERVAL_I2FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_I2FM

   FUNCTION FMADD_INTERVAL_R2FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_R2FM

   FUNCTION FMADD_INTERVAL_D2FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_D2FM

   FUNCTION FMADD_INTERVAL_FM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MA(J,K),MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2FM

   FUNCTION FMADD_INTERVAL_FM2FMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MA(J,K),TO_FM_INTERVAL(MB),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2FMA

   FUNCTION FMADD_INTERVAL_FMA2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(TO_FM_INTERVAL(MA(J,K)),MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMA2FM

   FUNCTION FMADD_INTERVAL_FM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2IM

   FUNCTION FMADD_INTERVAL_IM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,MTFM_I)
            CALL FMADD_INTERVAL(MTFM_I,MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_IM2FM

!             (6) rank 2  +  rank 2

   FUNCTION FMADD_INTERVAL_FM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2I2

   FUNCTION FMADD_INTERVAL_FM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2R2

   FUNCTION FMADD_INTERVAL_FM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2D2

   FUNCTION FMADD_INTERVAL_I2FM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_I2FM2

   FUNCTION FMADD_INTERVAL_R2FM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_R2FM2

   FUNCTION FMADD_INTERVAL_D2FM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMADD_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_D2FM2

   FUNCTION FMADD_INTERVAL_FM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MA(J,K),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2FM2

   FUNCTION FMADD_INTERVAL_FM2FMA2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(MA(J,K),TO_FM_INTERVAL(MB(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2FMA2

   FUNCTION FMADD_INTERVAL_FMA2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMADD_INTERVAL(TO_FM_INTERVAL(MA(J,K)),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FMA2FM2

   FUNCTION FMADD_INTERVAL_FM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MTFM_I)
            CALL FMADD_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2IM2

   FUNCTION FMADD_INTERVAL_IM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,MTFM_I)
            CALL FMADD_INTERVAL(MTFM_I,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_IM2FM2

   FUNCTION FMADD_INTERVAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMEQ_INTERVAL(MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM1

   FUNCTION FMADD_INTERVAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMEQ_INTERVAL(MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMADD_INTERVAL_FM2

 END MODULE FM_INTERVAL_ARITHMETIC_4

 MODULE FM_INTERVAL_ARITHMETIC_5
    USE FM_INTERVAL_ARITHMETIC_1

    INTERFACE OPERATOR (-)
       MODULE PROCEDURE FMSUB_INTERVAL_IFM
       MODULE PROCEDURE FMSUB_INTERVAL_RFM
       MODULE PROCEDURE FMSUB_INTERVAL_DFM
       MODULE PROCEDURE FMSUB_INTERVAL_FMI
       MODULE PROCEDURE FMSUB_INTERVAL_FMR
       MODULE PROCEDURE FMSUB_INTERVAL_FMD
       MODULE PROCEDURE FMSUB_INTERVAL_FMFM
       MODULE PROCEDURE FMSUB_INTERVAL_FMFMA
       MODULE PROCEDURE FMSUB_INTERVAL_FMAFM
       MODULE PROCEDURE FMSUB_INTERVAL_FMIM
       MODULE PROCEDURE FMSUB_INTERVAL_IMFM
       MODULE PROCEDURE FMSUB_INTERVAL_FM
       MODULE PROCEDURE FMSUB_INTERVAL_IFM1
       MODULE PROCEDURE FMSUB_INTERVAL_RFM1
       MODULE PROCEDURE FMSUB_INTERVAL_DFM1
       MODULE PROCEDURE FMSUB_INTERVAL_FMI1
       MODULE PROCEDURE FMSUB_INTERVAL_FMR1
       MODULE PROCEDURE FMSUB_INTERVAL_FMD1
       MODULE PROCEDURE FMSUB_INTERVAL_FMFM1
       MODULE PROCEDURE FMSUB_INTERVAL_FMFMA1
       MODULE PROCEDURE FMSUB_INTERVAL_FMAFM1
       MODULE PROCEDURE FMSUB_INTERVAL_IMFM1
       MODULE PROCEDURE FMSUB_INTERVAL_FMIM1
       MODULE PROCEDURE FMSUB_INTERVAL_FM1I
       MODULE PROCEDURE FMSUB_INTERVAL_FM1R
       MODULE PROCEDURE FMSUB_INTERVAL_FM1D
       MODULE PROCEDURE FMSUB_INTERVAL_I1FM
       MODULE PROCEDURE FMSUB_INTERVAL_R1FM
       MODULE PROCEDURE FMSUB_INTERVAL_D1FM
       MODULE PROCEDURE FMSUB_INTERVAL_FM1FM
       MODULE PROCEDURE FMSUB_INTERVAL_FM1FMA
       MODULE PROCEDURE FMSUB_INTERVAL_FMA1FM
       MODULE PROCEDURE FMSUB_INTERVAL_FM1IM
       MODULE PROCEDURE FMSUB_INTERVAL_IM1FM
       MODULE PROCEDURE FMSUB_INTERVAL_I1FM1
       MODULE PROCEDURE FMSUB_INTERVAL_R1FM1
       MODULE PROCEDURE FMSUB_INTERVAL_D1FM1
       MODULE PROCEDURE FMSUB_INTERVAL_FM1I1
       MODULE PROCEDURE FMSUB_INTERVAL_FM1R1
       MODULE PROCEDURE FMSUB_INTERVAL_FM1D1
       MODULE PROCEDURE FMSUB_INTERVAL_FM1FM1
       MODULE PROCEDURE FMSUB_INTERVAL_FM1FMA1
       MODULE PROCEDURE FMSUB_INTERVAL_FMA1FM1
       MODULE PROCEDURE FMSUB_INTERVAL_IM1FM1
       MODULE PROCEDURE FMSUB_INTERVAL_FM1IM1
       MODULE PROCEDURE FMSUB_INTERVAL_IFM2
       MODULE PROCEDURE FMSUB_INTERVAL_RFM2
       MODULE PROCEDURE FMSUB_INTERVAL_DFM2
       MODULE PROCEDURE FMSUB_INTERVAL_FMI2
       MODULE PROCEDURE FMSUB_INTERVAL_FMR2
       MODULE PROCEDURE FMSUB_INTERVAL_FMD2
       MODULE PROCEDURE FMSUB_INTERVAL_FMFM2
       MODULE PROCEDURE FMSUB_INTERVAL_FMFMA2
       MODULE PROCEDURE FMSUB_INTERVAL_FMAFM2
       MODULE PROCEDURE FMSUB_INTERVAL_IMFM2
       MODULE PROCEDURE FMSUB_INTERVAL_FMIM2
       MODULE PROCEDURE FMSUB_INTERVAL_FM2I
       MODULE PROCEDURE FMSUB_INTERVAL_FM2R
       MODULE PROCEDURE FMSUB_INTERVAL_FM2D
       MODULE PROCEDURE FMSUB_INTERVAL_I2FM
       MODULE PROCEDURE FMSUB_INTERVAL_R2FM
       MODULE PROCEDURE FMSUB_INTERVAL_D2FM
       MODULE PROCEDURE FMSUB_INTERVAL_FM2FM
       MODULE PROCEDURE FMSUB_INTERVAL_FM2FMA
       MODULE PROCEDURE FMSUB_INTERVAL_FMA2FM
       MODULE PROCEDURE FMSUB_INTERVAL_FM2IM
       MODULE PROCEDURE FMSUB_INTERVAL_IM2FM
       MODULE PROCEDURE FMSUB_INTERVAL_I2FM2
       MODULE PROCEDURE FMSUB_INTERVAL_R2FM2
       MODULE PROCEDURE FMSUB_INTERVAL_D2FM2
       MODULE PROCEDURE FMSUB_INTERVAL_FM2I2
       MODULE PROCEDURE FMSUB_INTERVAL_FM2R2
       MODULE PROCEDURE FMSUB_INTERVAL_FM2D2
       MODULE PROCEDURE FMSUB_INTERVAL_FM2FM2
       MODULE PROCEDURE FMSUB_INTERVAL_FM2FMA2
       MODULE PROCEDURE FMSUB_INTERVAL_FMA2FM2
       MODULE PROCEDURE FMSUB_INTERVAL_IM2FM2
       MODULE PROCEDURE FMSUB_INTERVAL_FM2IM2
       MODULE PROCEDURE FMSUB_INTERVAL_FM1
       MODULE PROCEDURE FMSUB_INTERVAL_FM2
    END INTERFACE

 CONTAINS

!                                                                   -

   FUNCTION FMSUB_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_IFM

   FUNCTION FMSUB_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_RFM

   FUNCTION FMSUB_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_DFM

   FUNCTION FMSUB_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_FMI

   FUNCTION FMSUB_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_FMR

   FUNCTION FMSUB_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_FMD

   FUNCTION FMSUB_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMSUB_INTERVAL(MA,MB,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_FMFM

   FUNCTION FMSUB_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL FMSUB_INTERVAL(MA,TO_FM_INTERVAL(MB),RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_FMFMA

   FUNCTION FMSUB_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      TYPE (FM) :: MA
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMSUB_INTERVAL(TO_FM_INTERVAL(MA),MB,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_FMAFM

   FUNCTION FMSUB_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_FMIM

   FUNCTION FMSUB_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      CALL FMSUB_INTERVAL(MTFM_I,MB,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_IMFM

   FUNCTION FMSUB_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(0,MTFM_I)
      CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMSUB_INTERVAL_FM


!             Array subtraction operations for FM.

!             (1) rank 0  -  rank 1

   FUNCTION FMSUB_INTERVAL_IFM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_IFM1

   FUNCTION FMSUB_INTERVAL_RFM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_RFM1

   FUNCTION FMSUB_INTERVAL_DFM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_DFM1

   FUNCTION FMSUB_INTERVAL_FMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMI1

   FUNCTION FMSUB_INTERVAL_FMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMR1

   FUNCTION FMSUB_INTERVAL_FMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMD1

   FUNCTION FMSUB_INTERVAL_FMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMFM1

   FUNCTION FMSUB_INTERVAL_FMFMA1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA,TO_FM_INTERVAL(MB(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMFMA1

   FUNCTION FMSUB_INTERVAL_FMAFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMSUB_INTERVAL(TO_FM_INTERVAL(MA),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMAFM1

   FUNCTION FMSUB_INTERVAL_IMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MTFM_I,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_IMFM1

   FUNCTION FMSUB_INTERVAL_FMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MTFM_I)
         CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMIM1

!             (2) rank 1  -  rank 0

   FUNCTION FMSUB_INTERVAL_FM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1I

   FUNCTION FMSUB_INTERVAL_FM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1R

   FUNCTION FMSUB_INTERVAL_FM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1D

   FUNCTION FMSUB_INTERVAL_I1FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_I1FM

   FUNCTION FMSUB_INTERVAL_R1FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_R1FM

   FUNCTION FMSUB_INTERVAL_D1FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_D1FM

   FUNCTION FMSUB_INTERVAL_FM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA(J),MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1FM

   FUNCTION FMSUB_INTERVAL_FM1FMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA(J),TO_FM_INTERVAL(MB),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1FMA

   FUNCTION FMSUB_INTERVAL_FMA1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB_INTERVAL(TO_FM_INTERVAL(MA(J)),MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMA1FM

   FUNCTION FMSUB_INTERVAL_FM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1IM

   FUNCTION FMSUB_INTERVAL_IM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,MTFM_I)
         CALL FMSUB_INTERVAL(MTFM_I,MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_IM1FM

!             (3) rank 1  -  rank 1

   FUNCTION FMSUB_INTERVAL_FM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMSUB_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1I1

   FUNCTION FMSUB_INTERVAL_FM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMSUB_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1R1

   FUNCTION FMSUB_INTERVAL_FM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMSUB_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1D1

   FUNCTION FMSUB_INTERVAL_I1FM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMSUB_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_I1FM1

   FUNCTION FMSUB_INTERVAL_R1FM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMSUB_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_R1FM1

   FUNCTION FMSUB_INTERVAL_D1FM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMSUB_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_D1FM1

   FUNCTION FMSUB_INTERVAL_FM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA(J),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1FM1

   FUNCTION FMSUB_INTERVAL_FM1FMA1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MA(J),TO_FM_INTERVAL(MB(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1FMA1

   FUNCTION FMSUB_INTERVAL_FMA1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSUB_INTERVAL(TO_FM_INTERVAL(MA(J)),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMA1FM1

   FUNCTION FMSUB_INTERVAL_FM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MTFM_I)
         CALL FMSUB_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1IM1

   FUNCTION FMSUB_INTERVAL_IM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,MTFM_I)
         CALL FMSUB_INTERVAL(MTFM_I,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_IM1FM1

!             (4) rank 0  -  rank 2

   FUNCTION FMSUB_INTERVAL_IFM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_IFM2

   FUNCTION FMSUB_INTERVAL_RFM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_RFM2

   FUNCTION FMSUB_INTERVAL_DFM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_DFM2

   FUNCTION FMSUB_INTERVAL_FMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMI2

   FUNCTION FMSUB_INTERVAL_FMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMR2

   FUNCTION FMSUB_INTERVAL_FMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMD2

   FUNCTION FMSUB_INTERVAL_FMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMSUB_INTERVAL(MA,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMFM2

   FUNCTION FMSUB_INTERVAL_FMFMA2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMSUB_INTERVAL(MA,TO_FM_INTERVAL(MB(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMFMA2

   FUNCTION FMSUB_INTERVAL_FMAFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMSUB_INTERVAL(TO_FM_INTERVAL(MA),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMAFM2

   FUNCTION FMSUB_INTERVAL_IMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMSUB_INTERVAL(MTFM_I,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_IMFM2

   FUNCTION FMSUB_INTERVAL_FMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MTFM_I)
            CALL FMSUB_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMIM2

!             (5) rank 2  -  rank 0

   FUNCTION FMSUB_INTERVAL_FM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2I

   FUNCTION FMSUB_INTERVAL_FM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2R

   FUNCTION FMSUB_INTERVAL_FM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2D

   FUNCTION FMSUB_INTERVAL_I2FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_I2FM

   FUNCTION FMSUB_INTERVAL_R2FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_R2FM

   FUNCTION FMSUB_INTERVAL_D2FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_D2FM

   FUNCTION FMSUB_INTERVAL_FM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MA(J,K),MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2FM

   FUNCTION FMSUB_INTERVAL_FM2FMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MA(J,K),TO_FM_INTERVAL(MB),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2FMA

   FUNCTION FMSUB_INTERVAL_FMA2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(TO_FM_INTERVAL(MA(J,K)),MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMA2FM

   FUNCTION FMSUB_INTERVAL_FM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2IM

   FUNCTION FMSUB_INTERVAL_IM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,MTFM_I)
            CALL FMSUB_INTERVAL(MTFM_I,MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_IM2FM

!             (6) rank 2  -  rank 2

   FUNCTION FMSUB_INTERVAL_FM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2I2

   FUNCTION FMSUB_INTERVAL_FM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2R2

   FUNCTION FMSUB_INTERVAL_FM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2D2

   FUNCTION FMSUB_INTERVAL_I2FM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_I2FM2

   FUNCTION FMSUB_INTERVAL_R2FM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_R2FM2

   FUNCTION FMSUB_INTERVAL_D2FM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMSUB_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_D2FM2

   FUNCTION FMSUB_INTERVAL_FM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MA(J,K),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2FM2

   FUNCTION FMSUB_INTERVAL_FM2FMA2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MA(J,K),TO_FM_INTERVAL(MB(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2FMA2

   FUNCTION FMSUB_INTERVAL_FMA2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(TO_FM_INTERVAL(MA(J,K)),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FMA2FM2

   FUNCTION FMSUB_INTERVAL_FM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MTFM_I)
            CALL FMSUB_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2IM2

   FUNCTION FMSUB_INTERVAL_IM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,MTFM_I)
            CALL FMSUB_INTERVAL(MTFM_I,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_IM2FM2

   FUNCTION FMSUB_INTERVAL_FM1(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(0,MTFM_I)
      DO J = 1, N
         CALL FMSUB_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM1

   FUNCTION FMSUB_INTERVAL_FM2(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(0,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSUB_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMSUB_INTERVAL_FM2

 END MODULE FM_INTERVAL_ARITHMETIC_5

 MODULE FM_INTERVAL_ARITHMETIC_6
    USE FM_INTERVAL_ARITHMETIC_1

    INTERFACE OPERATOR (*)
       MODULE PROCEDURE FMMPY_INTERVAL_IFM
       MODULE PROCEDURE FMMPY_INTERVAL_RFM
       MODULE PROCEDURE FMMPY_INTERVAL_DFM
       MODULE PROCEDURE FMMPY_INTERVAL_FMI
       MODULE PROCEDURE FMMPY_INTERVAL_FMR
       MODULE PROCEDURE FMMPY_INTERVAL_FMD
       MODULE PROCEDURE FMMPY_INTERVAL_FMFM
       MODULE PROCEDURE FMMPY_INTERVAL_FMFMA
       MODULE PROCEDURE FMMPY_INTERVAL_FMAFM
       MODULE PROCEDURE FMMPY_INTERVAL_FMIM
       MODULE PROCEDURE FMMPY_INTERVAL_IMFM
       MODULE PROCEDURE FMMPY_INTERVAL_IFM1
       MODULE PROCEDURE FMMPY_INTERVAL_RFM1
       MODULE PROCEDURE FMMPY_INTERVAL_DFM1
       MODULE PROCEDURE FMMPY_INTERVAL_FMI1
       MODULE PROCEDURE FMMPY_INTERVAL_FMR1
       MODULE PROCEDURE FMMPY_INTERVAL_FMD1
       MODULE PROCEDURE FMMPY_INTERVAL_FMFM1
       MODULE PROCEDURE FMMPY_INTERVAL_FMFMA1
       MODULE PROCEDURE FMMPY_INTERVAL_FMAFM1
       MODULE PROCEDURE FMMPY_INTERVAL_IMFM1
       MODULE PROCEDURE FMMPY_INTERVAL_FMIM1
       MODULE PROCEDURE FMMPY_INTERVAL_FM1I
       MODULE PROCEDURE FMMPY_INTERVAL_FM1R
       MODULE PROCEDURE FMMPY_INTERVAL_FM1D
       MODULE PROCEDURE FMMPY_INTERVAL_I1FM
       MODULE PROCEDURE FMMPY_INTERVAL_R1FM
       MODULE PROCEDURE FMMPY_INTERVAL_D1FM
       MODULE PROCEDURE FMMPY_INTERVAL_FM1FM
       MODULE PROCEDURE FMMPY_INTERVAL_FM1FMA
       MODULE PROCEDURE FMMPY_INTERVAL_FMA1FM
       MODULE PROCEDURE FMMPY_INTERVAL_FM1IM
       MODULE PROCEDURE FMMPY_INTERVAL_IM1FM
       MODULE PROCEDURE FMMPY_INTERVAL_I1FM1
       MODULE PROCEDURE FMMPY_INTERVAL_R1FM1
       MODULE PROCEDURE FMMPY_INTERVAL_D1FM1
       MODULE PROCEDURE FMMPY_INTERVAL_FM1I1
       MODULE PROCEDURE FMMPY_INTERVAL_FM1R1
       MODULE PROCEDURE FMMPY_INTERVAL_FM1D1
       MODULE PROCEDURE FMMPY_INTERVAL_FM1FM1
       MODULE PROCEDURE FMMPY_INTERVAL_FM1FMA1
       MODULE PROCEDURE FMMPY_INTERVAL_FMA1FM1
       MODULE PROCEDURE FMMPY_INTERVAL_IM1FM1
       MODULE PROCEDURE FMMPY_INTERVAL_FM1IM1
       MODULE PROCEDURE FMMPY_INTERVAL_IFM2
       MODULE PROCEDURE FMMPY_INTERVAL_RFM2
       MODULE PROCEDURE FMMPY_INTERVAL_DFM2
       MODULE PROCEDURE FMMPY_INTERVAL_FMI2
       MODULE PROCEDURE FMMPY_INTERVAL_FMR2
       MODULE PROCEDURE FMMPY_INTERVAL_FMD2
       MODULE PROCEDURE FMMPY_INTERVAL_FMFM2
       MODULE PROCEDURE FMMPY_INTERVAL_FMFMA2
       MODULE PROCEDURE FMMPY_INTERVAL_FMAFM2
       MODULE PROCEDURE FMMPY_INTERVAL_IMFM2
       MODULE PROCEDURE FMMPY_INTERVAL_FMIM2
       MODULE PROCEDURE FMMPY_INTERVAL_FM2I
       MODULE PROCEDURE FMMPY_INTERVAL_FM2R
       MODULE PROCEDURE FMMPY_INTERVAL_FM2D
       MODULE PROCEDURE FMMPY_INTERVAL_I2FM
       MODULE PROCEDURE FMMPY_INTERVAL_R2FM
       MODULE PROCEDURE FMMPY_INTERVAL_D2FM
       MODULE PROCEDURE FMMPY_INTERVAL_FM2FM
       MODULE PROCEDURE FMMPY_INTERVAL_FM2FMA
       MODULE PROCEDURE FMMPY_INTERVAL_FMA2FM
       MODULE PROCEDURE FMMPY_INTERVAL_FM2IM
       MODULE PROCEDURE FMMPY_INTERVAL_IM2FM
       MODULE PROCEDURE FMMPY_INTERVAL_I2FM2
       MODULE PROCEDURE FMMPY_INTERVAL_R2FM2
       MODULE PROCEDURE FMMPY_INTERVAL_D2FM2
       MODULE PROCEDURE FMMPY_INTERVAL_FM2I2
       MODULE PROCEDURE FMMPY_INTERVAL_FM2R2
       MODULE PROCEDURE FMMPY_INTERVAL_FM2D2
       MODULE PROCEDURE FMMPY_INTERVAL_FM2FM2
       MODULE PROCEDURE FMMPY_INTERVAL_FM2FMA2
       MODULE PROCEDURE FMMPY_INTERVAL_FMA2FM2
       MODULE PROCEDURE FMMPY_INTERVAL_IM2FM2
       MODULE PROCEDURE FMMPY_INTERVAL_FM2IM2
    END INTERFACE

 CONTAINS

!                                                                   *

   FUNCTION FMMPY_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMMPYI_INTERVAL(MA,IVAL,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_IFM

   FUNCTION FMMPY_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMMPY_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_RFM

   FUNCTION FMMPY_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMMPY_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_DFM

   FUNCTION FMMPY_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMMPYI_INTERVAL(MA,IVAL,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_FMI

   FUNCTION FMMPY_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_FMR

   FUNCTION FMMPY_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_FMD

   FUNCTION FMMPY_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMMPY_INTERVAL(MA,MB,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_FMFM

   FUNCTION FMMPY_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL FMMPY_INTERVAL(MA,TO_FM_INTERVAL(MB),RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_FMFMA

   FUNCTION FMMPY_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      TYPE (FM) :: MA
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMMPY_INTERVAL(TO_FM_INTERVAL(MA),MB,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_FMAFM

   FUNCTION FMMPY_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_FMIM

   FUNCTION FMMPY_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      CALL FMMPY_INTERVAL(MTFM_I,MB,RETURN_VALUE)
   END FUNCTION FMMPY_INTERVAL_IMFM


!             Array multiplication operations for FM.

!             (1) rank 0  *  rank 1

   FUNCTION FMMPY_INTERVAL_IFM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_IFM1

   FUNCTION FMMPY_INTERVAL_RFM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_RFM1

   FUNCTION FMMPY_INTERVAL_DFM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_DFM1

   FUNCTION FMMPY_INTERVAL_FMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMI1

   FUNCTION FMMPY_INTERVAL_FMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMR1

   FUNCTION FMMPY_INTERVAL_FMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMD1

   FUNCTION FMMPY_INTERVAL_FMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMFM1

   FUNCTION FMMPY_INTERVAL_FMFMA1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA,TO_FM_INTERVAL(MB(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMFMA1

   FUNCTION FMMPY_INTERVAL_FMAFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMMPY_INTERVAL(TO_FM_INTERVAL(MA),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMAFM1

   FUNCTION FMMPY_INTERVAL_IMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MTFM_I,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_IMFM1

   FUNCTION FMMPY_INTERVAL_FMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MTFM_I)
         CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMIM1

!             (2) rank 1  *  rank 0

   FUNCTION FMMPY_INTERVAL_FM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1I

   FUNCTION FMMPY_INTERVAL_FM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1R

   FUNCTION FMMPY_INTERVAL_FM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1D

   FUNCTION FMMPY_INTERVAL_I1FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMMPY_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_I1FM

   FUNCTION FMMPY_INTERVAL_R1FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMMPY_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_R1FM

   FUNCTION FMMPY_INTERVAL_D1FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMMPY_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_D1FM

   FUNCTION FMMPY_INTERVAL_FM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA(J),MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1FM

   FUNCTION FMMPY_INTERVAL_FM1FMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA(J),TO_FM_INTERVAL(MB),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1FMA

   FUNCTION FMMPY_INTERVAL_FMA1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMMPY_INTERVAL(TO_FM_INTERVAL(MA(J)),MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMA1FM

   FUNCTION FMMPY_INTERVAL_FM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1IM

   FUNCTION FMMPY_INTERVAL_IM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,MTFM_I)
         CALL FMMPY_INTERVAL(MTFM_I,MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_IM1FM

!             (3) rank 1  *  rank 1

   FUNCTION FMMPY_INTERVAL_FM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMMPY_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1I1

   FUNCTION FMMPY_INTERVAL_FM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMMPY_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1R1

   FUNCTION FMMPY_INTERVAL_FM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMMPY_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1D1

   FUNCTION FMMPY_INTERVAL_I1FM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMMPY_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_I1FM1

   FUNCTION FMMPY_INTERVAL_R1FM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMMPY_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_R1FM1

   FUNCTION FMMPY_INTERVAL_D1FM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMMPY_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_D1FM1

   FUNCTION FMMPY_INTERVAL_FM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA(J),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1FM1

   FUNCTION FMMPY_INTERVAL_FM1FMA1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMMPY_INTERVAL(MA(J),TO_FM_INTERVAL(MB(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1FMA1

   FUNCTION FMMPY_INTERVAL_FMA1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMMPY_INTERVAL(TO_FM_INTERVAL(MA(J)),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMA1FM1

   FUNCTION FMMPY_INTERVAL_FM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MTFM_I)
         CALL FMMPY_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM1IM1

   FUNCTION FMMPY_INTERVAL_IM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,MTFM_I)
         CALL FMMPY_INTERVAL(MTFM_I,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMMPY_INTERVAL_IM1FM1

!             (4) rank 0  *  rank 2

   FUNCTION FMMPY_INTERVAL_IFM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_IFM2

   FUNCTION FMMPY_INTERVAL_RFM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_RFM2

   FUNCTION FMMPY_INTERVAL_DFM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_DFM2

   FUNCTION FMMPY_INTERVAL_FMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMI2

   FUNCTION FMMPY_INTERVAL_FMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMR2

   FUNCTION FMMPY_INTERVAL_FMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMD2

   FUNCTION FMMPY_INTERVAL_FMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMMPY_INTERVAL(MA,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMFM2

   FUNCTION FMMPY_INTERVAL_FMFMA2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMMPY_INTERVAL(MA,TO_FM_INTERVAL(MB(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMFMA2

   FUNCTION FMMPY_INTERVAL_FMAFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMMPY_INTERVAL(TO_FM_INTERVAL(MA),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMAFM2

   FUNCTION FMMPY_INTERVAL_IMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMMPY_INTERVAL(MTFM_I,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_IMFM2

   FUNCTION FMMPY_INTERVAL_FMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MTFM_I)
            CALL FMMPY_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMIM2

!             (5) rank 2  *  rank 0

   FUNCTION FMMPY_INTERVAL_FM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2I

   FUNCTION FMMPY_INTERVAL_FM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2R

   FUNCTION FMMPY_INTERVAL_FM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2D

   FUNCTION FMMPY_INTERVAL_I2FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_I2FM

   FUNCTION FMMPY_INTERVAL_R2FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_R2FM

   FUNCTION FMMPY_INTERVAL_D2FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_D2FM

   FUNCTION FMMPY_INTERVAL_FM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MA(J,K),MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2FM

   FUNCTION FMMPY_INTERVAL_FM2FMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MA(J,K),TO_FM_INTERVAL(MB),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2FMA

   FUNCTION FMMPY_INTERVAL_FMA2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(TO_FM_INTERVAL(MA(J,K)),MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMA2FM

   FUNCTION FMMPY_INTERVAL_FM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2IM

   FUNCTION FMMPY_INTERVAL_IM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,MTFM_I)
            CALL FMMPY_INTERVAL(MTFM_I,MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_IM2FM

!             (6) rank 2  *  rank 2

   FUNCTION FMMPY_INTERVAL_FM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2I2

   FUNCTION FMMPY_INTERVAL_FM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2R2

   FUNCTION FMMPY_INTERVAL_FM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2D2

   FUNCTION FMMPY_INTERVAL_I2FM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_I2FM2

   FUNCTION FMMPY_INTERVAL_R2FM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_R2FM2

   FUNCTION FMMPY_INTERVAL_D2FM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMMPY_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_D2FM2

   FUNCTION FMMPY_INTERVAL_FM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MA(J,K),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2FM2

   FUNCTION FMMPY_INTERVAL_FM2FMA2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(MA(J,K),TO_FM_INTERVAL(MB(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2FMA2

   FUNCTION FMMPY_INTERVAL_FMA2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMMPY_INTERVAL(TO_FM_INTERVAL(MA(J,K)),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FMA2FM2

   FUNCTION FMMPY_INTERVAL_FM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MTFM_I)
            CALL FMMPY_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_FM2IM2

   FUNCTION FMMPY_INTERVAL_IM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,MTFM_I)
            CALL FMMPY_INTERVAL(MTFM_I,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMMPY_INTERVAL_IM2FM2

 END MODULE FM_INTERVAL_ARITHMETIC_6

 MODULE FM_INTERVAL_ARITHMETIC_7
    USE FM_INTERVAL_ARITHMETIC_1

    INTERFACE OPERATOR (/)
       MODULE PROCEDURE FMDIV_INTERVAL_IFM
       MODULE PROCEDURE FMDIV_INTERVAL_RFM
       MODULE PROCEDURE FMDIV_INTERVAL_DFM
       MODULE PROCEDURE FMDIV_INTERVAL_FMI
       MODULE PROCEDURE FMDIV_INTERVAL_FMR
       MODULE PROCEDURE FMDIV_INTERVAL_FMD
       MODULE PROCEDURE FMDIV_INTERVAL_FMFM
       MODULE PROCEDURE FMDIV_INTERVAL_FMFMA
       MODULE PROCEDURE FMDIV_INTERVAL_FMAFM
       MODULE PROCEDURE FMDIV_INTERVAL_FMIM
       MODULE PROCEDURE FMDIV_INTERVAL_IMFM
       MODULE PROCEDURE FMDIV_INTERVAL_IFM1
       MODULE PROCEDURE FMDIV_INTERVAL_RFM1
       MODULE PROCEDURE FMDIV_INTERVAL_DFM1
       MODULE PROCEDURE FMDIV_INTERVAL_FMI1
       MODULE PROCEDURE FMDIV_INTERVAL_FMR1
       MODULE PROCEDURE FMDIV_INTERVAL_FMD1
       MODULE PROCEDURE FMDIV_INTERVAL_FMFM1
       MODULE PROCEDURE FMDIV_INTERVAL_FMFMA1
       MODULE PROCEDURE FMDIV_INTERVAL_FMAFM1
       MODULE PROCEDURE FMDIV_INTERVAL_IMFM1
       MODULE PROCEDURE FMDIV_INTERVAL_FMIM1
       MODULE PROCEDURE FMDIV_INTERVAL_FM1I
       MODULE PROCEDURE FMDIV_INTERVAL_FM1R
       MODULE PROCEDURE FMDIV_INTERVAL_FM1D
       MODULE PROCEDURE FMDIV_INTERVAL_I1FM
       MODULE PROCEDURE FMDIV_INTERVAL_R1FM
       MODULE PROCEDURE FMDIV_INTERVAL_D1FM
       MODULE PROCEDURE FMDIV_INTERVAL_FM1FM
       MODULE PROCEDURE FMDIV_INTERVAL_FM1FMA
       MODULE PROCEDURE FMDIV_INTERVAL_FMA1FM
       MODULE PROCEDURE FMDIV_INTERVAL_FM1IM
       MODULE PROCEDURE FMDIV_INTERVAL_IM1FM
       MODULE PROCEDURE FMDIV_INTERVAL_I1FM1
       MODULE PROCEDURE FMDIV_INTERVAL_R1FM1
       MODULE PROCEDURE FMDIV_INTERVAL_D1FM1
       MODULE PROCEDURE FMDIV_INTERVAL_FM1I1
       MODULE PROCEDURE FMDIV_INTERVAL_FM1R1
       MODULE PROCEDURE FMDIV_INTERVAL_FM1D1
       MODULE PROCEDURE FMDIV_INTERVAL_FM1FM1
       MODULE PROCEDURE FMDIV_INTERVAL_FM1FMA1
       MODULE PROCEDURE FMDIV_INTERVAL_FMA1FM1
       MODULE PROCEDURE FMDIV_INTERVAL_IM1FM1
       MODULE PROCEDURE FMDIV_INTERVAL_FM1IM1
       MODULE PROCEDURE FMDIV_INTERVAL_IFM2
       MODULE PROCEDURE FMDIV_INTERVAL_RFM2
       MODULE PROCEDURE FMDIV_INTERVAL_DFM2
       MODULE PROCEDURE FMDIV_INTERVAL_FMI2
       MODULE PROCEDURE FMDIV_INTERVAL_FMR2
       MODULE PROCEDURE FMDIV_INTERVAL_FMD2
       MODULE PROCEDURE FMDIV_INTERVAL_FMFM2
       MODULE PROCEDURE FMDIV_INTERVAL_FMFMA2
       MODULE PROCEDURE FMDIV_INTERVAL_FMAFM2
       MODULE PROCEDURE FMDIV_INTERVAL_IMFM2
       MODULE PROCEDURE FMDIV_INTERVAL_FMIM2
       MODULE PROCEDURE FMDIV_INTERVAL_FM2I
       MODULE PROCEDURE FMDIV_INTERVAL_FM2R
       MODULE PROCEDURE FMDIV_INTERVAL_FM2D
       MODULE PROCEDURE FMDIV_INTERVAL_I2FM
       MODULE PROCEDURE FMDIV_INTERVAL_R2FM
       MODULE PROCEDURE FMDIV_INTERVAL_D2FM
       MODULE PROCEDURE FMDIV_INTERVAL_FM2FM
       MODULE PROCEDURE FMDIV_INTERVAL_FM2FMA
       MODULE PROCEDURE FMDIV_INTERVAL_FMA2FM
       MODULE PROCEDURE FMDIV_INTERVAL_FM2IM
       MODULE PROCEDURE FMDIV_INTERVAL_IM2FM
       MODULE PROCEDURE FMDIV_INTERVAL_I2FM2
       MODULE PROCEDURE FMDIV_INTERVAL_R2FM2
       MODULE PROCEDURE FMDIV_INTERVAL_D2FM2
       MODULE PROCEDURE FMDIV_INTERVAL_FM2I2
       MODULE PROCEDURE FMDIV_INTERVAL_FM2R2
       MODULE PROCEDURE FMDIV_INTERVAL_FM2D2
       MODULE PROCEDURE FMDIV_INTERVAL_FM2FM2
       MODULE PROCEDURE FMDIV_INTERVAL_FM2FMA2
       MODULE PROCEDURE FMDIV_INTERVAL_FMA2FM2
       MODULE PROCEDURE FMDIV_INTERVAL_IM2FM2
       MODULE PROCEDURE FMDIV_INTERVAL_FM2IM2
    END INTERFACE

 CONTAINS

!                                                                   /

   FUNCTION FMDIV_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_IFM

   FUNCTION FMDIV_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_RFM

   FUNCTION FMDIV_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_DFM

   FUNCTION FMDIV_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDIVI_INTERVAL(MA,IVAL,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_FMI

   FUNCTION FMDIV_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_FMR

   FUNCTION FMDIV_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_FMD

   FUNCTION FMDIV_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMDIV_INTERVAL(MA,MB,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_FMFM

   FUNCTION FMDIV_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL FMDIV_INTERVAL(MA,TO_FM_INTERVAL(MB),RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_FMFMA

   FUNCTION FMDIV_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      TYPE (FM) :: MA
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMDIV_INTERVAL(TO_FM_INTERVAL(MA),MB,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_FMAFM

   FUNCTION FMDIV_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_FMIM

   FUNCTION FMDIV_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      CALL FMDIV_INTERVAL(MTFM_I,MB,RETURN_VALUE)
   END FUNCTION FMDIV_INTERVAL_IMFM


!             Array division operations for FM.

!             (1) rank 0  /  rank 1

   FUNCTION FMDIV_INTERVAL_IFM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_IFM1

   FUNCTION FMDIV_INTERVAL_RFM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_RFM1

   FUNCTION FMDIV_INTERVAL_DFM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_DFM1

   FUNCTION FMDIV_INTERVAL_FMI1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMI1

   FUNCTION FMDIV_INTERVAL_FMR1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMR1

   FUNCTION FMDIV_INTERVAL_FMD1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMD1

   FUNCTION FMDIV_INTERVAL_FMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMFM1

   FUNCTION FMDIV_INTERVAL_FMFMA1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA,TO_FM_INTERVAL(MB(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMFMA1

   FUNCTION FMDIV_INTERVAL_FMAFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL FMDIV_INTERVAL(TO_FM_INTERVAL(MA),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMAFM1

   FUNCTION FMDIV_INTERVAL_IMFM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MTFM_I,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_IMFM1

   FUNCTION FMDIV_INTERVAL_FMIM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MB)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MTFM_I)
         CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMIM1

!             (2) rank 1  /  rank 0

   FUNCTION FMDIV_INTERVAL_FM1I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: IVAL,J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1I

   FUNCTION FMDIV_INTERVAL_FM1R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1R

   FUNCTION FMDIV_INTERVAL_FM1D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1D

   FUNCTION FMDIV_INTERVAL_I1FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_I1FM

   FUNCTION FMDIV_INTERVAL_R1FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_R1FM

   FUNCTION FMDIV_INTERVAL_D1FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_D1FM

   FUNCTION FMDIV_INTERVAL_FM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA(J),MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1FM

   FUNCTION FMDIV_INTERVAL_FM1FMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA(J),TO_FM_INTERVAL(MB),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1FMA

   FUNCTION FMDIV_INTERVAL_FMA1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDIV_INTERVAL(TO_FM_INTERVAL(MA(J)),MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMA1FM

   FUNCTION FMDIV_INTERVAL_FM1IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      N = SIZE(MA)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1IM

   FUNCTION FMDIV_INTERVAL_IM1FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,MTFM_I)
         CALL FMDIV_INTERVAL(MTFM_I,MB,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_IM1FM

!             (3) rank 1  /  rank 1

   FUNCTION FMDIV_INTERVAL_FM1I1(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER, DIMENSION(:) :: IVAL
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMDIV_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1I1

   FUNCTION FMDIV_INTERVAL_FM1R1(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      REAL, DIMENSION(:) :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMDIV_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1R1

   FUNCTION FMDIV_INTERVAL_FM1D1(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      DOUBLE PRECISION, DIMENSION(:) :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMDIV_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1D1

   FUNCTION FMDIV_INTERVAL_I1FM1(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      INTEGER, DIMENSION(:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(IVAL)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(IVAL)
      DO J = 1, N
         CALL FMI2M_INTERVAL(IVAL(J),MTFM_I)
         CALL FMDIV_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_I1FM1

   FUNCTION FMDIV_INTERVAL_R1FM1(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      REAL, DIMENSION(:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(R)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(R)
      DO J = 1, N
         CALL FMSP2M_INTERVAL(R(J),MTFM_I)
         CALL FMDIV_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_R1FM1

   FUNCTION FMDIV_INTERVAL_D1FM1(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      DOUBLE PRECISION, DIMENSION(:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA) /= SIZE(D)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(D)
      DO J = 1, N
         CALL FMDP2M_INTERVAL(D(J),MTFM_I)
         CALL FMDIV_INTERVAL(MTFM_I,MA(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_D1FM1

   FUNCTION FMDIV_INTERVAL_FM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA(J),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1FM1

   FUNCTION FMDIV_INTERVAL_FM1FMA1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (FM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDIV_INTERVAL(MA(J),TO_FM_INTERVAL(MB(J)),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1FMA1

   FUNCTION FMDIV_INTERVAL_FMA1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL FMDIV_INTERVAL(TO_FM_INTERVAL(MA(J)),MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMA1FM1

   FUNCTION FMDIV_INTERVAL_FM1IM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:) :: MA
      TYPE (IM), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MB(J)%MIM,MTFM_I)
         CALL FMDIV_INTERVAL(MA(J),MTFM_I,RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM1IM1

   FUNCTION FMDIV_INTERVAL_IM1FM1(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA)) :: RETURN_VALUE
      INTEGER :: J,N
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) /= SIZE(MB)) THEN
          DO J = 1, SIZE(MA)
             CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J))
          ENDDO
          RETURN
      ENDIF
      N = SIZE(MA)
      DO J = 1, N
         CALL IMI2FM_INTERVAL(MA(J)%MIM,MTFM_I)
         CALL FMDIV_INTERVAL(MTFM_I,MB(J),RETURN_VALUE(J))
      ENDDO
   END FUNCTION FMDIV_INTERVAL_IM1FM1

!             (4) rank 0  /  rank 2

   FUNCTION FMDIV_INTERVAL_IFM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_IFM2

   FUNCTION FMDIV_INTERVAL_RFM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_RFM2

   FUNCTION FMDIV_INTERVAL_DFM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_DFM2

   FUNCTION FMDIV_INTERVAL_FMI2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMI2

   FUNCTION FMDIV_INTERVAL_FMR2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMR2

   FUNCTION FMDIV_INTERVAL_FMD2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMD2

   FUNCTION FMDIV_INTERVAL_FMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMDIV_INTERVAL(MA,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMFM2

   FUNCTION FMDIV_INTERVAL_FMFMA2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMDIV_INTERVAL(MA,TO_FM_INTERVAL(MB(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMFMA2

   FUNCTION FMDIV_INTERVAL_FMAFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMDIV_INTERVAL(TO_FM_INTERVAL(MA),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMAFM2

   FUNCTION FMDIV_INTERVAL_IMFM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL FMDIV_INTERVAL(MTFM_I,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_IMFM2

   FUNCTION FMDIV_INTERVAL_FMIM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MB,DIM=1)
         DO K = 1, SIZE(MB,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MTFM_I)
            CALL FMDIV_INTERVAL(MA,MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMIM2

!             (5) rank 2  /  rank 0

   FUNCTION FMDIV_INTERVAL_FM2I(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: IVAL,J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2I

   FUNCTION FMDIV_INTERVAL_FM2R(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2R

   FUNCTION FMDIV_INTERVAL_FM2D(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2D

   FUNCTION FMDIV_INTERVAL_I2FM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(IVAL,DIM=1)
         DO K = 1, SIZE(IVAL,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_I2FM

   FUNCTION FMDIV_INTERVAL_R2FM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(R,DIM=1)
         DO K = 1, SIZE(R,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_R2FM

   FUNCTION FMDIV_INTERVAL_D2FM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 1, SIZE(D,DIM=1)
         DO K = 1, SIZE(D,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MTFM_I,MA,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_D2FM

   FUNCTION FMDIV_INTERVAL_FM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MA(J,K),MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2FM

   FUNCTION FMDIV_INTERVAL_FM2FMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MA(J,K),TO_FM_INTERVAL(MB),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2FMA

   FUNCTION FMDIV_INTERVAL_FMA2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(TO_FM_INTERVAL(MA(J,K)),MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMA2FM

   FUNCTION FMDIV_INTERVAL_FM2IM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2IM

   FUNCTION FMDIV_INTERVAL_IM2FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,MTFM_I)
            CALL FMDIV_INTERVAL(MTFM_I,MB,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_IM2FM

!             (6) rank 2  /  rank 2

   FUNCTION FMDIV_INTERVAL_FM2I2(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER, DIMENSION(:,:) :: IVAL
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2I2

   FUNCTION FMDIV_INTERVAL_FM2R2(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      REAL, DIMENSION(:,:) :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2R2

   FUNCTION FMDIV_INTERVAL_FM2D2(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2D2

   FUNCTION FMDIV_INTERVAL_I2FM2(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      INTEGER, DIMENSION(:,:) :: IVAL
      TYPE (FM_INTERVAL), DIMENSION(SIZE(IVAL,DIM=1),SIZE(IVAL,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(IVAL,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(IVAL,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMI2M_INTERVAL(IVAL(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_I2FM2

   FUNCTION FMDIV_INTERVAL_R2FM2(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      REAL, DIMENSION(:,:) :: R
      TYPE (FM_INTERVAL), DIMENSION(SIZE(R,DIM=1),SIZE(R,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(R,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(R,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMSP2M_INTERVAL(R(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_R2FM2

   FUNCTION FMDIV_INTERVAL_D2FM2(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      DOUBLE PRECISION, DIMENSION(:,:) :: D
      TYPE (FM_INTERVAL), DIMENSION(SIZE(D,DIM=1),SIZE(D,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (SIZE(MA,DIM=1) /= SIZE(D,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(D,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDP2M_INTERVAL(D(J,K),MTFM_I)
            CALL FMDIV_INTERVAL(MTFM_I,MA(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_D2FM2

   FUNCTION FMDIV_INTERVAL_FM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MA(J,K),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2FM2

   FUNCTION FMDIV_INTERVAL_FM2FMA2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (FM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(MA(J,K),TO_FM_INTERVAL(MB(J,K)),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2FMA2

   FUNCTION FMDIV_INTERVAL_FMA2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL FMDIV_INTERVAL(TO_FM_INTERVAL(MA(J,K)),MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FMA2FM2

   FUNCTION FMDIV_INTERVAL_FM2IM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MA
      TYPE (IM), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MB,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MB(J,K)%MIM,MTFM_I)
            CALL FMDIV_INTERVAL(MA(J,K),MTFM_I,RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_FM2IM2

   FUNCTION FMDIV_INTERVAL_IM2FM2(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM), DIMENSION(:,:) :: MA
      TYPE (FM_INTERVAL), DIMENSION(:,:) :: MB
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MA,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=1) /= SIZE(MB,DIM=1) .OR. SIZE(MA,DIM=2) /= SIZE(MB,DIM=2)) THEN
          DO J = 1, SIZE(MA,DIM=1)
             DO K = 1, SIZE(MA,DIM=2)
                CALL FMST2M_INTERVAL(' UNKNOWN ',RETURN_VALUE(J,K))
             ENDDO
          ENDDO
          RETURN
      ENDIF
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            CALL IMI2FM_INTERVAL(MA(J,K)%MIM,MTFM_I)
            CALL FMDIV_INTERVAL(MTFM_I,MB(J,K),RETURN_VALUE(J,K))
         ENDDO
      ENDDO
   END FUNCTION FMDIV_INTERVAL_IM2FM2

 END MODULE FM_INTERVAL_ARITHMETIC_7

 MODULE FM_INTERVAL_ARITHMETIC_8
    USE FM_INTERVAL_ARITHMETIC_1

    INTERFACE OPERATOR (**)
       MODULE PROCEDURE FMPWR_INTERVAL_IFM
       MODULE PROCEDURE FMPWR_INTERVAL_RFM
       MODULE PROCEDURE FMPWR_INTERVAL_DFM
       MODULE PROCEDURE FMPWR_INTERVAL_FMI
       MODULE PROCEDURE FMPWR_INTERVAL_FMR
       MODULE PROCEDURE FMPWR_INTERVAL_FMD
       MODULE PROCEDURE FMPWR_INTERVAL_FMFM
       MODULE PROCEDURE FMPWR_INTERVAL_FMFMA
       MODULE PROCEDURE FMPWR_INTERVAL_FMAFM
       MODULE PROCEDURE FMPWR_INTERVAL_FMIM
       MODULE PROCEDURE FMPWR_INTERVAL_IMFM
    END INTERFACE

   INTERFACE ABS
      MODULE PROCEDURE FMABS_INTERVAL_FM
   END INTERFACE

   INTERFACE ACOS
      MODULE PROCEDURE FMACOS_INTERVAL_FM
   END INTERFACE

   INTERFACE ACOSH
      MODULE PROCEDURE FMACOSH_INTERVAL_FM
   END INTERFACE

   INTERFACE AINT
      MODULE PROCEDURE FMAINT_INTERVAL_FM
   END INTERFACE

   INTERFACE ANINT
      MODULE PROCEDURE FMANINT_INTERVAL_FM
   END INTERFACE

   INTERFACE ASIN
      MODULE PROCEDURE FMASIN_INTERVAL_FM
   END INTERFACE

   INTERFACE ASINH
      MODULE PROCEDURE FMASINH_INTERVAL_FM
   END INTERFACE

   INTERFACE ATAN
      MODULE PROCEDURE FMATAN_INTERVAL_FM
   END INTERFACE

   INTERFACE ATANH
      MODULE PROCEDURE FMATANH_INTERVAL_FM
   END INTERFACE

   INTERFACE ATAN2
      MODULE PROCEDURE FMATAN2_INTERVAL_FM
   END INTERFACE

   INTERFACE CEILING
      MODULE PROCEDURE FMCEILING_INTERVAL_FM
   END INTERFACE

   INTERFACE COS
      MODULE PROCEDURE FMCOS_INTERVAL_FM
   END INTERFACE

   INTERFACE COSH
      MODULE PROCEDURE FMCOSH_INTERVAL_FM
   END INTERFACE

   INTERFACE DBLE
      MODULE PROCEDURE FMDBLE_INTERVAL_FM
   END INTERFACE

   INTERFACE DIGITS
      MODULE PROCEDURE FMDIGITS_INTERVAL_FM
   END INTERFACE

   INTERFACE DIM
      MODULE PROCEDURE FMDIM_INTERVAL_FM
   END INTERFACE

   INTERFACE DINT
      MODULE PROCEDURE FMDINT_INTERVAL_FM
   END INTERFACE

   INTERFACE DOT_PRODUCT
      MODULE PROCEDURE FMDOTPRODUCT_INTERVAL_FM
   END INTERFACE

   INTERFACE EPSILON
      MODULE PROCEDURE FMEPSILON_INTERVAL_FM
   END INTERFACE

   INTERFACE EXP
      MODULE PROCEDURE FMEXP_INTERVAL_FM
   END INTERFACE

   INTERFACE EXPONENT
      MODULE PROCEDURE FMEXPONENT_INTERVAL_FM
   END INTERFACE

   INTERFACE FLOOR
      MODULE PROCEDURE FMFLOOR_INTERVAL_FM
   END INTERFACE

   INTERFACE FRACTION
      MODULE PROCEDURE FMFRACTION_INTERVAL_FM
   END INTERFACE

   INTERFACE HUGE
      MODULE PROCEDURE FMHUGE_INTERVAL_FM
   END INTERFACE

   INTERFACE INT
      MODULE PROCEDURE FMINT_INTERVAL_FM
   END INTERFACE

   INTERFACE LOG
      MODULE PROCEDURE FMLOG_INTERVAL_FM
   END INTERFACE

   INTERFACE LOG10
      MODULE PROCEDURE FMLOG10_INTERVAL_FM
   END INTERFACE

   INTERFACE MATMUL
      MODULE PROCEDURE FMMATMUL22_INTERVAL_FM
      MODULE PROCEDURE FMMATMUL12_INTERVAL_FM
      MODULE PROCEDURE FMMATMUL21_INTERVAL_FM
   END INTERFACE

   INTERFACE MAX
      MODULE PROCEDURE FMMAX_INTERVAL_FM
   END INTERFACE

   INTERFACE MAXEXPONENT
      MODULE PROCEDURE FMMAXEXPONENT_INTERVAL_FM
   END INTERFACE

   INTERFACE MAXVAL
      MODULE PROCEDURE FMMAXVAL1_INTERVAL_FM
      MODULE PROCEDURE FMMAXVAL2_INTERVAL_FM
   END INTERFACE

   INTERFACE MIN
      MODULE PROCEDURE FMMIN_INTERVAL_FM
   END INTERFACE

   INTERFACE MINEXPONENT
      MODULE PROCEDURE FMMINEXPONENT_INTERVAL_FM
   END INTERFACE

   INTERFACE MINVAL
      MODULE PROCEDURE FMMINVAL1_INTERVAL_FM
      MODULE PROCEDURE FMMINVAL2_INTERVAL_FM
   END INTERFACE

   INTERFACE MOD
      MODULE PROCEDURE FMMOD_INTERVAL_FM
   END INTERFACE

   INTERFACE MODULO
      MODULE PROCEDURE FMMODULO_INTERVAL_FM
   END INTERFACE

   INTERFACE NEAREST
      MODULE PROCEDURE FMNEAREST_INTERVAL_FM
   END INTERFACE

   INTERFACE NINT
      MODULE PROCEDURE FMNINT_INTERVAL_FM
   END INTERFACE

   INTERFACE PRECISION
      MODULE PROCEDURE FMPRECISION_INTERVAL_FM
   END INTERFACE

   INTERFACE PRODUCT
      MODULE PROCEDURE FMPRODUCT1_INTERVAL_FM
      MODULE PROCEDURE FMPRODUCT2_INTERVAL_FM
   END INTERFACE

   INTERFACE RADIX
      MODULE PROCEDURE FMRADIX_INTERVAL_FM
   END INTERFACE

   INTERFACE RANGE
      MODULE PROCEDURE FMRANGE_INTERVAL_FM
   END INTERFACE

   INTERFACE REAL
      MODULE PROCEDURE FMREAL_INTERVAL_FM
   END INTERFACE

   INTERFACE RRSPACING
      MODULE PROCEDURE FMRRSPACING_INTERVAL_FM
   END INTERFACE

   INTERFACE SCALE
      MODULE PROCEDURE FMSCALE_INTERVAL_FM
   END INTERFACE

   INTERFACE SETEXPONENT
      MODULE PROCEDURE FMSETEXPONENT_INTERVAL_FM
   END INTERFACE

   INTERFACE SIGN
      MODULE PROCEDURE FMSIGN_INTERVAL_FM
   END INTERFACE

 CONTAINS

!                                                                  **

   SUBROUTINE FMPWR_INTERVAL(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KL,KRSAVE,KWRNSV,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM,MVLVFM
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO .OR.  &
          MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
          GO TO 110
      ENDIF
      IF (FMCOMP(MB%LEFT,'==',MB%RIGHT)) THEN
          CALL FMM2I(MB%LEFT,KL)
          IF (KFLAG == 0) THEN
              CALL FMIPWR_INTERVAL(MA,KL,MC)
              GO TO 110
          ENDIF
      ENDIF
      IF (MA%RIGHT%MP(1) < 0) THEN
          CALL FMST2M('UNKNOWN',MC%LEFT)
          CALL FMST2M('UNKNOWN',MC%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(1) < 0) THEN
          CALL FMI2M(0,MVLVFM)
      ELSE
          CALL FMEQ(MA%LEFT,MVLVFM)
      ENDIF
      IF (MVLVFM%MP(3) == 0 .AND. MA%RIGHT%MP(3) == 0) THEN
          IF (MB%RIGHT%MP(1) < 0) THEN
              CALL FMST2M('-OVERFLOW',MC%LEFT)
              CALL FMST2M('+OVERFLOW',MC%RIGHT)
          ELSE IF (MB%LEFT%MP(1) > 0) THEN
              CALL FMI2M(0,MC%LEFT)
              CALL FMI2M(0,MC%RIGHT)
          ELSE
              CALL FMI2M(0,MC%LEFT)
              CALL FMST2M('+OVERFLOW',MC%RIGHT)
          ENDIF
          GO TO 110
      ENDIF
      IF (ABS(MA%LEFT%MP(2)) == MEXPOV .OR. ABS(MA%RIGHT%MP(2)) == MEXPOV .OR.  &
          ABS(MB%LEFT%MP(2)) == MEXPOV .OR. ABS(MB%RIGHT%MP(2)) == MEXPOV) THEN
          NDSAVE = NDIG
          NDIG = MAX(NDIG+NGRD52,2)
          KROUND = 1
          CALL FMEQU_INTERVAL(MA,M8FM_I,NDSAVE,NDIG)
          CALL FMEQU_INTERVAL(MB,M9FM_I,NDSAVE,NDIG)
          CALL FMMPY_INTERVAL(M9FM_I,LOG(M8FM_I),M7FM_I)
          CALL FMEQ_INTERVAL(EXP(M7FM_I),M8FM_I)
          KROUND = -1
          CALL FMEQU(M8FM_I%LEFT,MC%LEFT,NDIG,NDSAVE)
          KROUND = 2
          CALL FMEQU(M8FM_I%RIGHT,MC%RIGHT,NDIG,NDSAVE)
          NDIG = NDSAVE
          GO TO 110
      ENDIF
      CALL FMI2M(1,MTLVFM)
      CALL FMI2M(0,MULVFM)
      IF (FMCOMP(MA%LEFT,'>=',MTLVFM) .AND. FMCOMP(MB%LEFT,'>=',MULVFM)) THEN
          KROUND = -1
          CALL FMPWR(MA%LEFT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MA%RIGHT,MB%RIGHT,MC%RIGHT)
      ELSE IF (FMCOMP(MA%LEFT,'>=',MTLVFM) .AND. FMCOMP(MB%RIGHT,'<',MULVFM)) THEN
          KROUND = -1
          CALL FMPWR(MA%RIGHT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MA%LEFT,MB%RIGHT,MC%RIGHT)
      ELSE IF (FMCOMP(MA%LEFT,'>=',MTLVFM)) THEN
          KROUND = -1
          CALL FMPWR(MA%RIGHT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MA%RIGHT,MB%RIGHT,MC%RIGHT)
      ELSE IF (FMCOMP(MA%RIGHT,'<',MTLVFM) .AND. FMCOMP(MB%LEFT,'>=',MULVFM)) THEN
          KROUND = -1
          CALL FMPWR(MVLVFM,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MA%RIGHT,MB%LEFT,MC%RIGHT)
      ELSE IF (FMCOMP(MA%RIGHT,'<',MTLVFM) .AND. FMCOMP(MB%RIGHT,'<',MULVFM)) THEN
          KROUND = -1
          CALL FMPWR(MA%RIGHT,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MVLVFM,MB%LEFT,MC%RIGHT)
          IF (MVLVFM%MP(3) == 0) CALL FMST2M('+OVERFLOW',MC%RIGHT)
      ELSE IF (FMCOMP(MA%RIGHT,'<',MTLVFM)) THEN
          KROUND = -1
          CALL FMPWR(MVLVFM,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MVLVFM,MB%LEFT,MC%RIGHT)
          IF (MVLVFM%MP(3) == 0) CALL FMST2M('+OVERFLOW',MC%RIGHT)
      ELSE IF (FMCOMP(MB%LEFT,'>=',MULVFM)) THEN
          KROUND = -1
          CALL FMPWR(MVLVFM,MB%RIGHT,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MA%RIGHT,MB%RIGHT,MC%RIGHT)
      ELSE IF (FMCOMP(MB%RIGHT,'<',MULVFM)) THEN
          KROUND = -1
          CALL FMPWR(MA%RIGHT,MB%LEFT,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MVLVFM,MB%LEFT,MC%RIGHT)
          IF (MVLVFM%MP(3) == 0) CALL FMST2M('+OVERFLOW',MC%RIGHT)
      ELSE
          KROUND = -1
          CALL FMPWR(MVLVFM,MB%RIGHT,MTLVFM)
          CALL FMPWR(MA%RIGHT,MB%LEFT,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MC%LEFT)
          KROUND = 2
          CALL FMPWR(MA%RIGHT,MB%RIGHT,MTLVFM)
          CALL FMPWR(MVLVFM,MB%LEFT,MULVFM)
          IF (MVLVFM%MP(3) == 0) CALL FMST2M('+OVERFLOW',MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MC%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END SUBROUTINE FMPWR_INTERVAL

   FUNCTION FMPWR_INTERVAL_IFM(IVAL,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: IVAL,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(IVAL,MTFM_I)
      CALL FMPWR_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_IFM

   FUNCTION FMPWR_INTERVAL_RFM(R,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: R,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMPWR_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_RFM

   FUNCTION FMPWR_INTERVAL_DFM(D,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: D,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMPWR_INTERVAL(MTFM_I,MA,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_DFM

   SUBROUTINE FMIPWR_INTERVAL(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE,KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (IVAL > 0) THEN
          IF (MOD(IVAL,2) == 1) THEN
              KROUND = -1
              CALL FMIPWR(MA%LEFT,IVAL,MB%LEFT)
              KROUND = 2
              CALL FMIPWR(MA%RIGHT,IVAL,MB%RIGHT)
          ELSE
              CALL FMABS(MA%LEFT,M_1%MFM)
              CALL FMABS(MA%RIGHT,M_2%MFM)
              CALL FMI2M(0,M_3%MFM)
              IF (FMCOMP(M_1%MFM,'<=',M_2%MFM)) THEN
                  KROUND = -1
                  IF (FMCOMP(MA%LEFT,'<=',M_3%MFM) .AND. FMCOMP(MA%RIGHT,'>=',M_3%MFM)) THEN
                      CALL FMI2M(0,MB%LEFT)
                  ELSE
                      CALL FMIPWR(MA%LEFT,IVAL,MB%LEFT)
                  ENDIF
                  KROUND = 2
                  CALL FMIPWR(MA%RIGHT,IVAL,MB%RIGHT)
              ELSE
                  KROUND = -1
                  IF (FMCOMP(MA%LEFT,'<=',M_3%MFM) .AND. FMCOMP(MA%RIGHT,'>=',M_3%MFM)) THEN
                      CALL FMI2M(0,MB%LEFT)
                  ELSE
                      CALL FMIPWR(MA%RIGHT,IVAL,MB%LEFT)
                  ENDIF
                  KROUND = 2
                  CALL FMIPWR(MA%LEFT,IVAL,MB%RIGHT)
              ENDIF
          ENDIF
      ELSE IF (IVAL < 0) THEN
          IF (MOD(IVAL,2) /= 0) THEN
              CALL FMI2M(0,M_3%MFM)
              IF (FMCOMP(MA%LEFT,'<=',M_3%MFM) .AND. FMCOMP(MA%RIGHT,'>=',M_3%MFM)) THEN
                  CALL FMST2M('-OVERFLOW',MB%LEFT)
                  CALL FMST2M('+OVERFLOW',MB%RIGHT)
              ELSE
                  KROUND = -1
                  CALL FMIPWR(MA%RIGHT,IVAL,MB%LEFT)
                  KROUND = 2
                  CALL FMIPWR(MA%LEFT,IVAL,MB%RIGHT)
              ENDIF
          ELSE
              CALL FMI2M(0,M_3%MFM)
              IF (FMCOMP(MA%LEFT,'<=',M_3%MFM) .AND. FMCOMP(MA%RIGHT,'>=',M_3%MFM)) THEN
                  CALL FMST2M('0',MB%LEFT)
                  CALL FMST2M('+OVERFLOW',MB%RIGHT)
              ELSE
                  IF (FMCOMP(MA%LEFT,'<',M_3%MFM)) THEN
                      KROUND = -1
                      CALL FMIPWR(MA%LEFT,IVAL,MB%LEFT)
                      KROUND = 2
                      CALL FMIPWR(MA%RIGHT,IVAL,MB%RIGHT)
                  ELSE
                      KROUND = -1
                      CALL FMIPWR(MA%RIGHT,IVAL,MB%LEFT)
                      KROUND = 2
                      CALL FMIPWR(MA%LEFT,IVAL,MB%RIGHT)
                  ENDIF
              ENDIF
          ENDIF
      ELSE
          CALL FMI2M(0,M_3%MFM)
          IF (FMCOMP(MA%LEFT,'<=',M_3%MFM) .AND. FMCOMP(MA%RIGHT,'>=',M_3%MFM)) THEN
              CALL FMST2M('-OVERFLOW',MB%LEFT)
              CALL FMST2M('+OVERFLOW',MB%RIGHT)
          ELSE
              CALL FMI2M(1,MB%LEFT)
              CALL FMI2M(1,MB%RIGHT)
          ENDIF
      ENDIF
      KWARN = KWRNSV
      KROUND = KRSAVE
   END SUBROUTINE FMIPWR_INTERVAL

   FUNCTION FMPWR_INTERVAL_FMI(MA,IVAL)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMIPWR_INTERVAL(MA,IVAL,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_FMI

   FUNCTION FMPWR_INTERVAL_FMR(MA,R)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      REAL :: R
      INTENT (IN) :: MA,R
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSP2M_INTERVAL(R,MTFM_I)
      CALL FMPWR_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_FMR

   FUNCTION FMPWR_INTERVAL_FMD(MA,D)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      DOUBLE PRECISION :: D
      INTENT (IN) :: MA,D
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDP2M_INTERVAL(D,MTFM_I)
      CALL FMPWR_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_FMD

   FUNCTION FMPWR_INTERVAL_FMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMPWR_INTERVAL(MA,MB,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_FMFM

   FUNCTION FMPWR_INTERVAL_FMFMA(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (FM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL FMPWR_INTERVAL(MA,TO_FM_INTERVAL(MB),RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_FMFMA

   FUNCTION FMPWR_INTERVAL_FMAFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      TYPE (FM) :: MA
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMPWR_INTERVAL(TO_FM_INTERVAL(MA),MB,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_FMAFM

   FUNCTION FMPWR_INTERVAL_FMIM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      TYPE (IM) :: MB
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MB%MIM,MTFM_I)
      CALL FMPWR_INTERVAL(MA,MTFM_I,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_FMIM

   FUNCTION FMPWR_INTERVAL_IMFM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      TYPE (FM_INTERVAL) :: MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL IMI2FM_INTERVAL(MA%MIM,MTFM_I)
      CALL FMPWR_INTERVAL(MTFM_I,MB,RETURN_VALUE)
   END FUNCTION FMPWR_INTERVAL_IMFM

!                                                                 ABS

   FUNCTION FMABS_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMABS_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMABS_INTERVAL_FM

!                                                                ACOS

   FUNCTION FMACOS_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      CALL FMI2M(-1,MTLVFM)
      CALL FMI2M(1,MULVFM)
      IF (FMCOMP(MA%RIGHT,'<',MTLVFM) .OR. FMCOMP(MA%LEFT,'>',MULVFM)) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
      ELSE
          IF (FMCOMP(MA%LEFT,'<',MTLVFM)) THEN
              CALL FMI2M(-1,M_1%MFM)
          ELSE
              CALL FMEQ(MA%LEFT,M_1%MFM)
          ENDIF
          IF (FMCOMP(MA%RIGHT,'>',MULVFM)) THEN
              CALL FMI2M(1,M_2%MFM)
          ELSE
              CALL FMEQ(MA%RIGHT,M_2%MFM)
          ENDIF
          KROUND = -1
          CALL FMACOS(M_2%MFM,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMACOS(M_1%MFM,RETURN_VALUE%RIGHT)
      ENDIF
      KROUND = KRSAVE
   END FUNCTION FMACOS_INTERVAL_FM

!                                                                 ACOSH

   FUNCTION FMACOSH_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (LEFT_ENDPOINT(MA) < 1) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KROUND = -1
      CALL FMACOSH(MA%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMACOSH(MA%RIGHT,RETURN_VALUE%RIGHT)
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMACOSH_INTERVAL_FM

!                                                                AINT

   FUNCTION FMAINT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMINT_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMAINT_INTERVAL_FM

!                                                               ANINT

   FUNCTION FMANINT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMNINT_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMANINT_INTERVAL_FM

!                                                                ASIN

   FUNCTION FMASIN_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KROUND = -1
      KWRNSV = KWARN
      KWARN = 0
      CALL FMI2M(-1,MTLVFM)
      CALL FMI2M(1,MULVFM)
      IF (FMCOMP(MA%RIGHT,'<',MTLVFM) .OR. FMCOMP(MA%LEFT,'>',MULVFM)) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
      ELSE
          IF (FMCOMP(MA%LEFT,'<',MTLVFM)) THEN
              CALL FMI2M(-1,M_1%MFM)
          ELSE
              CALL FMEQ(MA%LEFT,M_1%MFM)
          ENDIF
          IF (FMCOMP(MA%RIGHT,'>',MULVFM)) THEN
              CALL FMI2M(1,M_2%MFM)
          ELSE
              CALL FMEQ(MA%RIGHT,M_2%MFM)
          ENDIF
          KROUND = -1
          CALL FMASIN(M_1%MFM,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMASIN(M_2%MFM,RETURN_VALUE%RIGHT)
          IF (KRAD /= 1) THEN
              IF (MA%LEFT%MP(2) == MEXPUN) THEN
                  IF (MA%LEFT%MP(1) < 0) THEN
                      CALL FMTINY(M_1%MFM)
                      CALL FMMPYI_R1(M_1%MFM,-1)
                      KROUND = -1
                      CALL FMASIN(M_1%MFM,RETURN_VALUE%LEFT)
                  ELSE
                      CALL FMST2M('+UNDERFLOW',RETURN_VALUE%LEFT)
                  ENDIF
              ENDIF
              IF (MA%RIGHT%MP(2) == MEXPUN) THEN
                  IF (MA%RIGHT%MP(1) < 0) THEN
                      CALL FMST2M('-UNDERFLOW',RETURN_VALUE%RIGHT)
                  ELSE
                      CALL FMTINY(M_1%MFM)
                      KROUND = 2
                      CALL FMASIN(M_1%MFM,RETURN_VALUE%RIGHT)
                  ENDIF
              ENDIF
          ENDIF
      ENDIF
      KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMASIN_INTERVAL_FM

!                                                                 ASINH

   FUNCTION FMASINH_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KROUND = -1
      CALL FMASINH(MA%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMASINH(MA%RIGHT,RETURN_VALUE%RIGHT)
      KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMASINH_INTERVAL_FM

!                                                                ATAN

   FUNCTION FMATAN_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KROUND = -1
      KWRNSV = KWARN
      KWARN = 0
      CALL FMATAN(MA%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMATAN(MA%RIGHT,RETURN_VALUE%RIGHT)
      IF (KRAD /= 1) THEN
          IF (MA%LEFT%MP(2) == MEXPUN) THEN
              IF (MA%LEFT%MP(1) < 0) THEN
                  CALL FMTINY(M_1%MFM)
                  CALL FMMPYI_R1(M_1%MFM,-1)
                  KROUND = -1
                  CALL FMATAN(M_1%MFM,RETURN_VALUE%LEFT)
              ELSE
                  CALL FMST2M('+UNDERFLOW',RETURN_VALUE%LEFT)
              ENDIF
          ENDIF
          IF (MA%RIGHT%MP(2) == MEXPUN) THEN
              IF (MA%RIGHT%MP(1) < 0) THEN
                  CALL FMST2M('-UNDERFLOW',RETURN_VALUE%RIGHT)
              ELSE
                  CALL FMTINY(M_1%MFM)
                  KROUND = 2
                  CALL FMATAN(M_1%MFM,RETURN_VALUE%RIGHT)
              ENDIF
          ENDIF
      ENDIF
      KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMATAN_INTERVAL_FM

!                                                               ATAN2

   FUNCTION FMATAN2_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      INTEGER :: KRSAVE,KWRNSV,NDSAVE
      TYPE(MULTI), SAVE :: MULVFM,MVLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO .OR.  &
          MB%LEFT%MP(2) == MUNKNO .OR. MB%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(3) == 0 .AND. MA%RIGHT%MP(3) == 0) THEN
          IF (MB%LEFT%MP(3) == 0 .AND. MB%RIGHT%MP(3) == 0) THEN
              CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
              CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          ELSE IF (MB%LEFT%MP(1) > 0) THEN
              CALL FMI2M(0,RETURN_VALUE%LEFT)
              CALL FMI2M(0,RETURN_VALUE%RIGHT)
          ELSE IF (MB%RIGHT%MP(1) < 0) THEN
              CALL FMI2M(-1,MULVFM)
              KROUND = -1
              CALL FMACOS(MULVFM,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
          ELSE
              CALL FMI2M(-1,MULVFM)
              CALL FMI2M(0,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
          ENDIF
          GO TO 110
      ENDIF
      IF (MB%LEFT%MP(3) == 0 .AND. MB%RIGHT%MP(3) == 0) THEN
          IF (MA%LEFT%MP(1) > 0) THEN
              CALL FMI2M(0,MULVFM)
              KROUND = -1
              CALL FMACOS(MULVFM,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
          ELSE IF (MA%RIGHT%MP(1) < 0) THEN
              CALL FMI2M(0,MULVFM)
              KROUND = 2
              CALL FMACOS(MULVFM,RETURN_VALUE%LEFT)
              CALL FMMPYI_R1(RETURN_VALUE%LEFT,-1)
              KROUND = -1
              CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
              CALL FMMPYI_R1(RETURN_VALUE%RIGHT,-1)
          ELSE
              CALL FMI2M(0,MULVFM)
              KROUND = 2
              CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
              CALL FMMPYI(RETURN_VALUE%RIGHT,-1,RETURN_VALUE%LEFT)
          ENDIF
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(3) == 0 .AND. MB%LEFT%MP(3) == 0) THEN
          CALL FMI2M(0,RETURN_VALUE%LEFT)
          CALL FMI2M(0,MULVFM)
          KROUND = 2
          CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(3) == 0 .AND. MB%RIGHT%MP(3) == 0) THEN
          CALL FMI2M(0,MULVFM)
          KROUND = -1
          CALL FMACOS(MULVFM,RETURN_VALUE%LEFT)
          CALL FMI2M(-1,MULVFM)
          KROUND = 2
          CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%RIGHT%MP(3) == 0 .AND. MB%LEFT%MP(3) == 0) THEN
          CALL FMI2M(0,MULVFM)
          KROUND = 2
          CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
          CALL FMMPYI(RETURN_VALUE%RIGHT,-1,RETURN_VALUE%LEFT)
          CALL FMI2M(0,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%RIGHT%MP(3) == 0 .AND. MB%RIGHT%MP(3) == 0) THEN
          CALL FMI2M(-1,MULVFM)
          KROUND = 2
          CALL FMACOS(MULVFM,RETURN_VALUE%LEFT)
          CALL FMMPYI(RETURN_VALUE%LEFT,-1,RETURN_VALUE%LEFT)
          KROUND = -1
          CALL FMI2M(0,MULVFM)
          CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
          CALL FMMPYI(RETURN_VALUE%RIGHT,-1,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (ABS(MA%LEFT%MP(2)) == MEXPOV .OR. ABS(MA%RIGHT%MP(2)) == MEXPOV .OR.  &
          ABS(MB%LEFT%MP(2)) == MEXPOV .OR. ABS(MB%RIGHT%MP(2)) == MEXPOV) THEN
          NDSAVE = NDIG
          NDIG = MAX(NDIG+NGRD52,2)
          IF (MB%LEFT%MP(1) > 0) THEN
              KROUND = 1
              CALL FMEQU_INTERVAL(MA,M8FM_I,NDSAVE,NDIG)
              CALL FMEQU_INTERVAL(MB,M9FM_I,NDSAVE,NDIG)
              CALL FMDIV_INTERVAL(M8FM_I,M9FM_I,M7FM_I)
              CALL FMEQ_INTERVAL(ATAN(M7FM_I),M8FM_I)
              KROUND = -1
              CALL FMEQU(M8FM_I%LEFT,RETURN_VALUE%LEFT,NDIG,NDSAVE)
              KROUND = 2
              CALL FMEQU(M8FM_I%RIGHT,RETURN_VALUE%RIGHT,NDIG,NDSAVE)
          ELSE IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) > 0) THEN
              NDIG = NDSAVE
              KROUND = 2
              CALL FMI2M(-1,MULVFM)
              CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
              CALL FMMPYI(RETURN_VALUE%RIGHT,-1,RETURN_VALUE%LEFT)
          ELSE IF (MB%RIGHT%MP(1) < 0 .AND. MA%RIGHT%MP(1) < 0) THEN
              KROUND = 1
              CALL FMEQU_INTERVAL(MA,M8FM_I,NDSAVE,NDIG)
              CALL FMEQU_INTERVAL(MB,M9FM_I,NDSAVE,NDIG)
              CALL FMDIV_INTERVAL(M8FM_I,M9FM_I,M7FM_I)
              CALL FMEQ_INTERVAL(ATAN(M7FM_I),M8FM_I)
              CALL FMI2M(-1,MULVFM)
              CALL FMACOS(MULVFM,MVLVFM)
              KROUND = -1
              CALL FMSUB(M8FM_I%LEFT,MVLVFM,M9FM_I%LEFT)
              CALL FMEQU(M9FM_I%LEFT,RETURN_VALUE%LEFT,NDIG,NDSAVE)
              KROUND = 2
              CALL FMSUB(M8FM_I%RIGHT,MVLVFM,M9FM_I%RIGHT)
              CALL FMEQU(M9FM_I%RIGHT,RETURN_VALUE%RIGHT,NDIG,NDSAVE)
          ELSE IF (MB%LEFT%MP(1) < 0 .AND. MB%RIGHT%MP(1) > 0 .AND.  &
                   MA%RIGHT%MP(1) < 0) THEN
              KROUND = 1
              CALL FMEQU_INTERVAL(MA,M8FM_I,NDSAVE,NDIG)
              CALL FMEQU_INTERVAL(MB,M9FM_I,NDSAVE,NDIG)
              CALL FMDIV_INTERVAL(M9FM_I,M8FM_I,M7FM_I)
              CALL FMMPYI_INTERVAL(M7FM_I,-1,M9FM_I)
              CALL FMEQ_INTERVAL(ATAN(M9FM_I),M8FM_I)
              CALL FMI2M(0,MULVFM)
              CALL FMACOS(MULVFM,MVLVFM)
              KROUND = -1
              CALL FMSUB(M8FM_I%LEFT,MVLVFM,M9FM_I%LEFT)
              CALL FMEQU(M9FM_I%LEFT,RETURN_VALUE%LEFT,NDIG,NDSAVE)
              KROUND = 2
              CALL FMSUB(M8FM_I%RIGHT,MVLVFM,M9FM_I%RIGHT)
              CALL FMEQU(M9FM_I%RIGHT,RETURN_VALUE%RIGHT,NDIG,NDSAVE)
          ELSE IF (MB%RIGHT%MP(1) < 0 .AND. MA%LEFT%MP(1) > 0) THEN
              KROUND = 1
              CALL FMEQU_INTERVAL(MA,M8FM_I,NDSAVE,NDIG)
              CALL FMEQU_INTERVAL(MB,M9FM_I,NDSAVE,NDIG)
              CALL FMDIV_INTERVAL(M8FM_I,M9FM_I,M7FM_I)
              CALL FMEQ_INTERVAL(ATAN(M7FM_I),M8FM_I)
              CALL FMI2M(-1,MULVFM)
              CALL FMACOS(MULVFM,MVLVFM)
              KROUND = -1
              CALL FMADD(M8FM_I%LEFT,MVLVFM,M9FM_I%LEFT)
              CALL FMEQU(M9FM_I%LEFT,RETURN_VALUE%LEFT,NDIG,NDSAVE)
              KROUND = 2
              CALL FMADD(M8FM_I%RIGHT,MVLVFM,M9FM_I%RIGHT)
              CALL FMEQU(M9FM_I%RIGHT,RETURN_VALUE%RIGHT,NDIG,NDSAVE)
          ELSE IF (MB%LEFT%MP(1) < 0 .AND. MB%RIGHT%MP(1) > 0 .AND.  &
                   MA%LEFT%MP(1) > 0) THEN
              KROUND = 1
              CALL FMEQU_INTERVAL(MA,M8FM_I,NDSAVE,NDIG)
              CALL FMEQU_INTERVAL(MB,M9FM_I,NDSAVE,NDIG)
              CALL FMDIV_INTERVAL(M9FM_I,M8FM_I,M7FM_I)
              CALL FMMPYI_INTERVAL(M7FM_I,-1,M9FM_I)
              CALL FMEQ_INTERVAL(ATAN(M9FM_I),M8FM_I)
              CALL FMI2M(0,MULVFM)
              CALL FMACOS(MULVFM,MVLVFM)
              KROUND = -1
              CALL FMADD(M8FM_I%LEFT,MVLVFM,M9FM_I%LEFT)
              CALL FMEQU(M9FM_I%LEFT,RETURN_VALUE%LEFT,NDIG,NDSAVE)
              KROUND = 2
              CALL FMADD(M8FM_I%RIGHT,MVLVFM,M9FM_I%RIGHT)
              CALL FMEQU(M9FM_I%RIGHT,RETURN_VALUE%RIGHT,NDIG,NDSAVE)
          ENDIF
          NDIG = NDSAVE
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(1) >= 0 .AND. MB%LEFT%MP(1) >= 0) THEN
          KROUND = -1
          CALL FMATN2(MA%LEFT,MB%RIGHT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMATN2(MA%RIGHT,MB%LEFT,RETURN_VALUE%RIGHT)
      ELSE IF (MA%LEFT%MP(1) >= 0 .AND. MB%RIGHT%MP(1) <= 0) THEN
          KROUND = -1
          CALL FMATN2(MA%RIGHT,MB%RIGHT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMATN2(MA%LEFT,MB%LEFT,RETURN_VALUE%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) <= 0 .AND. MB%RIGHT%MP(1) <= 0) THEN
          KROUND = -1
          CALL FMATN2(MA%RIGHT,MB%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMATN2(MA%LEFT,MB%RIGHT,RETURN_VALUE%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) <= 0 .AND. MB%LEFT%MP(1) >= 0) THEN
          KROUND = -1
          CALL FMATN2(MA%LEFT,MB%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMATN2(MA%RIGHT,MB%RIGHT,RETURN_VALUE%RIGHT)
      ELSE IF (MA%LEFT%MP(1) >= 0 .AND. MB%LEFT%MP(1) <= 0 .AND.  &
               MB%RIGHT%MP(1) >= 0) THEN
          KROUND = -1
          CALL FMATN2(MA%LEFT,MB%RIGHT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMATN2(MA%LEFT,MB%LEFT,RETURN_VALUE%RIGHT)
      ELSE IF (MB%LEFT%MP(1) >= 0 .AND. MA%LEFT%MP(1) <= 0 .AND.  &
               MA%RIGHT%MP(1) >= 0) THEN
          KROUND = -1
          CALL FMATN2(MA%LEFT,MB%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMATN2(MA%RIGHT,MB%LEFT,RETURN_VALUE%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) <= 0 .AND. MB%LEFT%MP(1) <= 0 .AND.  &
               MB%RIGHT%MP(1) >= 0) THEN
          KROUND = -1
          CALL FMATN2(MA%RIGHT,MB%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMATN2(MA%RIGHT,MB%RIGHT,RETURN_VALUE%RIGHT)
      ELSE
          KROUND = 2
          CALL FMI2M(-1,MULVFM)
          CALL FMACOS(MULVFM,RETURN_VALUE%RIGHT)
          CALL FMMPYI(RETURN_VALUE%RIGHT,-1,RETURN_VALUE%LEFT)
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMATAN2_INTERVAL_FM

!                                                                 ATANH

   FUNCTION FMATANH_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (LEFT_ENDPOINT(MA) <= -1 .OR. RIGHT_ENDPOINT(MA) >= 1) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KROUND = -1
      CALL FMATANH(MA%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMATANH(MA%RIGHT,RETURN_VALUE%RIGHT)
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMATANH_INTERVAL_FM

!                                                             CEILING

   FUNCTION FMCEILING_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      CALL FMINT_INTERVAL(MA,M7FM_I)
      CALL FMEQ_INTERVAL(M7FM_I,MTFM_I)
      IF (FMCOMP(MA%LEFT,'/=',MTFM_I%LEFT)) THEN
          IF (MA%LEFT%MP(1) >= 0) THEN
              CALL FMADDI(MTFM_I%LEFT,1)
          ENDIF
      ENDIF
      IF (FMCOMP(MA%RIGHT,'/=',MTFM_I%RIGHT)) THEN
          IF (MA%RIGHT%MP(1) >= 0) THEN
              CALL FMADDI(MTFM_I%RIGHT,1)
          ENDIF
      ENDIF
      CALL FMEQ_INTERVAL(MTFM_I,RETURN_VALUE)
      KWARN = KWRNSV
   END FUNCTION FMCEILING_INTERVAL_FM

!                                                                 COS

   FUNCTION FMCOS_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(2) == MEXPOV .OR. MA%RIGHT%MP(2) == MEXPOV) THEN
          CALL FMI2M(-1,RETURN_VALUE%LEFT)
          CALL FMI2M(1,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (RIGHT_ENDPOINT(MA) == LEFT_ENDPOINT(MA)) THEN
          KROUND = -1
          CALL FMCOS(MA%LEFT,RETURN_VALUE%LEFT)
          IF ( IS_UNKNOWN(LEFT_ENDPOINT(RETURN_VALUE)) ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
          ENDIF
          KROUND = 2
          CALL FMCOS(MA%RIGHT,RETURN_VALUE%RIGHT)
          IF ( IS_UNKNOWN(RIGHT_ENDPOINT(RETURN_VALUE)) ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
          ENDIF
          GO TO 110
      ENDIF
      CALL FM_EQ( ASIN( TO_FM(1) ) , M_1 )
      IF (RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 4.01*M_1) THEN
          CALL FMI2M(-1,RETURN_VALUE%LEFT)
          CALL FMI2M(1,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FM_EQ( FLOOR( LEFT_ENDPOINT(MA) / M_1 ) , M_2 )
      CALL FM_EQ( FLOOR( RIGHT_ENDPOINT(MA) / M_1 ) , M_3 )
      IF ( M_3 - M_2 >= 4 ) THEN
          CALL FMI2M(-1,RETURN_VALUE%LEFT)
          CALL FMI2M(1,RETURN_VALUE%RIGHT)
      ELSE IF ( MODULO( M_2 , TO_FM(4) ) == 0 ) THEN
          IF ( M_3 - M_2 <= 1 ) THEN
              KROUND = -1
              CALL FMCOS(MA%RIGHT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMCOS(MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 2 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMCOS(MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 3 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              KROUND = 2
              IF ( RIGHT_ENDPOINT(MA) - M_1*(M_3-1) > M_1*(M_3-1) - LEFT_ENDPOINT(MA) ) THEN
                  CALL FMCOS(MA%RIGHT,RETURN_VALUE%RIGHT)
              ELSE
                  CALL FMCOS(MA%LEFT,RETURN_VALUE%RIGHT)
              ENDIF
          ENDIF
      ELSE IF ( MODULO( M_2 , TO_FM(4) ) == 1 ) THEN
          IF ( M_3 - M_2 == 0 ) THEN
              KROUND = -1
              CALL FMCOS(MA%RIGHT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMCOS(MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 1 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              KROUND = 2
              IF ( RIGHT_ENDPOINT(MA) - M_1*M_3 > M_1*M_3 - LEFT_ENDPOINT(MA) ) THEN
                  CALL FMCOS(MA%RIGHT,RETURN_VALUE%RIGHT)
              ELSE
                  CALL FMCOS(MA%LEFT,RETURN_VALUE%RIGHT)
              ENDIF
          ELSE IF ( M_3 - M_2 == 2 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMCOS(MA%RIGHT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 3 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE IF ( MODULO( M_2 , TO_FM(4) ) == 2 ) THEN
          IF ( M_3 - M_2 <= 1 ) THEN
              KROUND = -1
              CALL FMCOS(MA%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMCOS(MA%RIGHT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 2 ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
              KROUND = -1
              CALL FMCOS(MA%LEFT,RETURN_VALUE%LEFT)
          ELSE IF ( M_3 - M_2 == 3 ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
              KROUND = -1
              IF ( RIGHT_ENDPOINT(MA) - M_1*(M_3-1) > M_1*(M_3-1) - LEFT_ENDPOINT(MA) ) THEN
                  CALL FMCOS(MA%RIGHT,RETURN_VALUE%LEFT)
              ELSE
                  CALL FMCOS(MA%LEFT,RETURN_VALUE%LEFT)
              ENDIF
          ENDIF
      ELSE IF ( MODULO( M_2 , TO_FM(4) ) == 3 ) THEN
          IF ( M_3 - M_2 == 0 ) THEN
              KROUND = -1
              CALL FMCOS(MA%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMCOS(MA%RIGHT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 1 ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
              KROUND = -1
              IF ( RIGHT_ENDPOINT(MA) - M_1*M_3 > M_1*M_3 - LEFT_ENDPOINT(MA) ) THEN
                  CALL FMCOS(MA%RIGHT,RETURN_VALUE%LEFT)
              ELSE
                  CALL FMCOS(MA%LEFT,RETURN_VALUE%LEFT)
              ENDIF
          ELSE IF ( M_3 - M_2 == 2 ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
              KROUND = -1
              CALL FMCOS(MA%RIGHT,RETURN_VALUE%LEFT)
          ELSE IF ( M_3 - M_2 == 3 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
          ENDIF
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMCOS_INTERVAL_FM

!                                                                COSH

   FUNCTION FMCOSH_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      TYPE(MULTI), SAVE :: MULVFM,MVLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      KROUND = -1
      IF (MA%LEFT%MP(1) >= 0) THEN
          CALL FMEQ(MA%LEFT,MTFM_I%LEFT)
          CALL FMEQ(MA%RIGHT,MTFM_I%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) <= 0) THEN
          CALL FMABS(MA%RIGHT,MTFM_I%LEFT)
          CALL FMABS(MA%LEFT,MTFM_I%RIGHT)
      ELSE
          CALL FMI2M(1,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMCOSH(MA%LEFT,MULVFM)
          CALL FMCOSH(MA%RIGHT,MVLVFM)
          CALL FMMAX(MULVFM,MVLVFM,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      KROUND = -1
      CALL FMCOSH(MTFM_I%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMCOSH(MTFM_I%RIGHT,RETURN_VALUE%RIGHT)
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMCOSH_INTERVAL_FM

!                                                                DBLE

   FUNCTION FMDBLE_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMDBLE_INTERVAL_FM

!                                                                DIGITS

   FUNCTION FMDIGITS_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = NDIG
      IF (ALLOCATED(MA%LEFT%MP)) THEN
          IF (SIZE(MA%LEFT%MP) <= 2) RETURN_VALUE = RETURN_VALUE - 1
      ENDIF
   END FUNCTION FMDIGITS_INTERVAL_FM

!                                                                 DIM

   FUNCTION FMDIM_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FMSUB_INTERVAL(MA,MB,MTFM_I)
      CALL FMEQ(MTFM_I%LEFT,RETURN_VALUE%LEFT)
      CALL FMEQ(MTFM_I%RIGHT,RETURN_VALUE%RIGHT)
      IF (MTFM_I%LEFT%MP(1) < 0) THEN
          CALL FMI2M(0,RETURN_VALUE%LEFT)
      ENDIF
      IF (MTFM_I%RIGHT%MP(1) < 0) THEN
          CALL FMI2M(0,RETURN_VALUE%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMDIM_INTERVAL_FM

!                                                                DINT

   FUNCTION FMDINT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMINT_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMDINT_INTERVAL_FM

!                                                          DOT_PRODUCT

   FUNCTION FMDOTPRODUCT_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:),MB(:),RETURN_VALUE
      INTEGER :: J,JA,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) == SIZE(MB)) THEN
          NDSAVE = NDIG
          J = MAX(NGRD52,2)
          ND2 = MAX(2*NDIG+J,2)
          NDIG = ND2
          CALL FMI2M_INTERVAL(0,M2FM_I)
          DO J = 1, SIZE(MA)
             JA = LBOUND(MA,DIM=1) + J - 1
             CALL FMEQU_INTERVAL(MA(JA),MUFM_I,NDSAVE,NDIG)
             CALL FMEQU_INTERVAL(MB(JA),MVFM_I,NDSAVE,NDIG)
             CALL FMMPY_INTERVAL(MUFM_I,MVFM_I,MTFM_I)
             CALL FMADD_INTERVAL_R1(M2FM_I,MTFM_I)
          ENDDO
          CALL FMEQU_INTERVAL(M2FM_I,RETURN_VALUE,NDIG,NDSAVE)
          NDIG = NDSAVE
      ELSE
          CALL FMI2M_INTERVAL(1,MTFM_I)
          CALL FMI2M_INTERVAL(0,MUFM_I)
          CALL FMDIV_INTERVAL(MTFM_I,MUFM_I,RETURN_VALUE)
      ENDIF
   END FUNCTION FMDOTPRODUCT_INTERVAL_FM

!                                                             EPSILON

   FUNCTION FMEPSILON_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FMI2M_INTERVAL(1,MTFM_I)
      IF (ALLOCATED(MA%LEFT%MP)) THEN
          IF (SIZE(MA%LEFT%MP) <= 2) CALL FMI2M_INTERVAL(2,MTFM_I)
      ENDIF
      CALL FMULP_INTERVAL(MTFM_I,RETURN_VALUE)
   END FUNCTION FMEPSILON_INTERVAL_FM

!                                                                 EXP

   FUNCTION FMEXP_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      KWRNSV = KWARN
      KWARN = 0
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KROUND = -1
      CALL FMEXP(MA%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMEXP(MA%RIGHT,RETURN_VALUE%RIGHT)
      KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMEXP_INTERVAL_FM

!                                                                EXPONENT

   FUNCTION FMEXPONENT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      IF (MA%LEFT%MP(1) >= 0) THEN
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(EXPONENT(LEFT_ENDPOINT(MA)),  &
                             EXPONENT(RIGHT_ENDPOINT(MA))),RETURN_VALUE)
      ELSE IF (MA%RIGHT%MP(1) < 0) THEN
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(EXPONENT(RIGHT_ENDPOINT(MA)),  &
                             EXPONENT(LEFT_ENDPOINT(MA))),RETURN_VALUE)
      ELSE
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(MEXPUN),TO_FM(                               &
                             MAX(EXPONENT(LEFT_ENDPOINT(MA)),EXPONENT(RIGHT_ENDPOINT(MA))))),  &
                             RETURN_VALUE)
      ENDIF
   END FUNCTION FMEXPONENT_INTERVAL_FM

!                                                               FLOOR

   FUNCTION FMFLOOR_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      KWRNSV = KWARN
      KWARN = 0
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMINT_INTERVAL(MA,M7FM_I)
      CALL FMEQ_INTERVAL(M7FM_I,MTFM_I)
      IF (FMCOMP(MA%LEFT,'/=',MTFM_I%LEFT)) THEN
          IF (MA%LEFT%MP(1) < 0) THEN
              CALL FMADDI(MTFM_I%LEFT,-1)
          ENDIF
      ENDIF
      IF (FMCOMP(MA%RIGHT,'/=',MTFM_I%RIGHT)) THEN
          IF (MA%RIGHT%MP(1) < 0) THEN
              CALL FMADDI(MTFM_I%RIGHT,-1)
          ENDIF
      ENDIF
      CALL FMEQ_INTERVAL(MTFM_I,RETURN_VALUE)
      KWARN = KWRNSV
   END FUNCTION FMFLOOR_INTERVAL_FM

!                                                            FRACTION

   FUNCTION FMFRACTION_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      IF (IS_UNKNOWN(MA)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(3) == 0 .OR. MA%RIGHT%MP(3) == 0) THEN
          IF (MA%LEFT%MP(3) == 0 .AND. MA%RIGHT%MP(3) == 0) THEN
              CALL FMI2M(0,RETURN_VALUE%LEFT)
              CALL FMI2M(0,RETURN_VALUE%RIGHT)
          ELSE IF (MA%LEFT%MP(3) == 0) THEN
              CALL FMI2M(0,RETURN_VALUE%LEFT)
              CALL FM_EQ(FRACTION(HUGE(TO_FM(1))),M_1)
              CALL FMEQ(M_1%MFM,RETURN_VALUE%RIGHT)
          ELSE
              CALL FM_EQ(FRACTION(HUGE(TO_FM(1))),M_1)
              CALL FMMPYI(M_1%MFM,-1,RETURN_VALUE%LEFT)
              CALL FMI2M(0,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE IF (MA%LEFT%MP(1) == MA%RIGHT%MP(1) .AND.  &
          MA%LEFT%MP(2) == MA%RIGHT%MP(2)) THEN
          CALL FMEQ_INTERVAL(MA,RETURN_VALUE)
          RETURN_VALUE%LEFT%MP(2) = 0
          RETURN_VALUE%RIGHT%MP(2) = 0
      ELSE IF (MA%LEFT%MP(1) > 0) THEN
          CALL FMI2M(0,RETURN_VALUE%LEFT)
          CALL FM_EQ(FRACTION(HUGE(TO_FM(1))),M_1)
          CALL FMEQ(M_1%MFM,RETURN_VALUE%RIGHT)
      ELSE IF (MA%RIGHT%MP(1) < 0) THEN
          CALL FM_EQ(FRACTION(HUGE(TO_FM(1))),M_1)
          CALL FMMPYI(M_1%MFM,-1,RETURN_VALUE%LEFT)
          CALL FMI2M(0,RETURN_VALUE%RIGHT)
      ELSE
          CALL FM_EQ(FRACTION(HUGE(TO_FM(1))),M_1)
          CALL FMMPYI(M_1%MFM,-1,RETURN_VALUE%LEFT)
          CALL FM_EQ(FRACTION(HUGE(TO_FM(1))),M_1)
          CALL FMEQ(M_1%MFM,RETURN_VALUE%RIGHT)
      ENDIF
  110 KWARN = KWRNSV
   END FUNCTION FMFRACTION_INTERVAL_FM

!                                                                HUGE

   FUNCTION FMHUGE_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FMBIG(RETURN_VALUE%LEFT)
      IF (ALLOCATED(MA%LEFT%MP)) THEN
          IF (SIZE(MA%LEFT%MP) <= 2) CALL FMBIG(RETURN_VALUE%RIGHT)
      ENDIF
      CALL FMEQ(RETURN_VALUE%LEFT,RETURN_VALUE%RIGHT)
   END FUNCTION FMHUGE_INTERVAL_FM

!                                                                 INT

   FUNCTION FMINT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMINT_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMINT_INTERVAL_FM

!                                                                 LOG

   FUNCTION FMLOG_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%RIGHT%MP(1) < 0 .OR. MA%RIGHT%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(1) < 0 .OR. MA%LEFT%MP(3) == 0) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
      ELSE
          IF (MA%LEFT%MP(2) == MEXPOV) THEN
              CALL FMBIG(M_12%MFM)
              KROUND = -1
              CALL FMLN(M_12%MFM,RETURN_VALUE%LEFT)
          ELSE IF (MA%LEFT%MP(2) == MEXPUN) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          ELSE
              KROUND = -1
              CALL FMLN(MA%LEFT,RETURN_VALUE%LEFT)
          ENDIF
      ENDIF
      IF (MA%RIGHT%MP(2) == MEXPOV) THEN
          CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE IF (MA%RIGHT%MP(2) == MEXPUN) THEN
          CALL FMTINY(M_11%MFM)
          CALL FMLN(M_11%MFM,RETURN_VALUE%RIGHT)
      ELSE
          KROUND = 2
          CALL FMLN(MA%RIGHT,RETURN_VALUE%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMLOG_INTERVAL_FM

!                                                               LOG10

   FUNCTION FMLOG10_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%RIGHT%MP(1) < 0 .OR. MA%RIGHT%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(1) < 0 .OR. MA%LEFT%MP(3) == 0) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
      ELSE
          IF (MA%LEFT%MP(2) == MEXPOV) THEN
              CALL FMBIG(M_12%MFM)
              KROUND = -1
              CALL FMLG10(M_12%MFM,RETURN_VALUE%LEFT)
          ELSE IF (MA%LEFT%MP(2) == MEXPUN) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          ELSE
              KROUND = -1
              CALL FMLG10(MA%LEFT,RETURN_VALUE%LEFT)
          ENDIF
      ENDIF
      IF (MA%RIGHT%MP(2) == MEXPOV) THEN
          CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE IF (MA%RIGHT%MP(2) == MEXPUN) THEN
          CALL FMTINY(M_11%MFM)
          CALL FMLG10(M_11%MFM,RETURN_VALUE%RIGHT)
      ELSE
          KROUND = 2
          CALL FMLG10(MA%RIGHT,RETURN_VALUE%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMLOG10_INTERVAL_FM

!                                                              MATMUL

   FUNCTION FMMATMUL22_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:,:),MB(:,:)
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1),SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: I,J,K,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA,DIM=2) == SIZE(MB,DIM=1)) THEN
          NDSAVE = NDIG
          J = MAX(NGRD52,2)
          ND2 = MAX(2*NDIG+J,2)
          NDIG = ND2
          DO I = 1, SIZE(MA,DIM=1)
             DO J = 1, SIZE(MB,DIM=2)
                CALL FMI2M_INTERVAL(0,MTFM_I)
                DO K = 1, SIZE(MA,DIM=2)
                   CALL FMEQU_INTERVAL(MA(I,K),MUFM_I,NDSAVE,NDIG)
                   CALL FMEQU_INTERVAL(MB(K,J),MVFM_I,NDSAVE,NDIG)
                   CALL FMMPY_INTERVAL(MUFM_I,MVFM_I,M3FM_I)
                   CALL FMADD_INTERVAL_R1(MTFM_I,M3FM_I)
                ENDDO
                CALL FMEQU_INTERVAL(MTFM_I,RETURN_VALUE(I,J),NDIG,NDSAVE)
             ENDDO
          ENDDO
          NDIG = NDSAVE
      ELSE
          CALL FMI2M_INTERVAL(1,MTFM_I)
          CALL FMI2M_INTERVAL(0,MUFM_I)
          CALL FMDIV_INTERVAL(MTFM_I,MUFM_I,MVFM_I)
          DO I = 1, SIZE(MA,DIM=1)
             DO J = 1, SIZE(MB,DIM=2)
                CALL FMEQ_INTERVAL(MVFM_I,RETURN_VALUE(I,J))
             ENDDO
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL22_INTERVAL_FM

   FUNCTION FMMATMUL12_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:),MB(:,:)
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MB,DIM=2)) :: RETURN_VALUE
      INTEGER :: J,K,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MA) == SIZE(MB,DIM=1)) THEN
          NDSAVE = NDIG
          J = MAX(NGRD52,2)
          ND2 = MAX(2*NDIG+J,2)
          NDIG = ND2
          DO J = 1, SIZE(MB,DIM=2)
             CALL FMI2M_INTERVAL(0,MTFM_I)
             DO K = 1, SIZE(MA,DIM=1)
                CALL FMEQU_INTERVAL(MA(K),MUFM_I,NDSAVE,NDIG)
                CALL FMEQU_INTERVAL(MB(K,J),MVFM_I,NDSAVE,NDIG)
                CALL FMMPY_INTERVAL(MUFM_I,MVFM_I,M3FM_I)
                CALL FMADD_INTERVAL_R1(MTFM_I,M3FM_I)
             ENDDO
             CALL FMEQU_INTERVAL(MTFM_I,RETURN_VALUE(J),NDIG,NDSAVE)
          ENDDO
          NDIG = NDSAVE
      ELSE
          CALL FMST2M_INTERVAL(' UNKNOWN ',MVFM_I)
          DO J = 1, SIZE(MB,DIM=2)
             CALL FMEQ_INTERVAL(MVFM_I,RETURN_VALUE(J))
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL12_INTERVAL_FM

   FUNCTION FMMATMUL21_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:,:),MB(:)
      TYPE (FM_INTERVAL), DIMENSION(SIZE(MA,DIM=1)) :: RETURN_VALUE
      INTEGER :: J,K,ND2,NDSAVE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (SIZE(MB) == SIZE(MA,DIM=2)) THEN
          NDSAVE = NDIG
          J = MAX(NGRD52,2)
          ND2 = MAX(2*NDIG+J,2)
          NDIG = ND2
          DO J = 1, SIZE(MA,DIM=1)
             CALL FMI2M_INTERVAL(0,MTFM_I)
             DO K = 1, SIZE(MB,DIM=1)
                CALL FMEQU_INTERVAL(MA(J,K),MUFM_I,NDSAVE,NDIG)
                CALL FMEQU_INTERVAL(MB(K),MVFM_I,NDSAVE,NDIG)
                CALL FMMPY_INTERVAL(MUFM_I,MVFM_I,M3FM_I)
                CALL FMADD_INTERVAL_R1(MTFM_I,M3FM_I)
             ENDDO
             CALL FMEQU_INTERVAL(MTFM_I,RETURN_VALUE(J),NDIG,NDSAVE)
          ENDDO
          NDIG = NDSAVE
      ELSE
          CALL FMST2M_INTERVAL(' UNKNOWN ',MVFM_I)
          DO J = 1, SIZE(MA,DIM=1)
             CALL FMEQ_INTERVAL(MVFM_I,RETURN_VALUE(J))
          ENDDO
      ENDIF
   END FUNCTION FMMATMUL21_INTERVAL_FM

!                                                                 MAX

   SUBROUTINE FMMAX_INTERVAL(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      CALL FMMAX(MA%LEFT,MB%LEFT,MC%LEFT)
      CALL FMMAX(MA%RIGHT,MB%RIGHT,MC%RIGHT)
   END SUBROUTINE FMMAX_INTERVAL

   FUNCTION FMMAX_INTERVAL_FM(MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      TYPE (FM_INTERVAL), OPTIONAL :: MC,MD,ME,MF,MG,MH,MI,MJ
      INTENT (IN) :: MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMMAX_INTERVAL(MA,MB,MTFM_I)
      IF (PRESENT(MC)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MC)
          CALL FMMAX_INTERVAL(MTFM_I,MC,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MD)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MD)
          CALL FMMAX_INTERVAL(MTFM_I,MD,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(ME)) THEN
          CALL FM_INTERVAL_UNDEF_INP(ME)
          CALL FMMAX_INTERVAL(MTFM_I,ME,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MF)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MF)
          CALL FMMAX_INTERVAL(MTFM_I,MF,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MG)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MG)
          CALL FMMAX_INTERVAL(MTFM_I,MG,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MH)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MH)
          CALL FMMAX_INTERVAL(MTFM_I,MH,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MI)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MI)
          CALL FMMAX_INTERVAL(MTFM_I,MI,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MJ)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MJ)
          CALL FMMAX_INTERVAL(MTFM_I,MJ,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      CALL FMEQ_INTERVAL(MTFM_I,RETURN_VALUE)
   END FUNCTION FMMAX_INTERVAL_FM

!                                                                MAXEXPONENT

   FUNCTION FMMAXEXPONENT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(TO_FM_INTERVAL(MAXEXPONENT(LEFT_ENDPOINT(MA))),RETURN_VALUE)
   END FUNCTION FMMAXEXPONENT_INTERVAL_FM

!                                                              MAXVAL

   FUNCTION FMMAXVAL1_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMST2M_INTERVAL(' -OVERFLOW ',M2FM_I)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL FMMAX_INTERVAL(M2FM_I,MA(JA),M3FM_I)
         CALL FMEQ_INTERVAL(M3FM_I,M2FM_I)
      ENDDO
      CALL FMEQ_INTERVAL(M2FM_I,RETURN_VALUE)
   END FUNCTION FMMAXVAL1_INTERVAL_FM

   FUNCTION FMMAXVAL2_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMST2M_INTERVAL(' -OVERFLOW ',M2FM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL FMMAX_INTERVAL(M2FM_I,MA(JA,JB),M3FM_I)
            CALL FMEQ_INTERVAL(M3FM_I,M2FM_I)
         ENDDO
      ENDDO
      CALL FMEQ_INTERVAL(M2FM_I,RETURN_VALUE)
   END FUNCTION FMMAXVAL2_INTERVAL_FM

!                                                                 MIN

   SUBROUTINE FMMIN_INTERVAL(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      CALL FMMIN(MA%LEFT,MB%LEFT,MC%LEFT)
      CALL FMMIN(MA%RIGHT,MB%RIGHT,MC%RIGHT)
   END SUBROUTINE FMMIN_INTERVAL

   FUNCTION FMMIN_INTERVAL_FM(MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      TYPE (FM_INTERVAL), OPTIONAL :: MC,MD,ME,MF,MG,MH,MI,MJ
      INTENT (IN) :: MA,MB,MC,MD,ME,MF,MG,MH,MI,MJ
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMMIN_INTERVAL(MA,MB,MTFM_I)
      IF (PRESENT(MC)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MC)
          CALL FMMIN_INTERVAL(MTFM_I,MC,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MD)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MD)
          CALL FMMIN_INTERVAL(MTFM_I,MD,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(ME)) THEN
          CALL FM_INTERVAL_UNDEF_INP(ME)
          CALL FMMIN_INTERVAL(MTFM_I,ME,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MF)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MF)
          CALL FMMIN_INTERVAL(MTFM_I,MF,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MG)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MG)
          CALL FMMIN_INTERVAL(MTFM_I,MG,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MH)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MH)
          CALL FMMIN_INTERVAL(MTFM_I,MH,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MI)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MI)
          CALL FMMIN_INTERVAL(MTFM_I,MI,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      IF (PRESENT(MJ)) THEN
          CALL FM_INTERVAL_UNDEF_INP(MJ)
          CALL FMMIN_INTERVAL(MTFM_I,MJ,MUFM_I)
          CALL FMEQ_INTERVAL(MUFM_I,MTFM_I)
      ENDIF
      CALL FMEQ_INTERVAL(MTFM_I,RETURN_VALUE)
   END FUNCTION FMMIN_INTERVAL_FM

!                                                                MINEXPONENT

   FUNCTION FMMINEXPONENT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(TO_FM_INTERVAL(MINEXPONENT(LEFT_ENDPOINT(MA))),RETURN_VALUE)
   END FUNCTION FMMINEXPONENT_INTERVAL_FM

!                                                              MINVAL

   FUNCTION FMMINVAL1_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMST2M_INTERVAL(' OVERFLOW ',M2FM_I)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL FMMIN_INTERVAL(M2FM_I,MA(JA),M3FM_I)
         CALL FMEQ_INTERVAL(M3FM_I,M2FM_I)
      ENDDO
      CALL FMEQ_INTERVAL(M2FM_I,RETURN_VALUE)
   END FUNCTION FMMINVAL1_INTERVAL_FM

   FUNCTION FMMINVAL2_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMST2M_INTERVAL(' OVERFLOW ',M2FM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL FMMIN_INTERVAL(M2FM_I,MA(JA,JB),M3FM_I)
            CALL FMEQ_INTERVAL(M3FM_I,M2FM_I)
         ENDDO
      ENDDO
      CALL FMEQ_INTERVAL(M2FM_I,RETURN_VALUE)
   END FUNCTION FMMINVAL2_INTERVAL_FM

!                                                                 MOD

   FUNCTION FMMOD_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KWRNSV = KWARN
      KWARN = 0
      IF (IS_UNKNOWN(MA) .OR. IS_UNKNOWN(MB)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FMI2M(0,M_2%MFM)
      IF (FMCOMP(MB%LEFT,'<=',M_2%MFM) .AND. FMCOMP(MB%RIGHT,'>=',M_2%MFM)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) == RIGHT_ENDPOINT(MA) .AND.  &
          LEFT_ENDPOINT(MB) == RIGHT_ENDPOINT(MB)) THEN
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(MOD(LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB))),  &
                             RETURN_VALUE)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) >= 0) THEN
          CALL FMABS_INTERVAL(MA,M6FM_I)
          CALL FMABS_INTERVAL(MB,M7FM_I)
          CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,RETURN_VALUE)
      ELSE IF (RIGHT_ENDPOINT(MA) < 0) THEN
          CALL FMABS_INTERVAL(MA,M6FM_I)
          CALL FMABS_INTERVAL(MB,M7FM_I)
          CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M4FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(0),M7FM_I)
          CALL FMSUB_INTERVAL(M7FM_I,M4FM_I,RETURN_VALUE)
      ELSE
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(LEFT_ENDPOINT(MA),TO_FM(0)),M3FM_I)
          CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
          CALL FMABS_INTERVAL(MB,M7FM_I)
          CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M1FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(MA)),M3FM_I)
          CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
          CALL FMABS_INTERVAL(MB,M7FM_I)
          CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M2FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(-RIGHT_ENDPOINT(M1FM_I),RIGHT_ENDPOINT(M2FM_I)),  &
                             RETURN_VALUE)
      ENDIF
  110 KWARN = KWRNSV
   END FUNCTION FMMOD_INTERVAL_FM

   SUBROUTINE FMMOD_INTERVAL_POS(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      IF (RIGHT_ENDPOINT(MA) <= LEFT_ENDPOINT(MB)) THEN
          CALL FMEQ_INTERVAL(MA,MC)
          RETURN
      ENDIF
      CALL FMDIV_INTERVAL(MA,MB,MC)
      IF (AINT(RIGHT_ENDPOINT(MC)) < LEFT_ENDPOINT(MC)) THEN
          CALL FM_EQ(MOD(LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MB)),M_1)
          CALL FM_EQ(MOD(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB)),M_2)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(M_1,M_2),MC)
      ELSE
          CALL FM_I2M(0,M_1)
          IF (AINT(RIGHT_ENDPOINT(MC)) /= 0) THEN
              CALL FM_DIV(RIGHT_ENDPOINT(MA),AINT(RIGHT_ENDPOINT(MC)),M_3)
              CALL FM_MIN(RIGHT_ENDPOINT(MB),M_3,M_2)
          ELSE
              CALL FM_EQ(RIGHT_ENDPOINT(MB),M_2)
          ENDIF
          IF (CEILING(LEFT_ENDPOINT(MC)) /= 0) THEN
              CALL FM_DIV(RIGHT_ENDPOINT(MA),CEILING(LEFT_ENDPOINT(MC)),M_3)
              IF (M_3 >= LEFT_ENDPOINT(MB) .AND. M_3 <= RIGHT_ENDPOINT(MB)) CALL FM_EQ(M_3,M_2)
          ENDIF
          IF (AINT(RIGHT_ENDPOINT(MA)/RIGHT_ENDPOINT(MB))*RIGHT_ENDPOINT(MB) >=  &
              LEFT_ENDPOINT(MA)) CALL FM_EQ(RIGHT_ENDPOINT(MB),M_2)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(M_1,M_2),MC)
      ENDIF
   END SUBROUTINE FMMOD_INTERVAL_POS

!                                                              MODULO

   FUNCTION FMMODULO_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KWRNSV = KWARN
      KWARN = 0
      IF (IS_UNKNOWN(MA) .OR. IS_UNKNOWN(MB)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FMI2M(0,M_2%MFM)
      IF (FMCOMP(MB%LEFT,'<=',M_2%MFM) .AND. FMCOMP(MB%RIGHT,'>=',M_2%MFM)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) >= 0) THEN
          IF (LEFT_ENDPOINT(MB) >= 0) THEN
              CALL FMABS_INTERVAL(MA,M6FM_I)
              CALL FMABS_INTERVAL(MB,M7FM_I)
              CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,RETURN_VALUE)
          ELSE
              CALL FMABS_INTERVAL(MA,M6FM_I)
              CALL FMABS_INTERVAL(MB,M7FM_I)
              CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M5FM_I)
              CALL FMADD_INTERVAL(M5FM_I,MB,MUFM_I)
              IF (FMCOMP(MUFM_I%LEFT,'<',MB%LEFT)) CALL FMEQ(MB%LEFT,MUFM_I%LEFT)
              CALL FMI2M(0,M_2%MFM)
              IF (FMCOMP(MUFM_I%RIGHT,'>',M_2%MFM)) CALL FMI2M(0,MUFM_I%RIGHT)
              CALL FMEQ_INTERVAL(MUFM_I,RETURN_VALUE)
          ENDIF
      ELSE IF (RIGHT_ENDPOINT(MA) < 0) THEN
          IF (LEFT_ENDPOINT(MB) >= 0) THEN
              CALL FMABS_INTERVAL(MA,M6FM_I)
              CALL FMABS_INTERVAL(MB,M7FM_I)
              CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M5FM_I)
              CALL FMSUB_INTERVAL(MB,M5FM_I,MUFM_I)
              CALL FMI2M(0,M_2%MFM)
              IF (FMCOMP(MUFM_I%LEFT,'<',M_2%MFM)) CALL FMI2M(0,MUFM_I%LEFT)
              IF (FMCOMP(MUFM_I%RIGHT,'>',MB%RIGHT)) CALL FMEQ(MB%RIGHT,MUFM_I%RIGHT)
              CALL FMEQ_INTERVAL(MUFM_I,RETURN_VALUE)
          ELSE
              CALL FMABS_INTERVAL(MA,M6FM_I)
              CALL FMABS_INTERVAL(MB,M7FM_I)
              CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M5FM_I)
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(0),M7FM_I)
              CALL FMSUB_INTERVAL(M7FM_I,M5FM_I,RETURN_VALUE)
          ENDIF
      ELSE
          IF (LEFT_ENDPOINT(MB) >= 0) THEN
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(LEFT_ENDPOINT(MA),TO_FM(0)),M3FM_I)
              CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
              CALL FMABS_INTERVAL(MB,M7FM_I)
              CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M5FM_I)
              CALL FMSUB_INTERVAL(MB,M5FM_I,MUFM_I)
              CALL FMI2M(0,M_2%MFM)
              IF (FMCOMP(MUFM_I%LEFT,'<',M_2%MFM)) CALL FMI2M(0,MUFM_I%LEFT)
              IF (FMCOMP(MUFM_I%RIGHT,'>',MB%RIGHT)) CALL FMEQ(MB%RIGHT,MUFM_I%RIGHT)
              CALL FMEQ_INTERVAL(MUFM_I,M1FM_I)
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(MA)),M3FM_I)
              CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
              CALL FMABS_INTERVAL(MB,M7FM_I)
              CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M2FM_I)
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(MIN(LEFT_ENDPOINT(M1FM_I),LEFT_ENDPOINT(M2FM_I)),  &
                                            MAX(RIGHT_ENDPOINT(M1FM_I),RIGHT_ENDPOINT(M2FM_I))),   &
                                            RETURN_VALUE)
          ELSE
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(LEFT_ENDPOINT(MA),TO_FM(0)),M3FM_I)
              CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
              CALL FMABS_INTERVAL(MB,M7FM_I)
              CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M5FM_I)
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(0),M7FM_I)
              CALL FMSUB_INTERVAL(M7FM_I,M5FM_I,M1FM_I)
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(MA)),M3FM_I)
              CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
              CALL FMABS_INTERVAL(MB,M7FM_I)
              CALL FMMOD_INTERVAL_POS(M6FM_I,M7FM_I,M5FM_I)
              CALL FMADD_INTERVAL(M5FM_I,MB,MUFM_I)
              IF (FMCOMP(MUFM_I%LEFT,'<',MB%LEFT)) CALL FMEQ(MB%LEFT,MUFM_I%LEFT)
              CALL FMI2M(0,M_2%MFM)
              IF (FMCOMP(MUFM_I%RIGHT,'>',M_2%MFM)) CALL FMI2M(0,MUFM_I%RIGHT)
              CALL FMEQ_INTERVAL(MUFM_I,M2FM_I)
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(MIN(LEFT_ENDPOINT(M1FM_I),LEFT_ENDPOINT(M2FM_I)),  &
                                            MAX(RIGHT_ENDPOINT(M1FM_I),RIGHT_ENDPOINT(M2FM_I))),   &
                                            RETURN_VALUE)
          ENDIF
      ENDIF
  110 KWARN = KWRNSV
   END FUNCTION FMMODULO_INTERVAL_FM

!                                                             NEAREST

   FUNCTION FMNEAREST_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      INTEGER :: KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%RIGHT%MP(2) == MEXPOV .AND. MA%RIGHT%MP(1) < 0 .AND.  &
          MB%LEFT%MP(1) > 0) THEN
          CALL FMST2M(' -OVERFLOW ',RETURN_VALUE%LEFT)
          CALL FMBIG(RETURN_VALUE%RIGHT)
          CALL FMMPYI_R1(RETURN_VALUE%RIGHT,-1)
      ELSE IF (MA%LEFT%MP(2) == MEXPOV .AND. MA%LEFT%MP(1) > 0 .AND.  &
          MB%RIGHT%MP(1) < 0) THEN
          CALL FMBIG(RETURN_VALUE%LEFT)
          CALL FMST2M(' +OVERFLOW ',RETURN_VALUE%RIGHT)
      ELSE IF (LEFT_ENDPOINT(MB) <= 0 .AND. RIGHT_ENDPOINT(MB) >= 0) THEN
          CALL FM_EQ(NEAREST(LEFT_ENDPOINT(MA),TO_FM(-1)),M_1)
          CALL FM_EQ(NEAREST(RIGHT_ENDPOINT(MA),TO_FM(1)),M_2)
          CALL FMEQ_INTERVAL( TO_FM_INTERVAL( M_1 , M_2 ) , RETURN_VALUE )
      ELSE IF (RIGHT_ENDPOINT(MB) < 0) THEN
          CALL FM_EQ(NEAREST(LEFT_ENDPOINT(MA),TO_FM(-1)),M_1)
          CALL FM_EQ(NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)),M_2)
          CALL FMEQ_INTERVAL( TO_FM_INTERVAL( M_1 , M_2 ) , RETURN_VALUE )
      ELSE
          CALL FM_EQ(NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)),M_1)
          CALL FM_EQ(NEAREST(RIGHT_ENDPOINT(MA),TO_FM(1)),M_2)
          CALL FMEQ_INTERVAL( TO_FM_INTERVAL( M_1 , M_2 ) , RETURN_VALUE )
      ENDIF
      KWARN = KWRNSV
   END FUNCTION FMNEAREST_INTERVAL_FM

!                                                               NINT

   SUBROUTINE FMNINT_INTERVAL(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FMNINT(MA%LEFT,MB%LEFT)
      CALL FMNINT(MA%RIGHT,MB%RIGHT)
   END SUBROUTINE FMNINT_INTERVAL

   FUNCTION FMNINT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMNINT_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMNINT_INTERVAL_FM

!                                                                PRECISION

   FUNCTION FMPRECISION_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(TO_FM_INTERVAL(PRECISION(LEFT_ENDPOINT(MA))),RETURN_VALUE)
   END FUNCTION FMPRECISION_INTERVAL_FM

!                                                             PRODUCT

   FUNCTION FMPRODUCT1_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA,ND2,NDSAVE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      NDSAVE = NDIG
      J = MAX(NGRD52,2)
      ND2 = MAX(2*NDIG+J,2)
      NDIG = ND2
      CALL FMI2M_INTERVAL(1,M2FM_I)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL FMEQU_INTERVAL(MA(JA),MUFM_I,NDSAVE,NDIG)
         CALL FMMPY_INTERVAL_R1(M2FM_I,MUFM_I)
      ENDDO
      CALL FMEQU_INTERVAL(M2FM_I,RETURN_VALUE,NDIG,NDSAVE)
      NDIG = NDSAVE
   END FUNCTION FMPRODUCT1_INTERVAL_FM

   FUNCTION FMPRODUCT2_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB,ND2,NDSAVE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      NDSAVE = NDIG
      J = MAX(NGRD52,2)
      ND2 = MAX(2*NDIG+J,2)
      NDIG = ND2
      CALL FMI2M_INTERVAL(1,M2FM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL FMEQU_INTERVAL(MA(JA,JB),MUFM_I,NDSAVE,NDIG)
            CALL FMMPY_INTERVAL_R1(M2FM_I,MUFM_I)
         ENDDO
      ENDDO
      CALL FMEQU_INTERVAL(M2FM_I,RETURN_VALUE,NDIG,NDSAVE)
      NDIG = NDSAVE
   END FUNCTION FMPRODUCT2_INTERVAL_FM

!                                                                RADIX

   FUNCTION FMRADIX_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(TO_FM_INTERVAL(RADIX(LEFT_ENDPOINT(MA))),RETURN_VALUE)
   END FUNCTION FMRADIX_INTERVAL_FM

!                                                                RANGE

   FUNCTION FMRANGE_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(TO_FM_INTERVAL(RANGE(LEFT_ENDPOINT(MA))),RETURN_VALUE)
   END FUNCTION FMRANGE_INTERVAL_FM

!                                                                REAL

   FUNCTION FMREAL_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMREAL_INTERVAL_FM

!                                                           RRSPACING

   FUNCTION FMRRSPACING_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: ND
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMABS_INTERVAL(MA,MTFM_I)
      IF (LEFT_ENDPOINT(MTFM_I) == 0 .OR.  &
          MTFM_I%LEFT%MP(2) /= MTFM_I%RIGHT%MP(2)) THEN
          ND = NDIG
          CALL FM_EQ(TO_FM(MBASE)**(ND-1),M_1)
          CALL FM_EQ(NEAREST(TO_FM(MBASE)**ND,TO_FM(-1)),M_2)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(M_1,M_2),RETURN_VALUE)
      ELSE
          MTFM_I%LEFT%MP(2) = NDIG
          MTFM_I%RIGHT%MP(2) = NDIG
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(MTFM_I),RETURN_VALUE)
      ENDIF
   END FUNCTION FMRRSPACING_INTERVAL_FM

!                                                               SCALE

   FUNCTION FMSCALE_INTERVAL_FM(MA,L)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: L
      INTENT (IN) :: MA,L
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(MA,MTFM_I)
      IF (ABS(MTFM_I%RIGHT%MP(2)+L) < MXEXP) THEN
          MTFM_I%LEFT%MP(2) = MTFM_I%LEFT%MP(2) + L
          MTFM_I%RIGHT%MP(2) = MTFM_I%RIGHT%MP(2) + L
          CALL FMEQ_INTERVAL(MTFM_I,RETURN_VALUE)
      ELSE
          CALL FMI2M_INTERVAL(INT(MBASE),MUFM_I)
          CALL FMIPWR_INTERVAL(MUFM_I,L,MVFM_I)
          CALL FMMPY_INTERVAL(MA,MVFM_I,M2FM_I)
          CALL FMEQ_INTERVAL(M2FM_I,RETURN_VALUE)
      ENDIF
   END FUNCTION FMSCALE_INTERVAL_FM

!                                                         SETEXPONENT

   FUNCTION FMSETEXPONENT_INTERVAL_FM(MA,L)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: L
      INTENT (IN) :: MA,L
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(MA,MTFM_I)
      IF (MA%LEFT%MP(1) <= 0 .AND. MA%RIGHT%MP(1) >= 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
      ELSE IF (MTFM_I%LEFT%MP(2) == MTFM_I%RIGHT%MP(2)) THEN
          MTFM_I%LEFT%MP(2) = L
          MTFM_I%RIGHT%MP(2) = L
          CALL FMMIN(MTFM_I%LEFT,MTFM_I%RIGHT,RETURN_VALUE%LEFT)
          CALL FMMAX(MTFM_I%LEFT,MTFM_I%RIGHT,RETURN_VALUE%RIGHT)
      ELSE
          CALL FMI2M_INTERVAL(1,RETURN_VALUE)
          RETURN_VALUE%LEFT%MP(2) = L
          RETURN_VALUE%RIGHT%MP(2) = L + 1
      ENDIF
   END FUNCTION FMSETEXPONENT_INTERVAL_FM

!                                                                SIGN

   FUNCTION FMSIGN_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      IF (MB%LEFT%MP(1) >= 0) THEN
          CALL FMABS_INTERVAL(MA,RETURN_VALUE)
      ELSE IF (MB%RIGHT%MP(1) < 0) THEN
          CALL FMABS_INTERVAL(MA,M6FM_I)
          CALL FMMPYI_INTERVAL(M6FM_I,-1,RETURN_VALUE)
      ELSE
          CALL FMMPY_INTERVAL(MA,TO_FM_INTERVAL( '-1' , '1' ),RETURN_VALUE)
      ENDIF
   END FUNCTION FMSIGN_INTERVAL_FM

 END MODULE FM_INTERVAL_ARITHMETIC_8

 MODULE FM_INTERVAL_ARITHMETIC_9
    USE FM_INTERVAL_ARITHMETIC_1

   INTERFACE SIN
      MODULE PROCEDURE FMSIN_INTERVAL_FM
   END INTERFACE

   INTERFACE SINH
      MODULE PROCEDURE FMSINH_INTERVAL_FM
   END INTERFACE

   INTERFACE SPACING
      MODULE PROCEDURE FMSPACING_INTERVAL_FM
   END INTERFACE

   INTERFACE SQRT
      MODULE PROCEDURE FMSQRT_INTERVAL_FM
   END INTERFACE

   INTERFACE SUM
      MODULE PROCEDURE FMSUM1_INTERVAL_FM
      MODULE PROCEDURE FMSUM2_INTERVAL_FM
   END INTERFACE

   INTERFACE TAN
      MODULE PROCEDURE FMTAN_INTERVAL_FM
   END INTERFACE

   INTERFACE TANH
      MODULE PROCEDURE FMTANH_INTERVAL_FM
   END INTERFACE

   INTERFACE TINY
      MODULE PROCEDURE FMTINY_INTERVAL_FM
   END INTERFACE

   INTERFACE BETA
      MODULE PROCEDURE FMBETA_INTERVAL_FM
   END INTERFACE

   INTERFACE BINOMIAL
      MODULE PROCEDURE FMBINOMIAL_INTERVAL_FM
   END INTERFACE

   INTERFACE FACTORIAL
      MODULE PROCEDURE FMFACTORIAL_INTERVAL_FM
   END INTERFACE

   INTERFACE GAMMA
      MODULE PROCEDURE FMGAMMA_INTERVAL_FM
   END INTERFACE

   INTERFACE INCOMPLETE_BETA
      MODULE PROCEDURE FMINCOMPLETE_BETA_INTERVAL_FM
   END INTERFACE

   INTERFACE INCOMPLETE_GAMMA1
      MODULE PROCEDURE FMINCOMPLETE_GAMMA1_INTERVAL_FM
   END INTERFACE

   INTERFACE INCOMPLETE_GAMMA2
      MODULE PROCEDURE FMINCOMPLETE_GAMMA2_INTERVAL_FM
   END INTERFACE

   INTERFACE LOG_GAMMA
      MODULE PROCEDURE FMLOG_GAMMA_INTERVAL_FM
   END INTERFACE

   INTERFACE POLYGAMMA
      MODULE PROCEDURE FMPOLYGAMMA_INTERVAL_FM
   END INTERFACE

   INTERFACE POCHHAMMER
      MODULE PROCEDURE FMPOCHHAMMER_INTERVAL_FM
   END INTERFACE

   INTERFACE PSI
      MODULE PROCEDURE FMPSI_INTERVAL_FM
   END INTERFACE

   INTERFACE BESSEL_J
      MODULE PROCEDURE FMBESSEL_J_INTERVAL_FM
   END INTERFACE

   INTERFACE BESSEL_J0
      MODULE PROCEDURE FMBESSEL_J0_INTERVAL_FM
   END INTERFACE

   INTERFACE BESSEL_J1
      MODULE PROCEDURE FMBESSEL_J1_INTERVAL_FM
   END INTERFACE

   INTERFACE BESSEL_JN
      MODULE PROCEDURE FMBESSEL_JN_INTERVAL_FM1
      MODULE PROCEDURE FMBESSEL_JN_INTERVAL_FM2
   END INTERFACE

   INTERFACE BESSEL_Y
      MODULE PROCEDURE FMBESSEL_Y_INTERVAL_FM
   END INTERFACE

   INTERFACE BESSEL_Y0
      MODULE PROCEDURE FMBESSEL_Y0_INTERVAL_FM
   END INTERFACE

   INTERFACE BESSEL_Y1
      MODULE PROCEDURE FMBESSEL_Y1_INTERVAL_FM
   END INTERFACE

   INTERFACE BESSEL_YN
      MODULE PROCEDURE FMBESSEL_YN_INTERVAL_FM1
      MODULE PROCEDURE FMBESSEL_YN_INTERVAL_FM2
   END INTERFACE

   INTERFACE COS_INTEGRAL
      MODULE PROCEDURE FMCOS_INTEGRAL_INTERVAL_FM
   END INTERFACE

   INTERFACE COSH_INTEGRAL
      MODULE PROCEDURE FMCOSH_INTEGRAL_INTERVAL_FM
   END INTERFACE

   INTERFACE EXP_INTEGRAL_EI
      MODULE PROCEDURE FMEXP_INTEGRAL_EI_INTERVAL_FM
   END INTERFACE

   INTERFACE EXP_INTEGRAL_EN
      MODULE PROCEDURE FMEXP_INTEGRAL_EN_INTERVAL_FM
   END INTERFACE

   INTERFACE FRESNEL_C
      MODULE PROCEDURE FMFRESNEL_C_INTERVAL_FM
   END INTERFACE

   INTERFACE FRESNEL_S
      MODULE PROCEDURE FMFRESNEL_S_INTERVAL_FM
   END INTERFACE

   INTERFACE ERF
      MODULE PROCEDURE FMERF_INTERVAL_FM
   END INTERFACE

   INTERFACE ERFC
      MODULE PROCEDURE FMERFC_INTERVAL_FM
   END INTERFACE

   INTERFACE LOG_ERFC
      MODULE PROCEDURE FMLOG_ERFC_INTERVAL_FM
   END INTERFACE

   INTERFACE LOG_INTEGRAL
      MODULE PROCEDURE FMLOG_INTEGRAL_INTERVAL_FM
   END INTERFACE

   INTERFACE SIN_INTEGRAL
      MODULE PROCEDURE FMSIN_INTEGRAL_INTERVAL_FM
   END INTERFACE

   INTERFACE SINH_INTEGRAL
      MODULE PROCEDURE FMSINH_INTEGRAL_INTERVAL_FM
   END INTERFACE

 CONTAINS

!                                                                 SIN

   FUNCTION FMSIN_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(2) == MEXPOV .OR. MA%RIGHT%MP(2) == MEXPOV) THEN
          CALL FMI2M(-1,RETURN_VALUE%LEFT)
          CALL FMI2M(1,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (RIGHT_ENDPOINT(MA) == LEFT_ENDPOINT(MA)) THEN
          KROUND = -1
          CALL FMSIN(MA%LEFT,RETURN_VALUE%LEFT)
          IF ( IS_UNKNOWN(LEFT_ENDPOINT(RETURN_VALUE)) ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
          ENDIF
          KROUND = 2
          CALL FMSIN(MA%RIGHT,RETURN_VALUE%RIGHT)
          IF ( IS_UNKNOWN(RIGHT_ENDPOINT(RETURN_VALUE)) ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
          ENDIF
          GO TO 110
      ENDIF
      CALL FM_EQ( ASIN( TO_FM(1) ) , M_1 )
      IF (RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 4.01*M_1) THEN
          CALL FMI2M(-1,RETURN_VALUE%LEFT)
          CALL FMI2M(1,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FM_EQ( FLOOR( LEFT_ENDPOINT(MA) / M_1 ) , M_2 )
      CALL FM_EQ( FLOOR( RIGHT_ENDPOINT(MA) / M_1 ) , M_3 )
      IF ( M_3 - M_2 >= 4 ) THEN
          CALL FMI2M(-1,RETURN_VALUE%LEFT)
          CALL FMI2M(1,RETURN_VALUE%RIGHT)
      ELSE IF ( MODULO( M_2 , TO_FM(4) ) == 0 ) THEN
          IF ( M_3 - M_2 == 0 ) THEN
              KROUND = -1
              CALL FMSIN(MA%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMSIN(MA%RIGHT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 1 ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
              KROUND = -1
              IF ( RIGHT_ENDPOINT(MA) - M_1*M_3 > M_1*M_3 - LEFT_ENDPOINT(MA) ) THEN
                  CALL FMSIN(MA%RIGHT,RETURN_VALUE%LEFT)
              ELSE
                  CALL FMSIN(MA%LEFT,RETURN_VALUE%LEFT)
              ENDIF
          ELSE IF ( M_3 - M_2 == 2 ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
              KROUND = -1
              CALL FMSIN(MA%RIGHT,RETURN_VALUE%LEFT)
          ELSE IF ( M_3 - M_2 == 3 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE IF ( MODULO( M_2 , TO_FM(4) ) == 1 ) THEN
          IF ( M_3 - M_2 <= 1 ) THEN
              KROUND = -1
              CALL FMSIN(MA%RIGHT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMSIN(MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 2 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMSIN(MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 3 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              KROUND = 2
              IF ( RIGHT_ENDPOINT(MA) - M_1*(M_3-1) > M_1*(M_3-1) - LEFT_ENDPOINT(MA) ) THEN
                  CALL FMSIN(MA%RIGHT,RETURN_VALUE%RIGHT)
              ELSE
                  CALL FMSIN(MA%LEFT,RETURN_VALUE%RIGHT)
              ENDIF
          ENDIF
      ELSE IF ( MODULO( M_2 , TO_FM(4) ) == 2 ) THEN
          IF ( M_3 - M_2 == 0 ) THEN
              KROUND = -1
              CALL FMSIN(MA%RIGHT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMSIN(MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 1 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              KROUND = 2
              IF ( RIGHT_ENDPOINT(MA) - M_1*M_3 > M_1*M_3 - LEFT_ENDPOINT(MA) ) THEN
                  CALL FMSIN(MA%RIGHT,RETURN_VALUE%RIGHT)
              ELSE
                  CALL FMSIN(MA%LEFT,RETURN_VALUE%RIGHT)
              ENDIF
          ELSE IF ( M_3 - M_2 == 2 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMSIN(MA%RIGHT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 3 ) THEN
              CALL FMI2M(-1,RETURN_VALUE%LEFT)
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE IF ( MODULO( M_2 , TO_FM(4) ) == 3 ) THEN
          IF ( M_3 - M_2 <= 1 ) THEN
              KROUND = -1
              CALL FMSIN(MA%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMSIN(MA%RIGHT,RETURN_VALUE%RIGHT)
          ELSE IF ( M_3 - M_2 == 2 ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
              KROUND = -1
              CALL FMSIN(MA%LEFT,RETURN_VALUE%LEFT)
          ELSE IF ( M_3 - M_2 == 3 ) THEN
              CALL FMI2M(1,RETURN_VALUE%RIGHT)
              KROUND = -1
              IF ( RIGHT_ENDPOINT(MA) - M_1*(M_3-1) > M_1*(M_3-1) - LEFT_ENDPOINT(MA) ) THEN
                  CALL FMSIN(MA%RIGHT,RETURN_VALUE%LEFT)
              ELSE
                  CALL FMSIN(MA%LEFT,RETURN_VALUE%LEFT)
              ENDIF
          ENDIF
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMSIN_INTERVAL_FM

!                                                                SINH

   FUNCTION FMSINH_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      KROUND = -1
      CALL FMSINH(MA%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMSINH(MA%RIGHT,RETURN_VALUE%RIGHT)
      KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMSINH_INTERVAL_FM

!                                                             SPACING

   FUNCTION FMSPACING_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMABS_INTERVAL(MA,MTFM_I)
      CALL FM_EQ(SPACING(LEFT_ENDPOINT(MTFM_I)),M_1)
      CALL FMEQ(M_1%MFM,RETURN_VALUE%LEFT)
      CALL FM_EQ(SPACING(RIGHT_ENDPOINT(MTFM_I)),M_1)
      CALL FMEQ(M_1%MFM,RETURN_VALUE%RIGHT)
   END FUNCTION FMSPACING_INTERVAL_FM

!                                                                SQRT

   FUNCTION FMSQRT_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSQRT_INTERVAL(MA,RETURN_VALUE)
   END FUNCTION FMSQRT_INTERVAL_FM

!                                                                 SUM

   FUNCTION FMSUM1_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:),RETURN_VALUE
      INTEGER :: J,JA,ND2,NDSAVE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      NDSAVE = NDIG
      J = MAX(NGRD52,2)
      ND2 = MAX(2*NDIG+J,2)
      NDIG = ND2
      CALL FMI2M_INTERVAL(0,M2FM_I)
      DO J = 1, SIZE(MA)
         JA = LBOUND(MA,DIM=1) + J - 1
         CALL FMEQU_INTERVAL(MA(JA),MUFM_I,NDSAVE,NDIG)
         CALL FMADD_INTERVAL_R1(M2FM_I,MUFM_I)
      ENDDO
      CALL FMEQU_INTERVAL(M2FM_I,RETURN_VALUE,NDIG,NDSAVE)
      NDIG = NDSAVE
   END FUNCTION FMSUM1_INTERVAL_FM

   FUNCTION FMSUM2_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA(:,:),RETURN_VALUE
      INTEGER :: J,K,JA,JB,ND2,NDSAVE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      NDSAVE = NDIG
      J = MAX(NGRD52,2)
      ND2 = MAX(2*NDIG+J,2)
      NDIG = ND2
      CALL FMI2M_INTERVAL(0,M2FM_I)
      DO J = 1, SIZE(MA,DIM=1)
         DO K = 1, SIZE(MA,DIM=2)
            JA = LBOUND(MA,DIM=1) + J - 1
            JB = LBOUND(MA,DIM=2) + K - 1
            CALL FMEQU_INTERVAL(MA(JA,JB),MUFM_I,NDSAVE,NDIG)
            CALL FMADD_INTERVAL_R1(M2FM_I,MUFM_I)
         ENDDO
      ENDDO
      CALL FMEQU_INTERVAL(M2FM_I,RETURN_VALUE,NDIG,NDSAVE)
      NDIG = NDSAVE
   END FUNCTION FMSUM2_INTERVAL_FM

!                                                                 TAN

   FUNCTION FMTAN_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (RIGHT_ENDPOINT(MA) == LEFT_ENDPOINT(MA)) THEN
          KROUND = -1
          CALL FMTAN(MA%LEFT,RETURN_VALUE%LEFT)
          IF ( IS_UNKNOWN(LEFT_ENDPOINT(RETURN_VALUE)) ) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          ENDIF
          KROUND = 2
          CALL FMTAN(MA%RIGHT,RETURN_VALUE%RIGHT)
          IF ( IS_UNKNOWN(RIGHT_ENDPOINT(RETURN_VALUE)) ) THEN
              CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
          ENDIF
          GO TO 110
      ENDIF
      CALL FM_EQ( ASIN( TO_FM(1) ) , M_1 )
      IF (RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 2.01*M_1) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FMEQ(MA%RIGHT,M_2%MFM)
      CALL FM_EQ(FLOOR((M_2/M_1 - 1)/2),M_2)
      CALL FM_EQ((2*M_2 + 1)*M_1,M_2)
      IF (FMCOMP(MA%LEFT,'>=',M_2%MFM)) THEN
          KROUND = -1
          CALL FMTAN(MA%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMTAN(MA%RIGHT,RETURN_VALUE%RIGHT)
      ELSE
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMTAN_INTERVAL_FM

!                                                                TANH

   FUNCTION FMTANH_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      KROUND = -1
      CALL FMTANH(MA%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMTANH(MA%RIGHT,RETURN_VALUE%RIGHT)
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMTANH_INTERVAL_FM

!                                                                TINY

   FUNCTION FMTINY_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FMTINY(RETURN_VALUE%LEFT)
      IF (ALLOCATED(MA%LEFT%MP)) THEN
          IF (SIZE(MA%LEFT%MP) <= 2) CALL FMTINY(RETURN_VALUE%RIGHT)
      ENDIF
      CALL FMEQ(RETURN_VALUE%LEFT,RETURN_VALUE%RIGHT)
   END FUNCTION FMTINY_INTERVAL_FM

!                                                                BETA

   FUNCTION FMBETA_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      ROUTINE_PREV = 0
      KROUND_PREV = -4
      NUM_PREV = 0
      IF (LEFT_ENDPOINT(MA) <= 0) THEN
          IF (IS_OVERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
              CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
              GO TO 110
          ENDIF
          CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_1)
          IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
              CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
              CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
              GO TO 110
          ENDIF
      ENDIF
      IF (LEFT_ENDPOINT(MB) <= 0) THEN
          IF (IS_OVERFLOW(LEFT_ENDPOINT(MB))) THEN
              CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
              CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
              GO TO 110
          ENDIF
          CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MB)),M_1)
          IF (M_1 >= LEFT_ENDPOINT(MB)) THEN
              CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
              CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
              GO TO 110
          ENDIF
      ENDIF
      K_ROUTINE_EDGE = 1
      KROUND = -1
      CALL FMEDGE_INTERVAL_FM(MA,MB,F_LEFT%MFM,M_6%MFM)
      KROUND = 2
      CALL FMEDGE_INTERVAL_FM(MA,MB,M_6%MFM,F_RIGHT%MFM)
  110 IF (IS_UNKNOWN(F_LEFT) .OR. IS_UNKNOWN(F_RIGHT)) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE
          CALL FMEQ(F_LEFT%MFM,RETURN_VALUE%LEFT)
          CALL FMEQ(F_RIGHT%MFM,RETURN_VALUE%RIGHT)
      ENDIF
      KROUND = KRSAVE
      KWARN = KWRNSV
      IF (RETURN_VALUE%LEFT%MP(2) == MUNKNO) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
      ENDIF
      IF (F_RIGHT%MFM%MP(2) == MUNKNO) THEN
          CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
      ENDIF
   END FUNCTION FMBETA_INTERVAL_FM

!                                                            BINOMIAL

   FUNCTION FMBINOMIAL_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      TYPE (FM_INTERVAL), SAVE :: MB_SPLIT
      TYPE (FM), SAVE :: MB_SPLIT1, MB_SPLIT2
      INTENT (IN) :: MA,MB
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      ROUTINE_PREV = 0
      KROUND_PREV = -4
      NUM_PREV = 0
      IF (LEFT_ENDPOINT(MA) <= -1) THEN
          IF (IS_OVERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
              CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
              GO TO 110
          ENDIF
          CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_1)
          IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
              CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
              CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
              GO TO 110
          ENDIF
      ENDIF
      IF (LEFT_ENDPOINT(MB) < 0 .AND. RIGHT_ENDPOINT(MB) > 0) THEN
          K_ROUTINE_EDGE = 2
          KROUND = -1
          CALL FMEQ(MB%LEFT,MB_SPLIT%LEFT)
          CALL FMI2M(0,MB_SPLIT%RIGHT)
          CALL FMEDGE_INTERVAL_FM(MA,MB_SPLIT,MB_SPLIT1%MFM,M_6%MFM)
          CALL FMI2M(0,MB_SPLIT%LEFT)
          CALL FMEQ(MB%RIGHT,MB_SPLIT%RIGHT)
          CALL FMEDGE_INTERVAL_FM(MA,MB_SPLIT,MB_SPLIT2%MFM,M_6%MFM)
          CALL FMMIN(MB_SPLIT1%MFM,MB_SPLIT2%MFM,F_LEFT%MFM)
          KROUND = 2
          CALL FMEQ(MB%LEFT,MB_SPLIT%LEFT)
          CALL FMI2M(0,MB_SPLIT%RIGHT)
          CALL FMEDGE_INTERVAL_FM(MA,MB_SPLIT,M_6%MFM,MB_SPLIT1%MFM)
          CALL FMI2M(0,MB_SPLIT%LEFT)
          CALL FMEQ(MB%RIGHT,MB_SPLIT%RIGHT)
          CALL FMEDGE_INTERVAL_FM(MA,MB_SPLIT,M_6%MFM,MB_SPLIT2%MFM)
          CALL FMMAX(MB_SPLIT1%MFM,MB_SPLIT2%MFM,F_RIGHT%MFM)
          GO TO 110
      ENDIF
      K_ROUTINE_EDGE = 2
      KROUND = -1
      CALL FMEDGE_INTERVAL_FM(MA,MB,F_LEFT%MFM,M_6%MFM)
      KROUND = 2
      CALL FMEDGE_INTERVAL_FM(MA,MB,M_6%MFM,F_RIGHT%MFM)
  110 IF (IS_UNKNOWN(F_LEFT) .OR. IS_UNKNOWN(F_RIGHT)) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE
          CALL FMEQ(F_LEFT%MFM,RETURN_VALUE%LEFT)
          CALL FMEQ(F_RIGHT%MFM,RETURN_VALUE%RIGHT)
      ENDIF
      KROUND = KRSAVE
      KWARN = KWRNSV
      IF (F_LEFT%MFM%MP(2) == MUNKNO) THEN
          CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
      ENDIF
      IF (F_RIGHT%MFM%MP(2) == MUNKNO) THEN
          CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
      ENDIF
   END FUNCTION FMBINOMIAL_INTERVAL_FM

!                                                           FACTORIAL

   FUNCTION FMFACTORIAL_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      EXTERNAL :: FMFACT
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM,MVLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FMST2M('0.4617',MTLVFM)
      CALL FMI2M(-1,MULVFM)
      CALL FMST2M('0.4616',MVLVFM)
      IF (FMCOMP(MA%LEFT,'>=',MTLVFM)) THEN
          KROUND = -1
          CALL FMFACT(MA%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMFACT(MA%RIGHT,RETURN_VALUE%RIGHT)
      ELSE IF (FMCOMP(MA%LEFT,'>',MULVFM) .AND. FMCOMP(MA%RIGHT,'<=',MVLVFM)) THEN
          KROUND = -1
          CALL FMFACT(MA%RIGHT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMFACT(MA%LEFT,RETURN_VALUE%RIGHT)
      ELSE IF (LEFT_ENDPOINT(MA) <= -1 .AND. CEILING(LEFT_ENDPOINT(MA)) <= RIGHT_ENDPOINT(MA) ) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE
          IF (RIGHT_ENDPOINT(MA) > 10) THEN
              CALL FMEQ(MA%LEFT,MTFM_I%LEFT)
              CALL FMI2M(10,MTFM_I%RIGHT)
              CALL FM_INTERVAL_F_FM(FMFACT,MTFM_I,MUFM_I)
              CALL FMEQ(MUFM_I%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMFACT(MA%RIGHT,RETURN_VALUE%RIGHT)
              IF (FMCOMP(RETURN_VALUE%RIGHT,'<',MUFM_I%RIGHT)) THEN
                  CALL FMEQ(MUFM_I%RIGHT,RETURN_VALUE%RIGHT)
              ENDIF
          ELSE
              CALL FM_INTERVAL_F_FM(FMFACT,MA,RETURN_VALUE)
          ENDIF
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMFACTORIAL_INTERVAL_FM

!                                                               GAMMA

   FUNCTION FMGAMMA_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      EXTERNAL :: FMGAM
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM,MVLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FMST2M('1.4617',MTLVFM)
      CALL FMI2M(0,MULVFM)
      CALL FMST2M('1.4616',MVLVFM)
      IF (FMCOMP(MA%LEFT,'>=',MTLVFM)) THEN
          KROUND = -1
          CALL FMGAM(MA%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMGAM(MA%RIGHT,RETURN_VALUE%RIGHT)
      ELSE IF (FMCOMP(MA%LEFT,'>',MULVFM) .AND. FMCOMP(MA%RIGHT,'<=',MVLVFM)) THEN
          KROUND = -1
          CALL FMGAM(MA%RIGHT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMGAM(MA%LEFT,RETURN_VALUE%RIGHT)
      ELSE IF (LEFT_ENDPOINT(MA) <= 0 .AND. CEILING(LEFT_ENDPOINT(MA)) <= RIGHT_ENDPOINT(MA) ) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE
          IF (RIGHT_ENDPOINT(MA) > 10) THEN
              CALL FMEQ(MA%LEFT,MTFM_I%LEFT)
              CALL FMI2M(10,MTFM_I%RIGHT)
              CALL FM_INTERVAL_F_FM(FMGAM,MTFM_I,MUFM_I)
              CALL FMEQ(MUFM_I%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMGAM(MA%RIGHT,RETURN_VALUE%RIGHT)
              IF (FMCOMP(RETURN_VALUE%RIGHT,'<',MUFM_I%RIGHT)) THEN
                  CALL FMEQ(MUFM_I%RIGHT,RETURN_VALUE%RIGHT)
              ENDIF
          ELSE
              CALL FM_INTERVAL_F_FM(FMGAM,MA,RETURN_VALUE)
          ENDIF
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMGAMMA_INTERVAL_FM

!                                                     INCOMPLETE_BETA

   FUNCTION FMINCOMPLETE_BETA_INTERVAL_FM(MX,MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MX,MA,MB,RETURN_VALUE
      INTENT (IN) :: MX,MA,MB
      INTEGER :: KRSAVE,KWRNSV
      EXTERNAL :: FMIBTA
      CALL FM_INTERVAL_UNDEF_INP(MX)
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      KROUND = -1
      CALL FM_EQ(INCOMPLETE_BETA(LEFT_ENDPOINT(MX),RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB)),F_LEFT)
      KROUND = 2
      CALL FM_EQ(INCOMPLETE_BETA(RIGHT_ENDPOINT(MX),LEFT_ENDPOINT(MA),LEFT_ENDPOINT(MB)),F_RIGHT)
      CALL FMEQ(F_LEFT%MFM,RETURN_VALUE%LEFT)
      CALL FMEQ(F_RIGHT%MFM,RETURN_VALUE%RIGHT)
      KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMINCOMPLETE_BETA_INTERVAL_FM

!                                                   INCOMPLETE_GAMMA1

   FUNCTION FMINCOMPLETE_GAMMA1_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      INTEGER :: KRSAVE,KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      EXTERNAL :: F_EDGE
      TYPE(MULTI), SAVE :: M1LVFM,M2LVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (LEFT_ENDPOINT(MB) < 0) THEN
          CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
          CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) <= 0) THEN
          IF (IS_OVERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
              CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
              GO TO 110
          ENDIF
          CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_1)
          IF (M_1 >= LEFT_ENDPOINT(MA)) THEN
              CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
              CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
              GO TO 110
          ENDIF
      ENDIF
      IF ( ABS(RIGHT_ENDPOINT(MA)-LEFT_ENDPOINT(MA)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))) /  &
           (100*SQRT(EPSILON(TO_FM(1)))) .AND.                            &
           ABS(RIGHT_ENDPOINT(MB)-LEFT_ENDPOINT(MB)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MB)),SPACING(LEFT_ENDPOINT(MB))) /  &
           (100*SQRT(EPSILON(TO_FM(1))))) THEN
          KROUND = -1
          CALL FM_EQ(INCOMPLETE_GAMMA1(LEFT_ENDPOINT(MA), LEFT_ENDPOINT(MB)), M_1)
          CALL FM_EQ(INCOMPLETE_GAMMA1(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB)), M_2)
          CALL FM_EQ(MIN(M_1,M_2),F_LEFT)
          KROUND = 2
          CALL FM_EQ(INCOMPLETE_GAMMA1(LEFT_ENDPOINT(MA), RIGHT_ENDPOINT(MB)),M_1)
          CALL FM_EQ(INCOMPLETE_GAMMA1(RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB)),M_2)
          CALL FM_EQ(MAX(M_1,M_2),F_RIGHT)
          GO TO 110
      ENDIF

      KROUND = 1
      CALL FMIGM1(MA%LEFT,MB%LEFT,M1LVFM)
      CALL FMIGM1(MA%RIGHT,MB%LEFT,M2LVFM)
      IF (LEFT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( LEFT_ENDPOINT(MA) + ABS(LEFT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_3)
      ENDIF
      CALL FMIGM1(M_3%MFM,MB%LEFT,M_1%MFM)
      IF (RIGHT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - ABS(RIGHT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( -SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 < LEFT_ENDPOINT(MA)) THEN
              CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_3)
      ENDIF
      CALL FMIGM1(M_3%MFM,MB%LEFT,M_2%MFM)
      K_ROUTINE_EDGE = 3
      CALL FM_EQ(LEFT_ENDPOINT(MB),Y_EDGE)
      NDIG_XY_EDGE = NDIG
      IF (FMCOMP(M_1%MFM,'<=',M1LVFM) .AND. FMCOMP(M_2%MFM,'<=',M2LVFM)) THEN
          CALL FM_FIND_EXTREME_POINT(1,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,F_EDGE)
          KROUND = -1
          CALL FMIGM1(M_1%MFM,MB%LEFT,F_LEFT%MFM)
          KROUND = 2
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              CALL FMIGM1(MA%RIGHT,MB%LEFT,F_RIGHT%MFM)
          ELSE
              CALL FMIGM1(MA%LEFT,MB%LEFT,F_RIGHT%MFM)
          ENDIF
      ELSE IF (FMCOMP(M_1%MFM,'>=',M1LVFM) .AND. FMCOMP(M_2%MFM,'>=',M2LVFM)) THEN
          CALL FM_FIND_EXTREME_POINT(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,F_EDGE)
          KROUND = 2
          CALL FMIGM1(M_1%MFM,MB%LEFT,F_RIGHT%MFM)
          KROUND = -1
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              CALL FMIGM1(MA%LEFT,MB%LEFT,F_LEFT%MFM)
          ELSE
              CALL FMIGM1(MA%RIGHT,MB%LEFT,F_LEFT%MFM)
          ENDIF
      ELSE
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              KROUND = -1
              CALL FMIGM1(MA%LEFT,MB%LEFT,F_LEFT%MFM)
              KROUND = 2
              CALL FMIGM1(MA%RIGHT,MB%LEFT,F_RIGHT%MFM)
          ELSE
              KROUND = -1
              CALL FMIGM1(MA%RIGHT,MB%LEFT,F_LEFT%MFM)
              KROUND = 2
              CALL FMIGM1(MA%LEFT,MB%LEFT,F_RIGHT%MFM)
          ENDIF
      ENDIF

      KROUND = 1
      CALL FMIGM1(MA%LEFT,MB%RIGHT,M1LVFM)
      CALL FMIGM1(MA%RIGHT,MB%RIGHT,M2LVFM)
      IF (LEFT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( LEFT_ENDPOINT(MA) + ABS(LEFT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_3)
      ENDIF
      CALL FMIGM1(M_3%MFM,MB%RIGHT,M_1%MFM)
      IF (RIGHT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - ABS(RIGHT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( -SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 < LEFT_ENDPOINT(MA)) THEN
              CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_3)
      ENDIF
      CALL FMIGM1(M_3%MFM,MB%RIGHT,M_2%MFM)
      K_ROUTINE_EDGE = 3
      CALL FM_EQ(RIGHT_ENDPOINT(MB),Y_EDGE)
      NDIG_XY_EDGE = NDIG
      IF (FMCOMP(M_1%MFM,'<=',M1LVFM) .AND. FMCOMP(M_2%MFM,'<=',M2LVFM)) THEN
          CALL FM_FIND_EXTREME_POINT(1,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,F_EDGE)
          KROUND = -1
          CALL FMIGM1(M_1%MFM,MB%RIGHT,M_2%MFM)
          CALL FM_EQ(MIN(F_LEFT,M_2),F_LEFT)
          KROUND = 2
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              CALL FMIGM1(MA%RIGHT,MB%RIGHT,M_2%MFM)
          ELSE
              CALL FMIGM1(MA%LEFT,MB%RIGHT,M_2%MFM)
          ENDIF
          CALL FM_EQ(MAX(F_RIGHT,M_2),F_RIGHT)
      ELSE IF (FMCOMP(M_1%MFM,'>=',M1LVFM) .AND. FMCOMP(M_2%MFM,'>=',M2LVFM)) THEN
          CALL FM_FIND_EXTREME_POINT(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,F_EDGE)
          KROUND = 2
          CALL FMIGM1(M_1%MFM,MB%RIGHT,M_2%MFM)
          CALL FM_EQ(MAX(F_RIGHT,M_2),F_RIGHT)
          KROUND = -1
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              CALL FMIGM1(MA%LEFT,MB%RIGHT,M_2%MFM)
          ELSE
              CALL FMIGM1(MA%RIGHT,MB%RIGHT,M_2%MFM)
          ENDIF
          CALL FM_EQ(MIN(F_LEFT,M_2),F_LEFT)
      ELSE
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              KROUND = -1
              CALL FMIGM1(MA%LEFT,MB%RIGHT,M_2%MFM)
              CALL FM_EQ(MIN(F_LEFT,M_2),F_LEFT)
              KROUND = 2
              CALL FMIGM1(MA%RIGHT,MB%RIGHT,M_2%MFM)
              CALL FM_EQ(MAX(F_RIGHT,M_2),F_RIGHT)
          ELSE
              KROUND = -1
              CALL FMIGM1(MA%RIGHT,MB%RIGHT,M_2%MFM)
              CALL FM_EQ(MIN(F_LEFT,M_2),F_LEFT)
              KROUND = 2
              CALL FMIGM1(MA%LEFT,MB%RIGHT,M_2%MFM)
              CALL FM_EQ(MAX(F_RIGHT,M_2),F_RIGHT)
          ENDIF
      ENDIF
  110 IF (IS_UNKNOWN(F_LEFT) .OR. IS_UNKNOWN(F_RIGHT)) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE
          CALL FMEQ(F_LEFT%MFM,RETURN_VALUE%LEFT)
          CALL FMEQ(F_RIGHT%MFM,RETURN_VALUE%RIGHT)
      ENDIF
      KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMINCOMPLETE_GAMMA1_INTERVAL_FM

!                                                   INCOMPLETE_GAMMA2

   FUNCTION FMINCOMPLETE_GAMMA2_INTERVAL_FM(MA,MB)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,RETURN_VALUE
      INTENT (IN) :: MA,MB
      INTEGER :: KRSAVE,KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      EXTERNAL :: F_EDGE
      TYPE(MULTI), SAVE :: M1LVFM,M2LVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (LEFT_ENDPOINT(MB) < 0) THEN
          CALL FMST2M('-OVERFLOW',F_LEFT%MFM)
          CALL FMST2M(' OVERFLOW',F_RIGHT%MFM)
          GO TO 110
      ENDIF
      IF ( RIGHT_ENDPOINT(MA) == LEFT_ENDPOINT(MA) .OR.  &
           IS_UNKNOWN(RIGHT_ENDPOINT(MA)-LEFT_ENDPOINT(MA)) ) THEN
          KROUND = -1
          CALL FM_EQ(INCOMPLETE_GAMMA2(LEFT_ENDPOINT(MA), RIGHT_ENDPOINT(MB)),F_LEFT)
          KROUND = 2
          CALL FM_EQ(INCOMPLETE_GAMMA2(LEFT_ENDPOINT(MA), LEFT_ENDPOINT(MB)),F_RIGHT)
          GO TO 110
      ENDIF


      IF ( ABS(RIGHT_ENDPOINT(MA)-LEFT_ENDPOINT(MA)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))) /  &
           (100*SQRT(EPSILON(TO_FM(1)))) .AND.                            &
           ABS(RIGHT_ENDPOINT(MB)-LEFT_ENDPOINT(MB)) <=                   &
           MAX(SPACING(RIGHT_ENDPOINT(MB)),SPACING(LEFT_ENDPOINT(MB))) /  &
           (100*SQRT(EPSILON(TO_FM(1))))) THEN
          KROUND = -1
          CALL FM_EQ(INCOMPLETE_GAMMA2(LEFT_ENDPOINT(MA), RIGHT_ENDPOINT(MB)),M_1)
          CALL FM_EQ(INCOMPLETE_GAMMA2(RIGHT_ENDPOINT(MA),RIGHT_ENDPOINT(MB)),M_2)
          CALL FM_EQ(MIN(M_1,M_2),F_LEFT)
          KROUND = 2
          CALL FM_EQ(INCOMPLETE_GAMMA2(LEFT_ENDPOINT(MA), LEFT_ENDPOINT(MB)), M_1)
          CALL FM_EQ(INCOMPLETE_GAMMA2(RIGHT_ENDPOINT(MA),LEFT_ENDPOINT(MB)), M_2)
          CALL FM_EQ(MAX(M_1,M_2),F_RIGHT)
          GO TO 110
      ENDIF

      KROUND = 1
      CALL FMIGM2(MA%LEFT,MB%LEFT,M1LVFM)
      CALL FMIGM2(MA%RIGHT,MB%LEFT,M2LVFM)
      IF (LEFT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( LEFT_ENDPOINT(MA) + ABS(LEFT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_3)
      ENDIF
      CALL FMIGM2(M_3%MFM,MB%LEFT,M_1%MFM)
      IF (RIGHT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - ABS(RIGHT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( -SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 < LEFT_ENDPOINT(MA)) THEN
              CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_3)
      ENDIF
      CALL FMIGM2(M_3%MFM,MB%LEFT,M_2%MFM)
      K_ROUTINE_EDGE = 4
      CALL FM_EQ(LEFT_ENDPOINT(MB),Y_EDGE)
      NDIG_XY_EDGE = NDIG
      IF (FMCOMP(M_1%MFM,'<=',M1LVFM) .AND. FMCOMP(M_2%MFM,'<=',M2LVFM)) THEN
          CALL FM_FIND_EXTREME_POINT(1,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,F_EDGE)
          KROUND = -1
          CALL FMIGM2(M_1%MFM,MB%LEFT,F_LEFT%MFM)
          KROUND = 2
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              CALL FMIGM2(MA%RIGHT,MB%LEFT,F_RIGHT%MFM)
          ELSE
              CALL FMIGM2(MA%LEFT,MB%LEFT,F_RIGHT%MFM)
          ENDIF
      ELSE IF (FMCOMP(M_1%MFM,'>=',M1LVFM) .AND. FMCOMP(M_2%MFM,'>=',M2LVFM)) THEN
          CALL FM_FIND_EXTREME_POINT(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,F_EDGE)
          KROUND = 2
          CALL FMIGM2(M_1%MFM,MB%LEFT,F_RIGHT%MFM)
          KROUND = -1
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              CALL FMIGM2(MA%LEFT,MB%LEFT,F_LEFT%MFM)
          ELSE
              CALL FMIGM2(MA%RIGHT,MB%LEFT,F_LEFT%MFM)
          ENDIF
      ELSE
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              KROUND = -1
              CALL FMIGM2(MA%LEFT,MB%LEFT,F_LEFT%MFM)
              KROUND = 2
              CALL FMIGM2(MA%RIGHT,MB%LEFT,F_RIGHT%MFM)
          ELSE
              KROUND = -1
              CALL FMIGM2(MA%RIGHT,MB%LEFT,F_LEFT%MFM)
              KROUND = 2
              CALL FMIGM2(MA%LEFT,MB%LEFT,F_RIGHT%MFM)
          ENDIF
      ENDIF

      KROUND = 1
      CALL FMIGM2(MA%LEFT,MB%RIGHT,M1LVFM)
      CALL FMIGM2(MA%RIGHT,MB%RIGHT,M2LVFM)
      IF (LEFT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( LEFT_ENDPOINT(MA) + ABS(LEFT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_3)
      ENDIF
      CALL FMIGM2(M_3%MFM,MB%RIGHT,M_1%MFM)
      IF (RIGHT_ENDPOINT(MA) /= 0) THEN
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - ABS(RIGHT_ENDPOINT(MA))*SQRT(EPSILON(TO_FM(1))) , M_3)
      ELSE
          CALL FM_EQ( -SQRT(EPSILON(TO_FM(1))) , M_3)
          IF (M_3 < LEFT_ENDPOINT(MA)) THEN
              CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/100 , M_3)
          ENDIF
      ENDIF
      IF (IS_UNKNOWN(M_3)) THEN
          CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_3)
      ENDIF
      CALL FMIGM2(M_3%MFM,MB%RIGHT,M_2%MFM)
      K_ROUTINE_EDGE = 4
      CALL FM_EQ(RIGHT_ENDPOINT(MB),Y_EDGE)
      NDIG_XY_EDGE = NDIG
      IF (FMCOMP(M_1%MFM,'<=',M1LVFM) .AND. FMCOMP(M_2%MFM,'<=',M2LVFM)) THEN
          CALL FM_FIND_EXTREME_POINT(1,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,F_EDGE)
          KROUND = -1
          CALL FMIGM2(M_1%MFM,MB%RIGHT,M_2%MFM)
          CALL FM_EQ(MIN(F_LEFT,M_2),F_LEFT)
          KROUND = 2
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              CALL FMIGM2(MA%RIGHT,MB%RIGHT,M_2%MFM)
          ELSE
              CALL FMIGM2(MA%LEFT,MB%RIGHT,M_2%MFM)
          ENDIF
          CALL FM_EQ(MAX(F_RIGHT,M_2),F_RIGHT)
      ELSE IF (FMCOMP(M_1%MFM,'>=',M1LVFM) .AND. FMCOMP(M_2%MFM,'>=',M2LVFM)) THEN
          CALL FM_FIND_EXTREME_POINT(2,LEFT_ENDPOINT(MA),RIGHT_ENDPOINT(MA),                       &
                                     MAX(SPACING(RIGHT_ENDPOINT(MA)),SPACING(LEFT_ENDPOINT(MA))),  &
                                     M_1,M_2,F_EDGE)
          KROUND = 2
          CALL FMIGM2(M_1%MFM,MB%RIGHT,M_2%MFM)
          CALL FM_EQ(MAX(F_RIGHT,M_2),F_RIGHT)
          KROUND = -1
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              CALL FMIGM2(MA%LEFT,MB%RIGHT,M_2%MFM)
          ELSE
              CALL FMIGM2(MA%RIGHT,MB%RIGHT,M_2%MFM)
          ENDIF
          CALL FM_EQ(MIN(F_LEFT,M_2),F_LEFT)
      ELSE
          IF (FMCOMP(M1LVFM,'<',M2LVFM)) THEN
              KROUND = -1
              CALL FMIGM2(MA%LEFT,MB%RIGHT,M_2%MFM)
              CALL FM_EQ(MIN(F_LEFT,M_2),F_LEFT)
              KROUND = 2
              CALL FMIGM2(MA%RIGHT,MB%RIGHT,M_2%MFM)
              CALL FM_EQ(MAX(F_RIGHT,M_2),F_RIGHT)
          ELSE
              KROUND = -1
              CALL FMIGM2(MA%RIGHT,MB%RIGHT,M_2%MFM)
              CALL FM_EQ(MIN(F_LEFT,M_2),F_LEFT)
              KROUND = 2
              CALL FMIGM2(MA%LEFT,MB%RIGHT,M_2%MFM)
              CALL FM_EQ(MAX(F_RIGHT,M_2),F_RIGHT)
          ENDIF
      ENDIF
  110 IF (IS_UNKNOWN(F_LEFT) .OR. IS_UNKNOWN(F_RIGHT)) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE
          CALL FMEQ(F_LEFT%MFM,RETURN_VALUE%LEFT)
          CALL FMEQ(F_RIGHT%MFM,RETURN_VALUE%RIGHT)
      ENDIF
      KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMINCOMPLETE_GAMMA2_INTERVAL_FM

!                                                           LOG_GAMMA

   FUNCTION FMLOG_GAMMA_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      EXTERNAL :: FMLNGM
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM,MVLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(3) == 0 .AND. MA%RIGHT%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      CALL FMST2M('1.4617',MTLVFM)
      CALL FMI2M(0,MULVFM)
      CALL FMST2M('1.4616',MVLVFM)
      IF (FMCOMP(MA%LEFT,'>=',MTLVFM)) THEN
          KROUND = -1
          CALL FMLNGM(MA%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMLNGM(MA%RIGHT,RETURN_VALUE%RIGHT)
      ELSE IF (FMCOMP(MA%LEFT,'>=',MULVFM) .AND. FMCOMP(MA%RIGHT,'<=',MVLVFM)) THEN
          KROUND = -1
          CALL FMLNGM(MA%RIGHT,RETURN_VALUE%LEFT)
          KROUND = 2
          IF (MA%LEFT%MP(3) == 0 .OR. MA%LEFT%MP(2) == MEXPUN) THEN
              CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
          ELSE
              CALL FMLNGM(MA%LEFT,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE IF (LEFT_ENDPOINT(MA) <= 0 .AND. CEILING(LEFT_ENDPOINT(MA)) <= RIGHT_ENDPOINT(MA) ) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE IF (LEFT_ENDPOINT(MA) <= 0 .AND. MOD(CEILING(LEFT_ENDPOINT(MA)),TO_FM(2)) == 0) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
      ELSE
          IF (RIGHT_ENDPOINT(MA) > 10 .OR.  &
              (LEFT_ENDPOINT(MA) < 0.01 .AND. LEFT_ENDPOINT(MA) >= 0)) THEN
              CALL FMDP2M(0.01D0,MTLVFM)
              CALL FMMAX(MA%LEFT,MTLVFM,MTFM_I%LEFT)
              CALL FMDP2M(10.0D0,MTLVFM)
              CALL FMMIN(MA%RIGHT,MTLVFM,MTFM_I%RIGHT)
              CALL FM_INTERVAL_F_FM(FMLNGM,MTFM_I,MUFM_I)
              CALL FMEQ(MUFM_I%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              IF (MA%LEFT%MP(3) == 0 .OR. MA%LEFT%MP(2) == MEXPUN) THEN
                  CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
              ELSE
                  CALL FMLNGM(MA%LEFT,MTLVFM)
                  CALL FMLNGM(MA%RIGHT,MULVFM)
                  CALL FMMAX(MTLVFM,MULVFM,RETURN_VALUE%RIGHT)
              ENDIF
          ELSE
              CALL FM_INTERVAL_F_FM(FMLNGM,MA,RETURN_VALUE)
          ENDIF
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMLOG_GAMMA_INTERVAL_FM

!                                                           POLYGAMMA

   FUNCTION FMPOLYGAMMA_INTERVAL_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      INTEGER :: KRSAVE,KWRNSV
      EXTERNAL :: FMPGAM
      LOGICAL, EXTERNAL :: FMCOMP
      TYPE(MULTI), SAVE :: MULVFM,MVLVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (N < 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MOD(N,2) == 0) THEN
          CALL FMI2M(0,MULVFM)
          IF (FMCOMP(MA%LEFT,'>',MULVFM)) THEN
              KROUND = -1
              IF (N == 0 .AND. MA%LEFT%MP(2) == MEXPOV) THEN
                  CALL FMBIG(MVLVFM)
                  CALL FMPGAM(N,MVLVFM,RETURN_VALUE%LEFT)
              ELSE
                  CALL FMPGAM(N,MA%LEFT,RETURN_VALUE%LEFT)
              ENDIF
              KROUND = 2
              IF (N == 0 .AND. MA%RIGHT%MP(2) == MEXPOV) THEN
                  CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
              ELSE
                  CALL FMPGAM(N,MA%RIGHT,RETURN_VALUE%RIGHT)
              ENDIF
          ELSE IF (LEFT_ENDPOINT(MA) == 0 .AND. RIGHT_ENDPOINT(MA) > 0) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMPGAM(N,MA%RIGHT,RETURN_VALUE%RIGHT)
          ELSE IF (LEFT_ENDPOINT(MA) <= 0 .AND.  &
              CEILING(LEFT_ENDPOINT(MA)) <= RIGHT_ENDPOINT(MA) ) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
              CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
          ELSE
              KROUND = -1
              CALL FMPGAM(N,MA%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMPGAM(N,MA%RIGHT,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE
          CALL FMI2M(0,MULVFM)
          IF (FMCOMP(MA%LEFT,'>',MULVFM)) THEN
              KROUND = -1
              CALL FMPGAM(N,MA%RIGHT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMPGAM(N,MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE IF (LEFT_ENDPOINT(MA)<=0 .AND. CEILING(LEFT_ENDPOINT(MA))<=RIGHT_ENDPOINT(MA) ) THEN
              IF (RIGHT_ENDPOINT(MA) > 0) THEN
                  IF (LEFT_ENDPOINT(MA) <= -1) THEN
                      CALL FM_I2M(-1,M_4)
                      CALL FM_I2M(0,M_5)
                      CALL FM_EQ( SPACING(TO_FM(0.9)) , M_3)
                      CALL FM_FIND_EXTREME_POINT_IFM(1,M_4,M_5,M_3,M_1,M_2,N,FMPGAM)
                  ELSE IF (LEFT_ENDPOINT(MA) < 0) THEN
                      CALL FM_EQ( LEFT_ENDPOINT(MA) , M_4)
                      CALL FM_I2M(0,M_5)
                      CALL FM_EQ( SPACING(TO_FM(0.9)) , M_3)
                      IF (M_4 > -0.49D0) THEN
                          CALL FM_EQ(M_4,M_1)
                          CALL FMPGAM(N,M_1%MFM,M_2%MFM)
                      ELSE
                          CALL FM_FIND_EXTREME_POINT_IFM(1,M_4,M_5,M_3,M_1,M_2,N,FMPGAM)
                      ENDIF
                  ELSE
                      CALL FM_I2M(0,M_1)
                  ENDIF
                  KROUND = -1
                  CALL FMPGAM(N,MA%RIGHT,M_3%MFM)
                  IF (M_1 < 0) THEN
                      CALL FMPGAM(N,M_1%MFM,M_4%MFM)
                      CALL FM_MIN(M_3,M_4,M_5)
                      CALL FM_EQ(M_5,M_3)
                  ENDIF
                  IF (CEILING(LEFT_ENDPOINT(MA)) /= LEFT_ENDPOINT(MA)) THEN
                      CALL FMPGAM(N,MA%LEFT,M_4%MFM)
                      CALL FM_MIN(M_3,M_4,M_5)
                      CALL FM_EQ(M_5,M_3)
                  ENDIF
                  CALL FMEQ(M_3%MFM,RETURN_VALUE%LEFT)
              ELSE
                  IF (LEFT_ENDPOINT(MA) == RIGHT_ENDPOINT(MA)) THEN
                      CALL FMST2M(' OVERFLOW',RETURN_VALUE%LEFT)
                  ELSE IF (LEFT_ENDPOINT(MA) < FLOOR(RIGHT_ENDPOINT(MA))) THEN
                      CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_4)
                      CALL FM_EQ(RIGHT_ENDPOINT(MA),M_5)
                      CALL FM_EQ( SPACING(RIGHT_ENDPOINT(MA)-TO_FM(0.1)) , M_3)
                      IF (M_4 == M_5) THEN
                          CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_1)
                      ELSE IF (M_5 <= M_4+0.49D0) THEN
                          CALL FM_EQ(M_5,M_1)
                          CALL FMPGAM(N,M_1%MFM,M_2%MFM)
                      ELSE
                          CALL FM_FIND_EXTREME_POINT_IFM(1,M_4,M_5,M_3,M_1,M_2,N,FMPGAM)
                      ENDIF
                      CALL FM_EQ(MAX(FLOOR(RIGHT_ENDPOINT(MA))-1,LEFT_ENDPOINT(MA)),M_4)
                      CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_5)
                      CALL FM_EQ( SPACING(FLOOR(RIGHT_ENDPOINT(MA))-TO_FM(0.1)) , M_3)
                      IF (M_4 == M_5) THEN
                          CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_6)
                      ELSE IF (M_4 >= M_5-0.49D0) THEN
                          CALL FM_EQ(M_4,M_6)
                          CALL FMPGAM(N,M_6%MFM,M_7%MFM)
                      ELSE
                          CALL FM_FIND_EXTREME_POINT_IFM(1,M_4,M_5,M_3,M_6,M_7,N,FMPGAM)
                      ENDIF
                      KROUND = -1
                      CALL FMST2M(' OVERFLOW',M_3%MFM)
                      IF (CEILING(LEFT_ENDPOINT(MA)) /= LEFT_ENDPOINT(MA)) THEN
                          CALL FMPGAM(N,MA%LEFT,M_4%MFM)
                          CALL FM_MIN(M_3,M_4,M_5)
                          CALL FM_EQ(M_5,M_3)
                      ENDIF
                      IF (CEILING(RIGHT_ENDPOINT(MA)) /= RIGHT_ENDPOINT(MA)) THEN
                          CALL FMPGAM(N,MA%RIGHT,M_4%MFM)
                          CALL FM_MIN(M_3,M_4,M_5)
                          CALL FM_EQ(M_5,M_3)
                      ENDIF
                      IF (CEILING(M_1) /= M_1) THEN
                          CALL FMPGAM(N,M_1%MFM,M_4%MFM)
                          CALL FM_MIN(M_3,M_4,M_5)
                          CALL FM_EQ(M_5,M_3)
                      ENDIF
                      IF (CEILING(M_6) /= M_6) THEN
                          CALL FMPGAM(N,M_6%MFM,M_4%MFM)
                          CALL FM_MIN(M_3,M_4,M_5)
                          CALL FM_EQ(M_5,M_3)
                      ENDIF
                      CALL FMEQ(M_3%MFM,RETURN_VALUE%LEFT)
                  ELSE
                      CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_4)
                      CALL FM_EQ(RIGHT_ENDPOINT(MA),M_5)
                      CALL FM_EQ( SPACING(RIGHT_ENDPOINT(MA)-TO_FM(0.1)) , M_3)
                      IF (M_4 == M_5) THEN
                          CALL FM_EQ(FLOOR(RIGHT_ENDPOINT(MA)),M_6)
                      ELSE IF (M_5 <= M_4+0.49D0) THEN
                          CALL FM_EQ(M_5,M_1)
                          CALL FMPGAM(N,M_1%MFM,M_2%MFM)
                      ELSE
                          CALL FM_FIND_EXTREME_POINT_IFM(1,M_4,M_5,M_3,M_1,M_2,N,FMPGAM)
                      ENDIF
                      KROUND = -1
                      CALL FMST2M(' OVERFLOW',M_3%MFM)
                      IF (CEILING(LEFT_ENDPOINT(MA)) /= LEFT_ENDPOINT(MA)) THEN
                          CALL FMPGAM(N,MA%LEFT,M_4%MFM)
                          CALL FM_MIN(M_3,M_4,M_5)
                          CALL FM_EQ(M_5,M_3)
                      ENDIF
                      IF (CEILING(RIGHT_ENDPOINT(MA)) /= RIGHT_ENDPOINT(MA)) THEN
                          CALL FMPGAM(N,MA%RIGHT,M_4%MFM)
                          CALL FM_MIN(M_3,M_4,M_5)
                          CALL FM_EQ(M_5,M_3)
                      ENDIF
                      IF (CEILING(M_1) /= M_1) THEN
                          CALL FMPGAM(N,M_1%MFM,M_4%MFM)
                          CALL FM_MIN(M_3,M_4,M_5)
                          CALL FM_EQ(M_5,M_3)
                      ENDIF
                      CALL FMEQ(M_3%MFM,RETURN_VALUE%LEFT)
                  ENDIF
              ENDIF
              CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
          ELSE
              CALL FM_INTERVAL_F_IFM(FMPGAM,N,MA,RETURN_VALUE)
          ENDIF
      ENDIF
  110 KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMPOLYGAMMA_INTERVAL_FM

!                                                          POCHHAMMER

   FUNCTION FMPOCHHAMMER_INTERVAL_FM(MA,N)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: KRSAVE,KWRNSV,N
      INTENT (IN) :: N,MA
      EXTERNAL :: FMPOCH
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%LEFT%MP(2) == MUNKNO .OR. MA%RIGHT%MP(2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (N == 0) THEN
          CALL FMI2M(1,RETURN_VALUE%LEFT)
          CALL FMI2M(1,RETURN_VALUE%RIGHT)
          GO TO 110
      ELSE IF (N == 1) THEN
          CALL FMEQ(MA%LEFT,RETURN_VALUE%LEFT)
          CALL FMEQ(MA%RIGHT,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) >= 0 .AND. N >= 0) THEN
          KROUND = -1
          IF (MA%LEFT%MP(2) /= MEXPUN) THEN
              CALL FMPOCH(MA%LEFT,N,RETURN_VALUE%LEFT)
          ELSE
              CALL FMST2M('+UNDERFLOW',RETURN_VALUE%LEFT)
          ENDIF
          KROUND = 2
          IF (MA%RIGHT%MP(2) /= MEXPUN) THEN
              CALL FMPOCH(MA%RIGHT,N,RETURN_VALUE%RIGHT)
          ELSE
              CALL FMTINY(M_6%MFM)
              CALL FMPOCH(M_6%MFM,N,RETURN_VALUE%RIGHT)
          ENDIF
          GO TO 110
      ENDIF
      IF (RIGHT_ENDPOINT(MA) <= -N+1 .AND. N >= 0 .AND. MOD(N,2) /= 0) THEN
          KROUND = -1
          CALL FMPOCH(MA%LEFT,N,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMPOCH(MA%RIGHT,N,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (RIGHT_ENDPOINT(MA) <= -N+1 .AND. N >= 0 .AND. MOD(N,2) == 0) THEN
          KROUND = -1
          CALL FMPOCH(MA%RIGHT,N,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMPOCH(MA%LEFT,N,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (N >= 0) THEN
          CALL FM_EQ(MIN(TO_FM(0),CEILING(RIGHT_ENDPOINT(MA))),M_7)
          IF (M_7 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ(CEILING(RIGHT_ENDPOINT(MA))-1,M_7)
          ENDIF
          IF (M_7 >= LEFT_ENDPOINT(MA) .AND. M_7 <= RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ(MAX(TO_FM(-N+1),FLOOR(LEFT_ENDPOINT(MA))),M_6)
              IF (M_6 < LEFT_ENDPOINT(MA)) THEN
                  CALL FM_EQ(FLOOR(LEFT_ENDPOINT(MA))+1,M_6)
              ENDIF
              IF (M_6 >= LEFT_ENDPOINT(MA) .AND. M_6 <= RIGHT_ENDPOINT(MA) .AND. M_6 < M_7) THEN
                  IF (M_6+1 == M_7) THEN
                      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
                          IF (RIGHT_ENDPOINT(MA) < 0) THEN
                              CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,-TINY(TO_FM(1))),  &
                                                     N,M1FM_I)
                              CALL FMST2M('-UNDERFLOW',M2FM_I%RIGHT)
                              CALL FMMAX(M1FM_I%RIGHT,M2FM_I%RIGHT,M2FM_I%LEFT)
                              CALL FMEQ(M2FM_I%LEFT,M1FM_I%RIGHT)
                          ELSE
                              CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,TINY(TO_FM(1))),  &
                                                     N,M1FM_I)
                          ENDIF
                      ELSE
                          IF (M_7 == 0) THEN
                              CALL FMI2M(0,M1FM_I%LEFT)
                              KROUND = 2
                              CALL FMPOCH(MA%RIGHT,N,M1FM_I%RIGHT)
                          ELSE
                              CALL FM_INTERVAL_F_FMI(FMPOCH,                                  &
                                                     TO_FM_INTERVAL(M_7,RIGHT_ENDPOINT(MA)),  &
                                                     N,M1FM_I)
                          ENDIF
                      ENDIF
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_6,M_7),N,M2FM_I)
                      IF (M_6 == -N+1) THEN
                          IF (MOD(N,2) /= 0) THEN
                              KROUND = -1
                              CALL FMPOCH(MA%LEFT,N,M3FM_I%LEFT)
                              CALL FMI2M(0,M3FM_I%RIGHT)
                          ELSE
                              CALL FMI2M(0,M3FM_I%LEFT)
                              KROUND = 2
                              CALL FMPOCH(MA%LEFT,N,M3FM_I%RIGHT)
                          ENDIF
                      ELSE
                          CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(LEFT_ENDPOINT(MA),M_6),  &
                                                 N,M3FM_I)
                      ENDIF
                      CALL FM_EQ(MIN(LEFT_ENDPOINT(M1FM_I),LEFT_ENDPOINT(M2FM_I),  &
                                     LEFT_ENDPOINT(M3FM_I)),M_6)
                      CALL FMEQ(M_6%MFM,RETURN_VALUE%LEFT)
                      CALL FM_EQ(MAX(RIGHT_ENDPOINT(M1FM_I),RIGHT_ENDPOINT(M2FM_I),  &
                                     RIGHT_ENDPOINT(M3FM_I)),M_6)
                      CALL FMEQ(M_6%MFM,RETURN_VALUE%RIGHT)
                  ELSE IF (M_6+2 == M_7) THEN
                      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
                          IF (RIGHT_ENDPOINT(MA) < 0) THEN
                              CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,-TINY(TO_FM(1))),  &
                                                     N,M1FM_I)
                              CALL FMST2M('-UNDERFLOW',M2FM_I%RIGHT)
                              CALL FMMAX(M1FM_I%RIGHT,M2FM_I%RIGHT,M2FM_I%LEFT)
                              CALL FMEQ(M2FM_I%LEFT,M1FM_I%RIGHT)
                          ELSE
                              CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,TINY(TO_FM(1))),  &
                                                     N,M1FM_I)
                          ENDIF
                      ELSE
                          IF (M_7 == 0) THEN
                              CALL FMI2M(0,M1FM_I%LEFT)
                              KROUND = 2
                              CALL FMPOCH(MA%RIGHT,N,M1FM_I%RIGHT)
                          ELSE
                              CALL FM_INTERVAL_F_FMI(FMPOCH,                                  &
                                                     TO_FM_INTERVAL(M_7,RIGHT_ENDPOINT(MA)),  &
                                                     N,M1FM_I)
                          ENDIF
                      ENDIF
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7-1,M_7),N,M2FM_I)
                      IF (M_6 == -N+1) THEN
                          IF (MOD(N,2) /= 0) THEN
                              KROUND = -1
                              CALL FMPOCH(MA%LEFT,N,M3FM_I%LEFT)
                              CALL FMI2M(0,M3FM_I%RIGHT)
                          ELSE
                              CALL FMI2M(0,M3FM_I%LEFT)
                              KROUND = 2
                              CALL FMPOCH(MA%LEFT,N,M3FM_I%RIGHT)
                          ENDIF
                      ELSE
                          CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(LEFT_ENDPOINT(MA),M_6),  &
                                                 N,M3FM_I)
                      ENDIF
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_6,M_6+1),N,M4FM_I)
                      CALL FM_EQ(MIN(LEFT_ENDPOINT(M1FM_I),LEFT_ENDPOINT(M2FM_I),  &
                                     LEFT_ENDPOINT(M3FM_I),LEFT_ENDPOINT(M4FM_I)),M_6)
                      CALL FMEQ(M_6%MFM,RETURN_VALUE%LEFT)
                      CALL FM_EQ(MAX(RIGHT_ENDPOINT(M1FM_I),RIGHT_ENDPOINT(M2FM_I),  &
                                     RIGHT_ENDPOINT(M3FM_I),RIGHT_ENDPOINT(M4FM_I)),M_6)
                      CALL FMEQ(M_6%MFM,RETURN_VALUE%RIGHT)
                  ELSE IF (M_6+3 == M_7) THEN
                      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
                          IF (RIGHT_ENDPOINT(MA) < 0) THEN
                              CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,-TINY(TO_FM(1))),  &
                                                     N,M1FM_I)
                              CALL FMST2M('-UNDERFLOW',M2FM_I%RIGHT)
                              CALL FMMAX(M1FM_I%RIGHT,M2FM_I%RIGHT,M2FM_I%LEFT)
                              CALL FMEQ(M2FM_I%LEFT,M1FM_I%RIGHT)
                          ELSE
                              CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,TINY(TO_FM(1))),  &
                                                     N,M1FM_I)
                          ENDIF
                      ELSE
                          IF (M_7 == 0) THEN
                              CALL FMI2M(0,M1FM_I%LEFT)
                              KROUND = 2
                              CALL FMPOCH(MA%RIGHT,N,M1FM_I%RIGHT)
                          ELSE
                              CALL FM_INTERVAL_F_FMI(FMPOCH,                                  &
                                                     TO_FM_INTERVAL(M_7,RIGHT_ENDPOINT(MA)),  &
                                                     N,M1FM_I)
                          ENDIF
                      ENDIF
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7-1,M_7),N,M2FM_I)
                      CALL FM_EQ(MAX(M_7-2,LEFT_ENDPOINT(MA)),M_8)
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_8,M_7-1),N,M3FM_I)
                      IF (M_6 == -N+1) THEN
                          IF (MOD(N,2) /= 0) THEN
                              KROUND = -1
                              CALL FMPOCH(MA%LEFT,N,M4FM_I%LEFT)
                              CALL FMI2M(0,M4FM_I%RIGHT)
                          ELSE
                              CALL FMI2M(0,M4FM_I%LEFT)
                              KROUND = 2
                              CALL FMPOCH(MA%LEFT,N,M4FM_I%RIGHT)
                          ENDIF
                      ELSE
                          CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(LEFT_ENDPOINT(MA),M_6),  &
                                                 N,M4FM_I)
                      ENDIF
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_6,M_6+1),N,M5FM_I)
                      CALL FM_EQ(MIN(LEFT_ENDPOINT(M1FM_I),LEFT_ENDPOINT(M2FM_I),  &
                                     LEFT_ENDPOINT(M3FM_I),LEFT_ENDPOINT(M4FM_I),  &
                                     LEFT_ENDPOINT(M5FM_I)),M_6)
                      CALL FMEQ(M_6%MFM,RETURN_VALUE%LEFT)
                      CALL FM_EQ(MAX(RIGHT_ENDPOINT(M1FM_I),RIGHT_ENDPOINT(M2FM_I),  &
                                     RIGHT_ENDPOINT(M3FM_I),RIGHT_ENDPOINT(M4FM_I),  &
                                     RIGHT_ENDPOINT(M5FM_I)),M_6)
                      CALL FMEQ(M_6%MFM,RETURN_VALUE%RIGHT)
                  ELSE
                      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
                          IF (RIGHT_ENDPOINT(MA) < 0) THEN
                              CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,-TINY(TO_FM(1))),  &
                                                     N,M1FM_I)
                              CALL FMST2M('-UNDERFLOW',M2FM_I%RIGHT)
                              CALL FMMAX(M1FM_I%RIGHT,M2FM_I%RIGHT,M2FM_I%LEFT)
                              CALL FMEQ(M2FM_I%LEFT,M1FM_I%RIGHT)
                          ELSE
                              CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,TINY(TO_FM(1))),  &
                                                     N,M1FM_I)
                          ENDIF
                      ELSE
                          IF (M_7 == 0) THEN
                              CALL FMI2M(0,M1FM_I%LEFT)
                              KROUND = 2
                              CALL FMPOCH(MA%RIGHT,N,M1FM_I%RIGHT)
                          ELSE
                              CALL FM_INTERVAL_F_FMI(FMPOCH,                                  &
                                                     TO_FM_INTERVAL(M_7,RIGHT_ENDPOINT(MA)),  &
                                                     N,M1FM_I)
                          ENDIF
                      ENDIF
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7-1,M_7),N,M2FM_I)
                      CALL FM_EQ(MAX(M_7-2,LEFT_ENDPOINT(MA)),M_8)
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_8,M_7-1),N,M3FM_I)
                      IF (M_6 == -N+1) THEN
                          IF (MOD(N,2) /= 0) THEN
                              KROUND = -1
                              CALL FMPOCH(MA%LEFT,N,M4FM_I%LEFT)
                              CALL FMI2M(0,M4FM_I%RIGHT)
                          ELSE
                              CALL FMI2M(0,M4FM_I%LEFT)
                              KROUND = 2
                              CALL FMPOCH(MA%LEFT,N,M4FM_I%RIGHT)
                          ENDIF
                      ELSE
                          CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(LEFT_ENDPOINT(MA),M_6),  &
                                                 N,M4FM_I)
                      ENDIF
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_6,M_6+1),N,M5FM_I)
                      CALL FM_EQ(MIN(M_6+2,RIGHT_ENDPOINT(MA)),M_8)
                      CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_6+1,M_8),N,M6FM_I)
                      CALL FM_EQ(MIN(LEFT_ENDPOINT(M1FM_I),LEFT_ENDPOINT(M2FM_I),  &
                                     LEFT_ENDPOINT(M3FM_I),LEFT_ENDPOINT(M4FM_I),  &
                                     LEFT_ENDPOINT(M5FM_I),LEFT_ENDPOINT(M6FM_I)),M_6)
                      CALL FMEQ(M_6%MFM,RETURN_VALUE%LEFT)
                      CALL FM_EQ(MAX(RIGHT_ENDPOINT(M1FM_I),RIGHT_ENDPOINT(M2FM_I),  &
                                     RIGHT_ENDPOINT(M3FM_I),RIGHT_ENDPOINT(M4FM_I),  &
                                     RIGHT_ENDPOINT(M5FM_I),RIGHT_ENDPOINT(M6FM_I)),M_6)
                      CALL FMEQ(M_6%MFM,RETURN_VALUE%RIGHT)
                  ENDIF
              ELSE
                  IF (M_7 == -N+1) THEN
                      IF (MOD(N,2) /= 0) THEN
                          KROUND = -1
                          CALL FMPOCH(MA%LEFT,N,M1FM_I%LEFT)
                          CALL FMI2M(0,M1FM_I%RIGHT)
                      ELSE
                          CALL FMI2M(0,M1FM_I%LEFT)
                          KROUND = 2
                          CALL FMPOCH(MA%LEFT,N,M1FM_I%RIGHT)
                      ENDIF
                  ELSE
                      IF (MA%LEFT%MP(2) /= MEXPUN) THEN
                          CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(LEFT_ENDPOINT(MA),M_7),  &
                                                 N,M1FM_I)
                      ELSE
                          CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(-TINY(TO_FM(1)),M_7),  &
                                                 N,M1FM_I)
                      ENDIF
                  ENDIF

                  IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
                      IF (RIGHT_ENDPOINT(MA) < 0) THEN
                          CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,-TINY(TO_FM(1))),  &
                                                 N,M2FM_I)
                          CALL FMST2M('-UNDERFLOW',M3FM_I%RIGHT)
                          CALL FMMAX(M2FM_I%RIGHT,M3FM_I%RIGHT,M3FM_I%LEFT)
                          CALL FMEQ(M3FM_I%LEFT,M2FM_I%RIGHT)
                      ELSE
                          CALL FM_INTERVAL_F_FMI(FMPOCH,TO_FM_INTERVAL(M_7,TINY(TO_FM(1))),  &
                                                 N,M2FM_I)
                      ENDIF
                  ELSE
                      IF (M_7 == 0) THEN
                          CALL FMI2M(0,M2FM_I%LEFT)
                          KROUND = 2
                          CALL FMPOCH(MA%RIGHT,N,M2FM_I%RIGHT)
                      ELSE
                          CALL FM_INTERVAL_F_FMI(FMPOCH,                                  &
                                                 TO_FM_INTERVAL(M_7,RIGHT_ENDPOINT(MA)),  &
                                                 N,M2FM_I)
                      ENDIF
                  ENDIF
                  CALL FM_EQ(MIN(LEFT_ENDPOINT(M1FM_I),LEFT_ENDPOINT(M2FM_I)),M_6)
                  CALL FMEQ(M_6%MFM,RETURN_VALUE%LEFT)
                  CALL FM_EQ(MAX(RIGHT_ENDPOINT(M1FM_I),RIGHT_ENDPOINT(M2FM_I)),M_6)
                  CALL FMEQ(M_6%MFM,RETURN_VALUE%RIGHT)
              ENDIF
              GO TO 110
          ELSE
              IF (MA%LEFT%MP(2) /= MEXPUN .AND. MA%RIGHT%MP(2) /= MEXPUN) THEN
                  CALL FM_INTERVAL_F_FMI(FMPOCH,MA,N,RETURN_VALUE)
              ELSE
                  CALL FMEQ(MA%LEFT,M1FM_I%LEFT)
                  IF (MA%LEFT%MP(2) == MEXPUN) THEN
                      IF (MA%LEFT%MP(1) < 0) THEN
                          CALL FMTINY(M1FM_I%LEFT)
                          CALL FMMPYI_R1(M1FM_I%LEFT,-1)
                      ELSE
                          CALL FMTINY(M1FM_I%LEFT)
                      ENDIF
                  ENDIF
                  IF (MA%RIGHT%MP(2) == MEXPUN) THEN
                      IF (MA%RIGHT%MP(1) < 0) THEN
                          CALL FMTINY(M1FM_I%RIGHT)
                          CALL FMMPYI_R1(M1FM_I%RIGHT,-1)
                      ELSE
                          CALL FMTINY(M1FM_I%RIGHT)
                      ENDIF
                  ENDIF
                  CALL FM_INTERVAL_F_FMI(FMPOCH,M1FM_I,N,RETURN_VALUE)
                  IF (MA%RIGHT%MP(2) == MEXPUN .AND. MA%RIGHT%MP(1) < 0) THEN
                      IF (TO_FM('-UNDERFLOW') > RIGHT_ENDPOINT(RETURN_VALUE)) THEN
                          CALL FMST2M('-UNDERFLOW',RETURN_VALUE%RIGHT)
                      ENDIF
                  ENDIF
              ENDIF
              GO TO 110
          ENDIF
      ENDIF
      IF (RIGHT_ENDPOINT(MA) < 1 .AND. N < 0 .AND. MOD(N,2) == 0) THEN
          KROUND = -1
          CALL FMPOCH(MA%LEFT,N,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMPOCH(MA%RIGHT,N,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) > -N .AND. N < 0 .AND. MOD(N,2) == 0) THEN
          KROUND = -1
          CALL FMPOCH(MA%RIGHT,N,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMPOCH(MA%LEFT,N,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (RIGHT_ENDPOINT(MA) < 1 .AND. N < 0 .AND. MOD(N,2) /= 0) THEN
          KROUND = -1
          CALL FMPOCH(MA%RIGHT,N,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMPOCH(MA%LEFT,N,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) > -N .AND. N < 0 .AND. MOD(N,2) /= 0) THEN
          KROUND = -1
          CALL FMPOCH(MA%RIGHT,N,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMPOCH(MA%LEFT,N,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (N < 0) THEN
          CALL FM_EQ(MIN(TO_FM(-N),CEILING(RIGHT_ENDPOINT(MA))),M_7)
          IF (M_7 > RIGHT_ENDPOINT(MA)) THEN
              CALL FM_EQ(CEILING(RIGHT_ENDPOINT(MA))-1,M_7)
          ENDIF
          IF (M_7 >= LEFT_ENDPOINT(MA) .AND. M_7 <= RIGHT_ENDPOINT(MA)) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
              CALL FMST2M(' OVERFLOW',RETURN_VALUE%RIGHT)
              GO TO 110
          ENDIF
      ENDIF
      CALL FM_INTERVAL_F_FMI(FMPOCH,MA,N,RETURN_VALUE)
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMPOCHHAMMER_INTERVAL_FM

!                                                                 PSI

   FUNCTION FMPSI_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(FMPOLYGAMMA_INTERVAL_FM(0,MA),RETURN_VALUE)
   END FUNCTION FMPSI_INTERVAL_FM

!                                                            BESSEL_J

   FUNCTION FMBESSEL_J_INTERVAL_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      INTEGER :: KRSAVE,KWRNSV,NDSAVE
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      NDSAVE = NDIG
      IF (IS_UNKNOWN(MA)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(2) <= NDIG) THEN
          NDIG = NDIG + 2*MA%LEFT%MP(2)
          NDIG = MAX(NDSAVE,NDIG)
      ELSE IF (LEFT_ENDPOINT(MA) > 1.0D+10 .AND. RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 7  &
               .AND. MA%LEFT%MP(2) > NDIG) THEN
          NDIG = NDIG + NGRD52
      ENDIF
      CALL FMEQU(MA%LEFT,M9FM_I%LEFT,NDSAVE,NDIG)
      CALL FMEQU(MA%RIGHT,M9FM_I%RIGHT,NDSAVE,NDIG)
      IF (LEFT_ENDPOINT(M9FM_I) >= 0) THEN
          CALL FMBESJ_INTERVAL_POS(N,M9FM_I,RETURN_VALUE,NDSAVE)
      ELSE IF (RIGHT_ENDPOINT(M9FM_I) <= 0) THEN
          CALL FMABS_INTERVAL(M9FM_I,M6FM_I)
          CALL FMBESJ_INTERVAL_POS(N,M6FM_I,M5FM_I,NDSAVE)
          IF (MOD(N,2) == 0) THEN
              CALL FMEQ_INTERVAL(M5FM_I,RETURN_VALUE)
          ELSE
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(0),M7FM_I)
              CALL FMSUB_INTERVAL(M7FM_I,M5FM_I,RETURN_VALUE)
          ENDIF
      ELSE
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(LEFT_ENDPOINT(M9FM_I),TO_FM(0)),M3FM_I)
          CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
          CALL FMBESJ_INTERVAL_POS(N,M6FM_I,M5FM_I,NDSAVE)
          IF (MOD(N,2) == 0) THEN
              CALL FMEQ_INTERVAL(M5FM_I,M4FM_I)
          ELSE
              CALL FMEQ_INTERVAL(TO_FM_INTERVAL(0),M7FM_I)
              CALL FMSUB_INTERVAL(M7FM_I,M5FM_I,M4FM_I)
          ENDIF
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(M9FM_I)),M3FM_I)
          CALL FMBESJ_INTERVAL_POS(N,M3FM_I,M5FM_I,NDSAVE)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(                                             &
                             MIN(LEFT_ENDPOINT(M4FM_I),LEFT_ENDPOINT(M5FM_I)) ,          &
                             MAX(RIGHT_ENDPOINT(M4FM_I),RIGHT_ENDPOINT(M5FM_I)) ) ,      &
                             RETURN_VALUE)
      ENDIF
      KROUND = -1
      CALL FMEQU_R1(RETURN_VALUE%LEFT,NDIG,NDSAVE)
      KROUND = 2
      CALL FMEQU_R1(RETURN_VALUE%RIGHT,NDIG,NDSAVE)
  110 NDIG = NDSAVE
      KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMBESSEL_J_INTERVAL_FM

   SUBROUTINE FMBESJ_INTERVAL_POS(N,MA,MB,NDSAVE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTEGER :: N
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: J,KRSAVE,KTMAX,KTMIN,KTRIGHT,NDSAVE
      EXTERNAL :: FMBESJ
      KRSAVE = KROUND
      IF (IS_OVERFLOW(LEFT_ENDPOINT(MA))) THEN
          CALL FM_PI(M_3)
          CALL FM_EQ( (1/SQRT(M_3/2))/SQRT(HUGE(TO_FM(1))) , M_5 )
          CALL FM_EQ(-M_5,M_4)
          CALL FMEQ(M_4%MFM,MB%LEFT)
          CALL FMEQ(M_5%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF ((RIGHT_ENDPOINT(MA) == LEFT_ENDPOINT(MA) .AND.  &
          MA%LEFT%MP(2) <= MAX(3*10**5,NDSAVE))   &
          .OR. IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
          IF (N == 0) THEN
              KROUND = -1
              CALL FMBESJ(N,MA%RIGHT,MB%LEFT)
              KROUND = 2
              CALL FMBESJ(N,MA%LEFT,MB%RIGHT)
          ELSE
              KROUND = -1
              CALL FMBESJ(N,MA%LEFT,MB%LEFT)
              KROUND = 2
              CALL FMBESJ(N,MA%RIGHT,MB%RIGHT)
          ENDIF
          GO TO 120
      ENDIF
      IF (LEFT_ENDPOINT(MA) > 1.0D+10 .AND. RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 7 .AND.  &
          MA%LEFT%MP(2) > NDSAVE) THEN
          CALL FMEQ(MA%LEFT,M_4%MFM)
          CALL FM_PI(M_3)
          CALL FM_EQ( (1/SQRT(M_3/2))/SQRT(M_4) , M_5 )
          CALL FM_EQ(-M_5,M_4)
          CALL FMEQ(M_4%MFM,MB%LEFT)
          CALL FMEQ(M_5%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF ( RIGHT_ENDPOINT(MA) ** N < TINY(TO_FM(1)) ) THEN
          CALL FM_EQ( TINY(TO_FM(1)) , M_5 )
          KROUND = -1
          CALL FMBESJ(N,MA%LEFT,MB%LEFT)
          KROUND = 2
          CALL FMBESJ(N,M_5%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA) > 1.84D0) GO TO 110
      KROUND = -1
      CALL FMBESJ(N,MA%LEFT,M_1%MFM)
      IF (LEFT_ENDPOINT(MA) > 0) THEN
          IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_5 )
          ELSE
              CALL FM_EQ( LEFT_ENDPOINT(MA) * (1 + SQRT(EPSILON(TO_FM(1)))) , M_5 )
          ENDIF
      ELSE
          CALL FM_EQ( LEFT_ENDPOINT(MA) + SQRT(EPSILON(TO_FM(1))) , M_5 )
      ENDIF
      IF (M_5 < RIGHT_ENDPOINT(MA)) THEN
          CALL FMBESJ(N,M_5%MFM,M_2%MFM)
      ELSE
          CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/3 , M_5 )
          IF (IS_UNKNOWN(M_5)) THEN
              CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_5 )
              CALL FMBESJ(N,M_5%MFM,M_2%MFM)
          ELSE
              CALL FMBESJ(N,M_5%MFM,M_2%MFM)
          ENDIF
      ENDIF
      CALL FM_EQ( RIGHT_ENDPOINT(MA) * (1 - SQRT(EPSILON(TO_FM(1)))) , M_5 )
      IF (M_5 > LEFT_ENDPOINT(MA)) THEN
          CALL FMBESJ(N,M_5%MFM,M_3%MFM)
      ELSE
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/3 , M_5 )
          IF (IS_UNKNOWN(M_5)) THEN
              CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_5 )
              IF (M_5 < LEFT_ENDPOINT(MA)) CALL FM_EQ( RIGHT_ENDPOINT(MA) , M_5 )
              CALL FMBESJ(N,M_5%MFM,M_3%MFM)
          ELSE
              CALL FMBESJ(N,M_5%MFM,M_3%MFM)
          ENDIF
      ENDIF
      CALL FMBESJ(N,MA%RIGHT,M_4%MFM)
      IF (IS_UNDERFLOW(M_4)) THEN
          CALL FMEQ(M_1%MFM,MB%LEFT)
          CALL FMEQ(M_4%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF ((M_1 <= M_2 .OR. (IS_UNDERFLOW(M_1).AND.IS_UNDERFLOW(M_2))) .AND. M_3 <= M_4) THEN
          CALL FMEQ(M_1%MFM,MB%LEFT)
          KROUND = 2
          CALL FMBESJ(N,MA%RIGHT,MB%RIGHT)
      ELSE IF (M_1 >= M_2 .AND. M_3 >= M_4) THEN
          CALL FMEQ(M_4%MFM,MB%LEFT)
          KROUND = 2
          CALL FMBESJ(N,MA%LEFT,MB%RIGHT)
      ELSE IF (M_1 < M_2 .AND. M_3 > M_4) THEN
          CALL FMMIN(M_1%MFM,M_4%MFM,MB%LEFT)
          KROUND = 2
          CALL FMEQ(MA%LEFT,M_1%MFM)
          CALL FMEQ(MA%RIGHT,M_2%MFM)
          CALL FM_EQ( SPACING(MAX(RIGHT_ENDPOINT(MA),TO_FM(0.9))) , M_3)
          CALL FM_FIND_EXTREME_POINT_IFM(2,M_1,M_2,M_3,M_4,M_5,N,FMBESJ)
          CALL FMEQ(M_5%MFM,MB%RIGHT)
      ELSE IF (M_1 > M_2 .AND. M_3 < M_4) THEN
          KROUND = 2
          CALL FMBESJ(N,MA%LEFT,M_1%MFM)
          CALL FMBESJ(N,MA%RIGHT,M_4%MFM)
          CALL FMMAX(M_1%MFM,M_4%MFM,MB%RIGHT)
          KROUND = -1
          CALL FMEQ(MA%LEFT,M_1%MFM)
          CALL FMEQ(MA%RIGHT,M_2%MFM)
          CALL FM_EQ( SPACING(MAX(RIGHT_ENDPOINT(MA),TO_FM(0.9))) , M_3)
          CALL FM_FIND_EXTREME_POINT_IFM(1,M_1,M_2,M_3,M_4,M_5,N,FMBESJ)
          CALL FMEQ(M_5%MFM,MB%LEFT)
      ENDIF
      GO TO 120
  110 CALL FMEQ(MA%LEFT,M_5%MFM)
      CALL FMEQ(MA%RIGHT,M_7%MFM)
      IF (M_5+9+N+N/5 < M_7) CALL FM_EQ( M_5 + 9 + N + N/5 , M_7 )
      CALL FMBESJ(N,MA%LEFT,M_2%MFM)
      IF (LEFT_ENDPOINT(MA) > 0) THEN
          IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_5 )
          ELSE
              CALL FM_EQ( LEFT_ENDPOINT(MA) * (1 + SQRT(EPSILON(TO_FM(1)))) , M_5 )
          ENDIF
      ELSE
          CALL FM_EQ( LEFT_ENDPOINT(MA) + SQRT(EPSILON(TO_FM(1))) , M_5 )
      ENDIF
      IF (M_5 < M_7 .AND. M_5 <= LEFT_ENDPOINT(MA) + 0.2D0) THEN
          CALL FMBESJ(N,M_5%MFM,M_3%MFM)
      ELSE
          CALL FM_EQ( LEFT_ENDPOINT(MA) + (M_7 - LEFT_ENDPOINT(MA))/3 , M_5 )
          IF (M_5 >= LEFT_ENDPOINT(MA) + 0.2D0) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + 0.125D0 , M_5 )
          ENDIF
          CALL FMBESJ(N,M_5%MFM,M_3%MFM)
      ENDIF
      CALL FMDP2M(0.9D0,M_6%MFM)
      KTMAX = 0
      KTMIN = 0
      KTRIGHT = 0
      DO J = 1, MAX(1000,10+5*N)
         CALL FM_EQ(M_2,M_1)
         CALL FM_EQ(M_3,M_2)
         CALL FMADD_R1(M_5%MFM,M_6%MFM)
         IF (M_5 >= M_7) THEN
             KTRIGHT = KTRIGHT + 1
             IF (KTRIGHT == 1) THEN
                 CALL FM_EQ( M_7 * (1 - SQRT(EPSILON(TO_FM(1)))) , M_5 )
                 IF (M_5 < LEFT_ENDPOINT(MA) .OR. M_5 <= M_7 - 0.2D0) THEN
                     CALL FM_EQ( M_7 - (M_7 - LEFT_ENDPOINT(MA))/3 , &
                                 M_5 )
                     IF (M_5 <= M_7 - 0.2D0) THEN
                         CALL FM_EQ( M_7 - 0.125D0 , M_5 )
                     ENDIF
                 ENDIF
             ELSE
                 CALL FM_EQ(M_7,M_5)
             ENDIF
         ENDIF
         CALL FMBESJ(N,M_5%MFM,M_3%MFM)
         IF (M_1 <= M_2 .AND. M_2 >= M_3) THEN
             KROUND = 2
             CALL FM_SUB(M_5,M_6,M_4)
             CALL FM_SUB(M_4,M_6,M_8)
             CALL FM_EQ( SPACING(MAX(M_7,TO_FM(0.9))) , M_4)
             CALL FM_FIND_EXTREME_POINT_IFM(2,M_8,M_5,M_4,M_9,M_10,N,FMBESJ)
             KTMAX = KTMAX + 1
             CALL FMEQ(M_10%MFM,MB%RIGHT)
         ENDIF
         IF (M_1 >= M_2 .AND. M_2 <= M_3) THEN
             KROUND = -1
             CALL FM_SUB(M_5,M_6,M_4)
             CALL FM_SUB(M_4,M_6,M_8)
             CALL FM_EQ( SPACING(MAX(M_7,TO_FM(0.9))) , M_4)
             CALL FM_FIND_EXTREME_POINT_IFM(1,M_8,M_5,M_4,M_9,M_10,N,FMBESJ)
             KTMIN = KTMIN + 1
             CALL FMEQ(M_10%MFM,MB%LEFT)
         ENDIF
         IF (KTMAX > 0 .AND. KTMIN > 0) EXIT
         IF (KTRIGHT == 2) EXIT
      ENDDO
      KROUND = -1
      CALL FMBESJ(N,MA%LEFT,M_1%MFM)
      CALL FMBESJ(N,MA%RIGHT,M_2%MFM)
      IF (IS_UNKNOWN(M_2)) CALL FMI2M(2,M_2%MFM)
      CALL FM_MIN(M_1,M_2,M_3)
      IF (KTMIN > 0) THEN
          CALL FMMIN(M_3%MFM,MB%LEFT,M_4%MFM)
          CALL FMEQ(M_4%MFM,M_3%MFM)
      ENDIF
      CALL FMEQ(M_3%MFM,MB%LEFT)
      KROUND = 2
      CALL FMBESJ(N,MA%LEFT,M_1%MFM)
      CALL FMBESJ(N,MA%RIGHT,M_2%MFM)
      IF (IS_UNKNOWN(M_2)) CALL FMI2M(-2,M_2%MFM)
      CALL FM_MAX(M_1,M_2,M_3)
      IF (KTMAX > 0) THEN
          CALL FMMAX(M_3%MFM,MB%RIGHT,M_4%MFM)
          CALL FMEQ(M_4%MFM,M_3%MFM)
      ENDIF
      CALL FMEQ(M_3%MFM,MB%RIGHT)
  120 KROUND = KRSAVE
   END SUBROUTINE FMBESJ_INTERVAL_POS

!                                                                 BESSEL_J0

   FUNCTION FMBESSEL_J0_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = FMBESSEL_J_INTERVAL_FM(0,MA)
   END FUNCTION FMBESSEL_J0_INTERVAL_FM

!                                                                 BESSEL_J1

   FUNCTION FMBESSEL_J1_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = FMBESSEL_J_INTERVAL_FM(1,MA)
   END FUNCTION FMBESSEL_J1_INTERVAL_FM

!                                                                 BESSEL_JN

   FUNCTION FMBESSEL_JN_INTERVAL_FM1(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: N
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: N,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = FMBESSEL_J_INTERVAL_FM(N,MA)
   END FUNCTION FMBESSEL_JN_INTERVAL_FM1

   FUNCTION FMBESSEL_JN_INTERVAL_FM2(N1,N2,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: N1,N2
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(N2-N1+1) :: RETURN_VALUE
      INTEGER :: J
      INTENT (IN) :: N1,N2,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 0, N2-N1
         RETURN_VALUE(J+1) = FMBESSEL_J_INTERVAL_FM(N1+J,MA)
      ENDDO
   END FUNCTION FMBESSEL_JN_INTERVAL_FM2

!                                                            BESSEL_Y

   FUNCTION FMBESSEL_Y_INTERVAL_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      INTEGER :: KRSAVE,KWRNSV,NDSAVE
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      NDSAVE = NDIG
      IF (IS_UNKNOWN(MA)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(2) <= NDIG) THEN
          NDIG = NDIG + 2*MA%LEFT%MP(2)
          NDIG = MAX(NDSAVE,NDIG)
      ELSE IF (LEFT_ENDPOINT(MA) > 1.0D+10 .AND. RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 7  &
               .AND. MA%LEFT%MP(2) > NDIG) THEN
          NDIG = NDIG + NGRD52
      ENDIF
      CALL FMEQU(MA%LEFT,M9FM_I%LEFT,NDSAVE,NDIG)
      CALL FMEQU(MA%RIGHT,M9FM_I%RIGHT,NDSAVE,NDIG)
      IF (RIGHT_ENDPOINT(M9FM_I) <= 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
      ELSE IF (LEFT_ENDPOINT(M9FM_I) <= 0) THEN
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(M9FM_I)),M3FM_I)
          CALL FMBESY_INTERVAL_POS(N,M3FM_I,RETURN_VALUE,NDSAVE)
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
      ELSE
          CALL FMBESY_INTERVAL_POS(N,M9FM_I,RETURN_VALUE,NDSAVE)
      ENDIF
      KROUND = -1
      CALL FMEQU_R1(RETURN_VALUE%LEFT,NDIG,NDSAVE)
      KROUND = 2
      CALL FMEQU_R1(RETURN_VALUE%RIGHT,NDIG,NDSAVE)
  110 NDIG = NDSAVE
      KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMBESSEL_Y_INTERVAL_FM

   SUBROUTINE FMBESY_INTERVAL_POS(N,MA,MB,NDSAVE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTEGER :: N
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: J,KRSAVE,KTMAX,KTMIN,KTRIGHT,KWARNSAVE,NDSAVE
      EXTERNAL :: FMBESY
      KRSAVE = KROUND
      KWARNSAVE = KWARN
      KWARN = 0
      IF (IS_OVERFLOW(LEFT_ENDPOINT(MA))) THEN
          CALL FM_PI(M_3)
          CALL FM_EQ( (1/SQRT(M_3/2))/SQRT(HUGE(TO_FM(1))) , M_5 )
          CALL FM_EQ(-M_5,M_4)
          CALL FMEQ(M_4%MFM,MB%LEFT)
          CALL FMEQ(M_5%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
          CALL FMST2M('-OVERFLOW',MB%LEFT)
          CALL FMTINY(M_4%MFM)
          KROUND = 2
          CALL FMBESY(N,M_4%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF (RIGHT_ENDPOINT(MA) == LEFT_ENDPOINT(MA) .AND.  &
          MA%LEFT%MP(2) <= MAX(3*10**5,NDSAVE)) THEN
          KROUND = -1
          CALL FMBESY(N,MA%LEFT,MB%LEFT)
          KROUND = 2
          CALL FMBESY(N,MA%RIGHT,MB%RIGHT)
          GO TO 120
      ENDIF
      IF (LEFT_ENDPOINT(MA) > 1.0D+10 .AND. RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 7 .AND.  &
          MA%LEFT%MP(2) > NDSAVE) THEN
          CALL FMEQ(MA%LEFT,M_4%MFM)
          CALL FM_PI(M_3)
          CALL FM_EQ( (1/SQRT(M_3/2))/SQRT(M_4) , M_5 )
          CALL FM_EQ(-M_5,M_4)
          CALL FMEQ(M_4%MFM,MB%LEFT)
          CALL FMEQ(M_5%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA) > 2.19D0) GO TO 110
      KROUND = -1
      IF (LEFT_ENDPOINT(MA) == 0 .OR. IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
          CALL FMST2M('-OVERFLOW',M_1%MFM)
      ELSE
          CALL FMBESY(N,MA%LEFT,M_1%MFM)
      ENDIF
      IF (LEFT_ENDPOINT(MA) > 0) THEN
          IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_5 )
          ELSE
              CALL FM_EQ( LEFT_ENDPOINT(MA) * (1 + SQRT(EPSILON(TO_FM(1)))) , M_5 )
          ENDIF
      ELSE
          CALL FM_EQ( LEFT_ENDPOINT(MA) + SQRT(EPSILON(TO_FM(1))) , M_5 )
      ENDIF
      IF (M_5 < RIGHT_ENDPOINT(MA)) THEN
          CALL FMBESY(N,M_5%MFM,M_2%MFM)
      ELSE
          CALL FM_EQ( LEFT_ENDPOINT(MA) + (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/3 , M_5 )
          IF (IS_UNKNOWN(M_5)) THEN
              CALL FM_EQ( NEAREST(LEFT_ENDPOINT(MA),TO_FM(1)) , M_5 )
              CALL FMBESY(N,M_5%MFM,M_2%MFM)
          ELSE
              CALL FMBESY(N,M_5%MFM,M_2%MFM)
          ENDIF
      ENDIF
      CALL FM_EQ( RIGHT_ENDPOINT(MA) * (1 - SQRT(EPSILON(TO_FM(1)))) , M_5 )
      IF (M_5 > LEFT_ENDPOINT(MA)) THEN
          CALL FMBESY(N,M_5%MFM,M_3%MFM)
      ELSE
          CALL FM_EQ( RIGHT_ENDPOINT(MA) - (RIGHT_ENDPOINT(MA) - LEFT_ENDPOINT(MA))/3 , M_5 )
          IF (IS_UNKNOWN(M_5)) THEN
              CALL FM_EQ( NEAREST(RIGHT_ENDPOINT(MA),TO_FM(-1)) , M_5 )
              IF (M_5 < LEFT_ENDPOINT(MA)) CALL FM_EQ( RIGHT_ENDPOINT(MA) , M_5 )
              CALL FMBESY(N,M_5%MFM,M_3%MFM)
          ELSE
              CALL FMBESY(N,M_5%MFM,M_3%MFM)
          ENDIF
      ENDIF
      CALL FMBESY(N,MA%RIGHT,M_4%MFM)
      IF (IS_UNDERFLOW(M_4)) THEN
          CALL FMEQ(M_1%MFM,MB%LEFT)
          CALL FMEQ(M_4%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF (IS_OVERFLOW(M_1) .AND. IS_OVERFLOW(M_4)) THEN
          CALL FMEQ(M_1%MFM,MB%LEFT)
          CALL FMEQ(M_4%MFM,MB%RIGHT)
          GO TO 120
      ENDIF
      IF ((M_1 <= M_2 .OR. (IS_UNDERFLOW(M_1).AND.IS_UNDERFLOW(M_2))) .AND. M_3 <= M_4 ) THEN
          CALL FMEQ(M_1%MFM,MB%LEFT)
          KROUND = 2
          CALL FMBESY(N,MA%RIGHT,MB%RIGHT)
      ELSE IF (M_1 >= M_2 .AND. M_3 >= M_4) THEN
          CALL FMEQ(M_4%MFM,MB%LEFT)
          KROUND = 2
          CALL FMBESY(N,MA%LEFT,MB%RIGHT)
      ELSE IF (M_1 < M_2 .AND. M_3 > M_4) THEN
          CALL FMMIN(M_1%MFM,M_4%MFM,MB%LEFT)
          KROUND = 2
          CALL FMEQ(MA%LEFT,M_1%MFM)
          CALL FMEQ(MA%RIGHT,M_2%MFM)
          CALL FM_EQ( SPACING(MAX(RIGHT_ENDPOINT(MA),TO_FM(0.9))) , M_3)
          CALL FM_FIND_EXTREME_POINT_IFM(2,M_1,M_2,M_3,M_4,M_5,N,FMBESY)
          CALL FMEQ(M_5%MFM,MB%RIGHT)
      ELSE IF (M_1 > M_2 .AND. M_3 < M_4) THEN
          KROUND = 2
          CALL FMBESY(N,MA%LEFT,M_1%MFM)
          CALL FMBESY(N,MA%RIGHT,M_4%MFM)
          CALL FMMAX(M_1%MFM,M_4%MFM,MB%RIGHT)
          KROUND = -1
          CALL FMEQ(MA%LEFT,M_1%MFM)
          CALL FMEQ(MA%RIGHT,M_2%MFM)
          CALL FM_EQ( SPACING(MAX(RIGHT_ENDPOINT(MA),TO_FM(0.9))) , M_3)
          CALL FM_FIND_EXTREME_POINT_IFM(1,M_1,M_2,M_3,M_4,M_5,N,FMBESY)
          CALL FMEQ(M_5%MFM,MB%LEFT)
      ENDIF
      GO TO 120
  110 CALL FMEQ(MA%LEFT,M_5%MFM)
      CALL FMEQ(MA%RIGHT,M_7%MFM)
      IF (M_5+9+N+N/5 < M_7) CALL FM_EQ( M_5 + 9 + N + N/5 , M_7 )
      IF (M_5 == 0 .OR. IS_UNDERFLOW(M_5)) THEN
          CALL FMST2M('-OVERFLOW',M_2%MFM)
      ELSE
          CALL FMBESY(N,MA%LEFT,M_2%MFM)
      ENDIF
      IF (LEFT_ENDPOINT(MA) > 0) THEN
          IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FM_EQ( SQRT(EPSILON(TO_FM(1))) , M_5 )
          ELSE
              CALL FM_EQ( LEFT_ENDPOINT(MA) * (1 + SQRT(EPSILON(TO_FM(1)))) , M_5 )
          ENDIF
      ELSE
          CALL FM_EQ( LEFT_ENDPOINT(MA) + SQRT(EPSILON(TO_FM(1))) , M_5 )
      ENDIF
      IF (M_5 < M_7 .AND. M_5 <= LEFT_ENDPOINT(MA) + 0.2D0) THEN
          CALL FMBESY(N,M_5%MFM,M_3%MFM)
      ELSE
          CALL FM_EQ( LEFT_ENDPOINT(MA) + (M_7 - LEFT_ENDPOINT(MA))/3 , M_5 )
          IF (M_5 >= LEFT_ENDPOINT(MA) + 0.2D0) THEN
              CALL FM_EQ( LEFT_ENDPOINT(MA) + 0.125D0 , M_5 )
          ENDIF
          CALL FMBESY(N,M_5%MFM,M_3%MFM)
      ENDIF
      CALL FMDP2M(1.0D0,M_6%MFM)
      KTMAX = 0
      KTMIN = 0
      KTRIGHT = 0
      DO J = 1, MAX(1000,10+5*N)
         CALL FM_EQ(M_2,M_1)
         CALL FM_EQ(M_3,M_2)
         CALL FMADD_R1(M_5%MFM,M_6%MFM)
         IF (M_5 >= M_7) THEN
             KTRIGHT = KTRIGHT + 1
             IF (KTRIGHT == 1) THEN
                 CALL FM_EQ( M_7 * (1 - SQRT(EPSILON(TO_FM(1)))) , M_5 )
                 IF (M_5 < LEFT_ENDPOINT(MA) .OR. M_5 <= M_7 - 0.2D0) THEN
                     CALL FM_EQ( M_7 - (M_7 - LEFT_ENDPOINT(MA))/3 , M_5 )
                     IF (M_5 <= M_7 - 0.2D0) THEN
                         CALL FM_EQ( M_7 - 0.125D0 , M_5 )
                     ENDIF
                 ENDIF
             ELSE
                 CALL FM_EQ(M_7,M_5)
             ENDIF
         ENDIF
         CALL FMBESY(N,M_5%MFM,M_3%MFM)
         IF (M_1 <= M_2 .AND. M_2 >= M_3) THEN
             KROUND = 2
             CALL FM_SUB(M_5,M_6,M_4)
             CALL FM_SUB(M_4,M_6,M_8)
             CALL FM_EQ( SPACING(MAX(M_7,TO_FM(0.9))) , M_4)
             CALL FM_FIND_EXTREME_POINT_IFM(2,M_8,M_5,M_4,M_9,M_10,N,FMBESY)
             KTMAX = KTMAX + 1
             CALL FMEQ(M_10%MFM,MB%RIGHT)
         ENDIF
         IF (M_1 >= M_2 .AND. M_2 <= M_3) THEN
             KROUND = -1
             CALL FM_SUB(M_5,M_6,M_4)
             CALL FM_SUB(M_4,M_6,M_8)
             CALL FM_EQ( SPACING(MAX(M_7,TO_FM(0.9))) , M_4)
             CALL FM_FIND_EXTREME_POINT_IFM(1,M_8,M_5,M_4,M_9,M_10,N,FMBESY)
             KTMIN = KTMIN + 1
             CALL FMEQ(M_10%MFM,MB%LEFT)
         ENDIF
         IF (KTMAX > 0 .AND. KTMIN > 0) EXIT
         IF (KTRIGHT == 2) EXIT
      ENDDO
      KROUND = -1
      CALL FMBESY(N,MA%LEFT,M_1%MFM)
      IF (IS_UNKNOWN(M_1)) CALL FMST2M('-OVERFLOW',M_1%MFM)
      CALL FMBESY(N,MA%RIGHT,M_2%MFM)
      IF (IS_UNKNOWN(M_2)) CALL FMI2M(2,M_2%MFM)
      CALL FM_MIN(M_1,M_2,M_3)
      IF (KTMIN > 0) THEN
          CALL FMMIN(M_3%MFM,MB%LEFT,M_4%MFM)
          CALL FMEQ(M_4%MFM,M_3%MFM)
      ENDIF
      CALL FMEQ(M_3%MFM,MB%LEFT)
      KROUND = 2
      CALL FMBESY(N,MA%LEFT,M_1%MFM)
      IF (IS_UNKNOWN(M_1)) CALL FMST2M('-OVERFLOW',M_1%MFM)
      CALL FMBESY(N,MA%RIGHT,M_2%MFM)
      IF (IS_UNKNOWN(M_2)) CALL FMI2M(-2,M_2%MFM)
      CALL FM_MAX(M_1,M_2,M_3)
      IF (KTMAX > 0) THEN
          CALL FMMAX(M_3%MFM,MB%RIGHT,M_4%MFM)
          CALL FMEQ(M_4%MFM,M_3%MFM)
      ENDIF
      CALL FMEQ(M_3%MFM,MB%RIGHT)
  120 KROUND = KRSAVE
      KWARN = KWARNSAVE
   END SUBROUTINE FMBESY_INTERVAL_POS

!                                                                 BESSEL_Y0

   FUNCTION FMBESSEL_Y0_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = FMBESSEL_Y_INTERVAL_FM(0,MA)
   END FUNCTION FMBESSEL_Y0_INTERVAL_FM

!                                                                 BESSEL_Y1

   FUNCTION FMBESSEL_Y1_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = FMBESSEL_Y_INTERVAL_FM(1,MA)
   END FUNCTION FMBESSEL_Y1_INTERVAL_FM

!                                                                 BESSEL_YN

   FUNCTION FMBESSEL_YN_INTERVAL_FM1(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: N
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: N,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      RETURN_VALUE = FMBESSEL_Y_INTERVAL_FM(N,MA)
   END FUNCTION FMBESSEL_YN_INTERVAL_FM1

   FUNCTION FMBESSEL_YN_INTERVAL_FM2(N1,N2,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: N1,N2
      TYPE (FM_INTERVAL) :: MA
      TYPE (FM_INTERVAL), DIMENSION(N2-N1+1) :: RETURN_VALUE
      INTEGER :: J
      INTENT (IN) :: N1,N2,MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      DO J = 0, N2-N1
         RETURN_VALUE(J+1) = FMBESSEL_Y_INTERVAL_FM(N1+J,MA)
      ENDDO
   END FUNCTION FMBESSEL_YN_INTERVAL_FM2

!                                                        COS_INTEGRAL

   FUNCTION FMCOS_INTEGRAL_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV,NDSAVE
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      NDSAVE = NDIG
      IF (MA%LEFT%MP(2) <= NDIG) THEN
          NDIG = NDIG + 2*MA%LEFT%MP(2)
          NDIG = MAX(NDSAVE,NDIG)
      ELSE IF (LEFT_ENDPOINT(MA) > 1.0D+10 .AND. RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 7  &
               .AND. MA%LEFT%MP(2) > NDIG) THEN
          NDIG = NDIG + NGRD52
      ENDIF
      CALL FMEQU(MA%LEFT,M9FM_I%LEFT,NDSAVE,NDIG)
      CALL FMEQU(MA%RIGHT,M9FM_I%RIGHT,NDSAVE,NDIG)
      IF (RIGHT_ENDPOINT(M9FM_I) <= 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
      ELSE IF (LEFT_ENDPOINT(M9FM_I) <= 0) THEN
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(M9FM_I)),M3FM_I)
          CALL FMCI_INTERVAL_POS(M3FM_I,RETURN_VALUE,NDSAVE)
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
      ELSE
          CALL FMCI_INTERVAL_POS(M9FM_I,RETURN_VALUE,NDSAVE)
      ENDIF
      KROUND = -1
      CALL FMEQU_R1(RETURN_VALUE%LEFT,NDIG,NDSAVE)
      KROUND = 2
      CALL FMEQU_R1(RETURN_VALUE%RIGHT,NDIG,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV
      KROUND = KRSAVE
   END FUNCTION FMCOS_INTEGRAL_INTERVAL_FM

   SUBROUTINE FMCI_INTERVAL_POS(MA,MB,NDSAVE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV,NDSAVE
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KROUND = 1
      KWARN = 0
      CALL FM_PI(M_1)
      CALL FM_DIVI_R1(M_1,2)
      IF (IS_OVERFLOW(LEFT_ENDPOINT(MA))) THEN
          CALL FM_TINY(M_3)
          CALL FM_EQ(-M_3,M_4)
          CALL FMEQ(M_4%MFM,MB%LEFT)
          CALL FMEQ(M_3%MFM,MB%RIGHT)
          GO TO 110
      ENDIF
      IF (RIGHT_ENDPOINT(MA) == LEFT_ENDPOINT(MA) .AND.  &
          MA%LEFT%MP(2) <= MAX(3*10**5,NDSAVE)) THEN
          KROUND = -1
          CALL FMCI(MA%LEFT,MB%LEFT)
          KROUND = 2
          CALL FMCI(MA%RIGHT,MB%RIGHT)
          GO TO 110
      ENDIF
      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
          CALL FMST2M('-OVERFLOW',MB%LEFT)
          KROUND = 2
          CALL FMTINY(M_2%MFM)
          CALL FMCI(M_2%MFM,MB%RIGHT)
          GO TO 110
      ENDIF
      IF ((LEFT_ENDPOINT(MA) <= 0 .OR. IS_UNDERFLOW(LEFT_ENDPOINT(MA))) .AND.  &
          RIGHT_ENDPOINT(MA) <= M_1) THEN
          CALL FMST2M('-OVERFLOW',MB%LEFT)
          KROUND = 2
          CALL FMCI(MA%RIGHT,MB%RIGHT)
          GO TO 110
      ELSE IF ((LEFT_ENDPOINT(MA) <= 0 .OR. IS_UNDERFLOW(LEFT_ENDPOINT(MA))) .AND.  &
          RIGHT_ENDPOINT(MA) > M_1) THEN
          CALL FMST2M('-OVERFLOW',MB%LEFT)
          KROUND = 2
          CALL FMCI(M_1%MFM,MB%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) > 1.0D+10 .AND. RIGHT_ENDPOINT(MA) >= LEFT_ENDPOINT(MA) + 7 .AND.  &
          MA%LEFT%MP(2) > NDSAVE) THEN
          CALL FMEQ(MA%LEFT,M_4%MFM)
          CALL FM_EQ( 1/M_4 , M_5 )
          CALL FM_EQ(-M_5,M_4)
          CALL FMEQ(M_4%MFM,MB%LEFT)
          CALL FMEQ(M_5%MFM,MB%RIGHT)
          GO TO 110
      ENDIF
      CALL FM_EQ( FLOOR( LEFT_ENDPOINT(MA) / M_1 ) , M_2 )
      CALL FM_EQ( FLOOR( RIGHT_ENDPOINT(MA) / M_1 ) , M_3 )
      IF ( ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 0 ) .OR.  &
           ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 3 ) .OR.  &
           ( M_3 == M_2 + 1 .AND. MOD(M_2,TO_FM(4)) == 3 ) ) THEN
          KROUND = -1
          CALL FMCI(MA%LEFT,MB%LEFT)
          KROUND = 2
          CALL FMCI(MA%RIGHT,MB%RIGHT)
      ELSE IF ( ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 1 ) .OR.  &
                ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 2 ) .OR.  &
                ( M_3 == M_2 + 1 .AND. MOD(M_2,TO_FM(4)) == 1 ) ) THEN
          KROUND = -1
          CALL FMCI(MA%RIGHT,MB%LEFT)
          KROUND = 2
          CALL FMCI(MA%LEFT,MB%RIGHT)
      ELSE IF ( ( M_3 <= M_2 + 2 .AND. MOD(M_2,TO_FM(4)) == 0 ) .OR.  &
                ( M_3 <= M_2 + 3 .AND. MOD(M_2,TO_FM(4)) == 3 ) ) THEN
          KROUND = -1
          CALL FMCI(MA%LEFT,MTLVFM)
          CALL FMCI(MA%RIGHT,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MB%LEFT)
          KROUND = 1
          IF (MOD(M_3,TO_FM(4)) == 1) THEN
              CALL FM_EQ( M_1*M_3 , M_4 )
          ELSE
              CALL FM_EQ( M_1*(M_3-1) , M_4 )
          ENDIF
          KROUND = 2
          CALL FMCI(M_4%MFM,MB%RIGHT)
      ELSE IF ( ( M_3 <= M_2 + 2 .AND. MOD(M_2,TO_FM(4)) == 2 ) .OR.  &
                ( M_3 <= M_2 + 3 .AND. MOD(M_2,TO_FM(4)) == 1 ) ) THEN
          IF (MOD(M_3,TO_FM(4)) == 3) THEN
              CALL FM_EQ( M_1*M_3 , M_4 )
          ELSE
              CALL FM_EQ( M_1*(M_3-1) , M_4 )
          ENDIF
          KROUND = -1
          CALL FMCI(M_4%MFM,MB%LEFT)
          KROUND = 2
          CALL FMCI(MA%LEFT,MTLVFM)
          CALL FMCI(MA%RIGHT,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MB%RIGHT)
      ELSE
          CALL FM_EQ( CEILING( LEFT_ENDPOINT(MA) / M_1 ) , M_2 )
          CALL FM_EQ(M_2,M_3)
          IF (MOD(M_2,TO_FM(4)) == 0) THEN
              CALL FM_ADDI(M_2,3)
          ELSE IF (MOD(M_2,TO_FM(4)) == 1) THEN
              CALL FM_ADDI(M_2,2)
          ELSE IF (MOD(M_2,TO_FM(4)) == 2) THEN
              CALL FM_ADDI(M_2,1)
          ENDIF
          CALL FM_MPY_R1(M_2,M_1)
          KROUND = -1
          CALL FMCI(MA%LEFT,MTLVFM)
          CALL FMCI(M_2%MFM,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MB%LEFT)
          KROUND = 1
          IF (MOD(M_3,TO_FM(4)) == 0) THEN
              CALL FM_ADDI(M_3,1)
          ELSE IF (MOD(M_3,TO_FM(4)) == 2) THEN
              CALL FM_ADDI(M_3,3)
          ELSE IF (MOD(M_3,TO_FM(4)) == 3) THEN
              CALL FM_ADDI(M_3,2)
          ENDIF
          CALL FM_MPY_R1(M_3,M_1)
          KROUND = 2
          CALL FMCI(MA%LEFT,MTLVFM)
          CALL FMCI(M_3%MFM,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MB%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END SUBROUTINE FMCI_INTERVAL_POS

!                                                       COSH_INTEGRAL

   FUNCTION FMCOSH_INTEGRAL_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (MA%RIGHT%MP(1) < 0 .OR. MA%RIGHT%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%LEFT%MP(1) < 0 .OR. MA%LEFT%MP(3) == 0) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
      ELSE
          IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          ELSE
              KROUND = -1
              CALL FMCHI(MA%LEFT,RETURN_VALUE%LEFT)
          ENDIF
      ENDIF
      KROUND = 2
      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
          CALL FMTINY(M_1%MFM)
          CALL FMCHI(M_1%MFM,RETURN_VALUE%RIGHT)
      ELSE
          CALL FMCHI(MA%RIGHT,RETURN_VALUE%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMCOSH_INTEGRAL_INTERVAL_FM

!                                                     EXP_INTEGRAL_EI

   FUNCTION FMEXP_INTEGRAL_EI_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      IF (IS_UNKNOWN(MA)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) > 0) THEN
          KROUND = -1
          IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          ELSE
              CALL FMEI(MA%LEFT,RETURN_VALUE%LEFT)
          ENDIF
          KROUND = 2
          IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
              CALL FMTINY(M_1%MFM)
              CALL FMEI(M_1%MFM,RETURN_VALUE%RIGHT)
          ELSE
              CALL FMEI(MA%RIGHT,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE IF (RIGHT_ENDPOINT(MA) < 0) THEN
          KROUND = -1
          IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
              CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          ELSE
              CALL FMEI(MA%RIGHT,RETURN_VALUE%LEFT)
          ENDIF
          KROUND = 2
          IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
              CALL FMTINY(M_1%MFM)
              CALL FMEI(M_1%MFM,RETURN_VALUE%RIGHT)
          ELSE
              CALL FMEI(MA%LEFT,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMST2M('-OVERFLOW',M_1%MFM)
          IF (LEFT_ENDPOINT(MA) < 0) THEN
              IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
                  CALL FMTINY(M_2%MFM)
                  CALL FMEI(M_2%MFM,M_1%MFM)
              ELSE
                  CALL FMEI(MA%LEFT,M_1%MFM)
              ENDIF
          ENDIF
          CALL FMST2M('-OVERFLOW',M_2%MFM)
          IF (RIGHT_ENDPOINT(MA) > 0) THEN
              IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
                  CALL FMTINY(M_3%MFM)
                  CALL FMEI(M_3%MFM,M_2%MFM)
              ELSE
                  CALL FMEI(MA%RIGHT,M_2%MFM)
              ENDIF
          ENDIF
          CALL FMMAX(M_1%MFM,M_2%MFM,RETURN_VALUE%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMEXP_INTEGRAL_EI_INTERVAL_FM

!                                                     EXP_INTEGRAL_EN

   FUNCTION FMEXP_INTEGRAL_EN_INTERVAL_FM(N,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTEGER :: N
      INTENT (IN) :: N,MA
      INTEGER :: KWRNSV
      EXTERNAL :: FMEN
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      IF (IS_UNKNOWN(MA)) THEN
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%LEFT)
          CALL FMST2M(' UNKNOWN ',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (N >= 1) THEN
          IF (RIGHT_ENDPOINT(MA) <= 0) THEN
              CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
              CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
              IF (N > 1 .AND. RIGHT_ENDPOINT(MA) == 0) THEN
                  KROUND = -1
                  CALL FMEN(N,MA%RIGHT,RETURN_VALUE%LEFT)
                  KROUND = 2
                  CALL FMEN(N,MA%RIGHT,RETURN_VALUE%RIGHT)
              ENDIF
          ELSE IF (LEFT_ENDPOINT(MA) > 0) THEN
              KROUND = -1
              IF (N == 1 .AND. IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
                  CALL FMTINY(M_1%MFM)
                  CALL FMEN(N,M_1%MFM,RETURN_VALUE%LEFT)
              ELSE
                  CALL FMEN(N,MA%RIGHT,RETURN_VALUE%LEFT)
              ENDIF
              KROUND = 2
              IF (N == 1 .AND. IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
                  CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
              ELSE
                  CALL FMEN(N,MA%LEFT,RETURN_VALUE%RIGHT)
              ENDIF
          ELSE
              KROUND = -1
              IF (N == 1 .AND. IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
                  CALL FMTINY(M_1%MFM)
                  CALL FMEN(N,M_1%MFM,RETURN_VALUE%LEFT)
              ELSE
                  CALL FMEN(N,MA%RIGHT,RETURN_VALUE%LEFT)
              ENDIF
              IF (N == 1) THEN
                  CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
              ELSE
                  KROUND = 2
                  CALL FMI2M(0,M_1%MFM)
                  CALL FMEN(N,M_1%MFM,RETURN_VALUE%RIGHT)
              ENDIF
          ENDIF
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) > 0) THEN
          KROUND = -1
          CALL FMEN(N,MA%RIGHT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMEN(N,MA%LEFT,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) <= 0 .AND. RIGHT_ENDPOINT(MA) >= 0 .AND. MOD(-N,2) == 0) THEN
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) <= 0 .AND. RIGHT_ENDPOINT(MA) >= 0 .AND. MOD(-N,2) /= 0) THEN
          KROUND = -1
          IF (LEFT_ENDPOINT(MA) < 0) THEN
              CALL FMEN(N,MA%LEFT,M_1%MFM)
          ELSE
              CALL FMST2M('+OVERFLOW',M_1%MFM)
          ENDIF
          IF (RIGHT_ENDPOINT(MA) > 0) THEN
              CALL FMEN(N,MA%RIGHT,M_2%MFM)
          ELSE
              CALL FMST2M('+OVERFLOW',M_2%MFM)
          ENDIF
          CALL FMMIN(M_1%MFM,M_2%MFM,RETURN_VALUE%LEFT)
          CALL FMST2M('+OVERFLOW',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (RIGHT_ENDPOINT(MA) < 0 .AND. MOD(-N,2) /= 0) THEN
          KROUND = -1
          CALL FMEN(N,MA%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMEN(N,MA%RIGHT,RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (N == 0) THEN
          IF (RIGHT_ENDPOINT(MA) <= -1) THEN
              KROUND = -1
              CALL FMEN(N,MA%LEFT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMEN(N,MA%RIGHT,RETURN_VALUE%RIGHT)
          ELSE IF (LEFT_ENDPOINT(MA) >= -1) THEN
              KROUND = -1
              CALL FMEN(N,MA%RIGHT,RETURN_VALUE%LEFT)
              KROUND = 2
              CALL FMEN(N,MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE
              KROUND = -1
              CALL FMEN(N,MA%LEFT,M_1%MFM)
              CALL FMEN(N,MA%RIGHT,M_2%MFM)
              CALL FMMIN(M_1%MFM,M_2%MFM,RETURN_VALUE%LEFT)
              CALL FMI2M(-1,M_1%MFM)
              CALL FMEN(N,M_1%MFM,RETURN_VALUE%RIGHT)
          ENDIF
          GO TO 110
      ENDIF
      CALL FM_INTERVAL_F_IFM(FMEN,N,MA,RETURN_VALUE)
  110 KWARN = KWRNSV
   END FUNCTION FMEXP_INTEGRAL_EN_INTERVAL_FM

!                                                           FRESNEL_C

   FUNCTION FMFRESNEL_C_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      IF (LEFT_ENDPOINT(MA) >= 0) THEN
          CALL FMC_INTERVAL_POS(MA,RETURN_VALUE)
      ELSE IF (RIGHT_ENDPOINT(MA) <= 0) THEN
          CALL FMABS_INTERVAL(MA,M6FM_I)
          CALL FMC_INTERVAL_POS(M6FM_I,M5FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(0),M7FM_I)
          CALL FMSUB_INTERVAL(M7FM_I,M5FM_I,RETURN_VALUE)
      ELSE
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(LEFT_ENDPOINT(MA),TO_FM(0)),M3FM_I)
          CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
          CALL FMC_INTERVAL_POS(M6FM_I,M4FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(MA)),M3FM_I)
          CALL FMC_INTERVAL_POS(M3FM_I,M5FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(-RIGHT_ENDPOINT(M4FM_I),RIGHT_ENDPOINT(M5FM_I)),  &
                             RETURN_VALUE)
      ENDIF
      KWARN = KWRNSV
   END FUNCTION FMFRESNEL_C_INTERVAL_FM

   SUBROUTINE FMC_INTERVAL_POS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM
      KRSAVE = KROUND
      CALL FM_EQ( FLOOR( LEFT_ENDPOINT(MA)**2 ) , M_2 )
      CALL FM_EQ( FLOOR( RIGHT_ENDPOINT(MA)**2 ) , M_3 )
      IF ( ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 0 ) .OR.  &
           ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 3 ) .OR.  &
           ( M_3 == M_2 + 1 .AND. MOD(M_2,TO_FM(4)) == 3 ) ) THEN
          KROUND = -1
          CALL FMC(MA%LEFT,MB%LEFT)
          KROUND = 2
          CALL FMC(MA%RIGHT,MB%RIGHT)
      ELSE IF ( ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 1 ) .OR.  &
                ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 2 ) .OR.  &
                ( M_3 == M_2 + 1 .AND. MOD(M_2,TO_FM(4)) == 1 ) ) THEN
          KROUND = -1
          CALL FMC(MA%RIGHT,MB%LEFT)
          KROUND = 2
          CALL FMC(MA%LEFT,MB%RIGHT)
      ELSE IF ( ( M_3 <= M_2 + 2 .AND. MOD(M_2,TO_FM(4)) == 0 ) .OR.  &
                ( M_3 <= M_2 + 3 .AND. MOD(M_2,TO_FM(4)) == 3 ) ) THEN
          KROUND = -1
          CALL FMC(MA%LEFT,MTLVFM)
          CALL FMC(MA%RIGHT,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MB%LEFT)
          KROUND = 1
          IF (MOD(M_3,TO_FM(4)) == 1) THEN
              CALL FM_EQ( SQRT(M_3) , M_4 )
          ELSE
              CALL FM_EQ( SQRT(M_3-1) , M_4 )
          ENDIF
          KROUND = 2
          CALL FMC(M_4%MFM,MB%RIGHT)
      ELSE IF ( ( M_3 <= M_2 + 2 .AND. MOD(M_2,TO_FM(4)) == 2 ) .OR.  &
                ( M_3 <= M_2 + 3 .AND. MOD(M_2,TO_FM(4)) == 1 ) ) THEN
          IF (MOD(M_3,TO_FM(4)) == 3) THEN
              CALL FM_EQ( SQRT(M_3) , M_4 )
          ELSE
              CALL FM_EQ( SQRT(M_3-1) , M_4 )
          ENDIF
          KROUND = -1
          CALL FMC(M_4%MFM,MB%LEFT)
          KROUND = 2
          CALL FMC(MA%LEFT,MTLVFM)
          CALL FMC(MA%RIGHT,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MB%RIGHT)
      ELSE
          CALL FM_EQ( CEILING( LEFT_ENDPOINT(MA)**2 ) , M_2 )
          CALL FM_EQ(M_2,M_3)
          IF (MOD(M_2,TO_FM(4)) == 0) THEN
              CALL FM_ADDI(M_2,3)
          ELSE IF (MOD(M_2,TO_FM(4)) == 1) THEN
              CALL FM_ADDI(M_2,2)
          ELSE IF (MOD(M_2,TO_FM(4)) == 2) THEN
              CALL FM_ADDI(M_2,1)
          ENDIF
          CALL FM_SQRT_R1(M_2)
          KROUND = -1
          CALL FMC(MA%LEFT,MTLVFM)
          CALL FMC(M_2%MFM,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MB%LEFT)
          KROUND = 1
          IF (MOD(M_3,TO_FM(4)) == 0) THEN
              CALL FM_ADDI(M_3,1)
          ELSE IF (MOD(M_3,TO_FM(4)) == 2) THEN
              CALL FM_ADDI(M_3,3)
          ELSE IF (MOD(M_3,TO_FM(4)) == 3) THEN
              CALL FM_ADDI(M_3,2)
          ENDIF
          CALL FM_SQRT_R1(M_3)
          KROUND = 2
          CALL FMC(MA%LEFT,MTLVFM)
          CALL FMC(M_3%MFM,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MB%RIGHT)
          IF (3*MA%LEFT%MP(2) >= NDIG) THEN
              CALL FM_PI(M_2)
              KROUND = -1
              CALL FM_EQ(TO_FM(1)/2 - 1/(M_2*LEFT_ENDPOINT(MA)),M_3)
              CALL FMEQ(MB%LEFT,M_4%MFM)
              IF (IS_UNKNOWN(M_4)) THEN
                  CALL FMEQ(M_3%MFM,MB%LEFT)
              ELSE
                  CALL FMMIN(M_3%MFM,M_4%MFM,MB%LEFT)
              ENDIF
              KROUND = 2
              CALL FM_EQ(TO_FM(1)/2 + 1/(M_2*LEFT_ENDPOINT(MA)),M_3)
              CALL FMEQ(MB%RIGHT,M_4%MFM)
              IF (IS_UNKNOWN(M_4)) THEN
                  CALL FMEQ(M_3%MFM,MB%RIGHT)
              ELSE
                  CALL FMMAX(M_3%MFM,M_4%MFM,MB%RIGHT)
              ENDIF
          ENDIF
      ENDIF
      KROUND = KRSAVE
   END SUBROUTINE FMC_INTERVAL_POS

!                                                           FRESNEL_S

   FUNCTION FMFRESNEL_S_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      IF (LEFT_ENDPOINT(MA) >= 0) THEN
          CALL FMS_INTERVAL_POS(MA,RETURN_VALUE)
      ELSE IF (RIGHT_ENDPOINT(MA) <= 0) THEN
          CALL FMABS_INTERVAL(MA,M6FM_I)
          CALL FMS_INTERVAL_POS(M6FM_I,M5FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(0),M7FM_I)
          CALL FMSUB_INTERVAL(M7FM_I,M5FM_I,RETURN_VALUE)
      ELSE
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(LEFT_ENDPOINT(MA),TO_FM(0)),M3FM_I)
          CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
          CALL FMS_INTERVAL_POS(M6FM_I,M4FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(MA)),M3FM_I)
          CALL FMS_INTERVAL_POS(M3FM_I,M5FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(-RIGHT_ENDPOINT(M4FM_I),RIGHT_ENDPOINT(M5FM_I)),  &
                             RETURN_VALUE)
      ENDIF
      KWARN = KWRNSV
   END FUNCTION FMFRESNEL_S_INTERVAL_FM

   SUBROUTINE FMS_INTERVAL_POS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM
      KRSAVE = KROUND
      CALL FM_EQ( FLOOR( LEFT_ENDPOINT(MA)**2 ) , M_2 )
      CALL FM_EQ( FLOOR( RIGHT_ENDPOINT(MA)**2 ) , M_3 )
      IF ( ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 0 ) .OR.  &
           ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 1 ) .OR.  &
           ( M_3 == M_2 + 1 .AND. MOD(M_2,TO_FM(4)) == 0 ) ) THEN
          KROUND = -1
          CALL FMS(MA%LEFT,MB%LEFT)
          KROUND = 2
          CALL FMS(MA%RIGHT,MB%RIGHT)
      ELSE IF ( ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 2 ) .OR.  &
                ( M_3 == M_2 .AND. MOD(M_2,TO_FM(4)) == 3 ) .OR.  &
                ( M_3 == M_2 + 1 .AND. MOD(M_2,TO_FM(4)) == 2 ) ) THEN
          KROUND = -1
          CALL FMS(MA%RIGHT,MB%LEFT)
          KROUND = 2
          CALL FMS(MA%LEFT,MB%RIGHT)
      ELSE IF ( ( M_3 <= M_2 + 2 .AND. MOD(M_2,TO_FM(4)) == 1 ) .OR.  &
                ( M_3 <= M_2 + 3 .AND. MOD(M_2,TO_FM(4)) == 0 ) ) THEN
          KROUND = -1
          CALL FMS(MA%LEFT,MTLVFM)
          CALL FMS(MA%RIGHT,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MB%LEFT)
          KROUND = 1
          IF (MOD(M_3,TO_FM(4)) == 2) THEN
              CALL FM_EQ( SQRT(M_3) , M_4 )
          ELSE
              CALL FM_EQ( SQRT(M_3-1) , M_4 )
          ENDIF
          KROUND = 2
          CALL FMS(M_4%MFM,MB%RIGHT)
      ELSE IF ( ( M_3 <= M_2 + 2 .AND. MOD(M_2,TO_FM(4)) == 3 ) .OR.  &
                ( M_3 <= M_2 + 3 .AND. MOD(M_2,TO_FM(4)) == 2 ) ) THEN
          IF (MOD(M_3,TO_FM(4)) == 0) THEN
              CALL FM_EQ( SQRT(M_3) , M_4 )
          ELSE
              CALL FM_EQ( SQRT(M_3-1) , M_4 )
          ENDIF
          KROUND = -1
          CALL FMS(M_4%MFM,MB%LEFT)
          KROUND = 2
          CALL FMS(MA%LEFT,MTLVFM)
          CALL FMS(MA%RIGHT,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MB%RIGHT)
      ELSE
          CALL FM_EQ( CEILING( LEFT_ENDPOINT(MA)**2 ) , M_2 )
          CALL FM_EQ(M_2,M_3)
          IF (M_2 == 0) THEN
              CALL FM_ADDI(M_2,4)
          ELSE IF (MOD(M_2,TO_FM(4)) == 1) THEN
              CALL FM_ADDI(M_2,3)
          ELSE IF (MOD(M_2,TO_FM(4)) == 2) THEN
              CALL FM_ADDI(M_2,2)
          ELSE IF (MOD(M_2,TO_FM(4)) == 3) THEN
              CALL FM_ADDI(M_2,1)
          ENDIF
          CALL FM_SQRT_R1(M_2)
          KROUND = -1
          CALL FMS(MA%LEFT,MTLVFM)
          CALL FMS(M_2%MFM,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MB%LEFT)
          KROUND = 1
          IF (M_3 == 0) THEN
              CALL FM_ADDI(M_3,2)
          ELSE IF (MOD(M_3,TO_FM(4)) == 1) THEN
              CALL FM_ADDI(M_3,1)
          ELSE IF (MOD(M_3,TO_FM(4)) == 3) THEN
              CALL FM_ADDI(M_3,3)
          ELSE IF (MOD(M_3,TO_FM(4)) == 0) THEN
              CALL FM_ADDI(M_3,2)
          ENDIF
          CALL FM_SQRT_R1(M_3)
          KROUND = 2
          CALL FMS(MA%LEFT,MTLVFM)
          CALL FMS(M_3%MFM,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MB%RIGHT)
          IF (3*MA%LEFT%MP(2) >= NDIG) THEN
              CALL FM_PI(M_2)
              KROUND = -1
              CALL FM_EQ(TO_FM(1)/2 - 1/(M_2*LEFT_ENDPOINT(MA)),M_3)
              CALL FMEQ(MB%LEFT,M_4%MFM)
              IF (IS_UNKNOWN(M_4)) THEN
                  CALL FMEQ(M_3%MFM,MB%LEFT)
              ELSE
                  CALL FMMIN(M_3%MFM,M_4%MFM,MB%LEFT)
              ENDIF
              KROUND = 2
              CALL FM_EQ(TO_FM(1)/2 + 1/(M_2*LEFT_ENDPOINT(MA)),M_3)
              CALL FMEQ(MB%RIGHT,M_4%MFM)
              IF (IS_UNKNOWN(M_4)) THEN
                  CALL FMEQ(M_3%MFM,MB%RIGHT)
              ELSE
                  CALL FMMAX(M_3%MFM,M_4%MFM,MB%RIGHT)
              ENDIF
          ENDIF
      ENDIF
      KROUND = KRSAVE
   END SUBROUTINE FMS_INTERVAL_POS

!                                                                 ERF

   FUNCTION FMERF_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KRSAVE = KROUND
      KWRNSV = KWARN
      KWARN = 0
      KROUND = -1
      IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
          IF (LEFT_ENDPOINT(MA) > 0) THEN
              CALL FMST2M("+UNDERFLOW",RETURN_VALUE%LEFT)
          ELSE
              CALL FMTINY(M_1%MFM)
              M_1%MFM%MP(1) = -M_1%MFM%MP(1)
              CALL FMERF(M_1%MFM,RETURN_VALUE%LEFT)
          ENDIF
      ELSE
          CALL FMERF(MA%LEFT,RETURN_VALUE%LEFT)
      ENDIF
      KROUND = 2
      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
          IF (RIGHT_ENDPOINT(MA) > 0) THEN
              CALL FMTINY(M_1%MFM)
              CALL FMERF(M_1%MFM,RETURN_VALUE%RIGHT)
          ELSE
              CALL FMST2M("-UNDERFLOW",RETURN_VALUE%RIGHT)
          ENDIF
      ELSE
          CALL FMERF(MA%RIGHT,RETURN_VALUE%RIGHT)
      ENDIF
      KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMERF_INTERVAL_FM

!                                                                ERFC

   FUNCTION FMERFC_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      KROUND = -1
      CALL FMERFC(MA%RIGHT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMERFC(MA%LEFT,RETURN_VALUE%RIGHT)
      KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMERFC_INTERVAL_FM

!                                                            LOG_ERFC

   FUNCTION FMLOG_ERFC_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      KROUND = -1
      IF (IS_UNDERFLOW(RIGHT_ENDPOINT(MA))) THEN
          IF (RIGHT_ENDPOINT(MA) > 0) THEN
              CALL FM_EQ( TINY(TO_FM(1)) , M_5 )
              CALL FMLERC(M_5%MFM,RETURN_VALUE%LEFT)
          ELSE
              CALL FMST2M('UNDERFLOW',RETURN_VALUE%LEFT)
          ENDIF
      ELSE
          CALL FMLERC(MA%RIGHT,RETURN_VALUE%LEFT)
      ENDIF

      KROUND = 2
      IF (IS_UNDERFLOW(LEFT_ENDPOINT(MA))) THEN
          IF (LEFT_ENDPOINT(MA) < 0) THEN
              CALL FM_EQ( -TINY(TO_FM(1)) , M_5 )
              CALL FMLERC(M_5%MFM,RETURN_VALUE%RIGHT)
          ELSE
              CALL FMST2M('-UNDERFLOW',RETURN_VALUE%RIGHT)
          ENDIF
      ELSE
          CALL FMLERC(MA%LEFT,RETURN_VALUE%RIGHT)
      ENDIF
      KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMLOG_ERFC_INTERVAL_FM

!                                                        LOG_INTEGRAL

   FUNCTION FMLOG_INTEGRAL_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      IF (MA%RIGHT%MP(1) < 0 .OR. MA%RIGHT%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',RETURN_VALUE%LEFT)
          CALL FMST2M('UNKNOWN',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (IS_OVERFLOW(LEFT_ENDPOINT(MA))) THEN
          KROUND = -1
          CALL FM_EQ( HUGE(TO_FM(1)) , M_5 )
          CALL FMLI(M_5%MFM,RETURN_VALUE%LEFT)
          CALL FMST2M('OVERFLOW',RETURN_VALUE%RIGHT)
          GO TO 110
      ENDIF
      IF (LEFT_ENDPOINT(MA) > 1) THEN
          KROUND = -1
          CALL FMLI(MA%LEFT,RETURN_VALUE%LEFT)
          KROUND = 2
          IF (IS_OVERFLOW(RIGHT_ENDPOINT(MA))) THEN
              CALL FMST2M('OVERFLOW',RETURN_VALUE%RIGHT)
          ELSE
              CALL FMLI(MA%RIGHT,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE IF (RIGHT_ENDPOINT(MA) < 1) THEN
          KROUND = -1
          CALL FMLI(MA%RIGHT,RETURN_VALUE%LEFT)
          KROUND = 2
          IF (LEFT_ENDPOINT(MA) > 0) THEN
              CALL FMLI(MA%LEFT,RETURN_VALUE%RIGHT)
          ELSE
              CALL FMI2M(0,RETURN_VALUE%RIGHT)
          ENDIF
      ELSE
          CALL FMST2M('-OVERFLOW',RETURN_VALUE%LEFT)
          KROUND = 2
          CALL FMST2M('-OVERFLOW',M_1%MFM)
          IF (LEFT_ENDPOINT(MA) <= 0) CALL FMI2M(0,M_1%MFM)
          IF (LEFT_ENDPOINT(MA) > 0 .AND. LEFT_ENDPOINT(MA) < 1) CALL FMLI(MA%LEFT,M_1%MFM)
          CALL FMST2M('-OVERFLOW',M_2%MFM)
          IF (RIGHT_ENDPOINT(MA) > 1) THEN
              IF (IS_OVERFLOW(RIGHT_ENDPOINT(MA))) THEN
                  CALL FMST2M('OVERFLOW',M_2%MFM)
              ELSE
                  CALL FMLI(MA%RIGHT,M_2%MFM)
              ENDIF
          ENDIF
          CALL FMMAX(M_1%MFM,M_2%MFM,RETURN_VALUE%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMLOG_INTEGRAL_INTERVAL_FM

!                                                        SIN_INTEGRAL

   FUNCTION FMSIN_INTEGRAL_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      IF (LEFT_ENDPOINT(MA) >= 0) THEN
          CALL FMSI_INTERVAL_POS(MA,RETURN_VALUE)
      ELSE IF (RIGHT_ENDPOINT(MA) <= 0) THEN
          CALL FMABS_INTERVAL(MA,M6FM_I)
          CALL FMSI_INTERVAL_POS(M6FM_I,M5FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(0),M7FM_I)
          CALL FMSUB_INTERVAL(M7FM_I,M5FM_I,RETURN_VALUE)
      ELSE
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(LEFT_ENDPOINT(MA),TO_FM(0)),M3FM_I)
          CALL FMABS_INTERVAL(M3FM_I,M6FM_I)
          CALL FMSI_INTERVAL_POS(M6FM_I,M4FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(TO_FM(0),RIGHT_ENDPOINT(MA)),M3FM_I)
          CALL FMSI_INTERVAL_POS(M3FM_I,M5FM_I)
          CALL FMEQ_INTERVAL(TO_FM_INTERVAL(-RIGHT_ENDPOINT(M4FM_I),RIGHT_ENDPOINT(M5FM_I)),  &
                             RETURN_VALUE)
      ENDIF
      KWARN = KWRNSV
   END FUNCTION FMSIN_INTEGRAL_INTERVAL_FM

   SUBROUTINE FMSI_INTERVAL_POS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: KRSAVE,KRAD_SAVE
      TYPE(MULTI), SAVE :: MTLVFM,MULVFM
      KRSAVE = KROUND
      KROUND = 1
      CALL FM_PI(M_1)
      IF (IS_OVERFLOW(LEFT_ENDPOINT(MA))) THEN
          KROUND = -1
          KRAD_SAVE = KRAD
          KRAD = 1
          CALL FM_I2M(1,M_1)
          CALL FMASIN(M_1%MFM,MB%LEFT)
          KROUND = 2
          CALL FMASIN(M_1%MFM,MB%RIGHT)
          KRAD = KRAD_SAVE
          GO TO 110
      ENDIF
      CALL FM_EQ( FLOOR( LEFT_ENDPOINT(MA) / M_1 ) , M_2 )
      CALL FM_EQ( FLOOR( RIGHT_ENDPOINT(MA) / M_1 ) , M_3 )
      IF ( M_3 == M_2 .AND. MOD(M_2,TO_FM(2)) == 0 ) THEN
          KROUND = -1
          CALL FMSI(MA%LEFT,MB%LEFT)
          KROUND = 2
          CALL FMSI(MA%RIGHT,MB%RIGHT)
      ELSE IF ( M_3 == M_2 .AND. MOD(M_2,TO_FM(2)) == 1 ) THEN
          KROUND = -1
          CALL FMSI(MA%RIGHT,MB%LEFT)
          KROUND = 2
          CALL FMSI(MA%LEFT,MB%RIGHT)
      ELSE IF ( M_3 == M_2 + 1 .AND. MOD(M_2,TO_FM(2)) == 0 ) THEN
          KROUND = -1
          CALL FMSI(MA%LEFT,MTLVFM)
          CALL FMSI(MA%RIGHT,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MB%LEFT)
          KROUND = 1
          CALL FM_EQ( M_1*M_3 , M_4 )
          KROUND = 2
          CALL FMSI(M_4%MFM,MB%RIGHT)
      ELSE IF ( M_3 == M_2 + 1 .AND. MOD(M_2,TO_FM(2)) == 1 ) THEN
          CALL FM_EQ( M_1*M_3 , M_4 )
          KROUND = -1
          CALL FMSI(M_4%MFM,MB%LEFT)
          KROUND = 2
          CALL FMSI(MA%LEFT,MTLVFM)
          CALL FMSI(MA%RIGHT,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MB%RIGHT)
      ELSE
          CALL FM_EQ( CEILING( LEFT_ENDPOINT(MA) / M_1 ) , M_2 )
          CALL FM_EQ(M_2,M_3)
          IF (MOD(M_2,TO_FM(2)) == 1) THEN
              CALL FM_ADDI(M_2,1)
          ENDIF
          CALL FM_MPY_R1(M_2,M_1)
          KROUND = -1
          CALL FMSI(MA%LEFT,MTLVFM)
          CALL FMSI(M_2%MFM,MULVFM)
          CALL FMMIN(MTLVFM,MULVFM,MB%LEFT)
          KROUND = 1
          IF (MOD(M_3,TO_FM(2)) == 0) THEN
              CALL FM_ADDI(M_3,1)
          ENDIF
          CALL FM_MPY_R1(M_3,M_1)
          KROUND = 2
          CALL FMSI(MA%LEFT,MTLVFM)
          CALL FMSI(M_3%MFM,MULVFM)
          CALL FMMAX(MTLVFM,MULVFM,MB%RIGHT)
      ENDIF
  110 KROUND = KRSAVE
   END SUBROUTINE FMSI_INTERVAL_POS

!                                                       SINH_INTEGRAL

   FUNCTION FMSINH_INTEGRAL_INTERVAL_FM(MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,RETURN_VALUE
      INTENT (IN) :: MA
      INTEGER :: KRSAVE,KWRNSV
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KWRNSV = KWARN
      KWARN = 0
      KRSAVE = KROUND
      KROUND = -1
      CALL FMSHI(MA%LEFT,RETURN_VALUE%LEFT)
      KROUND = 2
      CALL FMSHI(MA%RIGHT,RETURN_VALUE%RIGHT)
      KROUND = KRSAVE
      KWARN = KWRNSV
   END FUNCTION FMSINH_INTEGRAL_INTERVAL_FM

 END MODULE FM_INTERVAL_ARITHMETIC_9

 MODULE FM_INTERVAL_ARITHMETIC_10
    USE FM_INTERVAL_ARITHMETIC_1

    CONTAINS

! Interface routines for calling with the FM_INTERVAL derived type.

   SUBROUTINE FM_INTERVAL_ADD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMADD_INTERVAL(MA,MB,MC)
   END SUBROUTINE FM_INTERVAL_ADD

   SUBROUTINE FM_INTERVAL_ADD_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMADD_INTERVAL_R1(MA,MB)
   END SUBROUTINE FM_INTERVAL_ADD_R1

   SUBROUTINE FM_INTERVAL_ADD_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMADD_INTERVAL_R2(MA,MB)
   END SUBROUTINE FM_INTERVAL_ADD_R2

   SUBROUTINE FM_INTERVAL_ADDI(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMADDI_INTERVAL(MA,IVAL)
   END SUBROUTINE FM_INTERVAL_ADDI

   SUBROUTINE FM_INTERVAL_DIV(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMDIV_INTERVAL(MA,MB,MC)
   END SUBROUTINE FM_INTERVAL_DIV

   SUBROUTINE FM_INTERVAL_DIV_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMDIV_INTERVAL_R1(MA,MB)
   END SUBROUTINE FM_INTERVAL_DIV_R1

   SUBROUTINE FM_INTERVAL_DIV_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMDIV_INTERVAL_R2(MA,MB)
   END SUBROUTINE FM_INTERVAL_DIV_R2

   SUBROUTINE FM_INTERVAL_DIVI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDIVI_INTERVAL(MA,IVAL,MB)
   END SUBROUTINE FM_INTERVAL_DIVI

   SUBROUTINE FM_INTERVAL_DIVI_R1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMDIVI_INTERVAL_R1(MA,IVAL)
   END SUBROUTINE FM_INTERVAL_DIVI_R1

   SUBROUTINE FM_INTERVAL_DP2M(X,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      DOUBLE PRECISION :: X
      INTENT (IN) :: X
      CALL FMDP2M_INTERVAL(X,MA)
   END SUBROUTINE FM_INTERVAL_DP2M

   SUBROUTINE FM_INTERVAL_EPSILON(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMI2M_INTERVAL(1,MTFM_I)
      CALL FMULP_INTERVAL(MTFM_I,MB)
   END SUBROUTINE FM_INTERVAL_EPSILON

   SUBROUTINE FM_INTERVAL_EQ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMEQ_INTERVAL(MA,MB)
   END SUBROUTINE FM_INTERVAL_EQ

   SUBROUTINE FM_INTERVAL_EQU(MA,MB,NA,NB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KA,KB,NA,NB,NDSAVE
      INTENT (IN) :: NA,NB
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      KA = NA
      KB = NB
      NDSAVE = NDIG
      NDIG = KA
      CALL FMEQU_INTERVAL(MA,MB,KA,KB)
      NDIG = NDSAVE
   END SUBROUTINE FM_INTERVAL_EQU

   SUBROUTINE FM_INTERVAL_FORM(FORM,MA,STRING)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM,STRING
      INTENT (IN) :: FORM
      INTENT (INOUT) :: STRING
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMFORM_INTERVAL(FORM,MA,STRING)
   END SUBROUTINE FM_INTERVAL_FORM

   SUBROUTINE FM_INTERVAL_MPY(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMMPY_INTERVAL(MA,MB,MC)
   END SUBROUTINE FM_INTERVAL_MPY

   SUBROUTINE FM_INTERVAL_MPY_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMMPY_INTERVAL_R1(MA,MB)
   END SUBROUTINE FM_INTERVAL_MPY_R1

   SUBROUTINE FM_INTERVAL_MPY_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMMPY_INTERVAL_R2(MA,MB)
   END SUBROUTINE FM_INTERVAL_MPY_R2

   SUBROUTINE FM_INTERVAL_MPYI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMMPYI_INTERVAL(MA,IVAL,MB)
   END SUBROUTINE FM_INTERVAL_MPYI

   SUBROUTINE FM_INTERVAL_MPYI_R1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMMPYI_INTERVAL_R1(MA,IVAL)
   END SUBROUTINE FM_INTERVAL_MPYI_R1

   SUBROUTINE FM_INTERVAL_READ(KREAD,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KREAD
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      CALL FMREAD_INTERVAL(KREAD,MA)
   END SUBROUTINE FM_INTERVAL_READ

   SUBROUTINE FM_INTERVAL_WRITE(KWRITE,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KWRITE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: KWRITE
      INTENT (INOUT) :: MA
      CALL FMWRITE_INTERVAL(KWRITE,MA)
   END SUBROUTINE FM_INTERVAL_WRITE

   SUBROUTINE FM_INTERVAL_RPWR(MA,IVAL,JVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: IVAL,JVAL
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMRPWR_INTERVAL(MA,IVAL,JVAL,MB)
   END SUBROUTINE FM_INTERVAL_RPWR

   SUBROUTINE FM_INTERVAL_SP2M(X,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      REAL :: X
      INTENT (IN) :: X
      CALL FMSP2M_INTERVAL(X,MA)
   END SUBROUTINE FM_INTERVAL_SP2M

   SUBROUTINE FM_INTERVAL_SQRT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSQRT_INTERVAL(MA,MB)
   END SUBROUTINE FM_INTERVAL_SQRT

   SUBROUTINE FM_INTERVAL_SQRT_R1(MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMSQRT_INTERVAL_R1(MA)
   END SUBROUTINE FM_INTERVAL_SQRT_R1

   SUBROUTINE FM_INTERVAL_ST2M(STRING,MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (INOUT) :: MA
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      CALL FMST2M_INTERVAL(STRING,MA)
   END SUBROUTINE FM_INTERVAL_ST2M

   SUBROUTINE FM_INTERVAL_SUB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMSUB_INTERVAL(MA,MB,MC)
   END SUBROUTINE FM_INTERVAL_SUB

   SUBROUTINE FM_INTERVAL_SUB_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MB
      INTENT (INOUT) :: MA
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMSUB_INTERVAL_R1(MA,MB)
   END SUBROUTINE FM_INTERVAL_SUB_R1

   SUBROUTINE FM_INTERVAL_SUB_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL FMSUB_INTERVAL_R2(MA,MB)
   END SUBROUTINE FM_INTERVAL_SUB_R2

   SUBROUTINE FM_INTERVAL_ULP(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FMULP_INTERVAL(MA,MB)
   END SUBROUTINE FM_INTERVAL_ULP

   SUBROUTINE IM_INTERVAL_FM2I(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      TYPE (IM) :: MB
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_UNDEF_INP(MB)
      CALL IMFM2I_INTERVAL(MA,MB%MIM)
   END SUBROUTINE IM_INTERVAL_FM2I

   SUBROUTINE IM_INTERVAL_I2FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (IM) :: MA
      INTENT (IN) :: MA
      TYPE (FM_INTERVAL) :: MB
      INTENT (INOUT) :: MB
      CALL FM_UNDEF_INP(MA)
      CALL IMI2FM_INTERVAL(MA%MIM,MB)
   END SUBROUTINE IM_INTERVAL_I2FM

   SUBROUTINE ZM_INTERVAL_CMPX(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTENT (IN) :: MA,MB
      TYPE (ZM) :: MC
      INTENT (INOUT) :: MC
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_UNDEF_INP(MB)
      CALL ZMCMPX_INTERVAL(MA,MB,MC)
   END SUBROUTINE ZM_INTERVAL_CMPX


   SUBROUTINE FM_INTERVAL_RATIONAL_POWER(MA,IVAL,JVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      CALL FM_INTERVAL_UNDEF_INP(MA)
      CALL FM_INTERVAL_RPWR(MA,IVAL,JVAL,MB)
   END SUBROUTINE FM_INTERVAL_RATIONAL_POWER

   SUBROUTINE ZM_INTERVAL_COMPLEX(MAFM,MBFM,MC)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MAFM,MBFM
      TYPE (ZM) :: MC
      INTENT (IN) :: MAFM,MBFM
      INTENT (INOUT) :: MC
      CALL FM_INTERVAL_UNDEF_INP(MAFM)
      CALL FM_INTERVAL_UNDEF_INP(MBFM)
      CALL ZM_INTERVAL_CMPX(MAFM,MBFM,MC)
   END SUBROUTINE ZM_INTERVAL_COMPLEX

   SUBROUTINE FMADDI_INTERVAL(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      CALL FMI2M(IVAL,MTFM_I%LEFT)
      CALL FMI2M(IVAL,MTFM_I%RIGHT)
      CALL FMADD_INTERVAL(MA,MTFM_I,MUFM_I)
      CALL FMEQ(MUFM_I%LEFT,MA%LEFT)
      CALL FMEQ(MUFM_I%RIGHT,MA%RIGHT)
   END SUBROUTINE FMADDI_INTERVAL

   FUNCTION FMFORMAT2(FMT,MA)     RESULT (RETURN_VALUE)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FMT
      TYPE(MULTI) :: MA
      CHARACTER(200) :: RETURN_VALUE
      INTENT (IN) :: FMT,MA
      CALL FMFORM(FMT,MA,RETURN_VALUE)
   END FUNCTION FMFORMAT2

   SUBROUTINE FMFORM_INTERVAL(FORM,MA,STRING)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM,STRING
      INTENT (IN) :: FORM
      INTENT (INOUT) :: STRING
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      STRING = ' [' // TRIM(FMFORMAT2(FORM,MA%LEFT)) //  &
               ' ,' // TRIM(FMFORMAT2(FORM,MA%RIGHT)) // ' ]'
   END SUBROUTINE FMFORM_INTERVAL

   SUBROUTINE FMREAD_INTERVAL(KREAD,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KREAD
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      CALL FMREAD(KREAD,MA%LEFT)
      CALL FMREAD(KREAD,MA%RIGHT)
   END SUBROUTINE FMREAD_INTERVAL

   SUBROUTINE FMPRINT_INTERVAL(MA)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: MA
      INTEGER :: KRSAVE
      KRSAVE = KROUND
      KROUND = -1
      CALL FMPRINT(MA%LEFT)
      KROUND = 2
      CALL FMPRINT(MA%RIGHT)
      KROUND = KRSAVE
   END SUBROUTINE FMPRINT_INTERVAL

   SUBROUTINE FMWRITE_INTERVAL(KWRITE,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KWRITE
      TYPE (FM_INTERVAL) :: MA
      INTENT (IN) :: KWRITE,MA
      CALL FMWRITE(KWRITE,MA%LEFT)
      CALL FMWRITE(KWRITE,MA%RIGHT)
   END SUBROUTINE FMWRITE_INTERVAL

   SUBROUTINE FMRPWR_INTERVAL(MA,IVAL,JVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      TYPE (FM_INTERVAL) :: MA,MB
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: IVAL,JVAL,MA
      INTENT (INOUT) :: MB
      INTEGER :: IV,JV,IJ_SIGN,KRSAVE
      KRSAVE = KROUND
      IV = ABS(IVAL)
      JV = ABS(JVAL)
      CALL FMGCDI(IV,JV)
      IJ_SIGN = 1
      IF (DBLE(IVAL)*DBLE(JVAL) < 0) IJ_SIGN = -1
      IF (IJ_SIGN >= 0 .AND. MA%LEFT%MP(1) >= 0) THEN
          KROUND = -1
          CALL FMRPWR(MA%LEFT,IVAL,JVAL,MB%LEFT)
          KROUND = 2
          CALL FMRPWR(MA%RIGHT,IVAL,JVAL,MB%RIGHT)
          GO TO 110
      ENDIF
      IF (IJ_SIGN < 0 .AND. MA%LEFT%MP(1) >= 0) THEN
          KROUND = -1
          CALL FMRPWR(MA%RIGHT,IVAL,JVAL,MB%LEFT)
          KROUND = 2
          CALL FMRPWR(MA%LEFT,IVAL,JVAL,MB%RIGHT)
          GO TO 110
      ENDIF
      IF (IJ_SIGN >= 0 .AND. MOD(JV,2) == 1) THEN
          KROUND = -1
          CALL FMRPWR(MA%LEFT,IVAL,JVAL,MB%LEFT)
          KROUND = 2
          CALL FMRPWR(MA%RIGHT,IVAL,JVAL,MB%RIGHT)
          GO TO 110
      ENDIF
      IF (IJ_SIGN < 0 .AND. MOD(JV,2) == 1) THEN
          IF (MA%LEFT%MP(1) < 0 .AND. MA%RIGHT%MP(1) >= 0) THEN
              CALL FMST2M('-OVERFLOW',MB%LEFT)
              CALL FMST2M(' OVERFLOW',MB%RIGHT)
              GO TO 110
          ENDIF
          KROUND = -1
          CALL FMRPWR(MA%RIGHT,IVAL,JVAL,MB%LEFT)
          KROUND = 2
          CALL FMRPWR(MA%LEFT,IVAL,JVAL,MB%RIGHT)
          GO TO 110
      ENDIF
      IF (MA%RIGHT%MP(1) < 0 .OR. MA%RIGHT%MP(3) == 0) THEN
          CALL FMST2M('UNKNOWN',MB%LEFT)
          CALL FMST2M('UNKNOWN',MB%RIGHT)
          GO TO 110
      ENDIF
      IF (IJ_SIGN >= 0) THEN
          CALL FMI2M(0,MB%LEFT)
          KROUND = 2
          CALL FMRPWR(MA%RIGHT,IVAL,JVAL,MB%RIGHT)
      ELSE
          CALL FMST2M(' OVERFLOW',MB%RIGHT)
          KROUND = -1
          CALL FMRPWR(MA%RIGHT,IVAL,JVAL,MB%LEFT)
      ENDIF
  110 KROUND = KRSAVE
   END SUBROUTINE FMRPWR_INTERVAL

 END MODULE FM_INTERVAL_ARITHMETIC_10

 MODULE FM_INTERVAL_ARITHMETIC

   USE FM_INTERVAL_ARITHMETIC_1
   USE FM_INTERVAL_ARITHMETIC_2
   USE FM_INTERVAL_ARITHMETIC_3
   USE FM_INTERVAL_ARITHMETIC_4
   USE FM_INTERVAL_ARITHMETIC_5
   USE FM_INTERVAL_ARITHMETIC_6
   USE FM_INTERVAL_ARITHMETIC_7
   USE FM_INTERVAL_ARITHMETIC_8
   USE FM_INTERVAL_ARITHMETIC_9
   USE FM_INTERVAL_ARITHMETIC_10

 END MODULE FM_INTERVAL_ARITHMETIC

   SUBROUTINE F_EDGE(X1,Y1)
      USE FMVALS
      USE FMZM
      USE FM_INTERVAL_ARITHMETIC_1
      IMPLICIT NONE
      TYPE(MULTI) :: X1,Y1
      TYPE (FM), SAVE :: X,Y
      IF (K_ROUTINE_EDGE == 1) THEN
          CALL FMEQ(X1,X%MFM)
          IF (KXY_EDGE == 1) THEN
              CALL FM_EQU(Y_EDGE,XY_EDGE,NDIG_XY_EDGE,NDIG)
              CALL FM_EQ(BETA(X,XY_EDGE),Y)
          ELSE IF (KXY_EDGE == 2) THEN
              CALL FM_EQU(X_EDGE,XY_EDGE,NDIG_XY_EDGE,NDIG)
              CALL FM_EQ(BETA(XY_EDGE,X),Y)
          ENDIF
          CALL FMEQ(Y%MFM,Y1)
      ENDIF
      IF (K_ROUTINE_EDGE == 2) THEN
          CALL FMEQ(X1,X%MFM)
          IF (KXY_EDGE == 1) THEN
              CALL FM_EQU(Y_EDGE,XY_EDGE,NDIG_XY_EDGE,NDIG)
              CALL FM_EQ(BINOMIAL(X,XY_EDGE),Y)
          ELSE IF (KXY_EDGE == 2) THEN
              CALL FM_EQU(X_EDGE,XY_EDGE,NDIG_XY_EDGE,NDIG)
              CALL FM_EQ(BINOMIAL(XY_EDGE,X),Y)
          ENDIF
          CALL FMEQ(Y%MFM,Y1)
      ENDIF
      IF (K_ROUTINE_EDGE == 3) THEN
          CALL FMEQ(X1,X%MFM)
          CALL FM_EQU(Y_EDGE,XY_EDGE,NDIG_XY_EDGE,NDIG)
          CALL FM_EQ(INCOMPLETE_GAMMA1(X,XY_EDGE),Y)
          CALL FMEQ(Y%MFM,Y1)
      ENDIF
      IF (K_ROUTINE_EDGE == 4) THEN
          CALL FMEQ(X1,X%MFM)
          CALL FM_EQU(Y_EDGE,XY_EDGE,NDIG_XY_EDGE,NDIG)
          CALL FM_EQ(INCOMPLETE_GAMMA2(X,XY_EDGE),Y)
          CALL FMEQ(Y%MFM,Y1)
      ENDIF
   END SUBROUTINE F_EDGE
